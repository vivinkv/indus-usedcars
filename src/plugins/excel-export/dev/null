var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __esm = (fn, res) => function __init() {
  return fn && (res = (0, fn[__getOwnPropNames(fn)[0]])(fn = 0)), res;
};
var __commonJS = (cb, mod) => function __require() {
  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// dist/_chunks/App-D58T0dWL.js
var require_App_D58T0dWL = __commonJS({
  "dist/_chunks/App-D58T0dWL.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, Symbol.toStringTag, { value: "Module" });
    var jsxRuntime = require("react/jsx-runtime");
    var admin = require("@strapi/strapi/admin");
    var reactRouterDom = require("react-router-dom");
    var designSystem = require("@strapi/design-system");
    var reactIntl = require("react-intl");
    var react = require("react");
    var icons = require("@strapi/icons");
    function bind(fn, thisArg) {
      return function wrap() {
        return fn.apply(thisArg, arguments);
      };
    }
    var { toString } = Object.prototype;
    var { getPrototypeOf } = Object;
    var kindOf = /* @__PURE__ */ ((cache) => (thing) => {
      const str = toString.call(thing);
      return cache[str] || (cache[str] = str.slice(8, -1).toLowerCase());
    })(/* @__PURE__ */ Object.create(null));
    var kindOfTest = (type) => {
      type = type.toLowerCase();
      return (thing) => kindOf(thing) === type;
    };
    var typeOfTest = (type) => (thing) => typeof thing === type;
    var { isArray } = Array;
    var isUndefined = typeOfTest("undefined");
    function isBuffer(val) {
      return val !== null && !isUndefined(val) && val.constructor !== null && !isUndefined(val.constructor) && isFunction(val.constructor.isBuffer) && val.constructor.isBuffer(val);
    }
    var isArrayBuffer = kindOfTest("ArrayBuffer");
    function isArrayBufferView(val) {
      let result;
      if (typeof ArrayBuffer !== "undefined" && ArrayBuffer.isView) {
        result = ArrayBuffer.isView(val);
      } else {
        result = val && val.buffer && isArrayBuffer(val.buffer);
      }
      return result;
    }
    var isString = typeOfTest("string");
    var isFunction = typeOfTest("function");
    var isNumber = typeOfTest("number");
    var isObject2 = (thing) => thing !== null && typeof thing === "object";
    var isBoolean = (thing) => thing === true || thing === false;
    var isPlainObject = (val) => {
      if (kindOf(val) !== "object") {
        return false;
      }
      const prototype2 = getPrototypeOf(val);
      return (prototype2 === null || prototype2 === Object.prototype || Object.getPrototypeOf(prototype2) === null) && !(Symbol.toStringTag in val) && !(Symbol.iterator in val);
    };
    var isDate = kindOfTest("Date");
    var isFile = kindOfTest("File");
    var isBlob = kindOfTest("Blob");
    var isFileList = kindOfTest("FileList");
    var isStream = (val) => isObject2(val) && isFunction(val.pipe);
    var isFormData = (thing) => {
      let kind;
      return thing && (typeof FormData === "function" && thing instanceof FormData || isFunction(thing.append) && ((kind = kindOf(thing)) === "formdata" || // detect form-data instance
      kind === "object" && isFunction(thing.toString) && thing.toString() === "[object FormData]"));
    };
    var isURLSearchParams = kindOfTest("URLSearchParams");
    var [isReadableStream, isRequest, isResponse, isHeaders] = ["ReadableStream", "Request", "Response", "Headers"].map(kindOfTest);
    var trim = (str) => str.trim ? str.trim() : str.replace(/^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g, "");
    function forEach(obj2, fn, { allOwnKeys = false } = {}) {
      if (obj2 === null || typeof obj2 === "undefined") {
        return;
      }
      let i;
      let l2;
      if (typeof obj2 !== "object") {
        obj2 = [obj2];
      }
      if (isArray(obj2)) {
        for (i = 0, l2 = obj2.length; i < l2; i++) {
          fn.call(null, obj2[i], i, obj2);
        }
      } else {
        const keys2 = allOwnKeys ? Object.getOwnPropertyNames(obj2) : Object.keys(obj2);
        const len = keys2.length;
        let key;
        for (i = 0; i < len; i++) {
          key = keys2[i];
          fn.call(null, obj2[key], key, obj2);
        }
      }
    }
    function findKey(obj2, key) {
      key = key.toLowerCase();
      const keys2 = Object.keys(obj2);
      let i = keys2.length;
      let _key;
      while (i-- > 0) {
        _key = keys2[i];
        if (key === _key.toLowerCase()) {
          return _key;
        }
      }
      return null;
    }
    var _global = (() => {
      if (typeof globalThis !== "undefined")
        return globalThis;
      return typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : global;
    })();
    var isContextDefined = (context) => !isUndefined(context) && context !== _global;
    function merge() {
      const { caseless } = isContextDefined(this) && this || {};
      const result = {};
      const assignValue = (val, key) => {
        const targetKey = caseless && findKey(result, key) || key;
        if (isPlainObject(result[targetKey]) && isPlainObject(val)) {
          result[targetKey] = merge(result[targetKey], val);
        } else if (isPlainObject(val)) {
          result[targetKey] = merge({}, val);
        } else if (isArray(val)) {
          result[targetKey] = val.slice();
        } else {
          result[targetKey] = val;
        }
      };
      for (let i = 0, l2 = arguments.length; i < l2; i++) {
        arguments[i] && forEach(arguments[i], assignValue);
      }
      return result;
    }
    var extend = (a, b, thisArg, { allOwnKeys } = {}) => {
      forEach(b, (val, key) => {
        if (thisArg && isFunction(val)) {
          a[key] = bind(val, thisArg);
        } else {
          a[key] = val;
        }
      }, { allOwnKeys });
      return a;
    };
    var stripBOM = (content) => {
      if (content.charCodeAt(0) === 65279) {
        content = content.slice(1);
      }
      return content;
    };
    var inherits2 = (constructor, superConstructor, props, descriptors2) => {
      constructor.prototype = Object.create(superConstructor.prototype, descriptors2);
      constructor.prototype.constructor = constructor;
      Object.defineProperty(constructor, "super", {
        value: superConstructor.prototype
      });
      props && Object.assign(constructor.prototype, props);
    };
    var toFlatObject = (sourceObj, destObj, filter2, propFilter) => {
      let props;
      let i;
      let prop;
      const merged = {};
      destObj = destObj || {};
      if (sourceObj == null)
        return destObj;
      do {
        props = Object.getOwnPropertyNames(sourceObj);
        i = props.length;
        while (i-- > 0) {
          prop = props[i];
          if ((!propFilter || propFilter(prop, sourceObj, destObj)) && !merged[prop]) {
            destObj[prop] = sourceObj[prop];
            merged[prop] = true;
          }
        }
        sourceObj = filter2 !== false && getPrototypeOf(sourceObj);
      } while (sourceObj && (!filter2 || filter2(sourceObj, destObj)) && sourceObj !== Object.prototype);
      return destObj;
    };
    var endsWith = (str, searchString, position) => {
      str = String(str);
      if (position === void 0 || position > str.length) {
        position = str.length;
      }
      position -= searchString.length;
      const lastIndex = str.indexOf(searchString, position);
      return lastIndex !== -1 && lastIndex === position;
    };
    var toArray = (thing) => {
      if (!thing)
        return null;
      if (isArray(thing))
        return thing;
      let i = thing.length;
      if (!isNumber(i))
        return null;
      const arr = new Array(i);
      while (i-- > 0) {
        arr[i] = thing[i];
      }
      return arr;
    };
    var isTypedArray = /* @__PURE__ */ ((TypedArray) => {
      return (thing) => {
        return TypedArray && thing instanceof TypedArray;
      };
    })(typeof Uint8Array !== "undefined" && getPrototypeOf(Uint8Array));
    var forEachEntry = (obj2, fn) => {
      const generator = obj2 && obj2[Symbol.iterator];
      const iterator = generator.call(obj2);
      let result;
      while ((result = iterator.next()) && !result.done) {
        const pair = result.value;
        fn.call(obj2, pair[0], pair[1]);
      }
    };
    var matchAll = (regExp, str) => {
      let matches;
      const arr = [];
      while ((matches = regExp.exec(str)) !== null) {
        arr.push(matches);
      }
      return arr;
    };
    var isHTMLForm = kindOfTest("HTMLFormElement");
    var toCamelCase = (str) => {
      return str.toLowerCase().replace(
        /[-_\s]([a-z\d])(\w*)/g,
        function replacer(m, p1, p2) {
          return p1.toUpperCase() + p2;
        }
      );
    };
    var hasOwnProperty = (({ hasOwnProperty: hasOwnProperty2 }) => (obj2, prop) => hasOwnProperty2.call(obj2, prop))(Object.prototype);
    var isRegExp = kindOfTest("RegExp");
    var reduceDescriptors = (obj2, reducer) => {
      const descriptors2 = Object.getOwnPropertyDescriptors(obj2);
      const reducedDescriptors = {};
      forEach(descriptors2, (descriptor, name) => {
        let ret2;
        if ((ret2 = reducer(descriptor, name, obj2)) !== false) {
          reducedDescriptors[name] = ret2 || descriptor;
        }
      });
      Object.defineProperties(obj2, reducedDescriptors);
    };
    var freezeMethods = (obj2) => {
      reduceDescriptors(obj2, (descriptor, name) => {
        if (isFunction(obj2) && ["arguments", "caller", "callee"].indexOf(name) !== -1) {
          return false;
        }
        const value = obj2[name];
        if (!isFunction(value))
          return;
        descriptor.enumerable = false;
        if ("writable" in descriptor) {
          descriptor.writable = false;
          return;
        }
        if (!descriptor.set) {
          descriptor.set = () => {
            throw Error("Can not rewrite read-only method '" + name + "'");
          };
        }
      });
    };
    var toObjectSet = (arrayOrString, delimiter) => {
      const obj2 = {};
      const define2 = (arr) => {
        arr.forEach((value) => {
          obj2[value] = true;
        });
      };
      isArray(arrayOrString) ? define2(arrayOrString) : define2(String(arrayOrString).split(delimiter));
      return obj2;
    };
    var noop = () => {
    };
    var toFiniteNumber = (value, defaultValue) => {
      return value != null && Number.isFinite(value = +value) ? value : defaultValue;
    };
    var ALPHA = "abcdefghijklmnopqrstuvwxyz";
    var DIGIT = "0123456789";
    var ALPHABET = {
      DIGIT,
      ALPHA,
      ALPHA_DIGIT: ALPHA + ALPHA.toUpperCase() + DIGIT
    };
    var generateString = (size = 16, alphabet = ALPHABET.ALPHA_DIGIT) => {
      let str = "";
      const { length } = alphabet;
      while (size--) {
        str += alphabet[Math.random() * length | 0];
      }
      return str;
    };
    function isSpecCompliantForm(thing) {
      return !!(thing && isFunction(thing.append) && thing[Symbol.toStringTag] === "FormData" && thing[Symbol.iterator]);
    }
    var toJSONObject = (obj2) => {
      const stack = new Array(10);
      const visit = (source, i) => {
        if (isObject2(source)) {
          if (stack.indexOf(source) >= 0) {
            return;
          }
          if (!("toJSON" in source)) {
            stack[i] = source;
            const target = isArray(source) ? [] : {};
            forEach(source, (value, key) => {
              const reducedValue = visit(value, i + 1);
              !isUndefined(reducedValue) && (target[key] = reducedValue);
            });
            stack[i] = void 0;
            return target;
          }
        }
        return source;
      };
      return visit(obj2, 0);
    };
    var isAsyncFn = kindOfTest("AsyncFunction");
    var isThenable = (thing) => thing && (isObject2(thing) || isFunction(thing)) && isFunction(thing.then) && isFunction(thing.catch);
    var _setImmediate = ((setImmediateSupported, postMessageSupported) => {
      if (setImmediateSupported) {
        return setImmediate;
      }
      return postMessageSupported ? ((token, callbacks) => {
        _global.addEventListener("message", ({ source, data }) => {
          if (source === _global && data === token) {
            callbacks.length && callbacks.shift()();
          }
        }, false);
        return (cb) => {
          callbacks.push(cb);
          _global.postMessage(token, "*");
        };
      })(`axios@${Math.random()}`, []) : (cb) => setTimeout(cb);
    })(
      typeof setImmediate === "function",
      isFunction(_global.postMessage)
    );
    var asap = typeof queueMicrotask !== "undefined" ? queueMicrotask.bind(_global) : typeof process !== "undefined" && process.nextTick || _setImmediate;
    var utils$2 = {
      isArray,
      isArrayBuffer,
      isBuffer,
      isFormData,
      isArrayBufferView,
      isString,
      isNumber,
      isBoolean,
      isObject: isObject2,
      isPlainObject,
      isReadableStream,
      isRequest,
      isResponse,
      isHeaders,
      isUndefined,
      isDate,
      isFile,
      isBlob,
      isRegExp,
      isFunction,
      isStream,
      isURLSearchParams,
      isTypedArray,
      isFileList,
      forEach,
      merge,
      extend,
      trim,
      stripBOM,
      inherits: inherits2,
      toFlatObject,
      kindOf,
      kindOfTest,
      endsWith,
      toArray,
      forEachEntry,
      matchAll,
      isHTMLForm,
      hasOwnProperty,
      hasOwnProp: hasOwnProperty,
      // an alias to avoid ESLint no-prototype-builtins detection
      reduceDescriptors,
      freezeMethods,
      toObjectSet,
      toCamelCase,
      noop,
      toFiniteNumber,
      findKey,
      global: _global,
      isContextDefined,
      ALPHABET,
      generateString,
      isSpecCompliantForm,
      toJSONObject,
      isAsyncFn,
      isThenable,
      setImmediate: _setImmediate,
      asap
    };
    function AxiosError$1(message, code, config, request, response) {
      Error.call(this);
      if (Error.captureStackTrace) {
        Error.captureStackTrace(this, this.constructor);
      } else {
        this.stack = new Error().stack;
      }
      this.message = message;
      this.name = "AxiosError";
      code && (this.code = code);
      config && (this.config = config);
      request && (this.request = request);
      response && (this.response = response);
    }
    utils$2.inherits(AxiosError$1, Error, {
      toJSON: function toJSON() {
        return {
          // Standard
          message: this.message,
          name: this.name,
          // Microsoft
          description: this.description,
          number: this.number,
          // Mozilla
          fileName: this.fileName,
          lineNumber: this.lineNumber,
          columnNumber: this.columnNumber,
          stack: this.stack,
          // Axios
          config: utils$2.toJSONObject(this.config),
          code: this.code,
          status: this.response && this.response.status ? this.response.status : null
        };
      }
    });
    var prototype$1 = AxiosError$1.prototype;
    var descriptors = {};
    [
      "ERR_BAD_OPTION_VALUE",
      "ERR_BAD_OPTION",
      "ECONNABORTED",
      "ETIMEDOUT",
      "ERR_NETWORK",
      "ERR_FR_TOO_MANY_REDIRECTS",
      "ERR_DEPRECATED",
      "ERR_BAD_RESPONSE",
      "ERR_BAD_REQUEST",
      "ERR_CANCELED",
      "ERR_NOT_SUPPORT",
      "ERR_INVALID_URL"
      // eslint-disable-next-line func-names
    ].forEach((code) => {
      descriptors[code] = { value: code };
    });
    Object.defineProperties(AxiosError$1, descriptors);
    Object.defineProperty(prototype$1, "isAxiosError", { value: true });
    AxiosError$1.from = (error, code, config, request, response, customProps) => {
      const axiosError = Object.create(prototype$1);
      utils$2.toFlatObject(error, axiosError, function filter2(obj2) {
        return obj2 !== Error.prototype;
      }, (prop) => {
        return prop !== "isAxiosError";
      });
      AxiosError$1.call(axiosError, error.message, code, config, request, response);
      axiosError.cause = error;
      axiosError.name = error.name;
      customProps && Object.assign(axiosError, customProps);
      return axiosError;
    };
    var httpAdapter = null;
    function isVisitable(thing) {
      return utils$2.isPlainObject(thing) || utils$2.isArray(thing);
    }
    function removeBrackets(key) {
      return utils$2.endsWith(key, "[]") ? key.slice(0, -2) : key;
    }
    function renderKey(path, key, dots) {
      if (!path)
        return key;
      return path.concat(key).map(function each(token, i) {
        token = removeBrackets(token);
        return !dots && i ? "[" + token + "]" : token;
      }).join(dots ? "." : "");
    }
    function isFlatArray(arr) {
      return utils$2.isArray(arr) && !arr.some(isVisitable);
    }
    var predicates = utils$2.toFlatObject(utils$2, {}, null, function filter(prop) {
      return /^is[A-Z]/.test(prop);
    });
    function toFormData$1(obj2, formData, options) {
      if (!utils$2.isObject(obj2)) {
        throw new TypeError("target must be an object");
      }
      formData = formData || new FormData();
      options = utils$2.toFlatObject(options, {
        metaTokens: true,
        dots: false,
        indexes: false
      }, false, function defined(option, source) {
        return !utils$2.isUndefined(source[option]);
      });
      const metaTokens = options.metaTokens;
      const visitor = options.visitor || defaultVisitor;
      const dots = options.dots;
      const indexes = options.indexes;
      const _Blob = options.Blob || typeof Blob !== "undefined" && Blob;
      const useBlob = _Blob && utils$2.isSpecCompliantForm(formData);
      if (!utils$2.isFunction(visitor)) {
        throw new TypeError("visitor must be a function");
      }
      function convertValue(value) {
        if (value === null)
          return "";
        if (utils$2.isDate(value)) {
          return value.toISOString();
        }
        if (!useBlob && utils$2.isBlob(value)) {
          throw new AxiosError$1("Blob is not supported. Use a Buffer instead.");
        }
        if (utils$2.isArrayBuffer(value) || utils$2.isTypedArray(value)) {
          return useBlob && typeof Blob === "function" ? new Blob([value]) : Buffer.from(value);
        }
        return value;
      }
      function defaultVisitor(value, key, path) {
        let arr = value;
        if (value && !path && typeof value === "object") {
          if (utils$2.endsWith(key, "{}")) {
            key = metaTokens ? key : key.slice(0, -2);
            value = JSON.stringify(value);
          } else if (utils$2.isArray(value) && isFlatArray(value) || (utils$2.isFileList(value) || utils$2.endsWith(key, "[]")) && (arr = utils$2.toArray(value))) {
            key = removeBrackets(key);
            arr.forEach(function each(el, index) {
              !(utils$2.isUndefined(el) || el === null) && formData.append(
                // eslint-disable-next-line no-nested-ternary
                indexes === true ? renderKey([key], index, dots) : indexes === null ? key : key + "[]",
                convertValue(el)
              );
            });
            return false;
          }
        }
        if (isVisitable(value)) {
          return true;
        }
        formData.append(renderKey(path, key, dots), convertValue(value));
        return false;
      }
      const stack = [];
      const exposedHelpers = Object.assign(predicates, {
        defaultVisitor,
        convertValue,
        isVisitable
      });
      function build(value, path) {
        if (utils$2.isUndefined(value))
          return;
        if (stack.indexOf(value) !== -1) {
          throw Error("Circular reference detected in " + path.join("."));
        }
        stack.push(value);
        utils$2.forEach(value, function each(el, key) {
          const result = !(utils$2.isUndefined(el) || el === null) && visitor.call(
            formData,
            el,
            utils$2.isString(key) ? key.trim() : key,
            path,
            exposedHelpers
          );
          if (result === true) {
            build(el, path ? path.concat(key) : [key]);
          }
        });
        stack.pop();
      }
      if (!utils$2.isObject(obj2)) {
        throw new TypeError("data must be an object");
      }
      build(obj2);
      return formData;
    }
    function encode$1(str) {
      const charMap = {
        "!": "%21",
        "'": "%27",
        "(": "%28",
        ")": "%29",
        "~": "%7E",
        "%20": "+",
        "%00": "\0"
      };
      return encodeURIComponent(str).replace(/[!'()~]|%20|%00/g, function replacer(match) {
        return charMap[match];
      });
    }
    function AxiosURLSearchParams(params, options) {
      this._pairs = [];
      params && toFormData$1(params, this, options);
    }
    var prototype = AxiosURLSearchParams.prototype;
    prototype.append = function append(name, value) {
      this._pairs.push([name, value]);
    };
    prototype.toString = function toString2(encoder) {
      const _encode = encoder ? function(value) {
        return encoder.call(this, value, encode$1);
      } : encode$1;
      return this._pairs.map(function each(pair) {
        return _encode(pair[0]) + "=" + _encode(pair[1]);
      }, "").join("&");
    };
    function encode(val) {
      return encodeURIComponent(val).replace(/%3A/gi, ":").replace(/%24/g, "$").replace(/%2C/gi, ",").replace(/%20/g, "+").replace(/%5B/gi, "[").replace(/%5D/gi, "]");
    }
    function buildURL(url, params, options) {
      if (!params) {
        return url;
      }
      const _encode = options && options.encode || encode;
      const serializeFn = options && options.serialize;
      let serializedParams;
      if (serializeFn) {
        serializedParams = serializeFn(params, options);
      } else {
        serializedParams = utils$2.isURLSearchParams(params) ? params.toString() : new AxiosURLSearchParams(params, options).toString(_encode);
      }
      if (serializedParams) {
        const hashmarkIndex = url.indexOf("#");
        if (hashmarkIndex !== -1) {
          url = url.slice(0, hashmarkIndex);
        }
        url += (url.indexOf("?") === -1 ? "?" : "&") + serializedParams;
      }
      return url;
    }
    var InterceptorManager = class {
      constructor() {
        this.handlers = [];
      }
      /**
       * Add a new interceptor to the stack
       *
       * @param {Function} fulfilled The function to handle `then` for a `Promise`
       * @param {Function} rejected The function to handle `reject` for a `Promise`
       *
       * @return {Number} An ID used to remove interceptor later
       */
      use(fulfilled, rejected, options) {
        this.handlers.push({
          fulfilled,
          rejected,
          synchronous: options ? options.synchronous : false,
          runWhen: options ? options.runWhen : null
        });
        return this.handlers.length - 1;
      }
      /**
       * Remove an interceptor from the stack
       *
       * @param {Number} id The ID that was returned by `use`
       *
       * @returns {Boolean} `true` if the interceptor was removed, `false` otherwise
       */
      eject(id) {
        if (this.handlers[id]) {
          this.handlers[id] = null;
        }
      }
      /**
       * Clear all interceptors from the stack
       *
       * @returns {void}
       */
      clear() {
        if (this.handlers) {
          this.handlers = [];
        }
      }
      /**
       * Iterate over all the registered interceptors
       *
       * This method is particularly useful for skipping over any
       * interceptors that may have become `null` calling `eject`.
       *
       * @param {Function} fn The function to call for each interceptor
       *
       * @returns {void}
       */
      forEach(fn) {
        utils$2.forEach(this.handlers, function forEachHandler(h) {
          if (h !== null) {
            fn(h);
          }
        });
      }
    };
    var transitionalDefaults = {
      silentJSONParsing: true,
      forcedJSONParsing: true,
      clarifyTimeoutError: false
    };
    var URLSearchParams$1 = typeof URLSearchParams !== "undefined" ? URLSearchParams : AxiosURLSearchParams;
    var FormData$1 = typeof FormData !== "undefined" ? FormData : null;
    var Blob$1 = typeof Blob !== "undefined" ? Blob : null;
    var platform$1 = {
      isBrowser: true,
      classes: {
        URLSearchParams: URLSearchParams$1,
        FormData: FormData$1,
        Blob: Blob$1
      },
      protocols: ["http", "https", "file", "blob", "url", "data"]
    };
    var hasBrowserEnv = typeof window !== "undefined" && typeof document !== "undefined";
    var hasStandardBrowserEnv = ((product) => {
      return hasBrowserEnv && ["ReactNative", "NativeScript", "NS"].indexOf(product) < 0;
    })(typeof navigator !== "undefined" && navigator.product);
    var hasStandardBrowserWebWorkerEnv = (() => {
      return typeof WorkerGlobalScope !== "undefined" && // eslint-disable-next-line no-undef
      self instanceof WorkerGlobalScope && typeof self.importScripts === "function";
    })();
    var origin = hasBrowserEnv && window.location.href || "http://localhost";
    var utils$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
      __proto__: null,
      hasBrowserEnv,
      hasStandardBrowserEnv,
      hasStandardBrowserWebWorkerEnv,
      origin
    }, Symbol.toStringTag, { value: "Module" }));
    var platform = {
      ...utils$1,
      ...platform$1
    };
    function toURLEncodedForm(data, options) {
      return toFormData$1(data, new platform.classes.URLSearchParams(), Object.assign({
        visitor: function(value, key, path, helpers) {
          if (platform.isNode && utils$2.isBuffer(value)) {
            this.append(key, value.toString("base64"));
            return false;
          }
          return helpers.defaultVisitor.apply(this, arguments);
        }
      }, options));
    }
    function parsePropPath(name) {
      return utils$2.matchAll(/\w+|\[(\w*)]/g, name).map((match) => {
        return match[0] === "[]" ? "" : match[1] || match[0];
      });
    }
    function arrayToObject(arr) {
      const obj2 = {};
      const keys2 = Object.keys(arr);
      let i;
      const len = keys2.length;
      let key;
      for (i = 0; i < len; i++) {
        key = keys2[i];
        obj2[key] = arr[key];
      }
      return obj2;
    }
    function formDataToJSON(formData) {
      function buildPath(path, value, target, index) {
        let name = path[index++];
        if (name === "__proto__")
          return true;
        const isNumericKey = Number.isFinite(+name);
        const isLast = index >= path.length;
        name = !name && utils$2.isArray(target) ? target.length : name;
        if (isLast) {
          if (utils$2.hasOwnProp(target, name)) {
            target[name] = [target[name], value];
          } else {
            target[name] = value;
          }
          return !isNumericKey;
        }
        if (!target[name] || !utils$2.isObject(target[name])) {
          target[name] = [];
        }
        const result = buildPath(path, value, target[name], index);
        if (result && utils$2.isArray(target[name])) {
          target[name] = arrayToObject(target[name]);
        }
        return !isNumericKey;
      }
      if (utils$2.isFormData(formData) && utils$2.isFunction(formData.entries)) {
        const obj2 = {};
        utils$2.forEachEntry(formData, (name, value) => {
          buildPath(parsePropPath(name), value, obj2, 0);
        });
        return obj2;
      }
      return null;
    }
    function stringifySafely(rawValue, parser, encoder) {
      if (utils$2.isString(rawValue)) {
        try {
          (parser || JSON.parse)(rawValue);
          return utils$2.trim(rawValue);
        } catch (e) {
          if (e.name !== "SyntaxError") {
            throw e;
          }
        }
      }
      return (encoder || JSON.stringify)(rawValue);
    }
    var defaults = {
      transitional: transitionalDefaults,
      adapter: ["xhr", "http", "fetch"],
      transformRequest: [function transformRequest(data, headers) {
        const contentType = headers.getContentType() || "";
        const hasJSONContentType = contentType.indexOf("application/json") > -1;
        const isObjectPayload = utils$2.isObject(data);
        if (isObjectPayload && utils$2.isHTMLForm(data)) {
          data = new FormData(data);
        }
        const isFormData2 = utils$2.isFormData(data);
        if (isFormData2) {
          return hasJSONContentType ? JSON.stringify(formDataToJSON(data)) : data;
        }
        if (utils$2.isArrayBuffer(data) || utils$2.isBuffer(data) || utils$2.isStream(data) || utils$2.isFile(data) || utils$2.isBlob(data) || utils$2.isReadableStream(data)) {
          return data;
        }
        if (utils$2.isArrayBufferView(data)) {
          return data.buffer;
        }
        if (utils$2.isURLSearchParams(data)) {
          headers.setContentType("application/x-www-form-urlencoded;charset=utf-8", false);
          return data.toString();
        }
        let isFileList2;
        if (isObjectPayload) {
          if (contentType.indexOf("application/x-www-form-urlencoded") > -1) {
            return toURLEncodedForm(data, this.formSerializer).toString();
          }
          if ((isFileList2 = utils$2.isFileList(data)) || contentType.indexOf("multipart/form-data") > -1) {
            const _FormData = this.env && this.env.FormData;
            return toFormData$1(
              isFileList2 ? { "files[]": data } : data,
              _FormData && new _FormData(),
              this.formSerializer
            );
          }
        }
        if (isObjectPayload || hasJSONContentType) {
          headers.setContentType("application/json", false);
          return stringifySafely(data);
        }
        return data;
      }],
      transformResponse: [function transformResponse(data) {
        const transitional2 = this.transitional || defaults.transitional;
        const forcedJSONParsing = transitional2 && transitional2.forcedJSONParsing;
        const JSONRequested = this.responseType === "json";
        if (utils$2.isResponse(data) || utils$2.isReadableStream(data)) {
          return data;
        }
        if (data && utils$2.isString(data) && (forcedJSONParsing && !this.responseType || JSONRequested)) {
          const silentJSONParsing = transitional2 && transitional2.silentJSONParsing;
          const strictJSONParsing = !silentJSONParsing && JSONRequested;
          try {
            return JSON.parse(data);
          } catch (e) {
            if (strictJSONParsing) {
              if (e.name === "SyntaxError") {
                throw AxiosError$1.from(e, AxiosError$1.ERR_BAD_RESPONSE, this, null, this.response);
              }
              throw e;
            }
          }
        }
        return data;
      }],
      /**
       * A timeout in milliseconds to abort a request. If set to 0 (default) a
       * timeout is not created.
       */
      timeout: 0,
      xsrfCookieName: "XSRF-TOKEN",
      xsrfHeaderName: "X-XSRF-TOKEN",
      maxContentLength: -1,
      maxBodyLength: -1,
      env: {
        FormData: platform.classes.FormData,
        Blob: platform.classes.Blob
      },
      validateStatus: function validateStatus(status) {
        return status >= 200 && status < 300;
      },
      headers: {
        common: {
          "Accept": "application/json, text/plain, */*",
          "Content-Type": void 0
        }
      }
    };
    utils$2.forEach(["delete", "get", "head", "post", "put", "patch"], (method) => {
      defaults.headers[method] = {};
    });
    var ignoreDuplicateOf = utils$2.toObjectSet([
      "age",
      "authorization",
      "content-length",
      "content-type",
      "etag",
      "expires",
      "from",
      "host",
      "if-modified-since",
      "if-unmodified-since",
      "last-modified",
      "location",
      "max-forwards",
      "proxy-authorization",
      "referer",
      "retry-after",
      "user-agent"
    ]);
    var parseHeaders = (rawHeaders) => {
      const parsed = {};
      let key;
      let val;
      let i;
      rawHeaders && rawHeaders.split("\n").forEach(function parser(line) {
        i = line.indexOf(":");
        key = line.substring(0, i).trim().toLowerCase();
        val = line.substring(i + 1).trim();
        if (!key || parsed[key] && ignoreDuplicateOf[key]) {
          return;
        }
        if (key === "set-cookie") {
          if (parsed[key]) {
            parsed[key].push(val);
          } else {
            parsed[key] = [val];
          }
        } else {
          parsed[key] = parsed[key] ? parsed[key] + ", " + val : val;
        }
      });
      return parsed;
    };
    var $internals = Symbol("internals");
    function normalizeHeader(header) {
      return header && String(header).trim().toLowerCase();
    }
    function normalizeValue(value) {
      if (value === false || value == null) {
        return value;
      }
      return utils$2.isArray(value) ? value.map(normalizeValue) : String(value);
    }
    function parseTokens(str) {
      const tokens = /* @__PURE__ */ Object.create(null);
      const tokensRE = /([^\s,;=]+)\s*(?:=\s*([^,;]+))?/g;
      let match;
      while (match = tokensRE.exec(str)) {
        tokens[match[1]] = match[2];
      }
      return tokens;
    }
    var isValidHeaderName = (str) => /^[-_a-zA-Z0-9^`|~,!#$%&'*+.]+$/.test(str.trim());
    function matchHeaderValue(context, value, header, filter2, isHeaderNameFilter) {
      if (utils$2.isFunction(filter2)) {
        return filter2.call(this, value, header);
      }
      if (isHeaderNameFilter) {
        value = header;
      }
      if (!utils$2.isString(value))
        return;
      if (utils$2.isString(filter2)) {
        return value.indexOf(filter2) !== -1;
      }
      if (utils$2.isRegExp(filter2)) {
        return filter2.test(value);
      }
    }
    function formatHeader(header) {
      return header.trim().toLowerCase().replace(/([a-z\d])(\w*)/g, (w, char, str) => {
        return char.toUpperCase() + str;
      });
    }
    function buildAccessors(obj2, header) {
      const accessorName = utils$2.toCamelCase(" " + header);
      ["get", "set", "has"].forEach((methodName) => {
        Object.defineProperty(obj2, methodName + accessorName, {
          value: function(arg1, arg2, arg3) {
            return this[methodName].call(this, header, arg1, arg2, arg3);
          },
          configurable: true
        });
      });
    }
    var AxiosHeaders$1 = class AxiosHeaders {
      constructor(headers) {
        headers && this.set(headers);
      }
      set(header, valueOrRewrite, rewrite) {
        const self2 = this;
        function setHeader(_value, _header, _rewrite) {
          const lHeader = normalizeHeader(_header);
          if (!lHeader) {
            throw new Error("header name must be a non-empty string");
          }
          const key = utils$2.findKey(self2, lHeader);
          if (!key || self2[key] === void 0 || _rewrite === true || _rewrite === void 0 && self2[key] !== false) {
            self2[key || _header] = normalizeValue(_value);
          }
        }
        const setHeaders = (headers, _rewrite) => utils$2.forEach(headers, (_value, _header) => setHeader(_value, _header, _rewrite));
        if (utils$2.isPlainObject(header) || header instanceof this.constructor) {
          setHeaders(header, valueOrRewrite);
        } else if (utils$2.isString(header) && (header = header.trim()) && !isValidHeaderName(header)) {
          setHeaders(parseHeaders(header), valueOrRewrite);
        } else if (utils$2.isHeaders(header)) {
          for (const [key, value] of header.entries()) {
            setHeader(value, key, rewrite);
          }
        } else {
          header != null && setHeader(valueOrRewrite, header, rewrite);
        }
        return this;
      }
      get(header, parser) {
        header = normalizeHeader(header);
        if (header) {
          const key = utils$2.findKey(this, header);
          if (key) {
            const value = this[key];
            if (!parser) {
              return value;
            }
            if (parser === true) {
              return parseTokens(value);
            }
            if (utils$2.isFunction(parser)) {
              return parser.call(this, value, key);
            }
            if (utils$2.isRegExp(parser)) {
              return parser.exec(value);
            }
            throw new TypeError("parser must be boolean|regexp|function");
          }
        }
      }
      has(header, matcher) {
        header = normalizeHeader(header);
        if (header) {
          const key = utils$2.findKey(this, header);
          return !!(key && this[key] !== void 0 && (!matcher || matchHeaderValue(this, this[key], key, matcher)));
        }
        return false;
      }
      delete(header, matcher) {
        const self2 = this;
        let deleted = false;
        function deleteHeader(_header) {
          _header = normalizeHeader(_header);
          if (_header) {
            const key = utils$2.findKey(self2, _header);
            if (key && (!matcher || matchHeaderValue(self2, self2[key], key, matcher))) {
              delete self2[key];
              deleted = true;
            }
          }
        }
        if (utils$2.isArray(header)) {
          header.forEach(deleteHeader);
        } else {
          deleteHeader(header);
        }
        return deleted;
      }
      clear(matcher) {
        const keys2 = Object.keys(this);
        let i = keys2.length;
        let deleted = false;
        while (i--) {
          const key = keys2[i];
          if (!matcher || matchHeaderValue(this, this[key], key, matcher, true)) {
            delete this[key];
            deleted = true;
          }
        }
        return deleted;
      }
      normalize(format) {
        const self2 = this;
        const headers = {};
        utils$2.forEach(this, (value, header) => {
          const key = utils$2.findKey(headers, header);
          if (key) {
            self2[key] = normalizeValue(value);
            delete self2[header];
            return;
          }
          const normalized = format ? formatHeader(header) : String(header).trim();
          if (normalized !== header) {
            delete self2[header];
          }
          self2[normalized] = normalizeValue(value);
          headers[normalized] = true;
        });
        return this;
      }
      concat(...targets) {
        return this.constructor.concat(this, ...targets);
      }
      toJSON(asStrings) {
        const obj2 = /* @__PURE__ */ Object.create(null);
        utils$2.forEach(this, (value, header) => {
          value != null && value !== false && (obj2[header] = asStrings && utils$2.isArray(value) ? value.join(", ") : value);
        });
        return obj2;
      }
      [Symbol.iterator]() {
        return Object.entries(this.toJSON())[Symbol.iterator]();
      }
      toString() {
        return Object.entries(this.toJSON()).map(([header, value]) => header + ": " + value).join("\n");
      }
      get [Symbol.toStringTag]() {
        return "AxiosHeaders";
      }
      static from(thing) {
        return thing instanceof this ? thing : new this(thing);
      }
      static concat(first, ...targets) {
        const computed = new this(first);
        targets.forEach((target) => computed.set(target));
        return computed;
      }
      static accessor(header) {
        const internals = this[$internals] = this[$internals] = {
          accessors: {}
        };
        const accessors = internals.accessors;
        const prototype2 = this.prototype;
        function defineAccessor(_header) {
          const lHeader = normalizeHeader(_header);
          if (!accessors[lHeader]) {
            buildAccessors(prototype2, _header);
            accessors[lHeader] = true;
          }
        }
        utils$2.isArray(header) ? header.forEach(defineAccessor) : defineAccessor(header);
        return this;
      }
    };
    AxiosHeaders$1.accessor(["Content-Type", "Content-Length", "Accept", "Accept-Encoding", "User-Agent", "Authorization"]);
    utils$2.reduceDescriptors(AxiosHeaders$1.prototype, ({ value }, key) => {
      let mapped = key[0].toUpperCase() + key.slice(1);
      return {
        get: () => value,
        set(headerValue) {
          this[mapped] = headerValue;
        }
      };
    });
    utils$2.freezeMethods(AxiosHeaders$1);
    function transformData(fns, response) {
      const config = this || defaults;
      const context = response || config;
      const headers = AxiosHeaders$1.from(context.headers);
      let data = context.data;
      utils$2.forEach(fns, function transform(fn) {
        data = fn.call(config, data, headers.normalize(), response ? response.status : void 0);
      });
      headers.normalize();
      return data;
    }
    function isCancel$1(value) {
      return !!(value && value.__CANCEL__);
    }
    function CanceledError$1(message, config, request) {
      AxiosError$1.call(this, message == null ? "canceled" : message, AxiosError$1.ERR_CANCELED, config, request);
      this.name = "CanceledError";
    }
    utils$2.inherits(CanceledError$1, AxiosError$1, {
      __CANCEL__: true
    });
    function settle(resolve, reject, response) {
      const validateStatus2 = response.config.validateStatus;
      if (!response.status || !validateStatus2 || validateStatus2(response.status)) {
        resolve(response);
      } else {
        reject(new AxiosError$1(
          "Request failed with status code " + response.status,
          [AxiosError$1.ERR_BAD_REQUEST, AxiosError$1.ERR_BAD_RESPONSE][Math.floor(response.status / 100) - 4],
          response.config,
          response.request,
          response
        ));
      }
    }
    function parseProtocol(url) {
      const match = /^([-+\w]{1,25})(:?\/\/|:)/.exec(url);
      return match && match[1] || "";
    }
    function speedometer(samplesCount, min) {
      samplesCount = samplesCount || 10;
      const bytes = new Array(samplesCount);
      const timestamps = new Array(samplesCount);
      let head = 0;
      let tail = 0;
      let firstSampleTS;
      min = min !== void 0 ? min : 1e3;
      return function push(chunkLength) {
        const now = Date.now();
        const startedAt = timestamps[tail];
        if (!firstSampleTS) {
          firstSampleTS = now;
        }
        bytes[head] = chunkLength;
        timestamps[head] = now;
        let i = tail;
        let bytesCount = 0;
        while (i !== head) {
          bytesCount += bytes[i++];
          i = i % samplesCount;
        }
        head = (head + 1) % samplesCount;
        if (head === tail) {
          tail = (tail + 1) % samplesCount;
        }
        if (now - firstSampleTS < min) {
          return;
        }
        const passed = startedAt && now - startedAt;
        return passed ? Math.round(bytesCount * 1e3 / passed) : void 0;
      };
    }
    function throttle(fn, freq) {
      let timestamp = 0;
      let threshold = 1e3 / freq;
      let lastArgs;
      let timer;
      const invoke = (args, now = Date.now()) => {
        timestamp = now;
        lastArgs = null;
        if (timer) {
          clearTimeout(timer);
          timer = null;
        }
        fn.apply(null, args);
      };
      const throttled = (...args) => {
        const now = Date.now();
        const passed = now - timestamp;
        if (passed >= threshold) {
          invoke(args, now);
        } else {
          lastArgs = args;
          if (!timer) {
            timer = setTimeout(() => {
              timer = null;
              invoke(lastArgs);
            }, threshold - passed);
          }
        }
      };
      const flush = () => lastArgs && invoke(lastArgs);
      return [throttled, flush];
    }
    var progressEventReducer = (listener, isDownloadStream, freq = 3) => {
      let bytesNotified = 0;
      const _speedometer = speedometer(50, 250);
      return throttle((e) => {
        const loaded = e.loaded;
        const total = e.lengthComputable ? e.total : void 0;
        const progressBytes = loaded - bytesNotified;
        const rate = _speedometer(progressBytes);
        const inRange = loaded <= total;
        bytesNotified = loaded;
        const data = {
          loaded,
          total,
          progress: total ? loaded / total : void 0,
          bytes: progressBytes,
          rate: rate ? rate : void 0,
          estimated: rate && total && inRange ? (total - loaded) / rate : void 0,
          event: e,
          lengthComputable: total != null,
          [isDownloadStream ? "download" : "upload"]: true
        };
        listener(data);
      }, freq);
    };
    var progressEventDecorator = (total, throttled) => {
      const lengthComputable = total != null;
      return [(loaded) => throttled[0]({
        lengthComputable,
        total,
        loaded
      }), throttled[1]];
    };
    var asyncDecorator = (fn) => (...args) => utils$2.asap(() => fn(...args));
    var isURLSameOrigin = platform.hasStandardBrowserEnv ? (
      // Standard browser envs have full support of the APIs needed to test
      // whether the request URL is of the same origin as current location.
      function standardBrowserEnv() {
        const msie = /(msie|trident)/i.test(navigator.userAgent);
        const urlParsingNode = document.createElement("a");
        let originURL;
        function resolveURL(url) {
          let href = url;
          if (msie) {
            urlParsingNode.setAttribute("href", href);
            href = urlParsingNode.href;
          }
          urlParsingNode.setAttribute("href", href);
          return {
            href: urlParsingNode.href,
            protocol: urlParsingNode.protocol ? urlParsingNode.protocol.replace(/:$/, "") : "",
            host: urlParsingNode.host,
            search: urlParsingNode.search ? urlParsingNode.search.replace(/^\?/, "") : "",
            hash: urlParsingNode.hash ? urlParsingNode.hash.replace(/^#/, "") : "",
            hostname: urlParsingNode.hostname,
            port: urlParsingNode.port,
            pathname: urlParsingNode.pathname.charAt(0) === "/" ? urlParsingNode.pathname : "/" + urlParsingNode.pathname
          };
        }
        originURL = resolveURL(window.location.href);
        return function isURLSameOrigin2(requestURL) {
          const parsed = utils$2.isString(requestURL) ? resolveURL(requestURL) : requestURL;
          return parsed.protocol === originURL.protocol && parsed.host === originURL.host;
        };
      }()
    ) : (
      // Non standard browser envs (web workers, react-native) lack needed support.
      /* @__PURE__ */ function nonStandardBrowserEnv() {
        return function isURLSameOrigin2() {
          return true;
        };
      }()
    );
    var cookies = platform.hasStandardBrowserEnv ? (
      // Standard browser envs support document.cookie
      {
        write(name, value, expires, path, domain, secure) {
          const cookie = [name + "=" + encodeURIComponent(value)];
          utils$2.isNumber(expires) && cookie.push("expires=" + new Date(expires).toGMTString());
          utils$2.isString(path) && cookie.push("path=" + path);
          utils$2.isString(domain) && cookie.push("domain=" + domain);
          secure === true && cookie.push("secure");
          document.cookie = cookie.join("; ");
        },
        read(name) {
          const match = document.cookie.match(new RegExp("(^|;\\s*)(" + name + ")=([^;]*)"));
          return match ? decodeURIComponent(match[3]) : null;
        },
        remove(name) {
          this.write(name, "", Date.now() - 864e5);
        }
      }
    ) : (
      // Non-standard browser env (web workers, react-native) lack needed support.
      {
        write() {
        },
        read() {
          return null;
        },
        remove() {
        }
      }
    );
    function isAbsoluteURL(url) {
      return /^([a-z][a-z\d+\-.]*:)?\/\//i.test(url);
    }
    function combineURLs(baseURL, relativeURL) {
      return relativeURL ? baseURL.replace(/\/?\/$/, "") + "/" + relativeURL.replace(/^\/+/, "") : baseURL;
    }
    function buildFullPath(baseURL, requestedURL) {
      if (baseURL && !isAbsoluteURL(requestedURL)) {
        return combineURLs(baseURL, requestedURL);
      }
      return requestedURL;
    }
    var headersToObject = (thing) => thing instanceof AxiosHeaders$1 ? { ...thing } : thing;
    function mergeConfig$1(config1, config2) {
      config2 = config2 || {};
      const config = {};
      function getMergedValue(target, source, caseless) {
        if (utils$2.isPlainObject(target) && utils$2.isPlainObject(source)) {
          return utils$2.merge.call({ caseless }, target, source);
        } else if (utils$2.isPlainObject(source)) {
          return utils$2.merge({}, source);
        } else if (utils$2.isArray(source)) {
          return source.slice();
        }
        return source;
      }
      function mergeDeepProperties(a, b, caseless) {
        if (!utils$2.isUndefined(b)) {
          return getMergedValue(a, b, caseless);
        } else if (!utils$2.isUndefined(a)) {
          return getMergedValue(void 0, a, caseless);
        }
      }
      function valueFromConfig2(a, b) {
        if (!utils$2.isUndefined(b)) {
          return getMergedValue(void 0, b);
        }
      }
      function defaultToConfig2(a, b) {
        if (!utils$2.isUndefined(b)) {
          return getMergedValue(void 0, b);
        } else if (!utils$2.isUndefined(a)) {
          return getMergedValue(void 0, a);
        }
      }
      function mergeDirectKeys(a, b, prop) {
        if (prop in config2) {
          return getMergedValue(a, b);
        } else if (prop in config1) {
          return getMergedValue(void 0, a);
        }
      }
      const mergeMap = {
        url: valueFromConfig2,
        method: valueFromConfig2,
        data: valueFromConfig2,
        baseURL: defaultToConfig2,
        transformRequest: defaultToConfig2,
        transformResponse: defaultToConfig2,
        paramsSerializer: defaultToConfig2,
        timeout: defaultToConfig2,
        timeoutMessage: defaultToConfig2,
        withCredentials: defaultToConfig2,
        withXSRFToken: defaultToConfig2,
        adapter: defaultToConfig2,
        responseType: defaultToConfig2,
        xsrfCookieName: defaultToConfig2,
        xsrfHeaderName: defaultToConfig2,
        onUploadProgress: defaultToConfig2,
        onDownloadProgress: defaultToConfig2,
        decompress: defaultToConfig2,
        maxContentLength: defaultToConfig2,
        maxBodyLength: defaultToConfig2,
        beforeRedirect: defaultToConfig2,
        transport: defaultToConfig2,
        httpAgent: defaultToConfig2,
        httpsAgent: defaultToConfig2,
        cancelToken: defaultToConfig2,
        socketPath: defaultToConfig2,
        responseEncoding: defaultToConfig2,
        validateStatus: mergeDirectKeys,
        headers: (a, b) => mergeDeepProperties(headersToObject(a), headersToObject(b), true)
      };
      utils$2.forEach(Object.keys(Object.assign({}, config1, config2)), function computeConfigValue(prop) {
        const merge2 = mergeMap[prop] || mergeDeepProperties;
        const configValue = merge2(config1[prop], config2[prop], prop);
        utils$2.isUndefined(configValue) && merge2 !== mergeDirectKeys || (config[prop] = configValue);
      });
      return config;
    }
    var resolveConfig = (config) => {
      const newConfig = mergeConfig$1({}, config);
      let { data, withXSRFToken, xsrfHeaderName, xsrfCookieName, headers, auth } = newConfig;
      newConfig.headers = headers = AxiosHeaders$1.from(headers);
      newConfig.url = buildURL(buildFullPath(newConfig.baseURL, newConfig.url), config.params, config.paramsSerializer);
      if (auth) {
        headers.set(
          "Authorization",
          "Basic " + btoa((auth.username || "") + ":" + (auth.password ? unescape(encodeURIComponent(auth.password)) : ""))
        );
      }
      let contentType;
      if (utils$2.isFormData(data)) {
        if (platform.hasStandardBrowserEnv || platform.hasStandardBrowserWebWorkerEnv) {
          headers.setContentType(void 0);
        } else if ((contentType = headers.getContentType()) !== false) {
          const [type, ...tokens] = contentType ? contentType.split(";").map((token) => token.trim()).filter(Boolean) : [];
          headers.setContentType([type || "multipart/form-data", ...tokens].join("; "));
        }
      }
      if (platform.hasStandardBrowserEnv) {
        withXSRFToken && utils$2.isFunction(withXSRFToken) && (withXSRFToken = withXSRFToken(newConfig));
        if (withXSRFToken || withXSRFToken !== false && isURLSameOrigin(newConfig.url)) {
          const xsrfValue = xsrfHeaderName && xsrfCookieName && cookies.read(xsrfCookieName);
          if (xsrfValue) {
            headers.set(xsrfHeaderName, xsrfValue);
          }
        }
      }
      return newConfig;
    };
    var isXHRAdapterSupported = typeof XMLHttpRequest !== "undefined";
    var xhrAdapter = isXHRAdapterSupported && function(config) {
      return new Promise(function dispatchXhrRequest(resolve, reject) {
        const _config = resolveConfig(config);
        let requestData = _config.data;
        const requestHeaders = AxiosHeaders$1.from(_config.headers).normalize();
        let { responseType, onUploadProgress, onDownloadProgress } = _config;
        let onCanceled;
        let uploadThrottled, downloadThrottled;
        let flushUpload, flushDownload;
        function done() {
          flushUpload && flushUpload();
          flushDownload && flushDownload();
          _config.cancelToken && _config.cancelToken.unsubscribe(onCanceled);
          _config.signal && _config.signal.removeEventListener("abort", onCanceled);
        }
        let request = new XMLHttpRequest();
        request.open(_config.method.toUpperCase(), _config.url, true);
        request.timeout = _config.timeout;
        function onloadend() {
          if (!request) {
            return;
          }
          const responseHeaders = AxiosHeaders$1.from(
            "getAllResponseHeaders" in request && request.getAllResponseHeaders()
          );
          const responseData = !responseType || responseType === "text" || responseType === "json" ? request.responseText : request.response;
          const response = {
            data: responseData,
            status: request.status,
            statusText: request.statusText,
            headers: responseHeaders,
            config,
            request
          };
          settle(function _resolve(value) {
            resolve(value);
            done();
          }, function _reject(err) {
            reject(err);
            done();
          }, response);
          request = null;
        }
        if ("onloadend" in request) {
          request.onloadend = onloadend;
        } else {
          request.onreadystatechange = function handleLoad() {
            if (!request || request.readyState !== 4) {
              return;
            }
            if (request.status === 0 && !(request.responseURL && request.responseURL.indexOf("file:") === 0)) {
              return;
            }
            setTimeout(onloadend);
          };
        }
        request.onabort = function handleAbort() {
          if (!request) {
            return;
          }
          reject(new AxiosError$1("Request aborted", AxiosError$1.ECONNABORTED, config, request));
          request = null;
        };
        request.onerror = function handleError() {
          reject(new AxiosError$1("Network Error", AxiosError$1.ERR_NETWORK, config, request));
          request = null;
        };
        request.ontimeout = function handleTimeout() {
          let timeoutErrorMessage = _config.timeout ? "timeout of " + _config.timeout + "ms exceeded" : "timeout exceeded";
          const transitional2 = _config.transitional || transitionalDefaults;
          if (_config.timeoutErrorMessage) {
            timeoutErrorMessage = _config.timeoutErrorMessage;
          }
          reject(new AxiosError$1(
            timeoutErrorMessage,
            transitional2.clarifyTimeoutError ? AxiosError$1.ETIMEDOUT : AxiosError$1.ECONNABORTED,
            config,
            request
          ));
          request = null;
        };
        requestData === void 0 && requestHeaders.setContentType(null);
        if ("setRequestHeader" in request) {
          utils$2.forEach(requestHeaders.toJSON(), function setRequestHeader(val, key) {
            request.setRequestHeader(key, val);
          });
        }
        if (!utils$2.isUndefined(_config.withCredentials)) {
          request.withCredentials = !!_config.withCredentials;
        }
        if (responseType && responseType !== "json") {
          request.responseType = _config.responseType;
        }
        if (onDownloadProgress) {
          [downloadThrottled, flushDownload] = progressEventReducer(onDownloadProgress, true);
          request.addEventListener("progress", downloadThrottled);
        }
        if (onUploadProgress && request.upload) {
          [uploadThrottled, flushUpload] = progressEventReducer(onUploadProgress);
          request.upload.addEventListener("progress", uploadThrottled);
          request.upload.addEventListener("loadend", flushUpload);
        }
        if (_config.cancelToken || _config.signal) {
          onCanceled = (cancel) => {
            if (!request) {
              return;
            }
            reject(!cancel || cancel.type ? new CanceledError$1(null, config, request) : cancel);
            request.abort();
            request = null;
          };
          _config.cancelToken && _config.cancelToken.subscribe(onCanceled);
          if (_config.signal) {
            _config.signal.aborted ? onCanceled() : _config.signal.addEventListener("abort", onCanceled);
          }
        }
        const protocol = parseProtocol(_config.url);
        if (protocol && platform.protocols.indexOf(protocol) === -1) {
          reject(new AxiosError$1("Unsupported protocol " + protocol + ":", AxiosError$1.ERR_BAD_REQUEST, config));
          return;
        }
        request.send(requestData || null);
      });
    };
    var composeSignals = (signals, timeout) => {
      let controller = new AbortController();
      let aborted;
      const onabort = function(cancel) {
        if (!aborted) {
          aborted = true;
          unsubscribe();
          const err = cancel instanceof Error ? cancel : this.reason;
          controller.abort(err instanceof AxiosError$1 ? err : new CanceledError$1(err instanceof Error ? err.message : err));
        }
      };
      let timer = timeout && setTimeout(() => {
        onabort(new AxiosError$1(`timeout ${timeout} of ms exceeded`, AxiosError$1.ETIMEDOUT));
      }, timeout);
      const unsubscribe = () => {
        if (signals) {
          timer && clearTimeout(timer);
          timer = null;
          signals.forEach((signal2) => {
            signal2 && (signal2.removeEventListener ? signal2.removeEventListener("abort", onabort) : signal2.unsubscribe(onabort));
          });
          signals = null;
        }
      };
      signals.forEach((signal2) => signal2 && signal2.addEventListener && signal2.addEventListener("abort", onabort));
      const { signal } = controller;
      signal.unsubscribe = unsubscribe;
      return [signal, () => {
        timer && clearTimeout(timer);
        timer = null;
      }];
    };
    var streamChunk = function* (chunk, chunkSize) {
      let len = chunk.byteLength;
      if (len < chunkSize) {
        yield chunk;
        return;
      }
      let pos = 0;
      let end;
      while (pos < len) {
        end = pos + chunkSize;
        yield chunk.slice(pos, end);
        pos = end;
      }
    };
    var readBytes = async function* (iterable, chunkSize, encode2) {
      for await (const chunk of iterable) {
        yield* streamChunk(ArrayBuffer.isView(chunk) ? chunk : await encode2(String(chunk)), chunkSize);
      }
    };
    var trackStream = (stream, chunkSize, onProgress, onFinish, encode2) => {
      const iterator = readBytes(stream, chunkSize, encode2);
      let bytes = 0;
      let done;
      let _onFinish = (e) => {
        if (!done) {
          done = true;
          onFinish && onFinish(e);
        }
      };
      return new ReadableStream({
        async pull(controller) {
          try {
            const { done: done2, value } = await iterator.next();
            if (done2) {
              _onFinish();
              controller.close();
              return;
            }
            let len = value.byteLength;
            if (onProgress) {
              let loadedBytes = bytes += len;
              onProgress(loadedBytes);
            }
            controller.enqueue(new Uint8Array(value));
          } catch (err) {
            _onFinish(err);
            throw err;
          }
        },
        cancel(reason) {
          _onFinish(reason);
          return iterator.return();
        }
      }, {
        highWaterMark: 2
      });
    };
    var isFetchSupported = typeof fetch === "function" && typeof Request === "function" && typeof Response === "function";
    var isReadableStreamSupported = isFetchSupported && typeof ReadableStream === "function";
    var encodeText = isFetchSupported && (typeof TextEncoder === "function" ? /* @__PURE__ */ ((encoder) => (str) => encoder.encode(str))(new TextEncoder()) : async (str) => new Uint8Array(await new Response(str).arrayBuffer()));
    var test = (fn, ...args) => {
      try {
        return !!fn(...args);
      } catch (e) {
        return false;
      }
    };
    var supportsRequestStream = isReadableStreamSupported && test(() => {
      let duplexAccessed = false;
      const hasContentType = new Request(platform.origin, {
        body: new ReadableStream(),
        method: "POST",
        get duplex() {
          duplexAccessed = true;
          return "half";
        }
      }).headers.has("Content-Type");
      return duplexAccessed && !hasContentType;
    });
    var DEFAULT_CHUNK_SIZE = 64 * 1024;
    var supportsResponseStream = isReadableStreamSupported && test(() => utils$2.isReadableStream(new Response("").body));
    var resolvers = {
      stream: supportsResponseStream && ((res) => res.body)
    };
    isFetchSupported && ((res) => {
      ["text", "arrayBuffer", "blob", "formData", "stream"].forEach((type) => {
        !resolvers[type] && (resolvers[type] = utils$2.isFunction(res[type]) ? (res2) => res2[type]() : (_2, config) => {
          throw new AxiosError$1(`Response type '${type}' is not supported`, AxiosError$1.ERR_NOT_SUPPORT, config);
        });
      });
    })(new Response());
    var getBodyLength = async (body) => {
      if (body == null) {
        return 0;
      }
      if (utils$2.isBlob(body)) {
        return body.size;
      }
      if (utils$2.isSpecCompliantForm(body)) {
        return (await new Request(body).arrayBuffer()).byteLength;
      }
      if (utils$2.isArrayBufferView(body) || utils$2.isArrayBuffer(body)) {
        return body.byteLength;
      }
      if (utils$2.isURLSearchParams(body)) {
        body = body + "";
      }
      if (utils$2.isString(body)) {
        return (await encodeText(body)).byteLength;
      }
    };
    var resolveBodyLength = async (headers, body) => {
      const length = utils$2.toFiniteNumber(headers.getContentLength());
      return length == null ? getBodyLength(body) : length;
    };
    var fetchAdapter = isFetchSupported && (async (config) => {
      let {
        url,
        method,
        data,
        signal,
        cancelToken,
        timeout,
        onDownloadProgress,
        onUploadProgress,
        responseType,
        headers,
        withCredentials = "same-origin",
        fetchOptions
      } = resolveConfig(config);
      responseType = responseType ? (responseType + "").toLowerCase() : "text";
      let [composedSignal, stopTimeout] = signal || cancelToken || timeout ? composeSignals([signal, cancelToken], timeout) : [];
      let finished, request;
      const onFinish = () => {
        !finished && setTimeout(() => {
          composedSignal && composedSignal.unsubscribe();
        });
        finished = true;
      };
      let requestContentLength;
      try {
        if (onUploadProgress && supportsRequestStream && method !== "get" && method !== "head" && (requestContentLength = await resolveBodyLength(headers, data)) !== 0) {
          let _request = new Request(url, {
            method: "POST",
            body: data,
            duplex: "half"
          });
          let contentTypeHeader;
          if (utils$2.isFormData(data) && (contentTypeHeader = _request.headers.get("content-type"))) {
            headers.setContentType(contentTypeHeader);
          }
          if (_request.body) {
            const [onProgress, flush] = progressEventDecorator(
              requestContentLength,
              progressEventReducer(asyncDecorator(onUploadProgress))
            );
            data = trackStream(_request.body, DEFAULT_CHUNK_SIZE, onProgress, flush, encodeText);
          }
        }
        if (!utils$2.isString(withCredentials)) {
          withCredentials = withCredentials ? "include" : "omit";
        }
        request = new Request(url, {
          ...fetchOptions,
          signal: composedSignal,
          method: method.toUpperCase(),
          headers: headers.normalize().toJSON(),
          body: data,
          duplex: "half",
          credentials: withCredentials
        });
        let response = await fetch(request);
        const isStreamResponse = supportsResponseStream && (responseType === "stream" || responseType === "response");
        if (supportsResponseStream && (onDownloadProgress || isStreamResponse)) {
          const options = {};
          ["status", "statusText", "headers"].forEach((prop) => {
            options[prop] = response[prop];
          });
          const responseContentLength = utils$2.toFiniteNumber(response.headers.get("content-length"));
          const [onProgress, flush] = onDownloadProgress && progressEventDecorator(
            responseContentLength,
            progressEventReducer(asyncDecorator(onDownloadProgress), true)
          ) || [];
          response = new Response(
            trackStream(response.body, DEFAULT_CHUNK_SIZE, onProgress, () => {
              flush && flush();
              isStreamResponse && onFinish();
            }, encodeText),
            options
          );
        }
        responseType = responseType || "text";
        let responseData = await resolvers[utils$2.findKey(resolvers, responseType) || "text"](response, config);
        !isStreamResponse && onFinish();
        stopTimeout && stopTimeout();
        return await new Promise((resolve, reject) => {
          settle(resolve, reject, {
            data: responseData,
            headers: AxiosHeaders$1.from(response.headers),
            status: response.status,
            statusText: response.statusText,
            config,
            request
          });
        });
      } catch (err) {
        onFinish();
        if (err && err.name === "TypeError" && /fetch/i.test(err.message)) {
          throw Object.assign(
            new AxiosError$1("Network Error", AxiosError$1.ERR_NETWORK, config, request),
            {
              cause: err.cause || err
            }
          );
        }
        throw AxiosError$1.from(err, err && err.code, config, request);
      }
    });
    var knownAdapters = {
      http: httpAdapter,
      xhr: xhrAdapter,
      fetch: fetchAdapter
    };
    utils$2.forEach(knownAdapters, (fn, value) => {
      if (fn) {
        try {
          Object.defineProperty(fn, "name", { value });
        } catch (e) {
        }
        Object.defineProperty(fn, "adapterName", { value });
      }
    });
    var renderReason = (reason) => `- ${reason}`;
    var isResolvedHandle = (adapter) => utils$2.isFunction(adapter) || adapter === null || adapter === false;
    var adapters = {
      getAdapter: (adapters2) => {
        adapters2 = utils$2.isArray(adapters2) ? adapters2 : [adapters2];
        const { length } = adapters2;
        let nameOrAdapter;
        let adapter;
        const rejectedReasons = {};
        for (let i = 0; i < length; i++) {
          nameOrAdapter = adapters2[i];
          let id;
          adapter = nameOrAdapter;
          if (!isResolvedHandle(nameOrAdapter)) {
            adapter = knownAdapters[(id = String(nameOrAdapter)).toLowerCase()];
            if (adapter === void 0) {
              throw new AxiosError$1(`Unknown adapter '${id}'`);
            }
          }
          if (adapter) {
            break;
          }
          rejectedReasons[id || "#" + i] = adapter;
        }
        if (!adapter) {
          const reasons = Object.entries(rejectedReasons).map(
            ([id, state]) => `adapter ${id} ` + (state === false ? "is not supported by the environment" : "is not available in the build")
          );
          let s = length ? reasons.length > 1 ? "since :\n" + reasons.map(renderReason).join("\n") : " " + renderReason(reasons[0]) : "as no adapter specified";
          throw new AxiosError$1(
            `There is no suitable adapter to dispatch the request ` + s,
            "ERR_NOT_SUPPORT"
          );
        }
        return adapter;
      },
      adapters: knownAdapters
    };
    function throwIfCancellationRequested(config) {
      if (config.cancelToken) {
        config.cancelToken.throwIfRequested();
      }
      if (config.signal && config.signal.aborted) {
        throw new CanceledError$1(null, config);
      }
    }
    function dispatchRequest(config) {
      throwIfCancellationRequested(config);
      config.headers = AxiosHeaders$1.from(config.headers);
      config.data = transformData.call(
        config,
        config.transformRequest
      );
      if (["post", "put", "patch"].indexOf(config.method) !== -1) {
        config.headers.setContentType("application/x-www-form-urlencoded", false);
      }
      const adapter = adapters.getAdapter(config.adapter || defaults.adapter);
      return adapter(config).then(function onAdapterResolution(response) {
        throwIfCancellationRequested(config);
        response.data = transformData.call(
          config,
          config.transformResponse,
          response
        );
        response.headers = AxiosHeaders$1.from(response.headers);
        return response;
      }, function onAdapterRejection(reason) {
        if (!isCancel$1(reason)) {
          throwIfCancellationRequested(config);
          if (reason && reason.response) {
            reason.response.data = transformData.call(
              config,
              config.transformResponse,
              reason.response
            );
            reason.response.headers = AxiosHeaders$1.from(reason.response.headers);
          }
        }
        return Promise.reject(reason);
      });
    }
    var VERSION$1 = "1.7.4";
    var validators$1 = {};
    ["object", "boolean", "number", "function", "string", "symbol"].forEach((type, i) => {
      validators$1[type] = function validator2(thing) {
        return typeof thing === type || "a" + (i < 1 ? "n " : " ") + type;
      };
    });
    var deprecatedWarnings = {};
    validators$1.transitional = function transitional(validator2, version2, message) {
      function formatMessage(opt, desc) {
        return "[Axios v" + VERSION$1 + "] Transitional option '" + opt + "'" + desc + (message ? ". " + message : "");
      }
      return (value, opt, opts) => {
        if (validator2 === false) {
          throw new AxiosError$1(
            formatMessage(opt, " has been removed" + (version2 ? " in " + version2 : "")),
            AxiosError$1.ERR_DEPRECATED
          );
        }
        if (version2 && !deprecatedWarnings[opt]) {
          deprecatedWarnings[opt] = true;
          console.warn(
            formatMessage(
              opt,
              " has been deprecated since v" + version2 + " and will be removed in the near future"
            )
          );
        }
        return validator2 ? validator2(value, opt, opts) : true;
      };
    };
    function assertOptions(options, schema, allowUnknown) {
      if (typeof options !== "object") {
        throw new AxiosError$1("options must be an object", AxiosError$1.ERR_BAD_OPTION_VALUE);
      }
      const keys2 = Object.keys(options);
      let i = keys2.length;
      while (i-- > 0) {
        const opt = keys2[i];
        const validator2 = schema[opt];
        if (validator2) {
          const value = options[opt];
          const result = value === void 0 || validator2(value, opt, options);
          if (result !== true) {
            throw new AxiosError$1("option " + opt + " must be " + result, AxiosError$1.ERR_BAD_OPTION_VALUE);
          }
          continue;
        }
        if (allowUnknown !== true) {
          throw new AxiosError$1("Unknown option " + opt, AxiosError$1.ERR_BAD_OPTION);
        }
      }
    }
    var validator = {
      assertOptions,
      validators: validators$1
    };
    var validators = validator.validators;
    var Axios$1 = class Axios {
      constructor(instanceConfig) {
        this.defaults = instanceConfig;
        this.interceptors = {
          request: new InterceptorManager(),
          response: new InterceptorManager()
        };
      }
      /**
       * Dispatch a request
       *
       * @param {String|Object} configOrUrl The config specific for this request (merged with this.defaults)
       * @param {?Object} config
       *
       * @returns {Promise} The Promise to be fulfilled
       */
      async request(configOrUrl, config) {
        try {
          return await this._request(configOrUrl, config);
        } catch (err) {
          if (err instanceof Error) {
            let dummy;
            Error.captureStackTrace ? Error.captureStackTrace(dummy = {}) : dummy = new Error();
            const stack = dummy.stack ? dummy.stack.replace(/^.+\n/, "") : "";
            try {
              if (!err.stack) {
                err.stack = stack;
              } else if (stack && !String(err.stack).endsWith(stack.replace(/^.+\n.+\n/, ""))) {
                err.stack += "\n" + stack;
              }
            } catch (e) {
            }
          }
          throw err;
        }
      }
      _request(configOrUrl, config) {
        if (typeof configOrUrl === "string") {
          config = config || {};
          config.url = configOrUrl;
        } else {
          config = configOrUrl || {};
        }
        config = mergeConfig$1(this.defaults, config);
        const { transitional: transitional2, paramsSerializer, headers } = config;
        if (transitional2 !== void 0) {
          validator.assertOptions(transitional2, {
            silentJSONParsing: validators.transitional(validators.boolean),
            forcedJSONParsing: validators.transitional(validators.boolean),
            clarifyTimeoutError: validators.transitional(validators.boolean)
          }, false);
        }
        if (paramsSerializer != null) {
          if (utils$2.isFunction(paramsSerializer)) {
            config.paramsSerializer = {
              serialize: paramsSerializer
            };
          } else {
            validator.assertOptions(paramsSerializer, {
              encode: validators.function,
              serialize: validators.function
            }, true);
          }
        }
        config.method = (config.method || this.defaults.method || "get").toLowerCase();
        let contextHeaders = headers && utils$2.merge(
          headers.common,
          headers[config.method]
        );
        headers && utils$2.forEach(
          ["delete", "get", "head", "post", "put", "patch", "common"],
          (method) => {
            delete headers[method];
          }
        );
        config.headers = AxiosHeaders$1.concat(contextHeaders, headers);
        const requestInterceptorChain = [];
        let synchronousRequestInterceptors = true;
        this.interceptors.request.forEach(function unshiftRequestInterceptors(interceptor) {
          if (typeof interceptor.runWhen === "function" && interceptor.runWhen(config) === false) {
            return;
          }
          synchronousRequestInterceptors = synchronousRequestInterceptors && interceptor.synchronous;
          requestInterceptorChain.unshift(interceptor.fulfilled, interceptor.rejected);
        });
        const responseInterceptorChain = [];
        this.interceptors.response.forEach(function pushResponseInterceptors(interceptor) {
          responseInterceptorChain.push(interceptor.fulfilled, interceptor.rejected);
        });
        let promise;
        let i = 0;
        let len;
        if (!synchronousRequestInterceptors) {
          const chain = [dispatchRequest.bind(this), void 0];
          chain.unshift.apply(chain, requestInterceptorChain);
          chain.push.apply(chain, responseInterceptorChain);
          len = chain.length;
          promise = Promise.resolve(config);
          while (i < len) {
            promise = promise.then(chain[i++], chain[i++]);
          }
          return promise;
        }
        len = requestInterceptorChain.length;
        let newConfig = config;
        i = 0;
        while (i < len) {
          const onFulfilled = requestInterceptorChain[i++];
          const onRejected = requestInterceptorChain[i++];
          try {
            newConfig = onFulfilled(newConfig);
          } catch (error) {
            onRejected.call(this, error);
            break;
          }
        }
        try {
          promise = dispatchRequest.call(this, newConfig);
        } catch (error) {
          return Promise.reject(error);
        }
        i = 0;
        len = responseInterceptorChain.length;
        while (i < len) {
          promise = promise.then(responseInterceptorChain[i++], responseInterceptorChain[i++]);
        }
        return promise;
      }
      getUri(config) {
        config = mergeConfig$1(this.defaults, config);
        const fullPath = buildFullPath(config.baseURL, config.url);
        return buildURL(fullPath, config.params, config.paramsSerializer);
      }
    };
    utils$2.forEach(["delete", "get", "head", "options"], function forEachMethodNoData(method) {
      Axios$1.prototype[method] = function(url, config) {
        return this.request(mergeConfig$1(config || {}, {
          method,
          url,
          data: (config || {}).data
        }));
      };
    });
    utils$2.forEach(["post", "put", "patch"], function forEachMethodWithData(method) {
      function generateHTTPMethod(isForm) {
        return function httpMethod(url, data, config) {
          return this.request(mergeConfig$1(config || {}, {
            method,
            headers: isForm ? {
              "Content-Type": "multipart/form-data"
            } : {},
            url,
            data
          }));
        };
      }
      Axios$1.prototype[method] = generateHTTPMethod();
      Axios$1.prototype[method + "Form"] = generateHTTPMethod(true);
    });
    var CancelToken$1 = class CancelToken {
      constructor(executor) {
        if (typeof executor !== "function") {
          throw new TypeError("executor must be a function.");
        }
        let resolvePromise;
        this.promise = new Promise(function promiseExecutor(resolve) {
          resolvePromise = resolve;
        });
        const token = this;
        this.promise.then((cancel) => {
          if (!token._listeners)
            return;
          let i = token._listeners.length;
          while (i-- > 0) {
            token._listeners[i](cancel);
          }
          token._listeners = null;
        });
        this.promise.then = (onfulfilled) => {
          let _resolve;
          const promise = new Promise((resolve) => {
            token.subscribe(resolve);
            _resolve = resolve;
          }).then(onfulfilled);
          promise.cancel = function reject() {
            token.unsubscribe(_resolve);
          };
          return promise;
        };
        executor(function cancel(message, config, request) {
          if (token.reason) {
            return;
          }
          token.reason = new CanceledError$1(message, config, request);
          resolvePromise(token.reason);
        });
      }
      /**
       * Throws a `CanceledError` if cancellation has been requested.
       */
      throwIfRequested() {
        if (this.reason) {
          throw this.reason;
        }
      }
      /**
       * Subscribe to the cancel signal
       */
      subscribe(listener) {
        if (this.reason) {
          listener(this.reason);
          return;
        }
        if (this._listeners) {
          this._listeners.push(listener);
        } else {
          this._listeners = [listener];
        }
      }
      /**
       * Unsubscribe from the cancel signal
       */
      unsubscribe(listener) {
        if (!this._listeners) {
          return;
        }
        const index = this._listeners.indexOf(listener);
        if (index !== -1) {
          this._listeners.splice(index, 1);
        }
      }
      /**
       * Returns an object that contains a new `CancelToken` and a function that, when called,
       * cancels the `CancelToken`.
       */
      static source() {
        let cancel;
        const token = new CancelToken(function executor(c) {
          cancel = c;
        });
        return {
          token,
          cancel
        };
      }
    };
    function spread$1(callback) {
      return function wrap(arr) {
        return callback.apply(null, arr);
      };
    }
    function isAxiosError$1(payload) {
      return utils$2.isObject(payload) && payload.isAxiosError === true;
    }
    var HttpStatusCode$1 = {
      Continue: 100,
      SwitchingProtocols: 101,
      Processing: 102,
      EarlyHints: 103,
      Ok: 200,
      Created: 201,
      Accepted: 202,
      NonAuthoritativeInformation: 203,
      NoContent: 204,
      ResetContent: 205,
      PartialContent: 206,
      MultiStatus: 207,
      AlreadyReported: 208,
      ImUsed: 226,
      MultipleChoices: 300,
      MovedPermanently: 301,
      Found: 302,
      SeeOther: 303,
      NotModified: 304,
      UseProxy: 305,
      Unused: 306,
      TemporaryRedirect: 307,
      PermanentRedirect: 308,
      BadRequest: 400,
      Unauthorized: 401,
      PaymentRequired: 402,
      Forbidden: 403,
      NotFound: 404,
      MethodNotAllowed: 405,
      NotAcceptable: 406,
      ProxyAuthenticationRequired: 407,
      RequestTimeout: 408,
      Conflict: 409,
      Gone: 410,
      LengthRequired: 411,
      PreconditionFailed: 412,
      PayloadTooLarge: 413,
      UriTooLong: 414,
      UnsupportedMediaType: 415,
      RangeNotSatisfiable: 416,
      ExpectationFailed: 417,
      ImATeapot: 418,
      MisdirectedRequest: 421,
      UnprocessableEntity: 422,
      Locked: 423,
      FailedDependency: 424,
      TooEarly: 425,
      UpgradeRequired: 426,
      PreconditionRequired: 428,
      TooManyRequests: 429,
      RequestHeaderFieldsTooLarge: 431,
      UnavailableForLegalReasons: 451,
      InternalServerError: 500,
      NotImplemented: 501,
      BadGateway: 502,
      ServiceUnavailable: 503,
      GatewayTimeout: 504,
      HttpVersionNotSupported: 505,
      VariantAlsoNegotiates: 506,
      InsufficientStorage: 507,
      LoopDetected: 508,
      NotExtended: 510,
      NetworkAuthenticationRequired: 511
    };
    Object.entries(HttpStatusCode$1).forEach(([key, value]) => {
      HttpStatusCode$1[value] = key;
    });
    function createInstance(defaultConfig) {
      const context = new Axios$1(defaultConfig);
      const instance = bind(Axios$1.prototype.request, context);
      utils$2.extend(instance, Axios$1.prototype, context, { allOwnKeys: true });
      utils$2.extend(instance, context, null, { allOwnKeys: true });
      instance.create = function create(instanceConfig) {
        return createInstance(mergeConfig$1(defaultConfig, instanceConfig));
      };
      return instance;
    }
    var axios = createInstance(defaults);
    axios.Axios = Axios$1;
    axios.CanceledError = CanceledError$1;
    axios.CancelToken = CancelToken$1;
    axios.isCancel = isCancel$1;
    axios.VERSION = VERSION$1;
    axios.toFormData = toFormData$1;
    axios.AxiosError = AxiosError$1;
    axios.Cancel = axios.CanceledError;
    axios.all = function all(promises) {
      return Promise.all(promises);
    };
    axios.spread = spread$1;
    axios.isAxiosError = isAxiosError$1;
    axios.mergeConfig = mergeConfig$1;
    axios.AxiosHeaders = AxiosHeaders$1;
    axios.formToJSON = (thing) => formDataToJSON(utils$2.isHTMLForm(thing) ? new FormData(thing) : thing);
    axios.getAdapter = adapters.getAdapter;
    axios.HttpStatusCode = HttpStatusCode$1;
    axios.default = axios;
    var {
      Axios: Axios2,
      AxiosError,
      CanceledError,
      isCancel,
      CancelToken: CancelToken2,
      VERSION,
      all: all2,
      Cancel,
      isAxiosError,
      spread,
      toFormData,
      AxiosHeaders: AxiosHeaders2,
      HttpStatusCode,
      formToJSON,
      getAdapter,
      mergeConfig
    } = axios;
    var XLSX = {};
    XLSX.version = "0.18.5";
    var current_ansi = 1252;
    var VALID_ANSI = [874, 932, 936, 949, 950, 1250, 1251, 1252, 1253, 1254, 1255, 1256, 1257, 1258, 1e4];
    var set_ansi = function(cp) {
      if (VALID_ANSI.indexOf(cp) == -1)
        return;
      current_ansi = cp;
    };
    function reset_ansi() {
      set_ansi(1252);
    }
    var set_cp = function(cp) {
      set_ansi(cp);
    };
    function reset_cp() {
      set_cp(1200);
      reset_ansi();
    }
    var _getchar = function _gc1(x) {
      return String.fromCharCode(x);
    };
    var _getansi = function _ga1(x) {
      return String.fromCharCode(x);
    };
    var $cptable;
    var Base64_map = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";
    function Base64_encode(input) {
      var o = "";
      var c1 = 0, c2 = 0, c3 = 0, e1 = 0, e2 = 0, e3 = 0, e4 = 0;
      for (var i = 0; i < input.length; ) {
        c1 = input.charCodeAt(i++);
        e1 = c1 >> 2;
        c2 = input.charCodeAt(i++);
        e2 = (c1 & 3) << 4 | c2 >> 4;
        c3 = input.charCodeAt(i++);
        e3 = (c2 & 15) << 2 | c3 >> 6;
        e4 = c3 & 63;
        if (isNaN(c2)) {
          e3 = e4 = 64;
        } else if (isNaN(c3)) {
          e4 = 64;
        }
        o += Base64_map.charAt(e1) + Base64_map.charAt(e2) + Base64_map.charAt(e3) + Base64_map.charAt(e4);
      }
      return o;
    }
    function Base64_decode(input) {
      var o = "";
      var c1 = 0, c2 = 0, c3 = 0, e1 = 0, e2 = 0, e3 = 0, e4 = 0;
      input = input.replace(/[^\w\+\/\=]/g, "");
      for (var i = 0; i < input.length; ) {
        e1 = Base64_map.indexOf(input.charAt(i++));
        e2 = Base64_map.indexOf(input.charAt(i++));
        c1 = e1 << 2 | e2 >> 4;
        o += String.fromCharCode(c1);
        e3 = Base64_map.indexOf(input.charAt(i++));
        c2 = (e2 & 15) << 4 | e3 >> 2;
        if (e3 !== 64) {
          o += String.fromCharCode(c2);
        }
        e4 = Base64_map.indexOf(input.charAt(i++));
        c3 = (e3 & 3) << 6 | e4;
        if (e4 !== 64) {
          o += String.fromCharCode(c3);
        }
      }
      return o;
    }
    var has_buf = /* @__PURE__ */ function() {
      return typeof Buffer !== "undefined" && typeof process !== "undefined" && typeof process.versions !== "undefined" && !!process.versions.node;
    }();
    var Buffer_from = /* @__PURE__ */ function() {
      if (typeof Buffer !== "undefined") {
        var nbfs = !Buffer.from;
        if (!nbfs)
          try {
            Buffer.from("foo", "utf8");
          } catch (e) {
            nbfs = true;
          }
        return nbfs ? function(buf, enc) {
          return enc ? new Buffer(buf, enc) : new Buffer(buf);
        } : Buffer.from.bind(Buffer);
      }
      return function() {
      };
    }();
    function new_raw_buf(len) {
      if (has_buf)
        return Buffer.alloc ? Buffer.alloc(len) : new Buffer(len);
      return typeof Uint8Array != "undefined" ? new Uint8Array(len) : new Array(len);
    }
    function new_unsafe_buf(len) {
      if (has_buf)
        return Buffer.allocUnsafe ? Buffer.allocUnsafe(len) : new Buffer(len);
      return typeof Uint8Array != "undefined" ? new Uint8Array(len) : new Array(len);
    }
    var s2a = function s2a2(s) {
      if (has_buf)
        return Buffer_from(s, "binary");
      return s.split("").map(function(x) {
        return x.charCodeAt(0) & 255;
      });
    };
    function s2ab(s) {
      if (typeof ArrayBuffer === "undefined")
        return s2a(s);
      var buf = new ArrayBuffer(s.length), view = new Uint8Array(buf);
      for (var i = 0; i != s.length; ++i)
        view[i] = s.charCodeAt(i) & 255;
      return buf;
    }
    function a2s(data) {
      if (Array.isArray(data))
        return data.map(function(c) {
          return String.fromCharCode(c);
        }).join("");
      var o = [];
      for (var i = 0; i < data.length; ++i)
        o[i] = String.fromCharCode(data[i]);
      return o.join("");
    }
    function a2u(data) {
      if (typeof Uint8Array === "undefined")
        throw new Error("Unsupported");
      return new Uint8Array(data);
    }
    var bconcat = has_buf ? function(bufs) {
      return Buffer.concat(bufs.map(function(buf) {
        return Buffer.isBuffer(buf) ? buf : Buffer_from(buf);
      }));
    } : function(bufs) {
      if (typeof Uint8Array !== "undefined") {
        var i = 0, maxlen = 0;
        for (i = 0; i < bufs.length; ++i)
          maxlen += bufs[i].length;
        var o = new Uint8Array(maxlen);
        var len = 0;
        for (i = 0, maxlen = 0; i < bufs.length; maxlen += len, ++i) {
          len = bufs[i].length;
          if (bufs[i] instanceof Uint8Array)
            o.set(bufs[i], maxlen);
          else if (typeof bufs[i] == "string") {
            throw "wtf";
          } else
            o.set(new Uint8Array(bufs[i]), maxlen);
        }
        return o;
      }
      return [].concat.apply([], bufs.map(function(buf) {
        return Array.isArray(buf) ? buf : [].slice.call(buf);
      }));
    };
    function utf8decode(content) {
      var out = [], widx = 0, L = content.length + 250;
      var o = new_raw_buf(content.length + 255);
      for (var ridx = 0; ridx < content.length; ++ridx) {
        var c = content.charCodeAt(ridx);
        if (c < 128)
          o[widx++] = c;
        else if (c < 2048) {
          o[widx++] = 192 | c >> 6 & 31;
          o[widx++] = 128 | c & 63;
        } else if (c >= 55296 && c < 57344) {
          c = (c & 1023) + 64;
          var d = content.charCodeAt(++ridx) & 1023;
          o[widx++] = 240 | c >> 8 & 7;
          o[widx++] = 128 | c >> 2 & 63;
          o[widx++] = 128 | d >> 6 & 15 | (c & 3) << 4;
          o[widx++] = 128 | d & 63;
        } else {
          o[widx++] = 224 | c >> 12 & 15;
          o[widx++] = 128 | c >> 6 & 63;
          o[widx++] = 128 | c & 63;
        }
        if (widx > L) {
          out.push(o.slice(0, widx));
          widx = 0;
          o = new_raw_buf(65535);
          L = 65530;
        }
      }
      out.push(o.slice(0, widx));
      return bconcat(out);
    }
    var chr0 = /\u0000/g;
    var chr1 = /[\u0001-\u0006]/g;
    function _strrev(x) {
      var o = "", i = x.length - 1;
      while (i >= 0)
        o += x.charAt(i--);
      return o;
    }
    function pad0(v, d) {
      var t = "" + v;
      return t.length >= d ? t : fill("0", d - t.length) + t;
    }
    function pad_(v, d) {
      var t = "" + v;
      return t.length >= d ? t : fill(" ", d - t.length) + t;
    }
    function rpad_(v, d) {
      var t = "" + v;
      return t.length >= d ? t : t + fill(" ", d - t.length);
    }
    function pad0r1(v, d) {
      var t = "" + Math.round(v);
      return t.length >= d ? t : fill("0", d - t.length) + t;
    }
    function pad0r2(v, d) {
      var t = "" + v;
      return t.length >= d ? t : fill("0", d - t.length) + t;
    }
    var p2_32 = /* @__PURE__ */ Math.pow(2, 32);
    function pad0r(v, d) {
      if (v > p2_32 || v < -p2_32)
        return pad0r1(v, d);
      var i = Math.round(v);
      return pad0r2(i, d);
    }
    function SSF_isgeneral(s, i) {
      i = i || 0;
      return s.length >= 7 + i && (s.charCodeAt(i) | 32) === 103 && (s.charCodeAt(i + 1) | 32) === 101 && (s.charCodeAt(i + 2) | 32) === 110 && (s.charCodeAt(i + 3) | 32) === 101 && (s.charCodeAt(i + 4) | 32) === 114 && (s.charCodeAt(i + 5) | 32) === 97 && (s.charCodeAt(i + 6) | 32) === 108;
    }
    var days = [
      ["Sun", "Sunday"],
      ["Mon", "Monday"],
      ["Tue", "Tuesday"],
      ["Wed", "Wednesday"],
      ["Thu", "Thursday"],
      ["Fri", "Friday"],
      ["Sat", "Saturday"]
    ];
    var months = [
      ["J", "Jan", "January"],
      ["F", "Feb", "February"],
      ["M", "Mar", "March"],
      ["A", "Apr", "April"],
      ["M", "May", "May"],
      ["J", "Jun", "June"],
      ["J", "Jul", "July"],
      ["A", "Aug", "August"],
      ["S", "Sep", "September"],
      ["O", "Oct", "October"],
      ["N", "Nov", "November"],
      ["D", "Dec", "December"]
    ];
    function SSF_init_table(t) {
      if (!t)
        t = {};
      t[0] = "General";
      t[1] = "0";
      t[2] = "0.00";
      t[3] = "#,##0";
      t[4] = "#,##0.00";
      t[9] = "0%";
      t[10] = "0.00%";
      t[11] = "0.00E+00";
      t[12] = "# ?/?";
      t[13] = "# ??/??";
      t[14] = "m/d/yy";
      t[15] = "d-mmm-yy";
      t[16] = "d-mmm";
      t[17] = "mmm-yy";
      t[18] = "h:mm AM/PM";
      t[19] = "h:mm:ss AM/PM";
      t[20] = "h:mm";
      t[21] = "h:mm:ss";
      t[22] = "m/d/yy h:mm";
      t[37] = "#,##0 ;(#,##0)";
      t[38] = "#,##0 ;[Red](#,##0)";
      t[39] = "#,##0.00;(#,##0.00)";
      t[40] = "#,##0.00;[Red](#,##0.00)";
      t[45] = "mm:ss";
      t[46] = "[h]:mm:ss";
      t[47] = "mmss.0";
      t[48] = "##0.0E+0";
      t[49] = "@";
      t[56] = '"\u4E0A\u5348/\u4E0B\u5348 "hh"\u6642"mm"\u5206"ss"\u79D2 "';
      return t;
    }
    var table_fmt = {
      0: "General",
      1: "0",
      2: "0.00",
      3: "#,##0",
      4: "#,##0.00",
      9: "0%",
      10: "0.00%",
      11: "0.00E+00",
      12: "# ?/?",
      13: "# ??/??",
      14: "m/d/yy",
      15: "d-mmm-yy",
      16: "d-mmm",
      17: "mmm-yy",
      18: "h:mm AM/PM",
      19: "h:mm:ss AM/PM",
      20: "h:mm",
      21: "h:mm:ss",
      22: "m/d/yy h:mm",
      37: "#,##0 ;(#,##0)",
      38: "#,##0 ;[Red](#,##0)",
      39: "#,##0.00;(#,##0.00)",
      40: "#,##0.00;[Red](#,##0.00)",
      45: "mm:ss",
      46: "[h]:mm:ss",
      47: "mmss.0",
      48: "##0.0E+0",
      49: "@",
      56: '"\u4E0A\u5348/\u4E0B\u5348 "hh"\u6642"mm"\u5206"ss"\u79D2 "'
    };
    var SSF_default_map = {
      5: 37,
      6: 38,
      7: 39,
      8: 40,
      //  5 -> 37 ...  8 -> 40
      23: 0,
      24: 0,
      25: 0,
      26: 0,
      // 23 ->  0 ... 26 ->  0
      27: 14,
      28: 14,
      29: 14,
      30: 14,
      31: 14,
      // 27 -> 14 ... 31 -> 14
      50: 14,
      51: 14,
      52: 14,
      53: 14,
      54: 14,
      // 50 -> 14 ... 58 -> 14
      55: 14,
      56: 14,
      57: 14,
      58: 14,
      59: 1,
      60: 2,
      61: 3,
      62: 4,
      // 59 ->  1 ... 62 ->  4
      67: 9,
      68: 10,
      // 67 ->  9 ... 68 -> 10
      69: 12,
      70: 13,
      71: 14,
      // 69 -> 12 ... 71 -> 14
      72: 14,
      73: 15,
      74: 16,
      75: 17,
      // 72 -> 14 ... 75 -> 17
      76: 20,
      77: 21,
      78: 22,
      // 76 -> 20 ... 78 -> 22
      79: 45,
      80: 46,
      81: 47,
      // 79 -> 45 ... 81 -> 47
      82: 0
      // 82 ->  0 ... 65536 -> 0 (omitted)
    };
    var SSF_default_str = {
      //  5 -- Currency,   0 decimal, black negative
      5: '"$"#,##0_);\\("$"#,##0\\)',
      63: '"$"#,##0_);\\("$"#,##0\\)',
      //  6 -- Currency,   0 decimal, red   negative
      6: '"$"#,##0_);[Red]\\("$"#,##0\\)',
      64: '"$"#,##0_);[Red]\\("$"#,##0\\)',
      //  7 -- Currency,   2 decimal, black negative
      7: '"$"#,##0.00_);\\("$"#,##0.00\\)',
      65: '"$"#,##0.00_);\\("$"#,##0.00\\)',
      //  8 -- Currency,   2 decimal, red   negative
      8: '"$"#,##0.00_);[Red]\\("$"#,##0.00\\)',
      66: '"$"#,##0.00_);[Red]\\("$"#,##0.00\\)',
      // 41 -- Accounting, 0 decimal, No Symbol
      41: '_(* #,##0_);_(* \\(#,##0\\);_(* "-"_);_(@_)',
      // 42 -- Accounting, 0 decimal, $  Symbol
      42: '_("$"* #,##0_);_("$"* \\(#,##0\\);_("$"* "-"_);_(@_)',
      // 43 -- Accounting, 2 decimal, No Symbol
      43: '_(* #,##0.00_);_(* \\(#,##0.00\\);_(* "-"??_);_(@_)',
      // 44 -- Accounting, 2 decimal, $  Symbol
      44: '_("$"* #,##0.00_);_("$"* \\(#,##0.00\\);_("$"* "-"??_);_(@_)'
    };
    function SSF_frac(x, D, mixed) {
      var sgn = x < 0 ? -1 : 1;
      var B = x * sgn;
      var P_2 = 0, P_1 = 1, P = 0;
      var Q_2 = 1, Q_1 = 0, Q = 0;
      var A = Math.floor(B);
      while (Q_1 < D) {
        A = Math.floor(B);
        P = A * P_1 + P_2;
        Q = A * Q_1 + Q_2;
        if (B - A < 5e-8)
          break;
        B = 1 / (B - A);
        P_2 = P_1;
        P_1 = P;
        Q_2 = Q_1;
        Q_1 = Q;
      }
      if (Q > D) {
        if (Q_1 > D) {
          Q = Q_2;
          P = P_2;
        } else {
          Q = Q_1;
          P = P_1;
        }
      }
      if (!mixed)
        return [0, sgn * P, Q];
      var q = Math.floor(sgn * P / Q);
      return [q, sgn * P - q * Q, Q];
    }
    function SSF_parse_date_code(v, opts, b2) {
      if (v > 2958465 || v < 0)
        return null;
      var date = v | 0, time = Math.floor(86400 * (v - date)), dow = 0;
      var dout = [];
      var out = { D: date, T: time, u: 86400 * (v - date) - time, y: 0, m: 0, d: 0, H: 0, M: 0, S: 0, q: 0 };
      if (Math.abs(out.u) < 1e-6)
        out.u = 0;
      if (opts && opts.date1904)
        date += 1462;
      if (out.u > 0.9999) {
        out.u = 0;
        if (++time == 86400) {
          out.T = time = 0;
          ++date;
          ++out.D;
        }
      }
      if (date === 60) {
        dout = b2 ? [1317, 10, 29] : [1900, 2, 29];
        dow = 3;
      } else if (date === 0) {
        dout = b2 ? [1317, 8, 29] : [1900, 1, 0];
        dow = 6;
      } else {
        if (date > 60)
          --date;
        var d = new Date(1900, 0, 1);
        d.setDate(d.getDate() + date - 1);
        dout = [d.getFullYear(), d.getMonth() + 1, d.getDate()];
        dow = d.getDay();
        if (date < 60)
          dow = (dow + 6) % 7;
        if (b2)
          dow = SSF_fix_hijri(d, dout);
      }
      out.y = dout[0];
      out.m = dout[1];
      out.d = dout[2];
      out.S = time % 60;
      time = Math.floor(time / 60);
      out.M = time % 60;
      time = Math.floor(time / 60);
      out.H = time;
      out.q = dow;
      return out;
    }
    var SSFbasedate = /* @__PURE__ */ new Date(1899, 11, 31, 0, 0, 0);
    var SSFdnthresh = /* @__PURE__ */ SSFbasedate.getTime();
    var SSFbase1904 = /* @__PURE__ */ new Date(1900, 2, 1, 0, 0, 0);
    function datenum_local(v, date1904) {
      var epoch = /* @__PURE__ */ v.getTime();
      if (date1904)
        epoch -= 1461 * 24 * 60 * 60 * 1e3;
      else if (v >= SSFbase1904)
        epoch += 24 * 60 * 60 * 1e3;
      return (epoch - (SSFdnthresh + (/* @__PURE__ */ v.getTimezoneOffset() - /* @__PURE__ */ SSFbasedate.getTimezoneOffset()) * 6e4)) / (24 * 60 * 60 * 1e3);
    }
    function SSF_strip_decimal(o) {
      return o.indexOf(".") == -1 ? o : o.replace(/(?:\.0*|(\.\d*[1-9])0+)$/, "$1");
    }
    function SSF_normalize_exp(o) {
      if (o.indexOf("E") == -1)
        return o;
      return o.replace(/(?:\.0*|(\.\d*[1-9])0+)[Ee]/, "$1E").replace(/(E[+-])(\d)$/, "$10$2");
    }
    function SSF_small_exp(v) {
      var w = v < 0 ? 12 : 11;
      var o = SSF_strip_decimal(v.toFixed(12));
      if (o.length <= w)
        return o;
      o = v.toPrecision(10);
      if (o.length <= w)
        return o;
      return v.toExponential(5);
    }
    function SSF_large_exp(v) {
      var o = SSF_strip_decimal(v.toFixed(11));
      return o.length > (v < 0 ? 12 : 11) || o === "0" || o === "-0" ? v.toPrecision(6) : o;
    }
    function SSF_general_num(v) {
      var V = Math.floor(Math.log(Math.abs(v)) * Math.LOG10E), o;
      if (V >= -4 && V <= -1)
        o = v.toPrecision(10 + V);
      else if (Math.abs(V) <= 9)
        o = SSF_small_exp(v);
      else if (V === 10)
        o = v.toFixed(10).substr(0, 12);
      else
        o = SSF_large_exp(v);
      return SSF_strip_decimal(SSF_normalize_exp(o.toUpperCase()));
    }
    function SSF_general(v, opts) {
      switch (typeof v) {
        case "string":
          return v;
        case "boolean":
          return v ? "TRUE" : "FALSE";
        case "number":
          return (v | 0) === v ? v.toString(10) : SSF_general_num(v);
        case "undefined":
          return "";
        case "object":
          if (v == null)
            return "";
          if (v instanceof Date)
            return SSF_format(14, datenum_local(v, opts && opts.date1904), opts);
      }
      throw new Error("unsupported value in General format: " + v);
    }
    function SSF_fix_hijri(date, o) {
      o[0] -= 581;
      var dow = date.getDay();
      if (date < 60)
        dow = (dow + 6) % 7;
      return dow;
    }
    function SSF_write_date(type, fmt, val, ss0) {
      var o = "", ss = 0, tt = 0, y = val.y, out, outl = 0;
      switch (type) {
        case 98:
          y = val.y + 543;
        case 121:
          switch (fmt.length) {
            case 1:
            case 2:
              out = y % 100;
              outl = 2;
              break;
            default:
              out = y % 1e4;
              outl = 4;
              break;
          }
          break;
        case 109:
          switch (fmt.length) {
            case 1:
            case 2:
              out = val.m;
              outl = fmt.length;
              break;
            case 3:
              return months[val.m - 1][1];
            case 5:
              return months[val.m - 1][0];
            default:
              return months[val.m - 1][2];
          }
          break;
        case 100:
          switch (fmt.length) {
            case 1:
            case 2:
              out = val.d;
              outl = fmt.length;
              break;
            case 3:
              return days[val.q][0];
            default:
              return days[val.q][1];
          }
          break;
        case 104:
          switch (fmt.length) {
            case 1:
            case 2:
              out = 1 + (val.H + 11) % 12;
              outl = fmt.length;
              break;
            default:
              throw "bad hour format: " + fmt;
          }
          break;
        case 72:
          switch (fmt.length) {
            case 1:
            case 2:
              out = val.H;
              outl = fmt.length;
              break;
            default:
              throw "bad hour format: " + fmt;
          }
          break;
        case 77:
          switch (fmt.length) {
            case 1:
            case 2:
              out = val.M;
              outl = fmt.length;
              break;
            default:
              throw "bad minute format: " + fmt;
          }
          break;
        case 115:
          if (fmt != "s" && fmt != "ss" && fmt != ".0" && fmt != ".00" && fmt != ".000")
            throw "bad second format: " + fmt;
          if (val.u === 0 && (fmt == "s" || fmt == "ss"))
            return pad0(val.S, fmt.length);
          if (ss0 >= 2)
            tt = ss0 === 3 ? 1e3 : 100;
          else
            tt = ss0 === 1 ? 10 : 1;
          ss = Math.round(tt * (val.S + val.u));
          if (ss >= 60 * tt)
            ss = 0;
          if (fmt === "s")
            return ss === 0 ? "0" : "" + ss / tt;
          o = pad0(ss, 2 + ss0);
          if (fmt === "ss")
            return o.substr(0, 2);
          return "." + o.substr(2, fmt.length - 1);
        case 90:
          switch (fmt) {
            case "[h]":
            case "[hh]":
              out = val.D * 24 + val.H;
              break;
            case "[m]":
            case "[mm]":
              out = (val.D * 24 + val.H) * 60 + val.M;
              break;
            case "[s]":
            case "[ss]":
              out = ((val.D * 24 + val.H) * 60 + val.M) * 60 + Math.round(val.S + val.u);
              break;
            default:
              throw "bad abstime format: " + fmt;
          }
          outl = fmt.length === 3 ? 1 : 2;
          break;
        case 101:
          out = y;
          outl = 1;
          break;
      }
      var outstr = outl > 0 ? pad0(out, outl) : "";
      return outstr;
    }
    function commaify(s) {
      var w = 3;
      if (s.length <= w)
        return s;
      var j = s.length % w, o = s.substr(0, j);
      for (; j != s.length; j += w)
        o += (o.length > 0 ? "," : "") + s.substr(j, w);
      return o;
    }
    var pct1 = /%/g;
    function write_num_pct(type, fmt, val) {
      var sfmt = fmt.replace(pct1, ""), mul = fmt.length - sfmt.length;
      return write_num(type, sfmt, val * Math.pow(10, 2 * mul)) + fill("%", mul);
    }
    function write_num_cm(type, fmt, val) {
      var idx = fmt.length - 1;
      while (fmt.charCodeAt(idx - 1) === 44)
        --idx;
      return write_num(type, fmt.substr(0, idx), val / Math.pow(10, 3 * (fmt.length - idx)));
    }
    function write_num_exp(fmt, val) {
      var o;
      var idx = fmt.indexOf("E") - fmt.indexOf(".") - 1;
      if (fmt.match(/^#+0.0E\+0$/)) {
        if (val == 0)
          return "0.0E+0";
        else if (val < 0)
          return "-" + write_num_exp(fmt, -val);
        var period = fmt.indexOf(".");
        if (period === -1)
          period = fmt.indexOf("E");
        var ee = Math.floor(Math.log(val) * Math.LOG10E) % period;
        if (ee < 0)
          ee += period;
        o = (val / Math.pow(10, ee)).toPrecision(idx + 1 + (period + ee) % period);
        if (o.indexOf("e") === -1) {
          var fakee = Math.floor(Math.log(val) * Math.LOG10E);
          if (o.indexOf(".") === -1)
            o = o.charAt(0) + "." + o.substr(1) + "E+" + (fakee - o.length + ee);
          else
            o += "E+" + (fakee - ee);
          while (o.substr(0, 2) === "0.") {
            o = o.charAt(0) + o.substr(2, period) + "." + o.substr(2 + period);
            o = o.replace(/^0+([1-9])/, "$1").replace(/^0+\./, "0.");
          }
          o = o.replace(/\+-/, "-");
        }
        o = o.replace(/^([+-]?)(\d*)\.(\d*)[Ee]/, function($$, $1, $2, $3) {
          return $1 + $2 + $3.substr(0, (period + ee) % period) + "." + $3.substr(ee) + "E";
        });
      } else
        o = val.toExponential(idx);
      if (fmt.match(/E\+00$/) && o.match(/e[+-]\d$/))
        o = o.substr(0, o.length - 1) + "0" + o.charAt(o.length - 1);
      if (fmt.match(/E\-/) && o.match(/e\+/))
        o = o.replace(/e\+/, "e");
      return o.replace("e", "E");
    }
    var frac1 = /# (\?+)( ?)\/( ?)(\d+)/;
    function write_num_f1(r, aval, sign) {
      var den = parseInt(r[4], 10), rr = Math.round(aval * den), base = Math.floor(rr / den);
      var myn = rr - base * den, myd = den;
      return sign + (base === 0 ? "" : "" + base) + " " + (myn === 0 ? fill(" ", r[1].length + 1 + r[4].length) : pad_(myn, r[1].length) + r[2] + "/" + r[3] + pad0(myd, r[4].length));
    }
    function write_num_f2(r, aval, sign) {
      return sign + (aval === 0 ? "" : "" + aval) + fill(" ", r[1].length + 2 + r[4].length);
    }
    var dec1 = /^#*0*\.([0#]+)/;
    var closeparen = /\).*[0#]/;
    var phone = /\(###\) ###\\?-####/;
    function hashq(str) {
      var o = "", cc;
      for (var i = 0; i != str.length; ++i)
        switch (cc = str.charCodeAt(i)) {
          case 35:
            break;
          case 63:
            o += " ";
            break;
          case 48:
            o += "0";
            break;
          default:
            o += String.fromCharCode(cc);
        }
      return o;
    }
    function rnd(val, d) {
      var dd = Math.pow(10, d);
      return "" + Math.round(val * dd) / dd;
    }
    function dec(val, d) {
      var _frac = val - Math.floor(val), dd = Math.pow(10, d);
      if (d < ("" + Math.round(_frac * dd)).length)
        return 0;
      return Math.round(_frac * dd);
    }
    function carry(val, d) {
      if (d < ("" + Math.round((val - Math.floor(val)) * Math.pow(10, d))).length) {
        return 1;
      }
      return 0;
    }
    function flr(val) {
      if (val < 2147483647 && val > -2147483648)
        return "" + (val >= 0 ? val | 0 : val - 1 | 0);
      return "" + Math.floor(val);
    }
    function write_num_flt(type, fmt, val) {
      if (type.charCodeAt(0) === 40 && !fmt.match(closeparen)) {
        var ffmt = fmt.replace(/\( */, "").replace(/ \)/, "").replace(/\)/, "");
        if (val >= 0)
          return write_num_flt("n", ffmt, val);
        return "(" + write_num_flt("n", ffmt, -val) + ")";
      }
      if (fmt.charCodeAt(fmt.length - 1) === 44)
        return write_num_cm(type, fmt, val);
      if (fmt.indexOf("%") !== -1)
        return write_num_pct(type, fmt, val);
      if (fmt.indexOf("E") !== -1)
        return write_num_exp(fmt, val);
      if (fmt.charCodeAt(0) === 36)
        return "$" + write_num_flt(type, fmt.substr(fmt.charAt(1) == " " ? 2 : 1), val);
      var o;
      var r, ri, ff, aval = Math.abs(val), sign = val < 0 ? "-" : "";
      if (fmt.match(/^00+$/))
        return sign + pad0r(aval, fmt.length);
      if (fmt.match(/^[#?]+$/)) {
        o = pad0r(val, 0);
        if (o === "0")
          o = "";
        return o.length > fmt.length ? o : hashq(fmt.substr(0, fmt.length - o.length)) + o;
      }
      if (r = fmt.match(frac1))
        return write_num_f1(r, aval, sign);
      if (fmt.match(/^#+0+$/))
        return sign + pad0r(aval, fmt.length - fmt.indexOf("0"));
      if (r = fmt.match(dec1)) {
        o = rnd(val, r[1].length).replace(/^([^\.]+)$/, "$1." + hashq(r[1])).replace(/\.$/, "." + hashq(r[1])).replace(/\.(\d*)$/, function($$, $1) {
          return "." + $1 + fill("0", hashq(
            /*::(*/
            r[1]
          ).length - $1.length);
        });
        return fmt.indexOf("0.") !== -1 ? o : o.replace(/^0\./, ".");
      }
      fmt = fmt.replace(/^#+([0.])/, "$1");
      if (r = fmt.match(/^(0*)\.(#*)$/)) {
        return sign + rnd(aval, r[2].length).replace(/\.(\d*[1-9])0*$/, ".$1").replace(/^(-?\d*)$/, "$1.").replace(/^0\./, r[1].length ? "0." : ".");
      }
      if (r = fmt.match(/^#{1,3},##0(\.?)$/))
        return sign + commaify(pad0r(aval, 0));
      if (r = fmt.match(/^#,##0\.([#0]*0)$/)) {
        return val < 0 ? "-" + write_num_flt(type, fmt, -val) : commaify("" + (Math.floor(val) + carry(val, r[1].length))) + "." + pad0(dec(val, r[1].length), r[1].length);
      }
      if (r = fmt.match(/^#,#*,#0/))
        return write_num_flt(type, fmt.replace(/^#,#*,/, ""), val);
      if (r = fmt.match(/^([0#]+)(\\?-([0#]+))+$/)) {
        o = _strrev(write_num_flt(type, fmt.replace(/[\\-]/g, ""), val));
        ri = 0;
        return _strrev(_strrev(fmt.replace(/\\/g, "")).replace(/[0#]/g, function(x2) {
          return ri < o.length ? o.charAt(ri++) : x2 === "0" ? "0" : "";
        }));
      }
      if (fmt.match(phone)) {
        o = write_num_flt(type, "##########", val);
        return "(" + o.substr(0, 3) + ") " + o.substr(3, 3) + "-" + o.substr(6);
      }
      var oa = "";
      if (r = fmt.match(/^([#0?]+)( ?)\/( ?)([#0?]+)/)) {
        ri = Math.min(
          /*::String(*/
          r[4].length,
          7
        );
        ff = SSF_frac(aval, Math.pow(10, ri) - 1, false);
        o = "" + sign;
        oa = write_num(
          "n",
          /*::String(*/
          r[1],
          ff[1]
        );
        if (oa.charAt(oa.length - 1) == " ")
          oa = oa.substr(0, oa.length - 1) + "0";
        o += oa + /*::String(*/
        r[2] + "/" + /*::String(*/
        r[3];
        oa = rpad_(ff[2], ri);
        if (oa.length < r[4].length)
          oa = hashq(r[4].substr(r[4].length - oa.length)) + oa;
        o += oa;
        return o;
      }
      if (r = fmt.match(/^# ([#0?]+)( ?)\/( ?)([#0?]+)/)) {
        ri = Math.min(Math.max(r[1].length, r[4].length), 7);
        ff = SSF_frac(aval, Math.pow(10, ri) - 1, true);
        return sign + (ff[0] || (ff[1] ? "" : "0")) + " " + (ff[1] ? pad_(ff[1], ri) + r[2] + "/" + r[3] + rpad_(ff[2], ri) : fill(" ", 2 * ri + 1 + r[2].length + r[3].length));
      }
      if (r = fmt.match(/^[#0?]+$/)) {
        o = pad0r(val, 0);
        if (fmt.length <= o.length)
          return o;
        return hashq(fmt.substr(0, fmt.length - o.length)) + o;
      }
      if (r = fmt.match(/^([#0?]+)\.([#0]+)$/)) {
        o = "" + val.toFixed(Math.min(r[2].length, 10)).replace(/([^0])0+$/, "$1");
        ri = o.indexOf(".");
        var lres = fmt.indexOf(".") - ri, rres = fmt.length - o.length - lres;
        return hashq(fmt.substr(0, lres) + o + fmt.substr(fmt.length - rres));
      }
      if (r = fmt.match(/^00,000\.([#0]*0)$/)) {
        ri = dec(val, r[1].length);
        return val < 0 ? "-" + write_num_flt(type, fmt, -val) : commaify(flr(val)).replace(/^\d,\d{3}$/, "0$&").replace(/^\d*$/, function($$) {
          return "00," + ($$.length < 3 ? pad0(0, 3 - $$.length) : "") + $$;
        }) + "." + pad0(ri, r[1].length);
      }
      switch (fmt) {
        case "###,##0.00":
          return write_num_flt(type, "#,##0.00", val);
        case "###,###":
        case "##,###":
        case "#,###":
          var x = commaify(pad0r(aval, 0));
          return x !== "0" ? sign + x : "";
        case "###,###.00":
          return write_num_flt(type, "###,##0.00", val).replace(/^0\./, ".");
        case "#,###.00":
          return write_num_flt(type, "#,##0.00", val).replace(/^0\./, ".");
      }
      throw new Error("unsupported format |" + fmt + "|");
    }
    function write_num_cm2(type, fmt, val) {
      var idx = fmt.length - 1;
      while (fmt.charCodeAt(idx - 1) === 44)
        --idx;
      return write_num(type, fmt.substr(0, idx), val / Math.pow(10, 3 * (fmt.length - idx)));
    }
    function write_num_pct2(type, fmt, val) {
      var sfmt = fmt.replace(pct1, ""), mul = fmt.length - sfmt.length;
      return write_num(type, sfmt, val * Math.pow(10, 2 * mul)) + fill("%", mul);
    }
    function write_num_exp2(fmt, val) {
      var o;
      var idx = fmt.indexOf("E") - fmt.indexOf(".") - 1;
      if (fmt.match(/^#+0.0E\+0$/)) {
        if (val == 0)
          return "0.0E+0";
        else if (val < 0)
          return "-" + write_num_exp2(fmt, -val);
        var period = fmt.indexOf(".");
        if (period === -1)
          period = fmt.indexOf("E");
        var ee = Math.floor(Math.log(val) * Math.LOG10E) % period;
        if (ee < 0)
          ee += period;
        o = (val / Math.pow(10, ee)).toPrecision(idx + 1 + (period + ee) % period);
        if (!o.match(/[Ee]/)) {
          var fakee = Math.floor(Math.log(val) * Math.LOG10E);
          if (o.indexOf(".") === -1)
            o = o.charAt(0) + "." + o.substr(1) + "E+" + (fakee - o.length + ee);
          else
            o += "E+" + (fakee - ee);
          o = o.replace(/\+-/, "-");
        }
        o = o.replace(/^([+-]?)(\d*)\.(\d*)[Ee]/, function($$, $1, $2, $3) {
          return $1 + $2 + $3.substr(0, (period + ee) % period) + "." + $3.substr(ee) + "E";
        });
      } else
        o = val.toExponential(idx);
      if (fmt.match(/E\+00$/) && o.match(/e[+-]\d$/))
        o = o.substr(0, o.length - 1) + "0" + o.charAt(o.length - 1);
      if (fmt.match(/E\-/) && o.match(/e\+/))
        o = o.replace(/e\+/, "e");
      return o.replace("e", "E");
    }
    function write_num_int(type, fmt, val) {
      if (type.charCodeAt(0) === 40 && !fmt.match(closeparen)) {
        var ffmt = fmt.replace(/\( */, "").replace(/ \)/, "").replace(/\)/, "");
        if (val >= 0)
          return write_num_int("n", ffmt, val);
        return "(" + write_num_int("n", ffmt, -val) + ")";
      }
      if (fmt.charCodeAt(fmt.length - 1) === 44)
        return write_num_cm2(type, fmt, val);
      if (fmt.indexOf("%") !== -1)
        return write_num_pct2(type, fmt, val);
      if (fmt.indexOf("E") !== -1)
        return write_num_exp2(fmt, val);
      if (fmt.charCodeAt(0) === 36)
        return "$" + write_num_int(type, fmt.substr(fmt.charAt(1) == " " ? 2 : 1), val);
      var o;
      var r, ri, ff, aval = Math.abs(val), sign = val < 0 ? "-" : "";
      if (fmt.match(/^00+$/))
        return sign + pad0(aval, fmt.length);
      if (fmt.match(/^[#?]+$/)) {
        o = "" + val;
        if (val === 0)
          o = "";
        return o.length > fmt.length ? o : hashq(fmt.substr(0, fmt.length - o.length)) + o;
      }
      if (r = fmt.match(frac1))
        return write_num_f2(r, aval, sign);
      if (fmt.match(/^#+0+$/))
        return sign + pad0(aval, fmt.length - fmt.indexOf("0"));
      if (r = fmt.match(dec1)) {
        o = ("" + val).replace(/^([^\.]+)$/, "$1." + hashq(r[1])).replace(/\.$/, "." + hashq(r[1]));
        o = o.replace(/\.(\d*)$/, function($$, $1) {
          return "." + $1 + fill("0", hashq(r[1]).length - $1.length);
        });
        return fmt.indexOf("0.") !== -1 ? o : o.replace(/^0\./, ".");
      }
      fmt = fmt.replace(/^#+([0.])/, "$1");
      if (r = fmt.match(/^(0*)\.(#*)$/)) {
        return sign + ("" + aval).replace(/\.(\d*[1-9])0*$/, ".$1").replace(/^(-?\d*)$/, "$1.").replace(/^0\./, r[1].length ? "0." : ".");
      }
      if (r = fmt.match(/^#{1,3},##0(\.?)$/))
        return sign + commaify("" + aval);
      if (r = fmt.match(/^#,##0\.([#0]*0)$/)) {
        return val < 0 ? "-" + write_num_int(type, fmt, -val) : commaify("" + val) + "." + fill("0", r[1].length);
      }
      if (r = fmt.match(/^#,#*,#0/))
        return write_num_int(type, fmt.replace(/^#,#*,/, ""), val);
      if (r = fmt.match(/^([0#]+)(\\?-([0#]+))+$/)) {
        o = _strrev(write_num_int(type, fmt.replace(/[\\-]/g, ""), val));
        ri = 0;
        return _strrev(_strrev(fmt.replace(/\\/g, "")).replace(/[0#]/g, function(x2) {
          return ri < o.length ? o.charAt(ri++) : x2 === "0" ? "0" : "";
        }));
      }
      if (fmt.match(phone)) {
        o = write_num_int(type, "##########", val);
        return "(" + o.substr(0, 3) + ") " + o.substr(3, 3) + "-" + o.substr(6);
      }
      var oa = "";
      if (r = fmt.match(/^([#0?]+)( ?)\/( ?)([#0?]+)/)) {
        ri = Math.min(
          /*::String(*/
          r[4].length,
          7
        );
        ff = SSF_frac(aval, Math.pow(10, ri) - 1, false);
        o = "" + sign;
        oa = write_num(
          "n",
          /*::String(*/
          r[1],
          ff[1]
        );
        if (oa.charAt(oa.length - 1) == " ")
          oa = oa.substr(0, oa.length - 1) + "0";
        o += oa + /*::String(*/
        r[2] + "/" + /*::String(*/
        r[3];
        oa = rpad_(ff[2], ri);
        if (oa.length < r[4].length)
          oa = hashq(r[4].substr(r[4].length - oa.length)) + oa;
        o += oa;
        return o;
      }
      if (r = fmt.match(/^# ([#0?]+)( ?)\/( ?)([#0?]+)/)) {
        ri = Math.min(Math.max(r[1].length, r[4].length), 7);
        ff = SSF_frac(aval, Math.pow(10, ri) - 1, true);
        return sign + (ff[0] || (ff[1] ? "" : "0")) + " " + (ff[1] ? pad_(ff[1], ri) + r[2] + "/" + r[3] + rpad_(ff[2], ri) : fill(" ", 2 * ri + 1 + r[2].length + r[3].length));
      }
      if (r = fmt.match(/^[#0?]+$/)) {
        o = "" + val;
        if (fmt.length <= o.length)
          return o;
        return hashq(fmt.substr(0, fmt.length - o.length)) + o;
      }
      if (r = fmt.match(/^([#0]+)\.([#0]+)$/)) {
        o = "" + val.toFixed(Math.min(r[2].length, 10)).replace(/([^0])0+$/, "$1");
        ri = o.indexOf(".");
        var lres = fmt.indexOf(".") - ri, rres = fmt.length - o.length - lres;
        return hashq(fmt.substr(0, lres) + o + fmt.substr(fmt.length - rres));
      }
      if (r = fmt.match(/^00,000\.([#0]*0)$/)) {
        return val < 0 ? "-" + write_num_int(type, fmt, -val) : commaify("" + val).replace(/^\d,\d{3}$/, "0$&").replace(/^\d*$/, function($$) {
          return "00," + ($$.length < 3 ? pad0(0, 3 - $$.length) : "") + $$;
        }) + "." + pad0(0, r[1].length);
      }
      switch (fmt) {
        case "###,###":
        case "##,###":
        case "#,###":
          var x = commaify("" + aval);
          return x !== "0" ? sign + x : "";
        default:
          if (fmt.match(/\.[0#?]*$/))
            return write_num_int(type, fmt.slice(0, fmt.lastIndexOf(".")), val) + hashq(fmt.slice(fmt.lastIndexOf(".")));
      }
      throw new Error("unsupported format |" + fmt + "|");
    }
    function write_num(type, fmt, val) {
      return (val | 0) === val ? write_num_int(type, fmt, val) : write_num_flt(type, fmt, val);
    }
    function SSF_split_fmt(fmt) {
      var out = [];
      var in_str = false;
      for (var i = 0, j = 0; i < fmt.length; ++i)
        switch (
          /*cc=*/
          fmt.charCodeAt(i)
        ) {
          case 34:
            in_str = !in_str;
            break;
          case 95:
          case 42:
          case 92:
            ++i;
            break;
          case 59:
            out[out.length] = fmt.substr(j, i - j);
            j = i + 1;
        }
      out[out.length] = fmt.substr(j);
      if (in_str === true)
        throw new Error("Format |" + fmt + "| unterminated string ");
      return out;
    }
    var SSF_abstime = /\[[HhMmSs\u0E0A\u0E19\u0E17]*\]/;
    function fmt_is_date(fmt) {
      var i = 0, c = "", o = "";
      while (i < fmt.length) {
        switch (c = fmt.charAt(i)) {
          case "G":
            if (SSF_isgeneral(fmt, i))
              i += 6;
            i++;
            break;
          case '"':
            for (
              ;
              /*cc=*/
              fmt.charCodeAt(++i) !== 34 && i < fmt.length;
            ) {
            }
            ++i;
            break;
          case "\\":
            i += 2;
            break;
          case "_":
            i += 2;
            break;
          case "@":
            ++i;
            break;
          case "B":
          case "b":
            if (fmt.charAt(i + 1) === "1" || fmt.charAt(i + 1) === "2")
              return true;
          case "M":
          case "D":
          case "Y":
          case "H":
          case "S":
          case "E":
          case "m":
          case "d":
          case "y":
          case "h":
          case "s":
          case "e":
          case "g":
            return true;
          case "A":
          case "a":
          case "\u4E0A":
            if (fmt.substr(i, 3).toUpperCase() === "A/P")
              return true;
            if (fmt.substr(i, 5).toUpperCase() === "AM/PM")
              return true;
            if (fmt.substr(i, 5).toUpperCase() === "\u4E0A\u5348/\u4E0B\u5348")
              return true;
            ++i;
            break;
          case "[":
            o = c;
            while (fmt.charAt(i++) !== "]" && i < fmt.length)
              o += fmt.charAt(i);
            if (o.match(SSF_abstime))
              return true;
            break;
          case ".":
          case "0":
          case "#":
            while (i < fmt.length && ("0#?.,E+-%".indexOf(c = fmt.charAt(++i)) > -1 || c == "\\" && fmt.charAt(i + 1) == "-" && "0#".indexOf(fmt.charAt(i + 2)) > -1)) {
            }
            break;
          case "?":
            while (fmt.charAt(++i) === c) {
            }
            break;
          case "*":
            ++i;
            if (fmt.charAt(i) == " " || fmt.charAt(i) == "*")
              ++i;
            break;
          case "(":
          case ")":
            ++i;
            break;
          case "1":
          case "2":
          case "3":
          case "4":
          case "5":
          case "6":
          case "7":
          case "8":
          case "9":
            while (i < fmt.length && "0123456789".indexOf(fmt.charAt(++i)) > -1) {
            }
            break;
          case " ":
            ++i;
            break;
          default:
            ++i;
            break;
        }
      }
      return false;
    }
    function eval_fmt(fmt, v, opts, flen) {
      var out = [], o = "", i = 0, c = "", lst = "t", dt, j, cc;
      var hr = "H";
      while (i < fmt.length) {
        switch (c = fmt.charAt(i)) {
          case "G":
            if (!SSF_isgeneral(fmt, i))
              throw new Error("unrecognized character " + c + " in " + fmt);
            out[out.length] = { t: "G", v: "General" };
            i += 7;
            break;
          case '"':
            for (o = ""; (cc = fmt.charCodeAt(++i)) !== 34 && i < fmt.length; )
              o += String.fromCharCode(cc);
            out[out.length] = { t: "t", v: o };
            ++i;
            break;
          case "\\":
            var w = fmt.charAt(++i), t = w === "(" || w === ")" ? w : "t";
            out[out.length] = { t, v: w };
            ++i;
            break;
          case "_":
            out[out.length] = { t: "t", v: " " };
            i += 2;
            break;
          case "@":
            out[out.length] = { t: "T", v };
            ++i;
            break;
          case "B":
          case "b":
            if (fmt.charAt(i + 1) === "1" || fmt.charAt(i + 1) === "2") {
              if (dt == null) {
                dt = SSF_parse_date_code(v, opts, fmt.charAt(i + 1) === "2");
                if (dt == null)
                  return "";
              }
              out[out.length] = { t: "X", v: fmt.substr(i, 2) };
              lst = c;
              i += 2;
              break;
            }
          case "M":
          case "D":
          case "Y":
          case "H":
          case "S":
          case "E":
            c = c.toLowerCase();
          case "m":
          case "d":
          case "y":
          case "h":
          case "s":
          case "e":
          case "g":
            if (v < 0)
              return "";
            if (dt == null) {
              dt = SSF_parse_date_code(v, opts);
              if (dt == null)
                return "";
            }
            o = c;
            while (++i < fmt.length && fmt.charAt(i).toLowerCase() === c)
              o += c;
            if (c === "m" && lst.toLowerCase() === "h")
              c = "M";
            if (c === "h")
              c = hr;
            out[out.length] = { t: c, v: o };
            lst = c;
            break;
          case "A":
          case "a":
          case "\u4E0A":
            var q = { t: c, v: c };
            if (dt == null)
              dt = SSF_parse_date_code(v, opts);
            if (fmt.substr(i, 3).toUpperCase() === "A/P") {
              if (dt != null)
                q.v = dt.H >= 12 ? "P" : "A";
              q.t = "T";
              hr = "h";
              i += 3;
            } else if (fmt.substr(i, 5).toUpperCase() === "AM/PM") {
              if (dt != null)
                q.v = dt.H >= 12 ? "PM" : "AM";
              q.t = "T";
              i += 5;
              hr = "h";
            } else if (fmt.substr(i, 5).toUpperCase() === "\u4E0A\u5348/\u4E0B\u5348") {
              if (dt != null)
                q.v = dt.H >= 12 ? "\u4E0B\u5348" : "\u4E0A\u5348";
              q.t = "T";
              i += 5;
              hr = "h";
            } else {
              q.t = "t";
              ++i;
            }
            if (dt == null && q.t === "T")
              return "";
            out[out.length] = q;
            lst = c;
            break;
          case "[":
            o = c;
            while (fmt.charAt(i++) !== "]" && i < fmt.length)
              o += fmt.charAt(i);
            if (o.slice(-1) !== "]")
              throw 'unterminated "[" block: |' + o + "|";
            if (o.match(SSF_abstime)) {
              if (dt == null) {
                dt = SSF_parse_date_code(v, opts);
                if (dt == null)
                  return "";
              }
              out[out.length] = { t: "Z", v: o.toLowerCase() };
              lst = o.charAt(1);
            } else if (o.indexOf("$") > -1) {
              o = (o.match(/\$([^-\[\]]*)/) || [])[1] || "$";
              if (!fmt_is_date(fmt))
                out[out.length] = { t: "t", v: o };
            }
            break;
          case ".":
            if (dt != null) {
              o = c;
              while (++i < fmt.length && (c = fmt.charAt(i)) === "0")
                o += c;
              out[out.length] = { t: "s", v: o };
              break;
            }
          case "0":
          case "#":
            o = c;
            while (++i < fmt.length && "0#?.,E+-%".indexOf(c = fmt.charAt(i)) > -1)
              o += c;
            out[out.length] = { t: "n", v: o };
            break;
          case "?":
            o = c;
            while (fmt.charAt(++i) === c)
              o += c;
            out[out.length] = { t: c, v: o };
            lst = c;
            break;
          case "*":
            ++i;
            if (fmt.charAt(i) == " " || fmt.charAt(i) == "*")
              ++i;
            break;
          case "(":
          case ")":
            out[out.length] = { t: flen === 1 ? "t" : c, v: c };
            ++i;
            break;
          case "1":
          case "2":
          case "3":
          case "4":
          case "5":
          case "6":
          case "7":
          case "8":
          case "9":
            o = c;
            while (i < fmt.length && "0123456789".indexOf(fmt.charAt(++i)) > -1)
              o += fmt.charAt(i);
            out[out.length] = { t: "D", v: o };
            break;
          case " ":
            out[out.length] = { t: c, v: c };
            ++i;
            break;
          case "$":
            out[out.length] = { t: "t", v: "$" };
            ++i;
            break;
          default:
            if (",$-+/():!^&'~{}<>=\u20ACacfijklopqrtuvwxzP".indexOf(c) === -1)
              throw new Error("unrecognized character " + c + " in " + fmt);
            out[out.length] = { t: "t", v: c };
            ++i;
            break;
        }
      }
      var bt = 0, ss0 = 0, ssm;
      for (i = out.length - 1, lst = "t"; i >= 0; --i) {
        switch (out[i].t) {
          case "h":
          case "H":
            out[i].t = hr;
            lst = "h";
            if (bt < 1)
              bt = 1;
            break;
          case "s":
            if (ssm = out[i].v.match(/\.0+$/))
              ss0 = Math.max(ss0, ssm[0].length - 1);
            if (bt < 3)
              bt = 3;
          case "d":
          case "y":
          case "M":
          case "e":
            lst = out[i].t;
            break;
          case "m":
            if (lst === "s") {
              out[i].t = "M";
              if (bt < 2)
                bt = 2;
            }
            break;
          case "X":
            break;
          case "Z":
            if (bt < 1 && out[i].v.match(/[Hh]/))
              bt = 1;
            if (bt < 2 && out[i].v.match(/[Mm]/))
              bt = 2;
            if (bt < 3 && out[i].v.match(/[Ss]/))
              bt = 3;
        }
      }
      switch (bt) {
        case 0:
          break;
        case 1:
          if (dt.u >= 0.5) {
            dt.u = 0;
            ++dt.S;
          }
          if (dt.S >= 60) {
            dt.S = 0;
            ++dt.M;
          }
          if (dt.M >= 60) {
            dt.M = 0;
            ++dt.H;
          }
          break;
        case 2:
          if (dt.u >= 0.5) {
            dt.u = 0;
            ++dt.S;
          }
          if (dt.S >= 60) {
            dt.S = 0;
            ++dt.M;
          }
          break;
      }
      var nstr = "", jj;
      for (i = 0; i < out.length; ++i) {
        switch (out[i].t) {
          case "t":
          case "T":
          case " ":
          case "D":
            break;
          case "X":
            out[i].v = "";
            out[i].t = ";";
            break;
          case "d":
          case "m":
          case "y":
          case "h":
          case "H":
          case "M":
          case "s":
          case "e":
          case "b":
          case "Z":
            out[i].v = SSF_write_date(out[i].t.charCodeAt(0), out[i].v, dt, ss0);
            out[i].t = "t";
            break;
          case "n":
          case "?":
            jj = i + 1;
            while (out[jj] != null && ((c = out[jj].t) === "?" || c === "D" || (c === " " || c === "t") && out[jj + 1] != null && (out[jj + 1].t === "?" || out[jj + 1].t === "t" && out[jj + 1].v === "/") || out[i].t === "(" && (c === " " || c === "n" || c === ")") || c === "t" && (out[jj].v === "/" || out[jj].v === " " && out[jj + 1] != null && out[jj + 1].t == "?"))) {
              out[i].v += out[jj].v;
              out[jj] = { v: "", t: ";" };
              ++jj;
            }
            nstr += out[i].v;
            i = jj - 1;
            break;
          case "G":
            out[i].t = "t";
            out[i].v = SSF_general(v, opts);
            break;
        }
      }
      var vv = "", myv, ostr;
      if (nstr.length > 0) {
        if (nstr.charCodeAt(0) == 40) {
          myv = v < 0 && nstr.charCodeAt(0) === 45 ? -v : v;
          ostr = write_num("n", nstr, myv);
        } else {
          myv = v < 0 && flen > 1 ? -v : v;
          ostr = write_num("n", nstr, myv);
          if (myv < 0 && out[0] && out[0].t == "t") {
            ostr = ostr.substr(1);
            out[0].v = "-" + out[0].v;
          }
        }
        jj = ostr.length - 1;
        var decpt = out.length;
        for (i = 0; i < out.length; ++i)
          if (out[i] != null && out[i].t != "t" && out[i].v.indexOf(".") > -1) {
            decpt = i;
            break;
          }
        var lasti = out.length;
        if (decpt === out.length && ostr.indexOf("E") === -1) {
          for (i = out.length - 1; i >= 0; --i) {
            if (out[i] == null || "n?".indexOf(out[i].t) === -1)
              continue;
            if (jj >= out[i].v.length - 1) {
              jj -= out[i].v.length;
              out[i].v = ostr.substr(jj + 1, out[i].v.length);
            } else if (jj < 0)
              out[i].v = "";
            else {
              out[i].v = ostr.substr(0, jj + 1);
              jj = -1;
            }
            out[i].t = "t";
            lasti = i;
          }
          if (jj >= 0 && lasti < out.length)
            out[lasti].v = ostr.substr(0, jj + 1) + out[lasti].v;
        } else if (decpt !== out.length && ostr.indexOf("E") === -1) {
          jj = ostr.indexOf(".") - 1;
          for (i = decpt; i >= 0; --i) {
            if (out[i] == null || "n?".indexOf(out[i].t) === -1)
              continue;
            j = out[i].v.indexOf(".") > -1 && i === decpt ? out[i].v.indexOf(".") - 1 : out[i].v.length - 1;
            vv = out[i].v.substr(j + 1);
            for (; j >= 0; --j) {
              if (jj >= 0 && (out[i].v.charAt(j) === "0" || out[i].v.charAt(j) === "#"))
                vv = ostr.charAt(jj--) + vv;
            }
            out[i].v = vv;
            out[i].t = "t";
            lasti = i;
          }
          if (jj >= 0 && lasti < out.length)
            out[lasti].v = ostr.substr(0, jj + 1) + out[lasti].v;
          jj = ostr.indexOf(".") + 1;
          for (i = decpt; i < out.length; ++i) {
            if (out[i] == null || "n?(".indexOf(out[i].t) === -1 && i !== decpt)
              continue;
            j = out[i].v.indexOf(".") > -1 && i === decpt ? out[i].v.indexOf(".") + 1 : 0;
            vv = out[i].v.substr(0, j);
            for (; j < out[i].v.length; ++j) {
              if (jj < ostr.length)
                vv += ostr.charAt(jj++);
            }
            out[i].v = vv;
            out[i].t = "t";
            lasti = i;
          }
        }
      }
      for (i = 0; i < out.length; ++i)
        if (out[i] != null && "n?".indexOf(out[i].t) > -1) {
          myv = flen > 1 && v < 0 && i > 0 && out[i - 1].v === "-" ? -v : v;
          out[i].v = write_num(out[i].t, out[i].v, myv);
          out[i].t = "t";
        }
      var retval = "";
      for (i = 0; i !== out.length; ++i)
        if (out[i] != null)
          retval += out[i].v;
      return retval;
    }
    var cfregex2 = /\[(=|>[=]?|<[>=]?)(-?\d+(?:\.\d*)?)\]/;
    function chkcond(v, rr) {
      if (rr == null)
        return false;
      var thresh = parseFloat(rr[2]);
      switch (rr[1]) {
        case "=":
          if (v == thresh)
            return true;
          break;
        case ">":
          if (v > thresh)
            return true;
          break;
        case "<":
          if (v < thresh)
            return true;
          break;
        case "<>":
          if (v != thresh)
            return true;
          break;
        case ">=":
          if (v >= thresh)
            return true;
          break;
        case "<=":
          if (v <= thresh)
            return true;
          break;
      }
      return false;
    }
    function choose_fmt(f, v) {
      var fmt = SSF_split_fmt(f);
      var l2 = fmt.length, lat = fmt[l2 - 1].indexOf("@");
      if (l2 < 4 && lat > -1)
        --l2;
      if (fmt.length > 4)
        throw new Error("cannot find right format for |" + fmt.join("|") + "|");
      if (typeof v !== "number")
        return [4, fmt.length === 4 || lat > -1 ? fmt[fmt.length - 1] : "@"];
      switch (fmt.length) {
        case 1:
          fmt = lat > -1 ? ["General", "General", "General", fmt[0]] : [fmt[0], fmt[0], fmt[0], "@"];
          break;
        case 2:
          fmt = lat > -1 ? [fmt[0], fmt[0], fmt[0], fmt[1]] : [fmt[0], fmt[1], fmt[0], "@"];
          break;
        case 3:
          fmt = lat > -1 ? [fmt[0], fmt[1], fmt[0], fmt[2]] : [fmt[0], fmt[1], fmt[2], "@"];
          break;
      }
      var ff = v > 0 ? fmt[0] : v < 0 ? fmt[1] : fmt[2];
      if (fmt[0].indexOf("[") === -1 && fmt[1].indexOf("[") === -1)
        return [l2, ff];
      if (fmt[0].match(/\[[=<>]/) != null || fmt[1].match(/\[[=<>]/) != null) {
        var m1 = fmt[0].match(cfregex2);
        var m2 = fmt[1].match(cfregex2);
        return chkcond(v, m1) ? [l2, fmt[0]] : chkcond(v, m2) ? [l2, fmt[1]] : [l2, fmt[m1 != null && m2 != null ? 2 : 1]];
      }
      return [l2, ff];
    }
    function SSF_format(fmt, v, o) {
      if (o == null)
        o = {};
      var sfmt = "";
      switch (typeof fmt) {
        case "string":
          if (fmt == "m/d/yy" && o.dateNF)
            sfmt = o.dateNF;
          else
            sfmt = fmt;
          break;
        case "number":
          if (fmt == 14 && o.dateNF)
            sfmt = o.dateNF;
          else
            sfmt = (o.table != null ? o.table : table_fmt)[fmt];
          if (sfmt == null)
            sfmt = o.table && o.table[SSF_default_map[fmt]] || table_fmt[SSF_default_map[fmt]];
          if (sfmt == null)
            sfmt = SSF_default_str[fmt] || "General";
          break;
      }
      if (SSF_isgeneral(sfmt, 0))
        return SSF_general(v, o);
      if (v instanceof Date)
        v = datenum_local(v, o.date1904);
      var f = choose_fmt(sfmt, v);
      if (SSF_isgeneral(f[1]))
        return SSF_general(v, o);
      if (v === true)
        v = "TRUE";
      else if (v === false)
        v = "FALSE";
      else if (v === "" || v == null)
        return "";
      return eval_fmt(f[1], v, o, f[0]);
    }
    function SSF_load(fmt, idx) {
      if (typeof idx != "number") {
        idx = +idx || -1;
        for (var i = 0; i < 392; ++i) {
          if (table_fmt[i] == void 0) {
            if (idx < 0)
              idx = i;
            continue;
          }
          if (table_fmt[i] == fmt) {
            idx = i;
            break;
          }
        }
        if (idx < 0)
          idx = 391;
      }
      table_fmt[idx] = fmt;
      return idx;
    }
    function SSF_load_table(tbl) {
      for (var i = 0; i != 392; ++i)
        if (tbl[i] !== void 0)
          SSF_load(tbl[i], i);
    }
    function make_ssf() {
      table_fmt = SSF_init_table();
    }
    var dateNFregex = /[dD]+|[mM]+|[yYeE]+|[Hh]+|[Ss]+/g;
    function dateNF_regex(dateNF) {
      var fmt = typeof dateNF == "number" ? table_fmt[dateNF] : dateNF;
      fmt = fmt.replace(dateNFregex, "(\\d+)");
      return new RegExp("^" + fmt + "$");
    }
    function dateNF_fix(str, dateNF, match) {
      var Y = -1, m = -1, d = -1, H = -1, M = -1, S = -1;
      (dateNF.match(dateNFregex) || []).forEach(function(n, i) {
        var v = parseInt(match[i + 1], 10);
        switch (n.toLowerCase().charAt(0)) {
          case "y":
            Y = v;
            break;
          case "d":
            d = v;
            break;
          case "h":
            H = v;
            break;
          case "s":
            S = v;
            break;
          case "m":
            if (H >= 0)
              M = v;
            else
              m = v;
            break;
        }
      });
      if (S >= 0 && M == -1 && m >= 0) {
        M = m;
        m = -1;
      }
      var datestr = ("" + (Y >= 0 ? Y : (/* @__PURE__ */ new Date()).getFullYear())).slice(-4) + "-" + ("00" + (m >= 1 ? m : 1)).slice(-2) + "-" + ("00" + (d >= 1 ? d : 1)).slice(-2);
      if (datestr.length == 7)
        datestr = "0" + datestr;
      if (datestr.length == 8)
        datestr = "20" + datestr;
      var timestr = ("00" + (H >= 0 ? H : 0)).slice(-2) + ":" + ("00" + (M >= 0 ? M : 0)).slice(-2) + ":" + ("00" + (S >= 0 ? S : 0)).slice(-2);
      if (H == -1 && M == -1 && S == -1)
        return datestr;
      if (Y == -1 && m == -1 && d == -1)
        return timestr;
      return datestr + "T" + timestr;
    }
    var CRC32 = /* @__PURE__ */ function() {
      var CRC322 = {};
      CRC322.version = "1.2.0";
      function signed_crc_table() {
        var c = 0, table = new Array(256);
        for (var n = 0; n != 256; ++n) {
          c = n;
          c = c & 1 ? -306674912 ^ c >>> 1 : c >>> 1;
          c = c & 1 ? -306674912 ^ c >>> 1 : c >>> 1;
          c = c & 1 ? -306674912 ^ c >>> 1 : c >>> 1;
          c = c & 1 ? -306674912 ^ c >>> 1 : c >>> 1;
          c = c & 1 ? -306674912 ^ c >>> 1 : c >>> 1;
          c = c & 1 ? -306674912 ^ c >>> 1 : c >>> 1;
          c = c & 1 ? -306674912 ^ c >>> 1 : c >>> 1;
          c = c & 1 ? -306674912 ^ c >>> 1 : c >>> 1;
          table[n] = c;
        }
        return typeof Int32Array !== "undefined" ? new Int32Array(table) : table;
      }
      var T0 = signed_crc_table();
      function slice_by_16_tables(T) {
        var c = 0, v = 0, n = 0, table = typeof Int32Array !== "undefined" ? new Int32Array(4096) : new Array(4096);
        for (n = 0; n != 256; ++n)
          table[n] = T[n];
        for (n = 0; n != 256; ++n) {
          v = T[n];
          for (c = 256 + n; c < 4096; c += 256)
            v = table[c] = v >>> 8 ^ T[v & 255];
        }
        var out = [];
        for (n = 1; n != 16; ++n)
          out[n - 1] = typeof Int32Array !== "undefined" ? table.subarray(n * 256, n * 256 + 256) : table.slice(n * 256, n * 256 + 256);
        return out;
      }
      var TT = slice_by_16_tables(T0);
      var T1 = TT[0], T2 = TT[1], T3 = TT[2], T4 = TT[3], T5 = TT[4];
      var T6 = TT[5], T7 = TT[6], T8 = TT[7], T9 = TT[8], Ta = TT[9];
      var Tb = TT[10], Tc = TT[11], Td = TT[12], Te = TT[13], Tf = TT[14];
      function crc32_bstr(bstr, seed) {
        var C = seed ^ -1;
        for (var i = 0, L = bstr.length; i < L; )
          C = C >>> 8 ^ T0[(C ^ bstr.charCodeAt(i++)) & 255];
        return ~C;
      }
      function crc32_buf(B, seed) {
        var C = seed ^ -1, L = B.length - 15, i = 0;
        for (; i < L; )
          C = Tf[B[i++] ^ C & 255] ^ Te[B[i++] ^ C >> 8 & 255] ^ Td[B[i++] ^ C >> 16 & 255] ^ Tc[B[i++] ^ C >>> 24] ^ Tb[B[i++]] ^ Ta[B[i++]] ^ T9[B[i++]] ^ T8[B[i++]] ^ T7[B[i++]] ^ T6[B[i++]] ^ T5[B[i++]] ^ T4[B[i++]] ^ T3[B[i++]] ^ T2[B[i++]] ^ T1[B[i++]] ^ T0[B[i++]];
        L += 15;
        while (i < L)
          C = C >>> 8 ^ T0[(C ^ B[i++]) & 255];
        return ~C;
      }
      function crc32_str(str, seed) {
        var C = seed ^ -1;
        for (var i = 0, L = str.length, c = 0, d = 0; i < L; ) {
          c = str.charCodeAt(i++);
          if (c < 128) {
            C = C >>> 8 ^ T0[(C ^ c) & 255];
          } else if (c < 2048) {
            C = C >>> 8 ^ T0[(C ^ (192 | c >> 6 & 31)) & 255];
            C = C >>> 8 ^ T0[(C ^ (128 | c & 63)) & 255];
          } else if (c >= 55296 && c < 57344) {
            c = (c & 1023) + 64;
            d = str.charCodeAt(i++) & 1023;
            C = C >>> 8 ^ T0[(C ^ (240 | c >> 8 & 7)) & 255];
            C = C >>> 8 ^ T0[(C ^ (128 | c >> 2 & 63)) & 255];
            C = C >>> 8 ^ T0[(C ^ (128 | d >> 6 & 15 | (c & 3) << 4)) & 255];
            C = C >>> 8 ^ T0[(C ^ (128 | d & 63)) & 255];
          } else {
            C = C >>> 8 ^ T0[(C ^ (224 | c >> 12 & 15)) & 255];
            C = C >>> 8 ^ T0[(C ^ (128 | c >> 6 & 63)) & 255];
            C = C >>> 8 ^ T0[(C ^ (128 | c & 63)) & 255];
          }
        }
        return ~C;
      }
      CRC322.table = T0;
      CRC322.bstr = crc32_bstr;
      CRC322.buf = crc32_buf;
      CRC322.str = crc32_str;
      return CRC322;
    }();
    var CFB = /* @__PURE__ */ function _CFB() {
      var exports22 = {};
      exports22.version = "1.2.1";
      function namecmp(l2, r) {
        var L = l2.split("/"), R = r.split("/");
        for (var i2 = 0, c = 0, Z = Math.min(L.length, R.length); i2 < Z; ++i2) {
          if (c = L[i2].length - R[i2].length)
            return c;
          if (L[i2] != R[i2])
            return L[i2] < R[i2] ? -1 : 1;
        }
        return L.length - R.length;
      }
      function dirname(p) {
        if (p.charAt(p.length - 1) == "/")
          return p.slice(0, -1).indexOf("/") === -1 ? p : dirname(p.slice(0, -1));
        var c = p.lastIndexOf("/");
        return c === -1 ? p : p.slice(0, c + 1);
      }
      function filename(p) {
        if (p.charAt(p.length - 1) == "/")
          return filename(p.slice(0, -1));
        var c = p.lastIndexOf("/");
        return c === -1 ? p : p.slice(c + 1);
      }
      function write_dos_date(buf, date) {
        if (typeof date === "string")
          date = new Date(date);
        var hms = date.getHours();
        hms = hms << 6 | date.getMinutes();
        hms = hms << 5 | date.getSeconds() >>> 1;
        buf.write_shift(2, hms);
        var ymd = date.getFullYear() - 1980;
        ymd = ymd << 4 | date.getMonth() + 1;
        ymd = ymd << 5 | date.getDate();
        buf.write_shift(2, ymd);
      }
      function parse_dos_date(buf) {
        var hms = buf.read_shift(2) & 65535;
        var ymd = buf.read_shift(2) & 65535;
        var val = /* @__PURE__ */ new Date();
        var d = ymd & 31;
        ymd >>>= 5;
        var m = ymd & 15;
        ymd >>>= 4;
        val.setMilliseconds(0);
        val.setFullYear(ymd + 1980);
        val.setMonth(m - 1);
        val.setDate(d);
        var S = hms & 31;
        hms >>>= 5;
        var M = hms & 63;
        hms >>>= 6;
        val.setHours(hms);
        val.setMinutes(M);
        val.setSeconds(S << 1);
        return val;
      }
      function parse_extra_field(blob) {
        prep_blob(blob, 0);
        var o = (
          /*::(*/
          {}
        );
        var flags = 0;
        while (blob.l <= blob.length - 4) {
          var type = blob.read_shift(2);
          var sz = blob.read_shift(2), tgt = blob.l + sz;
          var p = {};
          switch (type) {
            case 21589:
              {
                flags = blob.read_shift(1);
                if (flags & 1)
                  p.mtime = blob.read_shift(4);
                if (sz > 5) {
                  if (flags & 2)
                    p.atime = blob.read_shift(4);
                  if (flags & 4)
                    p.ctime = blob.read_shift(4);
                }
                if (p.mtime)
                  p.mt = new Date(p.mtime * 1e3);
              }
              break;
          }
          blob.l = tgt;
          o[type] = p;
        }
        return o;
      }
      var fs;
      function get_fs() {
        return fs || (fs = {});
      }
      function parse2(file, options) {
        if (file[0] == 80 && file[1] == 75)
          return parse_zip(file, options);
        if ((file[0] | 32) == 109 && (file[1] | 32) == 105)
          return parse_mad(file, options);
        if (file.length < 512)
          throw new Error("CFB file size " + file.length + " < 512");
        var mver = 3;
        var ssz = 512;
        var nmfs = 0;
        var difat_sec_cnt = 0;
        var dir_start = 0;
        var minifat_start = 0;
        var difat_start = 0;
        var fat_addrs = [];
        var blob = (
          /*::(*/
          file.slice(0, 512)
        );
        prep_blob(blob, 0);
        var mv = check_get_mver(blob);
        mver = mv[0];
        switch (mver) {
          case 3:
            ssz = 512;
            break;
          case 4:
            ssz = 4096;
            break;
          case 0:
            if (mv[1] == 0)
              return parse_zip(file, options);
          default:
            throw new Error("Major Version: Expected 3 or 4 saw " + mver);
        }
        if (ssz !== 512) {
          blob = /*::(*/
          file.slice(0, ssz);
          prep_blob(
            blob,
            28
            /* blob.l */
          );
        }
        var header = file.slice(0, ssz);
        check_shifts(blob, mver);
        var dir_cnt = blob.read_shift(4, "i");
        if (mver === 3 && dir_cnt !== 0)
          throw new Error("# Directory Sectors: Expected 0 saw " + dir_cnt);
        blob.l += 4;
        dir_start = blob.read_shift(4, "i");
        blob.l += 4;
        blob.chk("00100000", "Mini Stream Cutoff Size: ");
        minifat_start = blob.read_shift(4, "i");
        nmfs = blob.read_shift(4, "i");
        difat_start = blob.read_shift(4, "i");
        difat_sec_cnt = blob.read_shift(4, "i");
        for (var q2 = -1, j = 0; j < 109; ++j) {
          q2 = blob.read_shift(4, "i");
          if (q2 < 0)
            break;
          fat_addrs[j] = q2;
        }
        var sectors = sectorify(file, ssz);
        sleuth_fat(difat_start, difat_sec_cnt, sectors, ssz, fat_addrs);
        var sector_list = make_sector_list(sectors, dir_start, fat_addrs, ssz);
        sector_list[dir_start].name = "!Directory";
        if (nmfs > 0 && minifat_start !== ENDOFCHAIN)
          sector_list[minifat_start].name = "!MiniFAT";
        sector_list[fat_addrs[0]].name = "!FAT";
        sector_list.fat_addrs = fat_addrs;
        sector_list.ssz = ssz;
        var files = {}, Paths = [], FileIndex = [], FullPaths = [];
        read_directory(dir_start, sector_list, sectors, Paths, nmfs, files, FileIndex, minifat_start);
        build_full_paths(FileIndex, FullPaths, Paths);
        Paths.shift();
        var o = {
          FileIndex,
          FullPaths
        };
        if (options && options.raw)
          o.raw = { header, sectors };
        return o;
      }
      function check_get_mver(blob) {
        if (blob[blob.l] == 80 && blob[blob.l + 1] == 75)
          return [0, 0];
        blob.chk(HEADER_SIGNATURE, "Header Signature: ");
        blob.l += 16;
        var mver = blob.read_shift(2, "u");
        return [blob.read_shift(2, "u"), mver];
      }
      function check_shifts(blob, mver) {
        var shift = 9;
        blob.l += 2;
        switch (shift = blob.read_shift(2)) {
          case 9:
            if (mver != 3)
              throw new Error("Sector Shift: Expected 9 saw " + shift);
            break;
          case 12:
            if (mver != 4)
              throw new Error("Sector Shift: Expected 12 saw " + shift);
            break;
          default:
            throw new Error("Sector Shift: Expected 9 or 12 saw " + shift);
        }
        blob.chk("0600", "Mini Sector Shift: ");
        blob.chk("000000000000", "Reserved: ");
      }
      function sectorify(file, ssz) {
        var nsectors = Math.ceil(file.length / ssz) - 1;
        var sectors = [];
        for (var i2 = 1; i2 < nsectors; ++i2)
          sectors[i2 - 1] = file.slice(i2 * ssz, (i2 + 1) * ssz);
        sectors[nsectors - 1] = file.slice(nsectors * ssz);
        return sectors;
      }
      function build_full_paths(FI, FP, Paths) {
        var i2 = 0, L = 0, R = 0, C = 0, j = 0, pl = Paths.length;
        var dad = [], q2 = [];
        for (; i2 < pl; ++i2) {
          dad[i2] = q2[i2] = i2;
          FP[i2] = Paths[i2];
        }
        for (; j < q2.length; ++j) {
          i2 = q2[j];
          L = FI[i2].L;
          R = FI[i2].R;
          C = FI[i2].C;
          if (dad[i2] === i2) {
            if (L !== -1 && dad[L] !== L)
              dad[i2] = dad[L];
            if (R !== -1 && dad[R] !== R)
              dad[i2] = dad[R];
          }
          if (C !== -1)
            dad[C] = i2;
          if (L !== -1 && i2 != dad[i2]) {
            dad[L] = dad[i2];
            if (q2.lastIndexOf(L) < j)
              q2.push(L);
          }
          if (R !== -1 && i2 != dad[i2]) {
            dad[R] = dad[i2];
            if (q2.lastIndexOf(R) < j)
              q2.push(R);
          }
        }
        for (i2 = 1; i2 < pl; ++i2)
          if (dad[i2] === i2) {
            if (R !== -1 && dad[R] !== R)
              dad[i2] = dad[R];
            else if (L !== -1 && dad[L] !== L)
              dad[i2] = dad[L];
          }
        for (i2 = 1; i2 < pl; ++i2) {
          if (FI[i2].type === 0)
            continue;
          j = i2;
          if (j != dad[j])
            do {
              j = dad[j];
              FP[i2] = FP[j] + "/" + FP[i2];
            } while (j !== 0 && -1 !== dad[j] && j != dad[j]);
          dad[i2] = -1;
        }
        FP[0] += "/";
        for (i2 = 1; i2 < pl; ++i2) {
          if (FI[i2].type !== 2)
            FP[i2] += "/";
        }
      }
      function get_mfat_entry(entry, payload, mini) {
        var start = entry.start, size = entry.size;
        var o = [];
        var idx = start;
        while (mini && size > 0 && idx >= 0) {
          o.push(payload.slice(idx * MSSZ, idx * MSSZ + MSSZ));
          size -= MSSZ;
          idx = __readInt32LE(mini, idx * 4);
        }
        if (o.length === 0)
          return new_buf(0);
        return bconcat(o).slice(0, entry.size);
      }
      function sleuth_fat(idx, cnt, sectors, ssz, fat_addrs) {
        var q2 = ENDOFCHAIN;
        if (idx === ENDOFCHAIN) {
          if (cnt !== 0)
            throw new Error("DIFAT chain shorter than expected");
        } else if (idx !== -1) {
          var sector = sectors[idx], m = (ssz >>> 2) - 1;
          if (!sector)
            return;
          for (var i2 = 0; i2 < m; ++i2) {
            if ((q2 = __readInt32LE(sector, i2 * 4)) === ENDOFCHAIN)
              break;
            fat_addrs.push(q2);
          }
          sleuth_fat(__readInt32LE(sector, ssz - 4), cnt - 1, sectors, ssz, fat_addrs);
        }
      }
      function get_sector_list(sectors, start, fat_addrs, ssz, chkd) {
        var buf = [], buf_chain = [];
        if (!chkd)
          chkd = [];
        var modulus = ssz - 1, j = 0, jj = 0;
        for (j = start; j >= 0; ) {
          chkd[j] = true;
          buf[buf.length] = j;
          buf_chain.push(sectors[j]);
          var addr = fat_addrs[Math.floor(j * 4 / ssz)];
          jj = j * 4 & modulus;
          if (ssz < 4 + jj)
            throw new Error("FAT boundary crossed: " + j + " 4 " + ssz);
          if (!sectors[addr])
            break;
          j = __readInt32LE(sectors[addr], jj);
        }
        return { nodes: buf, data: __toBuffer([buf_chain]) };
      }
      function make_sector_list(sectors, dir_start, fat_addrs, ssz) {
        var sl = sectors.length, sector_list = [];
        var chkd = [], buf = [], buf_chain = [];
        var modulus = ssz - 1, i2 = 0, j = 0, k = 0, jj = 0;
        for (i2 = 0; i2 < sl; ++i2) {
          buf = [];
          k = i2 + dir_start;
          if (k >= sl)
            k -= sl;
          if (chkd[k])
            continue;
          buf_chain = [];
          var seen = [];
          for (j = k; j >= 0; ) {
            seen[j] = true;
            chkd[j] = true;
            buf[buf.length] = j;
            buf_chain.push(sectors[j]);
            var addr = fat_addrs[Math.floor(j * 4 / ssz)];
            jj = j * 4 & modulus;
            if (ssz < 4 + jj)
              throw new Error("FAT boundary crossed: " + j + " 4 " + ssz);
            if (!sectors[addr])
              break;
            j = __readInt32LE(sectors[addr], jj);
            if (seen[j])
              break;
          }
          sector_list[k] = { nodes: buf, data: __toBuffer([buf_chain]) };
        }
        return sector_list;
      }
      function read_directory(dir_start, sector_list, sectors, Paths, nmfs, files, FileIndex, mini) {
        var minifat_store = 0, pl = Paths.length ? 2 : 0;
        var sector = sector_list[dir_start].data;
        var i2 = 0, namelen = 0, name;
        for (; i2 < sector.length; i2 += 128) {
          var blob = (
            /*::(*/
            sector.slice(i2, i2 + 128)
          );
          prep_blob(blob, 64);
          namelen = blob.read_shift(2);
          name = __utf16le(blob, 0, namelen - pl);
          Paths.push(name);
          var o = {
            name,
            type: blob.read_shift(1),
            color: blob.read_shift(1),
            L: blob.read_shift(4, "i"),
            R: blob.read_shift(4, "i"),
            C: blob.read_shift(4, "i"),
            clsid: blob.read_shift(16),
            state: blob.read_shift(4, "i"),
            start: 0,
            size: 0
          };
          var ctime = blob.read_shift(2) + blob.read_shift(2) + blob.read_shift(2) + blob.read_shift(2);
          if (ctime !== 0)
            o.ct = read_date(blob, blob.l - 8);
          var mtime = blob.read_shift(2) + blob.read_shift(2) + blob.read_shift(2) + blob.read_shift(2);
          if (mtime !== 0)
            o.mt = read_date(blob, blob.l - 8);
          o.start = blob.read_shift(4, "i");
          o.size = blob.read_shift(4, "i");
          if (o.size < 0 && o.start < 0) {
            o.size = o.type = 0;
            o.start = ENDOFCHAIN;
            o.name = "";
          }
          if (o.type === 5) {
            minifat_store = o.start;
            if (nmfs > 0 && minifat_store !== ENDOFCHAIN)
              sector_list[minifat_store].name = "!StreamData";
          } else if (o.size >= 4096) {
            o.storage = "fat";
            if (sector_list[o.start] === void 0)
              sector_list[o.start] = get_sector_list(sectors, o.start, sector_list.fat_addrs, sector_list.ssz);
            sector_list[o.start].name = o.name;
            o.content = sector_list[o.start].data.slice(0, o.size);
          } else {
            o.storage = "minifat";
            if (o.size < 0)
              o.size = 0;
            else if (minifat_store !== ENDOFCHAIN && o.start !== ENDOFCHAIN && sector_list[minifat_store]) {
              o.content = get_mfat_entry(o, sector_list[minifat_store].data, (sector_list[mini] || {}).data);
            }
          }
          if (o.content)
            prep_blob(o.content, 0);
          files[name] = o;
          FileIndex.push(o);
        }
      }
      function read_date(blob, offset) {
        return new Date((__readUInt32LE(blob, offset + 4) / 1e7 * Math.pow(2, 32) + __readUInt32LE(blob, offset) / 1e7 - 11644473600) * 1e3);
      }
      function read_file(filename2, options) {
        get_fs();
        return parse2(fs.readFileSync(filename2), options);
      }
      function read(blob, options) {
        var type = options && options.type;
        if (!type) {
          if (has_buf && Buffer.isBuffer(blob))
            type = "buffer";
        }
        switch (type || "base64") {
          case "file":
            return read_file(blob, options);
          case "base64":
            return parse2(s2a(Base64_decode(blob)), options);
          case "binary":
            return parse2(s2a(blob), options);
        }
        return parse2(
          /*::typeof blob == 'string' ? new Buffer(blob, 'utf-8') : */
          blob,
          options
        );
      }
      function init_cfb(cfb, opts) {
        var o = opts || {}, root = o.root || "Root Entry";
        if (!cfb.FullPaths)
          cfb.FullPaths = [];
        if (!cfb.FileIndex)
          cfb.FileIndex = [];
        if (cfb.FullPaths.length !== cfb.FileIndex.length)
          throw new Error("inconsistent CFB structure");
        if (cfb.FullPaths.length === 0) {
          cfb.FullPaths[0] = root + "/";
          cfb.FileIndex[0] = { name: root, type: 5 };
        }
        if (o.CLSID)
          cfb.FileIndex[0].clsid = o.CLSID;
        seed_cfb(cfb);
      }
      function seed_cfb(cfb) {
        var nm = "Sh33tJ5";
        if (CFB.find(cfb, "/" + nm))
          return;
        var p = new_buf(4);
        p[0] = 55;
        p[1] = p[3] = 50;
        p[2] = 54;
        cfb.FileIndex.push({ name: nm, type: 2, content: p, size: 4, L: 69, R: 69, C: 69 });
        cfb.FullPaths.push(cfb.FullPaths[0] + nm);
        rebuild_cfb(cfb);
      }
      function rebuild_cfb(cfb, f) {
        init_cfb(cfb);
        var gc = false, s = false;
        for (var i2 = cfb.FullPaths.length - 1; i2 >= 0; --i2) {
          var _file = cfb.FileIndex[i2];
          switch (_file.type) {
            case 0:
              if (s)
                gc = true;
              else {
                cfb.FileIndex.pop();
                cfb.FullPaths.pop();
              }
              break;
            case 1:
            case 2:
            case 5:
              s = true;
              if (isNaN(_file.R * _file.L * _file.C))
                gc = true;
              if (_file.R > -1 && _file.L > -1 && _file.R == _file.L)
                gc = true;
              break;
            default:
              gc = true;
              break;
          }
        }
        if (!gc && !f)
          return;
        var now = new Date(1987, 1, 19), j = 0;
        var fullPaths = Object.create ? /* @__PURE__ */ Object.create(null) : {};
        var data = [];
        for (i2 = 0; i2 < cfb.FullPaths.length; ++i2) {
          fullPaths[cfb.FullPaths[i2]] = true;
          if (cfb.FileIndex[i2].type === 0)
            continue;
          data.push([cfb.FullPaths[i2], cfb.FileIndex[i2]]);
        }
        for (i2 = 0; i2 < data.length; ++i2) {
          var dad = dirname(data[i2][0]);
          s = fullPaths[dad];
          if (!s) {
            data.push([dad, {
              name: filename(dad).replace("/", ""),
              type: 1,
              clsid: HEADER_CLSID,
              ct: now,
              mt: now,
              content: null
            }]);
            fullPaths[dad] = true;
          }
        }
        data.sort(function(x, y) {
          return namecmp(x[0], y[0]);
        });
        cfb.FullPaths = [];
        cfb.FileIndex = [];
        for (i2 = 0; i2 < data.length; ++i2) {
          cfb.FullPaths[i2] = data[i2][0];
          cfb.FileIndex[i2] = data[i2][1];
        }
        for (i2 = 0; i2 < data.length; ++i2) {
          var elt = cfb.FileIndex[i2];
          var nm = cfb.FullPaths[i2];
          elt.name = filename(nm).replace("/", "");
          elt.L = elt.R = elt.C = -(elt.color = 1);
          elt.size = elt.content ? elt.content.length : 0;
          elt.start = 0;
          elt.clsid = elt.clsid || HEADER_CLSID;
          if (i2 === 0) {
            elt.C = data.length > 1 ? 1 : -1;
            elt.size = 0;
            elt.type = 5;
          } else if (nm.slice(-1) == "/") {
            for (j = i2 + 1; j < data.length; ++j)
              if (dirname(cfb.FullPaths[j]) == nm)
                break;
            elt.C = j >= data.length ? -1 : j;
            for (j = i2 + 1; j < data.length; ++j)
              if (dirname(cfb.FullPaths[j]) == dirname(nm))
                break;
            elt.R = j >= data.length ? -1 : j;
            elt.type = 1;
          } else {
            if (dirname(cfb.FullPaths[i2 + 1] || "") == dirname(nm))
              elt.R = i2 + 1;
            elt.type = 2;
          }
        }
      }
      function _write(cfb, options) {
        var _opts = options || {};
        if (_opts.fileType == "mad")
          return write_mad(cfb, _opts);
        rebuild_cfb(cfb);
        switch (_opts.fileType) {
          case "zip":
            return write_zip2(cfb, _opts);
        }
        var L = function(cfb2) {
          var mini_size = 0, fat_size = 0;
          for (var i3 = 0; i3 < cfb2.FileIndex.length; ++i3) {
            var file2 = cfb2.FileIndex[i3];
            if (!file2.content)
              continue;
            var flen2 = file2.content.length;
            if (flen2 > 0) {
              if (flen2 < 4096)
                mini_size += flen2 + 63 >> 6;
              else
                fat_size += flen2 + 511 >> 9;
            }
          }
          var dir_cnt = cfb2.FullPaths.length + 3 >> 2;
          var mini_cnt = mini_size + 7 >> 3;
          var mfat_cnt = mini_size + 127 >> 7;
          var fat_base = mini_cnt + fat_size + dir_cnt + mfat_cnt;
          var fat_cnt = fat_base + 127 >> 7;
          var difat_cnt = fat_cnt <= 109 ? 0 : Math.ceil((fat_cnt - 109) / 127);
          while (fat_base + fat_cnt + difat_cnt + 127 >> 7 > fat_cnt)
            difat_cnt = ++fat_cnt <= 109 ? 0 : Math.ceil((fat_cnt - 109) / 127);
          var L2 = [1, difat_cnt, fat_cnt, mfat_cnt, dir_cnt, fat_size, mini_size, 0];
          cfb2.FileIndex[0].size = mini_size << 6;
          L2[7] = (cfb2.FileIndex[0].start = L2[0] + L2[1] + L2[2] + L2[3] + L2[4] + L2[5]) + (L2[6] + 7 >> 3);
          return L2;
        }(cfb);
        var o = new_buf(L[7] << 9);
        var i2 = 0, T = 0;
        {
          for (i2 = 0; i2 < 8; ++i2)
            o.write_shift(1, HEADER_SIG[i2]);
          for (i2 = 0; i2 < 8; ++i2)
            o.write_shift(2, 0);
          o.write_shift(2, 62);
          o.write_shift(2, 3);
          o.write_shift(2, 65534);
          o.write_shift(2, 9);
          o.write_shift(2, 6);
          for (i2 = 0; i2 < 3; ++i2)
            o.write_shift(2, 0);
          o.write_shift(4, 0);
          o.write_shift(4, L[2]);
          o.write_shift(4, L[0] + L[1] + L[2] + L[3] - 1);
          o.write_shift(4, 0);
          o.write_shift(4, 1 << 12);
          o.write_shift(4, L[3] ? L[0] + L[1] + L[2] - 1 : ENDOFCHAIN);
          o.write_shift(4, L[3]);
          o.write_shift(-4, L[1] ? L[0] - 1 : ENDOFCHAIN);
          o.write_shift(4, L[1]);
          for (i2 = 0; i2 < 109; ++i2)
            o.write_shift(-4, i2 < L[2] ? L[1] + i2 : -1);
        }
        if (L[1]) {
          for (T = 0; T < L[1]; ++T) {
            for (; i2 < 236 + T * 127; ++i2)
              o.write_shift(-4, i2 < L[2] ? L[1] + i2 : -1);
            o.write_shift(-4, T === L[1] - 1 ? ENDOFCHAIN : T + 1);
          }
        }
        var chainit = function(w) {
          for (T += w; i2 < T - 1; ++i2)
            o.write_shift(-4, i2 + 1);
          if (w) {
            ++i2;
            o.write_shift(-4, ENDOFCHAIN);
          }
        };
        T = i2 = 0;
        for (T += L[1]; i2 < T; ++i2)
          o.write_shift(-4, consts.DIFSECT);
        for (T += L[2]; i2 < T; ++i2)
          o.write_shift(-4, consts.FATSECT);
        chainit(L[3]);
        chainit(L[4]);
        var j = 0, flen = 0;
        var file = cfb.FileIndex[0];
        for (; j < cfb.FileIndex.length; ++j) {
          file = cfb.FileIndex[j];
          if (!file.content)
            continue;
          flen = file.content.length;
          if (flen < 4096)
            continue;
          file.start = T;
          chainit(flen + 511 >> 9);
        }
        chainit(L[6] + 7 >> 3);
        while (o.l & 511)
          o.write_shift(-4, consts.ENDOFCHAIN);
        T = i2 = 0;
        for (j = 0; j < cfb.FileIndex.length; ++j) {
          file = cfb.FileIndex[j];
          if (!file.content)
            continue;
          flen = file.content.length;
          if (!flen || flen >= 4096)
            continue;
          file.start = T;
          chainit(flen + 63 >> 6);
        }
        while (o.l & 511)
          o.write_shift(-4, consts.ENDOFCHAIN);
        for (i2 = 0; i2 < L[4] << 2; ++i2) {
          var nm = cfb.FullPaths[i2];
          if (!nm || nm.length === 0) {
            for (j = 0; j < 17; ++j)
              o.write_shift(4, 0);
            for (j = 0; j < 3; ++j)
              o.write_shift(4, -1);
            for (j = 0; j < 12; ++j)
              o.write_shift(4, 0);
            continue;
          }
          file = cfb.FileIndex[i2];
          if (i2 === 0)
            file.start = file.size ? file.start - 1 : ENDOFCHAIN;
          var _nm = i2 === 0 && _opts.root || file.name;
          flen = 2 * (_nm.length + 1);
          o.write_shift(64, _nm, "utf16le");
          o.write_shift(2, flen);
          o.write_shift(1, file.type);
          o.write_shift(1, file.color);
          o.write_shift(-4, file.L);
          o.write_shift(-4, file.R);
          o.write_shift(-4, file.C);
          if (!file.clsid)
            for (j = 0; j < 4; ++j)
              o.write_shift(4, 0);
          else
            o.write_shift(16, file.clsid, "hex");
          o.write_shift(4, file.state || 0);
          o.write_shift(4, 0);
          o.write_shift(4, 0);
          o.write_shift(4, 0);
          o.write_shift(4, 0);
          o.write_shift(4, file.start);
          o.write_shift(4, file.size);
          o.write_shift(4, 0);
        }
        for (i2 = 1; i2 < cfb.FileIndex.length; ++i2) {
          file = cfb.FileIndex[i2];
          if (file.size >= 4096) {
            o.l = file.start + 1 << 9;
            if (has_buf && Buffer.isBuffer(file.content)) {
              file.content.copy(o, o.l, 0, file.size);
              o.l += file.size + 511 & -512;
            } else {
              for (j = 0; j < file.size; ++j)
                o.write_shift(1, file.content[j]);
              for (; j & 511; ++j)
                o.write_shift(1, 0);
            }
          }
        }
        for (i2 = 1; i2 < cfb.FileIndex.length; ++i2) {
          file = cfb.FileIndex[i2];
          if (file.size > 0 && file.size < 4096) {
            if (has_buf && Buffer.isBuffer(file.content)) {
              file.content.copy(o, o.l, 0, file.size);
              o.l += file.size + 63 & -64;
            } else {
              for (j = 0; j < file.size; ++j)
                o.write_shift(1, file.content[j]);
              for (; j & 63; ++j)
                o.write_shift(1, 0);
            }
          }
        }
        if (has_buf) {
          o.l = o.length;
        } else {
          while (o.l < o.length)
            o.write_shift(1, 0);
        }
        return o;
      }
      function find(cfb, path) {
        var UCFullPaths = cfb.FullPaths.map(function(x) {
          return x.toUpperCase();
        });
        var UCPaths = UCFullPaths.map(function(x) {
          var y = x.split("/");
          return y[y.length - (x.slice(-1) == "/" ? 2 : 1)];
        });
        var k = false;
        if (path.charCodeAt(0) === 47) {
          k = true;
          path = UCFullPaths[0].slice(0, -1) + path;
        } else
          k = path.indexOf("/") !== -1;
        var UCPath = path.toUpperCase();
        var w = k === true ? UCFullPaths.indexOf(UCPath) : UCPaths.indexOf(UCPath);
        if (w !== -1)
          return cfb.FileIndex[w];
        var m = !UCPath.match(chr1);
        UCPath = UCPath.replace(chr0, "");
        if (m)
          UCPath = UCPath.replace(chr1, "!");
        for (w = 0; w < UCFullPaths.length; ++w) {
          if ((m ? UCFullPaths[w].replace(chr1, "!") : UCFullPaths[w]).replace(chr0, "") == UCPath)
            return cfb.FileIndex[w];
          if ((m ? UCPaths[w].replace(chr1, "!") : UCPaths[w]).replace(chr0, "") == UCPath)
            return cfb.FileIndex[w];
        }
        return null;
      }
      var MSSZ = 64;
      var ENDOFCHAIN = -2;
      var HEADER_SIGNATURE = "d0cf11e0a1b11ae1";
      var HEADER_SIG = [208, 207, 17, 224, 161, 177, 26, 225];
      var HEADER_CLSID = "00000000000000000000000000000000";
      var consts = {
        /* 2.1 Compund File Sector Numbers and Types */
        MAXREGSECT: -6,
        DIFSECT: -4,
        FATSECT: -3,
        ENDOFCHAIN,
        FREESECT: -1,
        /* 2.2 Compound File Header */
        HEADER_SIGNATURE,
        HEADER_MINOR_VERSION: "3e00",
        MAXREGSID: -6,
        NOSTREAM: -1,
        HEADER_CLSID,
        /* 2.6.1 Compound File Directory Entry */
        EntryTypes: ["unknown", "storage", "stream", "lockbytes", "property", "root"]
      };
      function write_file(cfb, filename2, options) {
        get_fs();
        var o = _write(cfb, options);
        fs.writeFileSync(filename2, o);
      }
      function a2s2(o) {
        var out = new Array(o.length);
        for (var i2 = 0; i2 < o.length; ++i2)
          out[i2] = String.fromCharCode(o[i2]);
        return out.join("");
      }
      function write(cfb, options) {
        var o = _write(cfb, options);
        switch (options && options.type || "buffer") {
          case "file":
            get_fs();
            fs.writeFileSync(options.filename, o);
            return o;
          case "binary":
            return typeof o == "string" ? o : a2s2(o);
          case "base64":
            return Base64_encode(typeof o == "string" ? o : a2s2(o));
          case "buffer":
            if (has_buf)
              return Buffer.isBuffer(o) ? o : Buffer_from(o);
          case "array":
            return typeof o == "string" ? s2a(o) : o;
        }
        return o;
      }
      var _zlib;
      function use_zlib(zlib) {
        try {
          var InflateRaw = zlib.InflateRaw;
          var InflRaw = new InflateRaw();
          InflRaw._processChunk(new Uint8Array([3, 0]), InflRaw._finishFlushFlag);
          if (InflRaw.bytesRead)
            _zlib = zlib;
          else
            throw new Error("zlib does not expose bytesRead");
        } catch (e) {
          console.error("cannot use native zlib: " + (e.message || e));
        }
      }
      function _inflateRawSync(payload, usz) {
        if (!_zlib)
          return _inflate(payload, usz);
        var InflateRaw = _zlib.InflateRaw;
        var InflRaw = new InflateRaw();
        var out = InflRaw._processChunk(payload.slice(payload.l), InflRaw._finishFlushFlag);
        payload.l += InflRaw.bytesRead;
        return out;
      }
      function _deflateRawSync(payload) {
        return _zlib ? _zlib.deflateRawSync(payload) : _deflate(payload);
      }
      var CLEN_ORDER = [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15];
      var LEN_LN = [3, 4, 5, 6, 7, 8, 9, 10, 11, 13, 15, 17, 19, 23, 27, 31, 35, 43, 51, 59, 67, 83, 99, 115, 131, 163, 195, 227, 258];
      var DST_LN = [1, 2, 3, 4, 5, 7, 9, 13, 17, 25, 33, 49, 65, 97, 129, 193, 257, 385, 513, 769, 1025, 1537, 2049, 3073, 4097, 6145, 8193, 12289, 16385, 24577];
      function bit_swap_8(n) {
        var t = (n << 1 | n << 11) & 139536 | (n << 5 | n << 15) & 558144;
        return (t >> 16 | t >> 8 | t) & 255;
      }
      var use_typed_arrays = typeof Uint8Array !== "undefined";
      var bitswap8 = use_typed_arrays ? new Uint8Array(1 << 8) : [];
      for (var q = 0; q < 1 << 8; ++q)
        bitswap8[q] = bit_swap_8(q);
      function bit_swap_n(n, b) {
        var rev = bitswap8[n & 255];
        if (b <= 8)
          return rev >>> 8 - b;
        rev = rev << 8 | bitswap8[n >> 8 & 255];
        if (b <= 16)
          return rev >>> 16 - b;
        rev = rev << 8 | bitswap8[n >> 16 & 255];
        return rev >>> 24 - b;
      }
      function read_bits_2(buf, bl) {
        var w = bl & 7, h = bl >>> 3;
        return (buf[h] | (w <= 6 ? 0 : buf[h + 1] << 8)) >>> w & 3;
      }
      function read_bits_3(buf, bl) {
        var w = bl & 7, h = bl >>> 3;
        return (buf[h] | (w <= 5 ? 0 : buf[h + 1] << 8)) >>> w & 7;
      }
      function read_bits_4(buf, bl) {
        var w = bl & 7, h = bl >>> 3;
        return (buf[h] | (w <= 4 ? 0 : buf[h + 1] << 8)) >>> w & 15;
      }
      function read_bits_5(buf, bl) {
        var w = bl & 7, h = bl >>> 3;
        return (buf[h] | (w <= 3 ? 0 : buf[h + 1] << 8)) >>> w & 31;
      }
      function read_bits_7(buf, bl) {
        var w = bl & 7, h = bl >>> 3;
        return (buf[h] | (w <= 1 ? 0 : buf[h + 1] << 8)) >>> w & 127;
      }
      function read_bits_n(buf, bl, n) {
        var w = bl & 7, h = bl >>> 3, f = (1 << n) - 1;
        var v = buf[h] >>> w;
        if (n < 8 - w)
          return v & f;
        v |= buf[h + 1] << 8 - w;
        if (n < 16 - w)
          return v & f;
        v |= buf[h + 2] << 16 - w;
        if (n < 24 - w)
          return v & f;
        v |= buf[h + 3] << 24 - w;
        return v & f;
      }
      function write_bits_3(buf, bl, v) {
        var w = bl & 7, h = bl >>> 3;
        if (w <= 5)
          buf[h] |= (v & 7) << w;
        else {
          buf[h] |= v << w & 255;
          buf[h + 1] = (v & 7) >> 8 - w;
        }
        return bl + 3;
      }
      function write_bits_1(buf, bl, v) {
        var w = bl & 7, h = bl >>> 3;
        v = (v & 1) << w;
        buf[h] |= v;
        return bl + 1;
      }
      function write_bits_8(buf, bl, v) {
        var w = bl & 7, h = bl >>> 3;
        v <<= w;
        buf[h] |= v & 255;
        v >>>= 8;
        buf[h + 1] = v;
        return bl + 8;
      }
      function write_bits_16(buf, bl, v) {
        var w = bl & 7, h = bl >>> 3;
        v <<= w;
        buf[h] |= v & 255;
        v >>>= 8;
        buf[h + 1] = v & 255;
        buf[h + 2] = v >>> 8;
        return bl + 16;
      }
      function realloc(b, sz) {
        var L = b.length, M = 2 * L > sz ? 2 * L : sz + 5, i2 = 0;
        if (L >= sz)
          return b;
        if (has_buf) {
          var o = new_unsafe_buf(M);
          if (b.copy)
            b.copy(o);
          else
            for (; i2 < b.length; ++i2)
              o[i2] = b[i2];
          return o;
        } else if (use_typed_arrays) {
          var a = new Uint8Array(M);
          if (a.set)
            a.set(b);
          else
            for (; i2 < L; ++i2)
              a[i2] = b[i2];
          return a;
        }
        b.length = M;
        return b;
      }
      function zero_fill_array(n) {
        var o = new Array(n);
        for (var i2 = 0; i2 < n; ++i2)
          o[i2] = 0;
        return o;
      }
      function build_tree(clens, cmap, MAX) {
        var maxlen = 1, w = 0, i2 = 0, j = 0, ccode = 0, L = clens.length;
        var bl_count = use_typed_arrays ? new Uint16Array(32) : zero_fill_array(32);
        for (i2 = 0; i2 < 32; ++i2)
          bl_count[i2] = 0;
        for (i2 = L; i2 < MAX; ++i2)
          clens[i2] = 0;
        L = clens.length;
        var ctree = use_typed_arrays ? new Uint16Array(L) : zero_fill_array(L);
        for (i2 = 0; i2 < L; ++i2) {
          bl_count[w = clens[i2]]++;
          if (maxlen < w)
            maxlen = w;
          ctree[i2] = 0;
        }
        bl_count[0] = 0;
        for (i2 = 1; i2 <= maxlen; ++i2)
          bl_count[i2 + 16] = ccode = ccode + bl_count[i2 - 1] << 1;
        for (i2 = 0; i2 < L; ++i2) {
          ccode = clens[i2];
          if (ccode != 0)
            ctree[i2] = bl_count[ccode + 16]++;
        }
        var cleni = 0;
        for (i2 = 0; i2 < L; ++i2) {
          cleni = clens[i2];
          if (cleni != 0) {
            ccode = bit_swap_n(ctree[i2], maxlen) >> maxlen - cleni;
            for (j = (1 << maxlen + 4 - cleni) - 1; j >= 0; --j)
              cmap[ccode | j << cleni] = cleni & 15 | i2 << 4;
          }
        }
        return maxlen;
      }
      var fix_lmap = use_typed_arrays ? new Uint16Array(512) : zero_fill_array(512);
      var fix_dmap = use_typed_arrays ? new Uint16Array(32) : zero_fill_array(32);
      if (!use_typed_arrays) {
        for (var i = 0; i < 512; ++i)
          fix_lmap[i] = 0;
        for (i = 0; i < 32; ++i)
          fix_dmap[i] = 0;
      }
      (function() {
        var dlens = [];
        var i2 = 0;
        for (; i2 < 32; i2++)
          dlens.push(5);
        build_tree(dlens, fix_dmap, 32);
        var clens = [];
        i2 = 0;
        for (; i2 <= 143; i2++)
          clens.push(8);
        for (; i2 <= 255; i2++)
          clens.push(9);
        for (; i2 <= 279; i2++)
          clens.push(7);
        for (; i2 <= 287; i2++)
          clens.push(8);
        build_tree(clens, fix_lmap, 288);
      })();
      var _deflateRaw = /* @__PURE__ */ function _deflateRawIIFE() {
        var DST_LN_RE = use_typed_arrays ? new Uint8Array(32768) : [];
        var j = 0, k = 0;
        for (; j < DST_LN.length - 1; ++j) {
          for (; k < DST_LN[j + 1]; ++k)
            DST_LN_RE[k] = j;
        }
        for (; k < 32768; ++k)
          DST_LN_RE[k] = 29;
        var LEN_LN_RE = use_typed_arrays ? new Uint8Array(259) : [];
        for (j = 0, k = 0; j < LEN_LN.length - 1; ++j) {
          for (; k < LEN_LN[j + 1]; ++k)
            LEN_LN_RE[k] = j;
        }
        function write_stored(data, out) {
          var boff = 0;
          while (boff < data.length) {
            var L = Math.min(65535, data.length - boff);
            var h = boff + L == data.length;
            out.write_shift(1, +h);
            out.write_shift(2, L);
            out.write_shift(2, ~L & 65535);
            while (L-- > 0)
              out[out.l++] = data[boff++];
          }
          return out.l;
        }
        function write_huff_fixed(data, out) {
          var bl = 0;
          var boff = 0;
          var addrs = use_typed_arrays ? new Uint16Array(32768) : [];
          while (boff < data.length) {
            var L = (
              /* data.length - boff; */
              Math.min(65535, data.length - boff)
            );
            if (L < 10) {
              bl = write_bits_3(out, bl, +!!(boff + L == data.length));
              if (bl & 7)
                bl += 8 - (bl & 7);
              out.l = bl / 8 | 0;
              out.write_shift(2, L);
              out.write_shift(2, ~L & 65535);
              while (L-- > 0)
                out[out.l++] = data[boff++];
              bl = out.l * 8;
              continue;
            }
            bl = write_bits_3(out, bl, +!!(boff + L == data.length) + 2);
            var hash = 0;
            while (L-- > 0) {
              var d = data[boff];
              hash = (hash << 5 ^ d) & 32767;
              var match = -1, mlen = 0;
              if (match = addrs[hash]) {
                match |= boff & -32768;
                if (match > boff)
                  match -= 32768;
                if (match < boff)
                  while (data[match + mlen] == data[boff + mlen] && mlen < 250)
                    ++mlen;
              }
              if (mlen > 2) {
                d = LEN_LN_RE[mlen];
                if (d <= 22)
                  bl = write_bits_8(out, bl, bitswap8[d + 1] >> 1) - 1;
                else {
                  write_bits_8(out, bl, 3);
                  bl += 5;
                  write_bits_8(out, bl, bitswap8[d - 23] >> 5);
                  bl += 3;
                }
                var len_eb = d < 8 ? 0 : d - 4 >> 2;
                if (len_eb > 0) {
                  write_bits_16(out, bl, mlen - LEN_LN[d]);
                  bl += len_eb;
                }
                d = DST_LN_RE[boff - match];
                bl = write_bits_8(out, bl, bitswap8[d] >> 3);
                bl -= 3;
                var dst_eb = d < 4 ? 0 : d - 2 >> 1;
                if (dst_eb > 0) {
                  write_bits_16(out, bl, boff - match - DST_LN[d]);
                  bl += dst_eb;
                }
                for (var q2 = 0; q2 < mlen; ++q2) {
                  addrs[hash] = boff & 32767;
                  hash = (hash << 5 ^ data[boff]) & 32767;
                  ++boff;
                }
                L -= mlen - 1;
              } else {
                if (d <= 143)
                  d = d + 48;
                else
                  bl = write_bits_1(out, bl, 1);
                bl = write_bits_8(out, bl, bitswap8[d]);
                addrs[hash] = boff & 32767;
                ++boff;
              }
            }
            bl = write_bits_8(out, bl, 0) - 1;
          }
          out.l = (bl + 7) / 8 | 0;
          return out.l;
        }
        return function _deflateRaw2(data, out) {
          if (data.length < 8)
            return write_stored(data, out);
          return write_huff_fixed(data, out);
        };
      }();
      function _deflate(data) {
        var buf = new_buf(50 + Math.floor(data.length * 1.1));
        var off = _deflateRaw(data, buf);
        return buf.slice(0, off);
      }
      var dyn_lmap = use_typed_arrays ? new Uint16Array(32768) : zero_fill_array(32768);
      var dyn_dmap = use_typed_arrays ? new Uint16Array(32768) : zero_fill_array(32768);
      var dyn_cmap = use_typed_arrays ? new Uint16Array(128) : zero_fill_array(128);
      var dyn_len_1 = 1, dyn_len_2 = 1;
      function dyn(data, boff) {
        var _HLIT = read_bits_5(data, boff) + 257;
        boff += 5;
        var _HDIST = read_bits_5(data, boff) + 1;
        boff += 5;
        var _HCLEN = read_bits_4(data, boff) + 4;
        boff += 4;
        var w = 0;
        var clens = use_typed_arrays ? new Uint8Array(19) : zero_fill_array(19);
        var ctree = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];
        var maxlen = 1;
        var bl_count = use_typed_arrays ? new Uint8Array(8) : zero_fill_array(8);
        var next_code = use_typed_arrays ? new Uint8Array(8) : zero_fill_array(8);
        var L = clens.length;
        for (var i2 = 0; i2 < _HCLEN; ++i2) {
          clens[CLEN_ORDER[i2]] = w = read_bits_3(data, boff);
          if (maxlen < w)
            maxlen = w;
          bl_count[w]++;
          boff += 3;
        }
        var ccode = 0;
        bl_count[0] = 0;
        for (i2 = 1; i2 <= maxlen; ++i2)
          next_code[i2] = ccode = ccode + bl_count[i2 - 1] << 1;
        for (i2 = 0; i2 < L; ++i2)
          if ((ccode = clens[i2]) != 0)
            ctree[i2] = next_code[ccode]++;
        var cleni = 0;
        for (i2 = 0; i2 < L; ++i2) {
          cleni = clens[i2];
          if (cleni != 0) {
            ccode = bitswap8[ctree[i2]] >> 8 - cleni;
            for (var j = (1 << 7 - cleni) - 1; j >= 0; --j)
              dyn_cmap[ccode | j << cleni] = cleni & 7 | i2 << 3;
          }
        }
        var hcodes = [];
        maxlen = 1;
        for (; hcodes.length < _HLIT + _HDIST; ) {
          ccode = dyn_cmap[read_bits_7(data, boff)];
          boff += ccode & 7;
          switch (ccode >>>= 3) {
            case 16:
              w = 3 + read_bits_2(data, boff);
              boff += 2;
              ccode = hcodes[hcodes.length - 1];
              while (w-- > 0)
                hcodes.push(ccode);
              break;
            case 17:
              w = 3 + read_bits_3(data, boff);
              boff += 3;
              while (w-- > 0)
                hcodes.push(0);
              break;
            case 18:
              w = 11 + read_bits_7(data, boff);
              boff += 7;
              while (w-- > 0)
                hcodes.push(0);
              break;
            default:
              hcodes.push(ccode);
              if (maxlen < ccode)
                maxlen = ccode;
              break;
          }
        }
        var h1 = hcodes.slice(0, _HLIT), h2 = hcodes.slice(_HLIT);
        for (i2 = _HLIT; i2 < 286; ++i2)
          h1[i2] = 0;
        for (i2 = _HDIST; i2 < 30; ++i2)
          h2[i2] = 0;
        dyn_len_1 = build_tree(h1, dyn_lmap, 286);
        dyn_len_2 = build_tree(h2, dyn_dmap, 30);
        return boff;
      }
      function inflate(data, usz) {
        if (data[0] == 3 && !(data[1] & 3)) {
          return [new_raw_buf(usz), 2];
        }
        var boff = 0;
        var header = 0;
        var outbuf = new_unsafe_buf(usz ? usz : 1 << 18);
        var woff = 0;
        var OL = outbuf.length >>> 0;
        var max_len_1 = 0, max_len_2 = 0;
        while ((header & 1) == 0) {
          header = read_bits_3(data, boff);
          boff += 3;
          if (header >>> 1 == 0) {
            if (boff & 7)
              boff += 8 - (boff & 7);
            var sz = data[boff >>> 3] | data[(boff >>> 3) + 1] << 8;
            boff += 32;
            if (sz > 0) {
              if (!usz && OL < woff + sz) {
                outbuf = realloc(outbuf, woff + sz);
                OL = outbuf.length;
              }
              while (sz-- > 0) {
                outbuf[woff++] = data[boff >>> 3];
                boff += 8;
              }
            }
            continue;
          } else if (header >> 1 == 1) {
            max_len_1 = 9;
            max_len_2 = 5;
          } else {
            boff = dyn(data, boff);
            max_len_1 = dyn_len_1;
            max_len_2 = dyn_len_2;
          }
          for (; ; ) {
            if (!usz && OL < woff + 32767) {
              outbuf = realloc(outbuf, woff + 32767);
              OL = outbuf.length;
            }
            var bits = read_bits_n(data, boff, max_len_1);
            var code = header >>> 1 == 1 ? fix_lmap[bits] : dyn_lmap[bits];
            boff += code & 15;
            code >>>= 4;
            if ((code >>> 8 & 255) === 0)
              outbuf[woff++] = code;
            else if (code == 256)
              break;
            else {
              code -= 257;
              var len_eb = code < 8 ? 0 : code - 4 >> 2;
              if (len_eb > 5)
                len_eb = 0;
              var tgt = woff + LEN_LN[code];
              if (len_eb > 0) {
                tgt += read_bits_n(data, boff, len_eb);
                boff += len_eb;
              }
              bits = read_bits_n(data, boff, max_len_2);
              code = header >>> 1 == 1 ? fix_dmap[bits] : dyn_dmap[bits];
              boff += code & 15;
              code >>>= 4;
              var dst_eb = code < 4 ? 0 : code - 2 >> 1;
              var dst = DST_LN[code];
              if (dst_eb > 0) {
                dst += read_bits_n(data, boff, dst_eb);
                boff += dst_eb;
              }
              if (!usz && OL < tgt) {
                outbuf = realloc(outbuf, tgt + 100);
                OL = outbuf.length;
              }
              while (woff < tgt) {
                outbuf[woff] = outbuf[woff - dst];
                ++woff;
              }
            }
          }
        }
        if (usz)
          return [outbuf, boff + 7 >>> 3];
        return [outbuf.slice(0, woff), boff + 7 >>> 3];
      }
      function _inflate(payload, usz) {
        var data = payload.slice(payload.l || 0);
        var out = inflate(data, usz);
        payload.l += out[1];
        return out[0];
      }
      function warn_or_throw(wrn, msg) {
        if (wrn) {
          if (typeof console !== "undefined")
            console.error(msg);
        } else
          throw new Error(msg);
      }
      function parse_zip(file, options) {
        var blob = (
          /*::(*/
          file
        );
        prep_blob(blob, 0);
        var FileIndex = [], FullPaths = [];
        var o = {
          FileIndex,
          FullPaths
        };
        init_cfb(o, { root: options.root });
        var i2 = blob.length - 4;
        while ((blob[i2] != 80 || blob[i2 + 1] != 75 || blob[i2 + 2] != 5 || blob[i2 + 3] != 6) && i2 >= 0)
          --i2;
        blob.l = i2 + 4;
        blob.l += 4;
        var fcnt = blob.read_shift(2);
        blob.l += 6;
        var start_cd = blob.read_shift(4);
        blob.l = start_cd;
        for (i2 = 0; i2 < fcnt; ++i2) {
          blob.l += 20;
          var csz = blob.read_shift(4);
          var usz = blob.read_shift(4);
          var namelen = blob.read_shift(2);
          var efsz = blob.read_shift(2);
          var fcsz = blob.read_shift(2);
          blob.l += 8;
          var offset = blob.read_shift(4);
          var EF = parse_extra_field(
            /*::(*/
            blob.slice(blob.l + namelen, blob.l + namelen + efsz)
            /*:: :any)*/
          );
          blob.l += namelen + efsz + fcsz;
          var L = blob.l;
          blob.l = offset + 4;
          parse_local_file(blob, csz, usz, o, EF);
          blob.l = L;
        }
        return o;
      }
      function parse_local_file(blob, csz, usz, o, EF) {
        blob.l += 2;
        var flags = blob.read_shift(2);
        var meth = blob.read_shift(2);
        var date = parse_dos_date(blob);
        if (flags & 8257)
          throw new Error("Unsupported ZIP encryption");
        var crc32 = blob.read_shift(4);
        var _csz = blob.read_shift(4);
        var _usz = blob.read_shift(4);
        var namelen = blob.read_shift(2);
        var efsz = blob.read_shift(2);
        var name = "";
        for (var i2 = 0; i2 < namelen; ++i2)
          name += String.fromCharCode(blob[blob.l++]);
        if (efsz) {
          var ef = parse_extra_field(
            /*::(*/
            blob.slice(blob.l, blob.l + efsz)
            /*:: :any)*/
          );
          if ((ef[21589] || {}).mt)
            date = ef[21589].mt;
          if (((EF || {})[21589] || {}).mt)
            date = EF[21589].mt;
        }
        blob.l += efsz;
        var data = blob.slice(blob.l, blob.l + _csz);
        switch (meth) {
          case 8:
            data = _inflateRawSync(blob, _usz);
            break;
          case 0:
            break;
          default:
            throw new Error("Unsupported ZIP Compression method " + meth);
        }
        var wrn = false;
        if (flags & 8) {
          crc32 = blob.read_shift(4);
          if (crc32 == 134695760) {
            crc32 = blob.read_shift(4);
            wrn = true;
          }
          _csz = blob.read_shift(4);
          _usz = blob.read_shift(4);
        }
        if (_csz != csz)
          warn_or_throw(wrn, "Bad compressed size: " + csz + " != " + _csz);
        if (_usz != usz)
          warn_or_throw(wrn, "Bad uncompressed size: " + usz + " != " + _usz);
        cfb_add(o, name, data, { unsafe: true, mt: date });
      }
      function write_zip2(cfb, options) {
        var _opts = options || {};
        var out = [], cdirs = [];
        var o = new_buf(1);
        var method = _opts.compression ? 8 : 0, flags = 0;
        var i2 = 0, j = 0;
        var start_cd = 0, fcnt = 0;
        var root = cfb.FullPaths[0], fp = root, fi = cfb.FileIndex[0];
        var crcs = [];
        var sz_cd = 0;
        for (i2 = 1; i2 < cfb.FullPaths.length; ++i2) {
          fp = cfb.FullPaths[i2].slice(root.length);
          fi = cfb.FileIndex[i2];
          if (!fi.size || !fi.content || fp == "Sh33tJ5")
            continue;
          var start = start_cd;
          var namebuf = new_buf(fp.length);
          for (j = 0; j < fp.length; ++j)
            namebuf.write_shift(1, fp.charCodeAt(j) & 127);
          namebuf = namebuf.slice(0, namebuf.l);
          crcs[fcnt] = CRC32.buf(
            /*::((*/
            fi.content,
            0
          );
          var outbuf = fi.content;
          if (method == 8)
            outbuf = _deflateRawSync(outbuf);
          o = new_buf(30);
          o.write_shift(4, 67324752);
          o.write_shift(2, 20);
          o.write_shift(2, flags);
          o.write_shift(2, method);
          if (fi.mt)
            write_dos_date(o, fi.mt);
          else
            o.write_shift(4, 0);
          o.write_shift(-4, crcs[fcnt]);
          o.write_shift(4, outbuf.length);
          o.write_shift(
            4,
            /*::(*/
            fi.content.length
          );
          o.write_shift(2, namebuf.length);
          o.write_shift(2, 0);
          start_cd += o.length;
          out.push(o);
          start_cd += namebuf.length;
          out.push(namebuf);
          start_cd += outbuf.length;
          out.push(outbuf);
          o = new_buf(46);
          o.write_shift(4, 33639248);
          o.write_shift(2, 0);
          o.write_shift(2, 20);
          o.write_shift(2, flags);
          o.write_shift(2, method);
          o.write_shift(4, 0);
          o.write_shift(-4, crcs[fcnt]);
          o.write_shift(4, outbuf.length);
          o.write_shift(
            4,
            /*::(*/
            fi.content.length
          );
          o.write_shift(2, namebuf.length);
          o.write_shift(2, 0);
          o.write_shift(2, 0);
          o.write_shift(2, 0);
          o.write_shift(2, 0);
          o.write_shift(4, 0);
          o.write_shift(4, start);
          sz_cd += o.l;
          cdirs.push(o);
          sz_cd += namebuf.length;
          cdirs.push(namebuf);
          ++fcnt;
        }
        o = new_buf(22);
        o.write_shift(4, 101010256);
        o.write_shift(2, 0);
        o.write_shift(2, 0);
        o.write_shift(2, fcnt);
        o.write_shift(2, fcnt);
        o.write_shift(4, sz_cd);
        o.write_shift(4, start_cd);
        o.write_shift(2, 0);
        return bconcat([bconcat(out), bconcat(cdirs), o]);
      }
      var ContentTypeMap = {
        "htm": "text/html",
        "xml": "text/xml",
        "gif": "image/gif",
        "jpg": "image/jpeg",
        "png": "image/png",
        "mso": "application/x-mso",
        "thmx": "application/vnd.ms-officetheme",
        "sh33tj5": "application/octet-stream"
      };
      function get_content_type(fi, fp) {
        if (fi.ctype)
          return fi.ctype;
        var ext = fi.name || "", m = ext.match(/\.([^\.]+)$/);
        if (m && ContentTypeMap[m[1]])
          return ContentTypeMap[m[1]];
        if (fp) {
          m = (ext = fp).match(/[\.\\]([^\.\\])+$/);
          if (m && ContentTypeMap[m[1]])
            return ContentTypeMap[m[1]];
        }
        return "application/octet-stream";
      }
      function write_base64_76(bstr) {
        var data = Base64_encode(bstr);
        var o = [];
        for (var i2 = 0; i2 < data.length; i2 += 76)
          o.push(data.slice(i2, i2 + 76));
        return o.join("\r\n") + "\r\n";
      }
      function write_quoted_printable(text) {
        var encoded = text.replace(/[\x00-\x08\x0B\x0C\x0E-\x1F\x7E-\xFF=]/g, function(c) {
          var w = c.charCodeAt(0).toString(16).toUpperCase();
          return "=" + (w.length == 1 ? "0" + w : w);
        });
        encoded = encoded.replace(/ $/mg, "=20").replace(/\t$/mg, "=09");
        if (encoded.charAt(0) == "\n")
          encoded = "=0D" + encoded.slice(1);
        encoded = encoded.replace(/\r(?!\n)/mg, "=0D").replace(/\n\n/mg, "\n=0A").replace(/([^\r\n])\n/mg, "$1=0A");
        var o = [], split = encoded.split("\r\n");
        for (var si = 0; si < split.length; ++si) {
          var str = split[si];
          if (str.length == 0) {
            o.push("");
            continue;
          }
          for (var i2 = 0; i2 < str.length; ) {
            var end = 76;
            var tmp = str.slice(i2, i2 + end);
            if (tmp.charAt(end - 1) == "=")
              end--;
            else if (tmp.charAt(end - 2) == "=")
              end -= 2;
            else if (tmp.charAt(end - 3) == "=")
              end -= 3;
            tmp = str.slice(i2, i2 + end);
            i2 += end;
            if (i2 < str.length)
              tmp += "=";
            o.push(tmp);
          }
        }
        return o.join("\r\n");
      }
      function parse_quoted_printable(data) {
        var o = [];
        for (var di = 0; di < data.length; ++di) {
          var line = data[di];
          while (di <= data.length && line.charAt(line.length - 1) == "=")
            line = line.slice(0, line.length - 1) + data[++di];
          o.push(line);
        }
        for (var oi = 0; oi < o.length; ++oi)
          o[oi] = o[oi].replace(/[=][0-9A-Fa-f]{2}/g, function($$) {
            return String.fromCharCode(parseInt($$.slice(1), 16));
          });
        return s2a(o.join("\r\n"));
      }
      function parse_mime(cfb, data, root) {
        var fname = "", cte = "", ctype = "", fdata;
        var di = 0;
        for (; di < 10; ++di) {
          var line = data[di];
          if (!line || line.match(/^\s*$/))
            break;
          var m = line.match(/^(.*?):\s*([^\s].*)$/);
          if (m)
            switch (m[1].toLowerCase()) {
              case "content-location":
                fname = m[2].trim();
                break;
              case "content-type":
                ctype = m[2].trim();
                break;
              case "content-transfer-encoding":
                cte = m[2].trim();
                break;
            }
        }
        ++di;
        switch (cte.toLowerCase()) {
          case "base64":
            fdata = s2a(Base64_decode(data.slice(di).join("")));
            break;
          case "quoted-printable":
            fdata = parse_quoted_printable(data.slice(di));
            break;
          default:
            throw new Error("Unsupported Content-Transfer-Encoding " + cte);
        }
        var file = cfb_add(cfb, fname.slice(root.length), fdata, { unsafe: true });
        if (ctype)
          file.ctype = ctype;
      }
      function parse_mad(file, options) {
        if (a2s2(file.slice(0, 13)).toLowerCase() != "mime-version:")
          throw new Error("Unsupported MAD header");
        var root = options && options.root || "";
        var data = (has_buf && Buffer.isBuffer(file) ? file.toString("binary") : a2s2(file)).split("\r\n");
        var di = 0, row = "";
        for (di = 0; di < data.length; ++di) {
          row = data[di];
          if (!/^Content-Location:/i.test(row))
            continue;
          row = row.slice(row.indexOf("file"));
          if (!root)
            root = row.slice(0, row.lastIndexOf("/") + 1);
          if (row.slice(0, root.length) == root)
            continue;
          while (root.length > 0) {
            root = root.slice(0, root.length - 1);
            root = root.slice(0, root.lastIndexOf("/") + 1);
            if (row.slice(0, root.length) == root)
              break;
          }
        }
        var mboundary = (data[1] || "").match(/boundary="(.*?)"/);
        if (!mboundary)
          throw new Error("MAD cannot find boundary");
        var boundary = "--" + (mboundary[1] || "");
        var FileIndex = [], FullPaths = [];
        var o = {
          FileIndex,
          FullPaths
        };
        init_cfb(o);
        var start_di, fcnt = 0;
        for (di = 0; di < data.length; ++di) {
          var line = data[di];
          if (line !== boundary && line !== boundary + "--")
            continue;
          if (fcnt++)
            parse_mime(o, data.slice(start_di, di), root);
          start_di = di;
        }
        return o;
      }
      function write_mad(cfb, options) {
        var opts = options || {};
        var boundary = opts.boundary || "SheetJS";
        boundary = "------=" + boundary;
        var out = [
          "MIME-Version: 1.0",
          'Content-Type: multipart/related; boundary="' + boundary.slice(2) + '"',
          "",
          "",
          ""
        ];
        var root = cfb.FullPaths[0], fp = root, fi = cfb.FileIndex[0];
        for (var i2 = 1; i2 < cfb.FullPaths.length; ++i2) {
          fp = cfb.FullPaths[i2].slice(root.length);
          fi = cfb.FileIndex[i2];
          if (!fi.size || !fi.content || fp == "Sh33tJ5")
            continue;
          fp = fp.replace(/[\x00-\x08\x0B\x0C\x0E-\x1F\x7E-\xFF]/g, function(c) {
            return "_x" + c.charCodeAt(0).toString(16) + "_";
          }).replace(/[\u0080-\uFFFF]/g, function(u) {
            return "_u" + u.charCodeAt(0).toString(16) + "_";
          });
          var ca = fi.content;
          var cstr = has_buf && Buffer.isBuffer(ca) ? ca.toString("binary") : a2s2(ca);
          var dispcnt = 0, L = Math.min(1024, cstr.length), cc = 0;
          for (var csl = 0; csl <= L; ++csl)
            if ((cc = cstr.charCodeAt(csl)) >= 32 && cc < 128)
              ++dispcnt;
          var qp = dispcnt >= L * 4 / 5;
          out.push(boundary);
          out.push("Content-Location: " + (opts.root || "file:///C:/SheetJS/") + fp);
          out.push("Content-Transfer-Encoding: " + (qp ? "quoted-printable" : "base64"));
          out.push("Content-Type: " + get_content_type(fi, fp));
          out.push("");
          out.push(qp ? write_quoted_printable(cstr) : write_base64_76(cstr));
        }
        out.push(boundary + "--\r\n");
        return out.join("\r\n");
      }
      function cfb_new(opts) {
        var o = {};
        init_cfb(o, opts);
        return o;
      }
      function cfb_add(cfb, name, content, opts) {
        var unsafe = opts && opts.unsafe;
        if (!unsafe)
          init_cfb(cfb);
        var file = !unsafe && CFB.find(cfb, name);
        if (!file) {
          var fpath = cfb.FullPaths[0];
          if (name.slice(0, fpath.length) == fpath)
            fpath = name;
          else {
            if (fpath.slice(-1) != "/")
              fpath += "/";
            fpath = (fpath + name).replace("//", "/");
          }
          file = { name: filename(name), type: 2 };
          cfb.FileIndex.push(file);
          cfb.FullPaths.push(fpath);
          if (!unsafe)
            CFB.utils.cfb_gc(cfb);
        }
        file.content = content;
        file.size = content ? content.length : 0;
        if (opts) {
          if (opts.CLSID)
            file.clsid = opts.CLSID;
          if (opts.mt)
            file.mt = opts.mt;
          if (opts.ct)
            file.ct = opts.ct;
        }
        return file;
      }
      function cfb_del(cfb, name) {
        init_cfb(cfb);
        var file = CFB.find(cfb, name);
        if (file) {
          for (var j = 0; j < cfb.FileIndex.length; ++j)
            if (cfb.FileIndex[j] == file) {
              cfb.FileIndex.splice(j, 1);
              cfb.FullPaths.splice(j, 1);
              return true;
            }
        }
        return false;
      }
      function cfb_mov(cfb, old_name, new_name) {
        init_cfb(cfb);
        var file = CFB.find(cfb, old_name);
        if (file) {
          for (var j = 0; j < cfb.FileIndex.length; ++j)
            if (cfb.FileIndex[j] == file) {
              cfb.FileIndex[j].name = filename(new_name);
              cfb.FullPaths[j] = new_name;
              return true;
            }
        }
        return false;
      }
      function cfb_gc(cfb) {
        rebuild_cfb(cfb, true);
      }
      exports22.find = find;
      exports22.read = read;
      exports22.parse = parse2;
      exports22.write = write;
      exports22.writeFile = write_file;
      exports22.utils = {
        cfb_new,
        cfb_add,
        cfb_del,
        cfb_mov,
        cfb_gc,
        ReadShift,
        CheckField,
        prep_blob,
        bconcat,
        use_zlib,
        _deflateRaw: _deflate,
        _inflateRaw: _inflate,
        consts
      };
      return exports22;
    }();
    function blobify(data) {
      if (typeof data === "string")
        return s2ab(data);
      if (Array.isArray(data))
        return a2u(data);
      return data;
    }
    function write_dl(fname, payload, enc) {
      if (typeof Deno !== "undefined") {
        if (enc && typeof payload == "string")
          switch (enc) {
            case "utf8":
              payload = new TextEncoder(enc).encode(payload);
              break;
            case "binary":
              payload = s2ab(payload);
              break;
            default:
              throw new Error("Unsupported encoding " + enc);
          }
        return Deno.writeFileSync(fname, payload);
      }
      var data = enc == "utf8" ? utf8write(payload) : payload;
      if (typeof IE_SaveFile !== "undefined")
        return IE_SaveFile(data, fname);
      if (typeof Blob !== "undefined") {
        var blob = new Blob([blobify(data)], { type: "application/octet-stream" });
        if (typeof navigator !== "undefined" && navigator.msSaveBlob)
          return navigator.msSaveBlob(blob, fname);
        if (typeof saveAs !== "undefined")
          return saveAs(blob, fname);
        if (typeof URL !== "undefined" && typeof document !== "undefined" && document.createElement && URL.createObjectURL) {
          var url = URL.createObjectURL(blob);
          if (typeof chrome === "object" && typeof (chrome.downloads || {}).download == "function") {
            if (URL.revokeObjectURL && typeof setTimeout !== "undefined")
              setTimeout(function() {
                URL.revokeObjectURL(url);
              }, 6e4);
            return chrome.downloads.download({ url, filename: fname, saveAs: true });
          }
          var a = document.createElement("a");
          if (a.download != null) {
            a.download = fname;
            a.href = url;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            if (URL.revokeObjectURL && typeof setTimeout !== "undefined")
              setTimeout(function() {
                URL.revokeObjectURL(url);
              }, 6e4);
            return url;
          }
        }
      }
      if (typeof $ !== "undefined" && typeof File !== "undefined" && typeof Folder !== "undefined")
        try {
          var out = File(fname);
          out.open("w");
          out.encoding = "binary";
          if (Array.isArray(payload))
            payload = a2s(payload);
          out.write(payload);
          out.close();
          return payload;
        } catch (e) {
          if (!e.message || !e.message.match(/onstruct/))
            throw e;
        }
      throw new Error("cannot save file " + fname);
    }
    function keys(o) {
      var ks = Object.keys(o), o2 = [];
      for (var i = 0; i < ks.length; ++i)
        if (Object.prototype.hasOwnProperty.call(o, ks[i]))
          o2.push(ks[i]);
      return o2;
    }
    function evert_key(obj2, key) {
      var o = [], K = keys(obj2);
      for (var i = 0; i !== K.length; ++i)
        if (o[obj2[K[i]][key]] == null)
          o[obj2[K[i]][key]] = K[i];
      return o;
    }
    function evert(obj2) {
      var o = [], K = keys(obj2);
      for (var i = 0; i !== K.length; ++i)
        o[obj2[K[i]]] = K[i];
      return o;
    }
    function evert_num(obj2) {
      var o = [], K = keys(obj2);
      for (var i = 0; i !== K.length; ++i)
        o[obj2[K[i]]] = parseInt(K[i], 10);
      return o;
    }
    function evert_arr(obj2) {
      var o = [], K = keys(obj2);
      for (var i = 0; i !== K.length; ++i) {
        if (o[obj2[K[i]]] == null)
          o[obj2[K[i]]] = [];
        o[obj2[K[i]]].push(K[i]);
      }
      return o;
    }
    var basedate = /* @__PURE__ */ new Date(1899, 11, 30, 0, 0, 0);
    function datenum(v, date1904) {
      var epoch = /* @__PURE__ */ v.getTime();
      var dnthresh2 = /* @__PURE__ */ basedate.getTime() + (/* @__PURE__ */ v.getTimezoneOffset() - /* @__PURE__ */ basedate.getTimezoneOffset()) * 6e4;
      return (epoch - dnthresh2) / (24 * 60 * 60 * 1e3);
    }
    var refdate = /* @__PURE__ */ new Date();
    var dnthresh = /* @__PURE__ */ basedate.getTime() + (/* @__PURE__ */ refdate.getTimezoneOffset() - /* @__PURE__ */ basedate.getTimezoneOffset()) * 6e4;
    var refoffset = /* @__PURE__ */ refdate.getTimezoneOffset();
    function numdate(v) {
      var out = /* @__PURE__ */ new Date();
      out.setTime(v * 24 * 60 * 60 * 1e3 + dnthresh);
      if (out.getTimezoneOffset() !== refoffset) {
        out.setTime(out.getTime() + (out.getTimezoneOffset() - refoffset) * 6e4);
      }
      return out;
    }
    var good_pd_date_1 = /* @__PURE__ */ new Date("2017-02-19T19:06:09.000Z");
    var good_pd_date = /* @__PURE__ */ isNaN(/* @__PURE__ */ good_pd_date_1.getFullYear()) ? /* @__PURE__ */ new Date("2/19/17") : good_pd_date_1;
    var good_pd = /* @__PURE__ */ good_pd_date.getFullYear() == 2017;
    function parseDate(str, fixdate) {
      var d = new Date(str);
      if (good_pd) {
        if (fixdate > 0)
          d.setTime(d.getTime() + d.getTimezoneOffset() * 60 * 1e3);
        else if (fixdate < 0)
          d.setTime(d.getTime() - d.getTimezoneOffset() * 60 * 1e3);
        return d;
      }
      if (str instanceof Date)
        return str;
      if (good_pd_date.getFullYear() == 1917 && !isNaN(d.getFullYear())) {
        var s = d.getFullYear();
        if (str.indexOf("" + s) > -1)
          return d;
        d.setFullYear(d.getFullYear() + 100);
        return d;
      }
      var n = str.match(/\d+/g) || ["2017", "2", "19", "0", "0", "0"];
      var out = new Date(+n[0], +n[1] - 1, +n[2], +n[3] || 0, +n[4] || 0, +n[5] || 0);
      if (str.indexOf("Z") > -1)
        out = new Date(out.getTime() - out.getTimezoneOffset() * 60 * 1e3);
      return out;
    }
    function cc2str(arr, debomit) {
      if (has_buf && Buffer.isBuffer(arr)) {
        return arr.toString("binary");
      }
      if (typeof TextDecoder !== "undefined")
        try {
          if (debomit)
            ;
          var rev = {
            "\u20AC": "\x80",
            "\u201A": "\x82",
            "\u0192": "\x83",
            "\u201E": "\x84",
            "\u2026": "\x85",
            "\u2020": "\x86",
            "\u2021": "\x87",
            "\u02C6": "\x88",
            "\u2030": "\x89",
            "\u0160": "\x8A",
            "\u2039": "\x8B",
            "\u0152": "\x8C",
            "\u017D": "\x8E",
            "\u2018": "\x91",
            "\u2019": "\x92",
            "\u201C": "\x93",
            "\u201D": "\x94",
            "\u2022": "\x95",
            "\u2013": "\x96",
            "\u2014": "\x97",
            "\u02DC": "\x98",
            "\u2122": "\x99",
            "\u0161": "\x9A",
            "\u203A": "\x9B",
            "\u0153": "\x9C",
            "\u017E": "\x9E",
            "\u0178": "\x9F"
          };
          if (Array.isArray(arr))
            arr = new Uint8Array(arr);
          return new TextDecoder("latin1").decode(arr).replace(/[]/g, function(c) {
            return rev[c] || c;
          });
        } catch (e) {
        }
      var o = [];
      for (var i = 0; i != arr.length; ++i)
        o.push(String.fromCharCode(arr[i]));
      return o.join("");
    }
    function dup(o) {
      if (typeof JSON != "undefined" && !Array.isArray(o))
        return JSON.parse(JSON.stringify(o));
      if (typeof o != "object" || o == null)
        return o;
      if (o instanceof Date)
        return new Date(o.getTime());
      var out = {};
      for (var k in o)
        if (Object.prototype.hasOwnProperty.call(o, k))
          out[k] = dup(o[k]);
      return out;
    }
    function fill(c, l2) {
      var o = "";
      while (o.length < l2)
        o += c;
      return o;
    }
    function fuzzynum(s) {
      var v = Number(s);
      if (!isNaN(v))
        return isFinite(v) ? v : NaN;
      if (!/\d/.test(s))
        return v;
      var wt = 1;
      var ss = s.replace(/([\d]),([\d])/g, "$1$2").replace(/[$]/g, "").replace(/[%]/g, function() {
        wt *= 100;
        return "";
      });
      if (!isNaN(v = Number(ss)))
        return v / wt;
      ss = ss.replace(/[(](.*)[)]/, function($$, $1) {
        wt = -wt;
        return $1;
      });
      if (!isNaN(v = Number(ss)))
        return v / wt;
      return v;
    }
    var lower_months = ["january", "february", "march", "april", "may", "june", "july", "august", "september", "october", "november", "december"];
    function fuzzydate(s) {
      var o = new Date(s), n = /* @__PURE__ */ new Date(NaN);
      var y = o.getYear(), m = o.getMonth(), d = o.getDate();
      if (isNaN(d))
        return n;
      var lower = s.toLowerCase();
      if (lower.match(/jan|feb|mar|apr|may|jun|jul|aug|sep|oct|nov|dec/)) {
        lower = lower.replace(/[^a-z]/g, "").replace(/([^a-z]|^)[ap]m?([^a-z]|$)/, "");
        if (lower.length > 3 && lower_months.indexOf(lower) == -1)
          return n;
      } else if (lower.match(/[a-z]/))
        return n;
      if (y < 0 || y > 8099)
        return n;
      if ((m > 0 || d > 1) && y != 101)
        return o;
      if (s.match(/[^-0-9:,\/\\]/))
        return n;
      return o;
    }
    function zip_add_file(zip, path, content) {
      if (zip.FullPaths) {
        if (typeof content == "string") {
          var res;
          if (has_buf)
            res = Buffer_from(content);
          else
            res = utf8decode(content);
          return CFB.utils.cfb_add(zip, path, res);
        }
        CFB.utils.cfb_add(zip, path, content);
      } else
        zip.file(path, content);
    }
    function zip_new() {
      return CFB.utils.cfb_new();
    }
    var XML_HEADER = '<?xml version="1.0" encoding="UTF-8" standalone="yes"?>\r\n';
    var encodings = {
      "&quot;": '"',
      "&apos;": "'",
      "&gt;": ">",
      "&lt;": "<",
      "&amp;": "&"
    };
    var rencoding = /* @__PURE__ */ evert(encodings);
    var decregex = /[&<>'"]/g;
    var charegex = /[\u0000-\u0008\u000b-\u001f]/g;
    function escapexml(text) {
      var s = text + "";
      return s.replace(decregex, function(y) {
        return rencoding[y];
      }).replace(charegex, function(s2) {
        return "_x" + ("000" + s2.charCodeAt(0).toString(16)).slice(-4) + "_";
      });
    }
    function escapexmltag(text) {
      return escapexml(text).replace(/ /g, "_x0020_");
    }
    var htmlcharegex = /[\u0000-\u001f]/g;
    function escapehtml(text) {
      var s = text + "";
      return s.replace(decregex, function(y) {
        return rencoding[y];
      }).replace(/\n/g, "<br/>").replace(htmlcharegex, function(s2) {
        return "&#x" + ("000" + s2.charCodeAt(0).toString(16)).slice(-4) + ";";
      });
    }
    function escapexlml(text) {
      var s = text + "";
      return s.replace(decregex, function(y) {
        return rencoding[y];
      }).replace(htmlcharegex, function(s2) {
        return "&#x" + s2.charCodeAt(0).toString(16).toUpperCase() + ";";
      });
    }
    function xlml_unfixstr(str) {
      return str.replace(/(\r\n|[\r\n])/g, "&#10;");
    }
    function parsexmlbool(value) {
      switch (value) {
        case 1:
        case true:
        case "1":
        case "true":
        case "TRUE":
          return true;
        default:
          return false;
      }
    }
    function utf8reada(orig) {
      var out = "", i = 0, c = 0, d = 0, e = 0, f = 0, w = 0;
      while (i < orig.length) {
        c = orig.charCodeAt(i++);
        if (c < 128) {
          out += String.fromCharCode(c);
          continue;
        }
        d = orig.charCodeAt(i++);
        if (c > 191 && c < 224) {
          f = (c & 31) << 6;
          f |= d & 63;
          out += String.fromCharCode(f);
          continue;
        }
        e = orig.charCodeAt(i++);
        if (c < 240) {
          out += String.fromCharCode((c & 15) << 12 | (d & 63) << 6 | e & 63);
          continue;
        }
        f = orig.charCodeAt(i++);
        w = ((c & 7) << 18 | (d & 63) << 12 | (e & 63) << 6 | f & 63) - 65536;
        out += String.fromCharCode(55296 + (w >>> 10 & 1023));
        out += String.fromCharCode(56320 + (w & 1023));
      }
      return out;
    }
    function utf8readb(data) {
      var out = new_raw_buf(2 * data.length), w, i, j = 1, k = 0, ww = 0, c;
      for (i = 0; i < data.length; i += j) {
        j = 1;
        if ((c = data.charCodeAt(i)) < 128)
          w = c;
        else if (c < 224) {
          w = (c & 31) * 64 + (data.charCodeAt(i + 1) & 63);
          j = 2;
        } else if (c < 240) {
          w = (c & 15) * 4096 + (data.charCodeAt(i + 1) & 63) * 64 + (data.charCodeAt(i + 2) & 63);
          j = 3;
        } else {
          j = 4;
          w = (c & 7) * 262144 + (data.charCodeAt(i + 1) & 63) * 4096 + (data.charCodeAt(i + 2) & 63) * 64 + (data.charCodeAt(i + 3) & 63);
          w -= 65536;
          ww = 55296 + (w >>> 10 & 1023);
          w = 56320 + (w & 1023);
        }
        if (ww !== 0) {
          out[k++] = ww & 255;
          out[k++] = ww >>> 8;
          ww = 0;
        }
        out[k++] = w % 256;
        out[k++] = w >>> 8;
      }
      return out.slice(0, k).toString("ucs2");
    }
    function utf8readc(data) {
      return Buffer_from(data, "binary").toString("utf8");
    }
    var utf8corpus = "foo bar baz\xE2\x98\x83\xF0\x9F\x8D\xA3";
    var utf8read = has_buf && (/* @__PURE__ */ utf8readc(utf8corpus) == /* @__PURE__ */ utf8reada(utf8corpus) && utf8readc || /* @__PURE__ */ utf8readb(utf8corpus) == /* @__PURE__ */ utf8reada(utf8corpus) && utf8readb) || utf8reada;
    var utf8write = has_buf ? function(data) {
      return Buffer_from(data, "utf8").toString("binary");
    } : function(orig) {
      var out = [], i = 0, c = 0, d = 0;
      while (i < orig.length) {
        c = orig.charCodeAt(i++);
        switch (true) {
          case c < 128:
            out.push(String.fromCharCode(c));
            break;
          case c < 2048:
            out.push(String.fromCharCode(192 + (c >> 6)));
            out.push(String.fromCharCode(128 + (c & 63)));
            break;
          case (c >= 55296 && c < 57344):
            c -= 55296;
            d = orig.charCodeAt(i++) - 56320 + (c << 10);
            out.push(String.fromCharCode(240 + (d >> 18 & 7)));
            out.push(String.fromCharCode(144 + (d >> 12 & 63)));
            out.push(String.fromCharCode(128 + (d >> 6 & 63)));
            out.push(String.fromCharCode(128 + (d & 63)));
            break;
          default:
            out.push(String.fromCharCode(224 + (c >> 12)));
            out.push(String.fromCharCode(128 + (c >> 6 & 63)));
            out.push(String.fromCharCode(128 + (c & 63)));
        }
      }
      return out.join("");
    };
    var htmldecode = /* @__PURE__ */ function() {
      var entities = [
        ["nbsp", " "],
        ["middot", "\xB7"],
        ["quot", '"'],
        ["apos", "'"],
        ["gt", ">"],
        ["lt", "<"],
        ["amp", "&"]
      ].map(function(x) {
        return [new RegExp("&" + x[0] + ";", "ig"), x[1]];
      });
      return function htmldecode2(str) {
        var o = str.replace(/^[\t\n\r ]+/, "").replace(/[\t\n\r ]+$/, "").replace(/>\s+/g, ">").replace(/\s+</g, "<").replace(/[\t\n\r ]+/g, " ").replace(/<\s*[bB][rR]\s*\/?>/g, "\n").replace(/<[^>]*>/g, "");
        for (var i = 0; i < entities.length; ++i)
          o = o.replace(entities[i][0], entities[i][1]);
        return o;
      };
    }();
    var wtregex = /(^\s|\s$|\n)/;
    function writetag(f, g) {
      return "<" + f + (g.match(wtregex) ? ' xml:space="preserve"' : "") + ">" + g + "</" + f + ">";
    }
    function wxt_helper(h) {
      return keys(h).map(function(k) {
        return " " + k + '="' + h[k] + '"';
      }).join("");
    }
    function writextag(f, g, h) {
      return "<" + f + (h != null ? wxt_helper(h) : "") + (g != null ? (g.match(wtregex) ? ' xml:space="preserve"' : "") + ">" + g + "</" + f : "/") + ">";
    }
    function write_w3cdtf(d, t) {
      try {
        return d.toISOString().replace(/\.\d*/, "");
      } catch (e) {
        if (t)
          throw e;
      }
      return "";
    }
    function write_vt(s, xlsx) {
      switch (typeof s) {
        case "string":
          var o = writextag("vt:lpwstr", escapexml(s));
          o = o.replace(/&quot;/g, "_x0022_");
          return o;
        case "number":
          return writextag((s | 0) == s ? "vt:i4" : "vt:r8", escapexml(String(s)));
        case "boolean":
          return writextag("vt:bool", s ? "true" : "false");
      }
      if (s instanceof Date)
        return writextag("vt:filetime", write_w3cdtf(s));
      throw new Error("Unable to serialize " + s);
    }
    var XMLNS = {
      CORE_PROPS: "http://schemas.openxmlformats.org/package/2006/metadata/core-properties",
      CUST_PROPS: "http://schemas.openxmlformats.org/officeDocument/2006/custom-properties",
      EXT_PROPS: "http://schemas.openxmlformats.org/officeDocument/2006/extended-properties",
      CT: "http://schemas.openxmlformats.org/package/2006/content-types",
      RELS: "http://schemas.openxmlformats.org/package/2006/relationships",
      TCMNT: "http://schemas.microsoft.com/office/spreadsheetml/2018/threadedcomments",
      "dc": "http://purl.org/dc/elements/1.1/",
      "dcterms": "http://purl.org/dc/terms/",
      "dcmitype": "http://purl.org/dc/dcmitype/",
      "r": "http://schemas.openxmlformats.org/officeDocument/2006/relationships",
      "vt": "http://schemas.openxmlformats.org/officeDocument/2006/docPropsVTypes",
      "xsi": "http://www.w3.org/2001/XMLSchema-instance",
      "xsd": "http://www.w3.org/2001/XMLSchema"
    };
    var XMLNS_main = [
      "http://schemas.openxmlformats.org/spreadsheetml/2006/main",
      "http://purl.oclc.org/ooxml/spreadsheetml/main",
      "http://schemas.microsoft.com/office/excel/2006/main",
      "http://schemas.microsoft.com/office/excel/2006/2"
    ];
    var XLMLNS = {
      "o": "urn:schemas-microsoft-com:office:office",
      "x": "urn:schemas-microsoft-com:office:excel",
      "ss": "urn:schemas-microsoft-com:office:spreadsheet",
      "dt": "uuid:C2F41010-65B3-11d1-A29F-00AA00C14882",
      "mv": "http://macVmlSchemaUri",
      "v": "urn:schemas-microsoft-com:vml",
      "html": "http://www.w3.org/TR/REC-html40"
    };
    function read_double_le(b, idx) {
      var s = 1 - 2 * (b[idx + 7] >>> 7);
      var e = ((b[idx + 7] & 127) << 4) + (b[idx + 6] >>> 4 & 15);
      var m = b[idx + 6] & 15;
      for (var i = 5; i >= 0; --i)
        m = m * 256 + b[idx + i];
      if (e == 2047)
        return m == 0 ? s * Infinity : NaN;
      if (e == 0)
        e = -1022;
      else {
        e -= 1023;
        m += Math.pow(2, 52);
      }
      return s * Math.pow(2, e - 52) * m;
    }
    function write_double_le(b, v, idx) {
      var bs = (v < 0 || 1 / v == -Infinity ? 1 : 0) << 7, e = 0, m = 0;
      var av = bs ? -v : v;
      if (!isFinite(av)) {
        e = 2047;
        m = isNaN(v) ? 26985 : 0;
      } else if (av == 0)
        e = m = 0;
      else {
        e = Math.floor(Math.log(av) / Math.LN2);
        m = av * Math.pow(2, 52 - e);
        if (e <= -1023 && (!isFinite(m) || m < Math.pow(2, 52))) {
          e = -1022;
        } else {
          m -= Math.pow(2, 52);
          e += 1023;
        }
      }
      for (var i = 0; i <= 5; ++i, m /= 256)
        b[idx + i] = m & 255;
      b[idx + 6] = (e & 15) << 4 | m & 15;
      b[idx + 7] = e >> 4 | bs;
    }
    var ___toBuffer = function(bufs) {
      var x = [], w = 10240;
      for (var i = 0; i < bufs[0].length; ++i)
        if (bufs[0][i])
          for (var j = 0, L = bufs[0][i].length; j < L; j += w)
            x.push.apply(x, bufs[0][i].slice(j, j + w));
      return x;
    };
    var __toBuffer = has_buf ? function(bufs) {
      return bufs[0].length > 0 && Buffer.isBuffer(bufs[0][0]) ? Buffer.concat(bufs[0].map(function(x) {
        return Buffer.isBuffer(x) ? x : Buffer_from(x);
      })) : ___toBuffer(bufs);
    } : ___toBuffer;
    var ___utf16le = function(b, s, e) {
      var ss = [];
      for (var i = s; i < e; i += 2)
        ss.push(String.fromCharCode(__readUInt16LE(b, i)));
      return ss.join("").replace(chr0, "");
    };
    var __utf16le = has_buf ? function(b, s, e) {
      if (!Buffer.isBuffer(b))
        return ___utf16le(b, s, e);
      return b.toString("utf16le", s, e).replace(chr0, "");
    } : ___utf16le;
    var ___hexlify = function(b, s, l2) {
      var ss = [];
      for (var i = s; i < s + l2; ++i)
        ss.push(("0" + b[i].toString(16)).slice(-2));
      return ss.join("");
    };
    var __hexlify = has_buf ? function(b, s, l2) {
      return Buffer.isBuffer(b) ? b.toString("hex", s, s + l2) : ___hexlify(b, s, l2);
    } : ___hexlify;
    var ___utf8 = function(b, s, e) {
      var ss = [];
      for (var i = s; i < e; i++)
        ss.push(String.fromCharCode(__readUInt8(b, i)));
      return ss.join("");
    };
    var __utf8 = has_buf ? function utf8_b(b, s, e) {
      return Buffer.isBuffer(b) ? b.toString("utf8", s, e) : ___utf8(b, s, e);
    } : ___utf8;
    var ___lpstr = function(b, i) {
      var len = __readUInt32LE(b, i);
      return len > 0 ? __utf8(b, i + 4, i + 4 + len - 1) : "";
    };
    var __lpstr = ___lpstr;
    var ___cpstr = function(b, i) {
      var len = __readUInt32LE(b, i);
      return len > 0 ? __utf8(b, i + 4, i + 4 + len - 1) : "";
    };
    var __cpstr = ___cpstr;
    var ___lpwstr = function(b, i) {
      var len = 2 * __readUInt32LE(b, i);
      return len > 0 ? __utf8(b, i + 4, i + 4 + len - 1) : "";
    };
    var __lpwstr = ___lpwstr;
    var ___lpp4 = function lpp4_(b, i) {
      var len = __readUInt32LE(b, i);
      return len > 0 ? __utf16le(b, i + 4, i + 4 + len) : "";
    };
    var __lpp4 = ___lpp4;
    var ___8lpp4 = function(b, i) {
      var len = __readUInt32LE(b, i);
      return len > 0 ? __utf8(b, i + 4, i + 4 + len) : "";
    };
    var __8lpp4 = ___8lpp4;
    var ___double = function(b, idx) {
      return read_double_le(b, idx);
    };
    var __double = ___double;
    var is_buf = function is_buf_a(a) {
      return Array.isArray(a) || typeof Uint8Array !== "undefined" && a instanceof Uint8Array;
    };
    if (has_buf) {
      __lpstr = function lpstr_b(b, i) {
        if (!Buffer.isBuffer(b))
          return ___lpstr(b, i);
        var len = b.readUInt32LE(i);
        return len > 0 ? b.toString("utf8", i + 4, i + 4 + len - 1) : "";
      };
      __cpstr = function cpstr_b(b, i) {
        if (!Buffer.isBuffer(b))
          return ___cpstr(b, i);
        var len = b.readUInt32LE(i);
        return len > 0 ? b.toString("utf8", i + 4, i + 4 + len - 1) : "";
      };
      __lpwstr = function lpwstr_b(b, i) {
        if (!Buffer.isBuffer(b))
          return ___lpwstr(b, i);
        var len = 2 * b.readUInt32LE(i);
        return b.toString("utf16le", i + 4, i + 4 + len - 1);
      };
      __lpp4 = function lpp4_b(b, i) {
        if (!Buffer.isBuffer(b))
          return ___lpp4(b, i);
        var len = b.readUInt32LE(i);
        return b.toString("utf16le", i + 4, i + 4 + len);
      };
      __8lpp4 = function lpp4_8b(b, i) {
        if (!Buffer.isBuffer(b))
          return ___8lpp4(b, i);
        var len = b.readUInt32LE(i);
        return b.toString("utf8", i + 4, i + 4 + len);
      };
      __double = function double_(b, i) {
        if (Buffer.isBuffer(b))
          return b.readDoubleLE(i);
        return ___double(b, i);
      };
      is_buf = function is_buf_b(a) {
        return Buffer.isBuffer(a) || Array.isArray(a) || typeof Uint8Array !== "undefined" && a instanceof Uint8Array;
      };
    }
    var __readUInt8 = function(b, idx) {
      return b[idx];
    };
    var __readUInt16LE = function(b, idx) {
      return b[idx + 1] * (1 << 8) + b[idx];
    };
    var __readInt16LE = function(b, idx) {
      var u = b[idx + 1] * (1 << 8) + b[idx];
      return u < 32768 ? u : (65535 - u + 1) * -1;
    };
    var __readUInt32LE = function(b, idx) {
      return b[idx + 3] * (1 << 24) + (b[idx + 2] << 16) + (b[idx + 1] << 8) + b[idx];
    };
    var __readInt32LE = function(b, idx) {
      return b[idx + 3] << 24 | b[idx + 2] << 16 | b[idx + 1] << 8 | b[idx];
    };
    var __readInt32BE = function(b, idx) {
      return b[idx] << 24 | b[idx + 1] << 16 | b[idx + 2] << 8 | b[idx + 3];
    };
    function ReadShift(size, t) {
      var o = "", oI, oR, oo = [], w, vv, i, loc;
      switch (t) {
        case "dbcs":
          loc = this.l;
          if (has_buf && Buffer.isBuffer(this))
            o = this.slice(this.l, this.l + 2 * size).toString("utf16le");
          else
            for (i = 0; i < size; ++i) {
              o += String.fromCharCode(__readUInt16LE(this, loc));
              loc += 2;
            }
          size *= 2;
          break;
        case "utf8":
          o = __utf8(this, this.l, this.l + size);
          break;
        case "utf16le":
          size *= 2;
          o = __utf16le(this, this.l, this.l + size);
          break;
        case "wstr":
          return ReadShift.call(this, size, "dbcs");
        case "lpstr-ansi":
          o = __lpstr(this, this.l);
          size = 4 + __readUInt32LE(this, this.l);
          break;
        case "lpstr-cp":
          o = __cpstr(this, this.l);
          size = 4 + __readUInt32LE(this, this.l);
          break;
        case "lpwstr":
          o = __lpwstr(this, this.l);
          size = 4 + 2 * __readUInt32LE(this, this.l);
          break;
        case "lpp4":
          size = 4 + __readUInt32LE(this, this.l);
          o = __lpp4(this, this.l);
          if (size & 2)
            size += 2;
          break;
        case "8lpp4":
          size = 4 + __readUInt32LE(this, this.l);
          o = __8lpp4(this, this.l);
          if (size & 3)
            size += 4 - (size & 3);
          break;
        case "cstr":
          size = 0;
          o = "";
          while ((w = __readUInt8(this, this.l + size++)) !== 0)
            oo.push(_getchar(w));
          o = oo.join("");
          break;
        case "_wstr":
          size = 0;
          o = "";
          while ((w = __readUInt16LE(this, this.l + size)) !== 0) {
            oo.push(_getchar(w));
            size += 2;
          }
          size += 2;
          o = oo.join("");
          break;
        case "dbcs-cont":
          o = "";
          loc = this.l;
          for (i = 0; i < size; ++i) {
            if (this.lens && this.lens.indexOf(loc) !== -1) {
              w = __readUInt8(this, loc);
              this.l = loc + 1;
              vv = ReadShift.call(this, size - i, w ? "dbcs-cont" : "sbcs-cont");
              return oo.join("") + vv;
            }
            oo.push(_getchar(__readUInt16LE(this, loc)));
            loc += 2;
          }
          o = oo.join("");
          size *= 2;
          break;
        case "cpstr":
        case "sbcs-cont":
          o = "";
          loc = this.l;
          for (i = 0; i != size; ++i) {
            if (this.lens && this.lens.indexOf(loc) !== -1) {
              w = __readUInt8(this, loc);
              this.l = loc + 1;
              vv = ReadShift.call(this, size - i, w ? "dbcs-cont" : "sbcs-cont");
              return oo.join("") + vv;
            }
            oo.push(_getchar(__readUInt8(this, loc)));
            loc += 1;
          }
          o = oo.join("");
          break;
        default:
          switch (size) {
            case 1:
              oI = __readUInt8(this, this.l);
              this.l++;
              return oI;
            case 2:
              oI = (t === "i" ? __readInt16LE : __readUInt16LE)(this, this.l);
              this.l += 2;
              return oI;
            case 4:
            case -4:
              if (t === "i" || (this[this.l + 3] & 128) === 0) {
                oI = (size > 0 ? __readInt32LE : __readInt32BE)(this, this.l);
                this.l += 4;
                return oI;
              } else {
                oR = __readUInt32LE(this, this.l);
                this.l += 4;
              }
              return oR;
            case 8:
            case -8:
              if (t === "f") {
                if (size == 8)
                  oR = __double(this, this.l);
                else
                  oR = __double([this[this.l + 7], this[this.l + 6], this[this.l + 5], this[this.l + 4], this[this.l + 3], this[this.l + 2], this[this.l + 1], this[this.l + 0]], 0);
                this.l += 8;
                return oR;
              } else
                size = 8;
            case 16:
              o = __hexlify(this, this.l, size);
              break;
          }
      }
      this.l += size;
      return o;
    }
    var __writeUInt32LE = function(b, val, idx) {
      b[idx] = val & 255;
      b[idx + 1] = val >>> 8 & 255;
      b[idx + 2] = val >>> 16 & 255;
      b[idx + 3] = val >>> 24 & 255;
    };
    var __writeInt32LE = function(b, val, idx) {
      b[idx] = val & 255;
      b[idx + 1] = val >> 8 & 255;
      b[idx + 2] = val >> 16 & 255;
      b[idx + 3] = val >> 24 & 255;
    };
    var __writeUInt16LE = function(b, val, idx) {
      b[idx] = val & 255;
      b[idx + 1] = val >>> 8 & 255;
    };
    function WriteShift(t, val, f) {
      var size = 0, i = 0;
      if (f === "dbcs") {
        for (i = 0; i != val.length; ++i)
          __writeUInt16LE(this, val.charCodeAt(i), this.l + 2 * i);
        size = 2 * val.length;
      } else if (f === "sbcs") {
        {
          val = val.replace(/[^\x00-\x7F]/g, "_");
          for (i = 0; i != val.length; ++i)
            this[this.l + i] = val.charCodeAt(i) & 255;
        }
        size = val.length;
      } else if (f === "hex") {
        for (; i < t; ++i) {
          this[this.l++] = parseInt(val.slice(2 * i, 2 * i + 2), 16) || 0;
        }
        return this;
      } else if (f === "utf16le") {
        var end = Math.min(this.l + t, this.length);
        for (i = 0; i < Math.min(val.length, t); ++i) {
          var cc = val.charCodeAt(i);
          this[this.l++] = cc & 255;
          this[this.l++] = cc >> 8;
        }
        while (this.l < end)
          this[this.l++] = 0;
        return this;
      } else
        switch (t) {
          case 1:
            size = 1;
            this[this.l] = val & 255;
            break;
          case 2:
            size = 2;
            this[this.l] = val & 255;
            val >>>= 8;
            this[this.l + 1] = val & 255;
            break;
          case 3:
            size = 3;
            this[this.l] = val & 255;
            val >>>= 8;
            this[this.l + 1] = val & 255;
            val >>>= 8;
            this[this.l + 2] = val & 255;
            break;
          case 4:
            size = 4;
            __writeUInt32LE(this, val, this.l);
            break;
          case 8:
            size = 8;
            if (f === "f") {
              write_double_le(this, val, this.l);
              break;
            }
          case 16:
            break;
          case -4:
            size = 4;
            __writeInt32LE(this, val, this.l);
            break;
        }
      this.l += size;
      return this;
    }
    function CheckField(hexstr, fld) {
      var m = __hexlify(this, this.l, hexstr.length >> 1);
      if (m !== hexstr)
        throw new Error(fld + "Expected " + hexstr + " saw " + m);
      this.l += hexstr.length >> 1;
    }
    function prep_blob(blob, pos) {
      blob.l = pos;
      blob.read_shift = /*::(*/
      ReadShift;
      blob.chk = CheckField;
      blob.write_shift = WriteShift;
    }
    function parsenoop(blob, length) {
      blob.l += length;
    }
    function new_buf(sz) {
      var o = new_raw_buf(sz);
      prep_blob(o, 0);
      return o;
    }
    function buf_array() {
      var bufs = [], blksz = has_buf ? 256 : 2048;
      var newblk = function ba_newblk(sz) {
        var o = new_buf(sz);
        prep_blob(o, 0);
        return o;
      };
      var curbuf = newblk(blksz);
      var endbuf = function ba_endbuf() {
        if (!curbuf)
          return;
        if (curbuf.length > curbuf.l) {
          curbuf = curbuf.slice(0, curbuf.l);
          curbuf.l = curbuf.length;
        }
        if (curbuf.length > 0)
          bufs.push(curbuf);
        curbuf = null;
      };
      var next = function ba_next(sz) {
        if (curbuf && sz < curbuf.length - curbuf.l)
          return curbuf;
        endbuf();
        return curbuf = newblk(Math.max(sz + 1, blksz));
      };
      var end = function ba_end() {
        endbuf();
        return bconcat(bufs);
      };
      var push = function ba_push(buf) {
        endbuf();
        curbuf = buf;
        if (curbuf.l == null)
          curbuf.l = curbuf.length;
        next(blksz);
      };
      return { next, push, end, _bufs: bufs };
    }
    function write_record(ba, type, payload, length) {
      var t = +type, l2;
      if (isNaN(t))
        return;
      if (!length)
        length = XLSBRecordEnum[t].p || (payload || []).length || 0;
      l2 = 1 + (t >= 128 ? 1 : 0) + 1;
      if (length >= 128)
        ++l2;
      if (length >= 16384)
        ++l2;
      if (length >= 2097152)
        ++l2;
      var o = ba.next(l2);
      if (t <= 127)
        o.write_shift(1, t);
      else {
        o.write_shift(1, (t & 127) + 128);
        o.write_shift(1, t >> 7);
      }
      for (var i = 0; i != 4; ++i) {
        if (length >= 128) {
          o.write_shift(1, (length & 127) + 128);
          length >>= 7;
        } else {
          o.write_shift(1, length);
          break;
        }
      }
      if (
        /*:: length != null &&*/
        length > 0 && is_buf(payload)
      )
        ba.push(payload);
    }
    function shift_cell_xls(cell, tgt, opts) {
      var out = dup(cell);
      if (tgt.s) {
        if (out.cRel)
          out.c += tgt.s.c;
        if (out.rRel)
          out.r += tgt.s.r;
      } else {
        if (out.cRel)
          out.c += tgt.c;
        if (out.rRel)
          out.r += tgt.r;
      }
      if (!opts || opts.biff < 12) {
        while (out.c >= 256)
          out.c -= 256;
        while (out.r >= 65536)
          out.r -= 65536;
      }
      return out;
    }
    function shift_range_xls(cell, range, opts) {
      var out = dup(cell);
      out.s = shift_cell_xls(out.s, range.s, opts);
      out.e = shift_cell_xls(out.e, range.s, opts);
      return out;
    }
    function encode_cell_xls(c, biff) {
      if (c.cRel && c.c < 0) {
        c = dup(c);
        while (c.c < 0)
          c.c += biff > 8 ? 16384 : 256;
      }
      if (c.rRel && c.r < 0) {
        c = dup(c);
        while (c.r < 0)
          c.r += biff > 8 ? 1048576 : biff > 5 ? 65536 : 16384;
      }
      var s = encode_cell(c);
      if (!c.cRel && c.cRel != null)
        s = fix_col(s);
      if (!c.rRel && c.rRel != null)
        s = fix_row(s);
      return s;
    }
    function encode_range_xls(r, opts) {
      if (r.s.r == 0 && !r.s.rRel) {
        if (r.e.r == (opts.biff >= 12 ? 1048575 : opts.biff >= 8 ? 65536 : 16384) && !r.e.rRel) {
          return (r.s.cRel ? "" : "$") + encode_col(r.s.c) + ":" + (r.e.cRel ? "" : "$") + encode_col(r.e.c);
        }
      }
      if (r.s.c == 0 && !r.s.cRel) {
        if (r.e.c == (opts.biff >= 12 ? 16383 : 255) && !r.e.cRel) {
          return (r.s.rRel ? "" : "$") + encode_row(r.s.r) + ":" + (r.e.rRel ? "" : "$") + encode_row(r.e.r);
        }
      }
      return encode_cell_xls(r.s, opts.biff) + ":" + encode_cell_xls(r.e, opts.biff);
    }
    function decode_row(rowstr) {
      return parseInt(unfix_row(rowstr), 10) - 1;
    }
    function encode_row(row) {
      return "" + (row + 1);
    }
    function fix_row(cstr) {
      return cstr.replace(/([A-Z]|^)(\d+)$/, "$1$$$2");
    }
    function unfix_row(cstr) {
      return cstr.replace(/\$(\d+)$/, "$1");
    }
    function decode_col(colstr) {
      var c = unfix_col(colstr), d = 0, i = 0;
      for (; i !== c.length; ++i)
        d = 26 * d + c.charCodeAt(i) - 64;
      return d - 1;
    }
    function encode_col(col) {
      if (col < 0)
        throw new Error("invalid column " + col);
      var s = "";
      for (++col; col; col = Math.floor((col - 1) / 26))
        s = String.fromCharCode((col - 1) % 26 + 65) + s;
      return s;
    }
    function fix_col(cstr) {
      return cstr.replace(/^([A-Z])/, "$$$1");
    }
    function unfix_col(cstr) {
      return cstr.replace(/^\$([A-Z])/, "$1");
    }
    function split_cell(cstr) {
      return cstr.replace(/(\$?[A-Z]*)(\$?\d*)/, "$1,$2").split(",");
    }
    function decode_cell(cstr) {
      var R = 0, C = 0;
      for (var i = 0; i < cstr.length; ++i) {
        var cc = cstr.charCodeAt(i);
        if (cc >= 48 && cc <= 57)
          R = 10 * R + (cc - 48);
        else if (cc >= 65 && cc <= 90)
          C = 26 * C + (cc - 64);
      }
      return { c: C - 1, r: R - 1 };
    }
    function encode_cell(cell) {
      var col = cell.c + 1;
      var s = "";
      for (; col; col = (col - 1) / 26 | 0)
        s = String.fromCharCode((col - 1) % 26 + 65) + s;
      return s + (cell.r + 1);
    }
    function decode_range(range) {
      var idx = range.indexOf(":");
      if (idx == -1)
        return { s: decode_cell(range), e: decode_cell(range) };
      return { s: decode_cell(range.slice(0, idx)), e: decode_cell(range.slice(idx + 1)) };
    }
    function encode_range(cs, ce) {
      if (typeof ce === "undefined" || typeof ce === "number") {
        return encode_range(cs.s, cs.e);
      }
      if (typeof cs !== "string")
        cs = encode_cell(cs);
      if (typeof ce !== "string")
        ce = encode_cell(ce);
      return cs == ce ? cs : cs + ":" + ce;
    }
    function safe_decode_range(range) {
      var o = { s: { c: 0, r: 0 }, e: { c: 0, r: 0 } };
      var idx = 0, i = 0, cc = 0;
      var len = range.length;
      for (idx = 0; i < len; ++i) {
        if ((cc = range.charCodeAt(i) - 64) < 1 || cc > 26)
          break;
        idx = 26 * idx + cc;
      }
      o.s.c = --idx;
      for (idx = 0; i < len; ++i) {
        if ((cc = range.charCodeAt(i) - 48) < 0 || cc > 9)
          break;
        idx = 10 * idx + cc;
      }
      o.s.r = --idx;
      if (i === len || cc != 10) {
        o.e.c = o.s.c;
        o.e.r = o.s.r;
        return o;
      }
      ++i;
      for (idx = 0; i != len; ++i) {
        if ((cc = range.charCodeAt(i) - 64) < 1 || cc > 26)
          break;
        idx = 26 * idx + cc;
      }
      o.e.c = --idx;
      for (idx = 0; i != len; ++i) {
        if ((cc = range.charCodeAt(i) - 48) < 0 || cc > 9)
          break;
        idx = 10 * idx + cc;
      }
      o.e.r = --idx;
      return o;
    }
    function safe_format_cell(cell, v) {
      var q = cell.t == "d" && v instanceof Date;
      if (cell.z != null)
        try {
          return cell.w = SSF_format(cell.z, q ? datenum(v) : v);
        } catch (e) {
        }
      try {
        return cell.w = SSF_format((cell.XF || {}).numFmtId || (q ? 14 : 0), q ? datenum(v) : v);
      } catch (e) {
        return "" + v;
      }
    }
    function format_cell(cell, v, o) {
      if (cell == null || cell.t == null || cell.t == "z")
        return "";
      if (cell.w !== void 0)
        return cell.w;
      if (cell.t == "d" && !cell.z && o && o.dateNF)
        cell.z = o.dateNF;
      if (cell.t == "e")
        return BErr[cell.v] || cell.v;
      if (v == void 0)
        return safe_format_cell(cell, cell.v);
      return safe_format_cell(cell, v);
    }
    function sheet_to_workbook(sheet, opts) {
      var n = opts && opts.sheet ? opts.sheet : "Sheet1";
      var sheets = {};
      sheets[n] = sheet;
      return { SheetNames: [n], Sheets: sheets };
    }
    function sheet_add_aoa(_ws, data, opts) {
      var o = opts || {};
      var dense = _ws ? Array.isArray(_ws) : o.dense;
      var ws = _ws || (dense ? [] : {});
      var _R = 0, _C = 0;
      if (ws && o.origin != null) {
        if (typeof o.origin == "number")
          _R = o.origin;
        else {
          var _origin = typeof o.origin == "string" ? decode_cell(o.origin) : o.origin;
          _R = _origin.r;
          _C = _origin.c;
        }
        if (!ws["!ref"])
          ws["!ref"] = "A1:A1";
      }
      var range = { s: { c: 1e7, r: 1e7 }, e: { c: 0, r: 0 } };
      if (ws["!ref"]) {
        var _range = safe_decode_range(ws["!ref"]);
        range.s.c = _range.s.c;
        range.s.r = _range.s.r;
        range.e.c = Math.max(range.e.c, _range.e.c);
        range.e.r = Math.max(range.e.r, _range.e.r);
        if (_R == -1)
          range.e.r = _R = _range.e.r + 1;
      }
      for (var R = 0; R != data.length; ++R) {
        if (!data[R])
          continue;
        if (!Array.isArray(data[R]))
          throw new Error("aoa_to_sheet expects an array of arrays");
        for (var C = 0; C != data[R].length; ++C) {
          if (typeof data[R][C] === "undefined")
            continue;
          var cell = { v: data[R][C] };
          var __R = _R + R, __C = _C + C;
          if (range.s.r > __R)
            range.s.r = __R;
          if (range.s.c > __C)
            range.s.c = __C;
          if (range.e.r < __R)
            range.e.r = __R;
          if (range.e.c < __C)
            range.e.c = __C;
          if (data[R][C] && typeof data[R][C] === "object" && !Array.isArray(data[R][C]) && !(data[R][C] instanceof Date))
            cell = data[R][C];
          else {
            if (Array.isArray(cell.v)) {
              cell.f = data[R][C][1];
              cell.v = cell.v[0];
            }
            if (cell.v === null) {
              if (cell.f)
                cell.t = "n";
              else if (o.nullError) {
                cell.t = "e";
                cell.v = 0;
              } else if (!o.sheetStubs)
                continue;
              else
                cell.t = "z";
            } else if (typeof cell.v === "number")
              cell.t = "n";
            else if (typeof cell.v === "boolean")
              cell.t = "b";
            else if (cell.v instanceof Date) {
              cell.z = o.dateNF || table_fmt[14];
              if (o.cellDates) {
                cell.t = "d";
                cell.w = SSF_format(cell.z, datenum(cell.v));
              } else {
                cell.t = "n";
                cell.v = datenum(cell.v);
                cell.w = SSF_format(cell.z, cell.v);
              }
            } else
              cell.t = "s";
          }
          if (dense) {
            if (!ws[__R])
              ws[__R] = [];
            if (ws[__R][__C] && ws[__R][__C].z)
              cell.z = ws[__R][__C].z;
            ws[__R][__C] = cell;
          } else {
            var cell_ref = encode_cell({ c: __C, r: __R });
            if (ws[cell_ref] && ws[cell_ref].z)
              cell.z = ws[cell_ref].z;
            ws[cell_ref] = cell;
          }
        }
      }
      if (range.s.c < 1e7)
        ws["!ref"] = encode_range(range);
      return ws;
    }
    function aoa_to_sheet(data, opts) {
      return sheet_add_aoa(null, data, opts);
    }
    function parse_Int32LE(data) {
      return data.read_shift(4, "i");
    }
    function write_UInt32LE(x, o) {
      if (!o)
        o = new_buf(4);
      o.write_shift(4, x);
      return o;
    }
    function parse_XLWideString(data) {
      var cchCharacters = data.read_shift(4);
      return cchCharacters === 0 ? "" : data.read_shift(cchCharacters, "dbcs");
    }
    function write_XLWideString(data, o) {
      var _null = false;
      if (o == null) {
        _null = true;
        o = new_buf(4 + 2 * data.length);
      }
      o.write_shift(4, data.length);
      if (data.length > 0)
        o.write_shift(0, data, "dbcs");
      return _null ? o.slice(0, o.l) : o;
    }
    function parse_StrRun(data) {
      return { ich: data.read_shift(2), ifnt: data.read_shift(2) };
    }
    function write_StrRun(run, o) {
      if (!o)
        o = new_buf(4);
      o.write_shift(2, 0);
      o.write_shift(2, 0);
      return o;
    }
    function parse_RichStr(data, length) {
      var start = data.l;
      var flags = data.read_shift(1);
      var str = parse_XLWideString(data);
      var rgsStrRun = [];
      var z = { t: str, h: str };
      if ((flags & 1) !== 0) {
        var dwSizeStrRun = data.read_shift(4);
        for (var i = 0; i != dwSizeStrRun; ++i)
          rgsStrRun.push(parse_StrRun(data));
        z.r = rgsStrRun;
      } else
        z.r = [{ ich: 0, ifnt: 0 }];
      data.l = start + length;
      return z;
    }
    function write_RichStr(str, o) {
      var _null = false;
      if (o == null) {
        _null = true;
        o = new_buf(15 + 4 * str.t.length);
      }
      o.write_shift(1, 0);
      write_XLWideString(str.t, o);
      return _null ? o.slice(0, o.l) : o;
    }
    var parse_BrtCommentText = parse_RichStr;
    function write_BrtCommentText(str, o) {
      var _null = false;
      if (o == null) {
        _null = true;
        o = new_buf(23 + 4 * str.t.length);
      }
      o.write_shift(1, 1);
      write_XLWideString(str.t, o);
      o.write_shift(4, 1);
      write_StrRun({}, o);
      return _null ? o.slice(0, o.l) : o;
    }
    function parse_XLSBCell(data) {
      var col = data.read_shift(4);
      var iStyleRef = data.read_shift(2);
      iStyleRef += data.read_shift(1) << 16;
      data.l++;
      return { c: col, iStyleRef };
    }
    function write_XLSBCell(cell, o) {
      if (o == null)
        o = new_buf(8);
      o.write_shift(-4, cell.c);
      o.write_shift(3, cell.iStyleRef || cell.s);
      o.write_shift(1, 0);
      return o;
    }
    function parse_XLSBShortCell(data) {
      var iStyleRef = data.read_shift(2);
      iStyleRef += data.read_shift(1) << 16;
      data.l++;
      return { c: -1, iStyleRef };
    }
    function write_XLSBShortCell(cell, o) {
      if (o == null)
        o = new_buf(4);
      o.write_shift(3, cell.iStyleRef || cell.s);
      o.write_shift(1, 0);
      return o;
    }
    var parse_XLSBCodeName = parse_XLWideString;
    var write_XLSBCodeName = write_XLWideString;
    function parse_XLNullableWideString(data) {
      var cchCharacters = data.read_shift(4);
      return cchCharacters === 0 || cchCharacters === 4294967295 ? "" : data.read_shift(cchCharacters, "dbcs");
    }
    function write_XLNullableWideString(data, o) {
      var _null = false;
      if (o == null) {
        _null = true;
        o = new_buf(127);
      }
      o.write_shift(4, data.length > 0 ? data.length : 4294967295);
      if (data.length > 0)
        o.write_shift(0, data, "dbcs");
      return _null ? o.slice(0, o.l) : o;
    }
    var parse_XLNameWideString = parse_XLWideString;
    var parse_RelID = parse_XLNullableWideString;
    var write_RelID = write_XLNullableWideString;
    function parse_RkNumber(data) {
      var b = data.slice(data.l, data.l + 4);
      var fX100 = b[0] & 1, fInt = b[0] & 2;
      data.l += 4;
      var RK = fInt === 0 ? __double([0, 0, 0, 0, b[0] & 252, b[1], b[2], b[3]], 0) : __readInt32LE(b, 0) >> 2;
      return fX100 ? RK / 100 : RK;
    }
    function write_RkNumber(data, o) {
      if (o == null)
        o = new_buf(4);
      var fX100 = 0, fInt = 0, d100 = data * 100;
      if (data == (data | 0) && data >= -536870912 && data < 1 << 29) {
        fInt = 1;
      } else if (d100 == (d100 | 0) && d100 >= -536870912 && d100 < 1 << 29) {
        fInt = 1;
        fX100 = 1;
      }
      if (fInt)
        o.write_shift(-4, ((fX100 ? d100 : data) << 2) + (fX100 + 2));
      else
        throw new Error("unsupported RkNumber " + data);
    }
    function parse_RfX(data) {
      var cell = { s: {}, e: {} };
      cell.s.r = data.read_shift(4);
      cell.e.r = data.read_shift(4);
      cell.s.c = data.read_shift(4);
      cell.e.c = data.read_shift(4);
      return cell;
    }
    function write_RfX(r, o) {
      if (!o)
        o = new_buf(16);
      o.write_shift(4, r.s.r);
      o.write_shift(4, r.e.r);
      o.write_shift(4, r.s.c);
      o.write_shift(4, r.e.c);
      return o;
    }
    var parse_UncheckedRfX = parse_RfX;
    var write_UncheckedRfX = write_RfX;
    function parse_Xnum(data) {
      if (data.length - data.l < 8)
        throw "XLS Xnum Buffer underflow";
      return data.read_shift(8, "f");
    }
    function write_Xnum(data, o) {
      return (o || new_buf(8)).write_shift(8, data, "f");
    }
    function parse_BrtColor(data) {
      var out = {};
      var d = data.read_shift(1);
      var xColorType = d >>> 1;
      var index = data.read_shift(1);
      var nTS = data.read_shift(2, "i");
      var bR = data.read_shift(1);
      var bG = data.read_shift(1);
      var bB = data.read_shift(1);
      data.l++;
      switch (xColorType) {
        case 0:
          out.auto = 1;
          break;
        case 1:
          out.index = index;
          var icv = XLSIcv[index];
          if (icv)
            out.rgb = rgb2Hex(icv);
          break;
        case 2:
          out.rgb = rgb2Hex([bR, bG, bB]);
          break;
        case 3:
          out.theme = index;
          break;
      }
      if (nTS != 0)
        out.tint = nTS > 0 ? nTS / 32767 : nTS / 32768;
      return out;
    }
    function write_BrtColor(color, o) {
      if (!o)
        o = new_buf(8);
      if (!color || color.auto) {
        o.write_shift(4, 0);
        o.write_shift(4, 0);
        return o;
      }
      if (color.index != null) {
        o.write_shift(1, 2);
        o.write_shift(1, color.index);
      } else if (color.theme != null) {
        o.write_shift(1, 6);
        o.write_shift(1, color.theme);
      } else {
        o.write_shift(1, 5);
        o.write_shift(1, 0);
      }
      var nTS = color.tint || 0;
      if (nTS > 0)
        nTS *= 32767;
      else if (nTS < 0)
        nTS *= 32768;
      o.write_shift(2, nTS);
      if (!color.rgb || color.theme != null) {
        o.write_shift(2, 0);
        o.write_shift(1, 0);
        o.write_shift(1, 0);
      } else {
        var rgb = color.rgb || "FFFFFF";
        if (typeof rgb == "number")
          rgb = ("000000" + rgb.toString(16)).slice(-6);
        o.write_shift(1, parseInt(rgb.slice(0, 2), 16));
        o.write_shift(1, parseInt(rgb.slice(2, 4), 16));
        o.write_shift(1, parseInt(rgb.slice(4, 6), 16));
        o.write_shift(1, 255);
      }
      return o;
    }
    function parse_FontFlags(data) {
      var d = data.read_shift(1);
      data.l++;
      var out = {
        fBold: d & 1,
        fItalic: d & 2,
        fUnderline: d & 4,
        fStrikeout: d & 8,
        fOutline: d & 16,
        fShadow: d & 32,
        fCondense: d & 64,
        fExtend: d & 128
      };
      return out;
    }
    function write_FontFlags(font, o) {
      if (!o)
        o = new_buf(2);
      var grbit = (font.italic ? 2 : 0) | (font.strike ? 8 : 0) | (font.outline ? 16 : 0) | (font.shadow ? 32 : 0) | (font.condense ? 64 : 0) | (font.extend ? 128 : 0);
      o.write_shift(1, grbit);
      o.write_shift(1, 0);
      return o;
    }
    var VT_I2 = 2;
    var VT_I4 = 3;
    var VT_BOOL = 11;
    var VT_UI4 = 19;
    var VT_FILETIME = 64;
    var VT_BLOB = 65;
    var VT_CF = 71;
    var VT_VECTOR_VARIANT = 4108;
    var VT_VECTOR_LPSTR = 4126;
    var VT_STRING = 80;
    var DocSummaryPIDDSI = {
      /*::[*/
      1: { n: "CodePage", t: VT_I2 },
      /*::[*/
      2: { n: "Category", t: VT_STRING },
      /*::[*/
      3: { n: "PresentationFormat", t: VT_STRING },
      /*::[*/
      4: { n: "ByteCount", t: VT_I4 },
      /*::[*/
      5: { n: "LineCount", t: VT_I4 },
      /*::[*/
      6: { n: "ParagraphCount", t: VT_I4 },
      /*::[*/
      7: { n: "SlideCount", t: VT_I4 },
      /*::[*/
      8: { n: "NoteCount", t: VT_I4 },
      /*::[*/
      9: { n: "HiddenCount", t: VT_I4 },
      /*::[*/
      10: { n: "MultimediaClipCount", t: VT_I4 },
      /*::[*/
      11: { n: "ScaleCrop", t: VT_BOOL },
      /*::[*/
      12: {
        n: "HeadingPairs",
        t: VT_VECTOR_VARIANT
        /* VT_VECTOR | VT_VARIANT */
      },
      /*::[*/
      13: {
        n: "TitlesOfParts",
        t: VT_VECTOR_LPSTR
        /* VT_VECTOR | VT_LPSTR */
      },
      /*::[*/
      14: { n: "Manager", t: VT_STRING },
      /*::[*/
      15: { n: "Company", t: VT_STRING },
      /*::[*/
      16: { n: "LinksUpToDate", t: VT_BOOL },
      /*::[*/
      17: { n: "CharacterCount", t: VT_I4 },
      /*::[*/
      19: { n: "SharedDoc", t: VT_BOOL },
      /*::[*/
      22: { n: "HyperlinksChanged", t: VT_BOOL },
      /*::[*/
      23: { n: "AppVersion", t: VT_I4, p: "version" },
      /*::[*/
      24: { n: "DigSig", t: VT_BLOB },
      /*::[*/
      26: { n: "ContentType", t: VT_STRING },
      /*::[*/
      27: { n: "ContentStatus", t: VT_STRING },
      /*::[*/
      28: { n: "Language", t: VT_STRING },
      /*::[*/
      29: { n: "Version", t: VT_STRING },
      /*::[*/
      255: {},
      /* [MS-OLEPS] 2.18 */
      /*::[*/
      2147483648: { n: "Locale", t: VT_UI4 },
      /*::[*/
      2147483651: { n: "Behavior", t: VT_UI4 },
      /*::[*/
      1919054434: {}
    };
    var SummaryPIDSI = {
      /*::[*/
      1: { n: "CodePage", t: VT_I2 },
      /*::[*/
      2: { n: "Title", t: VT_STRING },
      /*::[*/
      3: { n: "Subject", t: VT_STRING },
      /*::[*/
      4: { n: "Author", t: VT_STRING },
      /*::[*/
      5: { n: "Keywords", t: VT_STRING },
      /*::[*/
      6: { n: "Comments", t: VT_STRING },
      /*::[*/
      7: { n: "Template", t: VT_STRING },
      /*::[*/
      8: { n: "LastAuthor", t: VT_STRING },
      /*::[*/
      9: { n: "RevNumber", t: VT_STRING },
      /*::[*/
      10: { n: "EditTime", t: VT_FILETIME },
      /*::[*/
      11: { n: "LastPrinted", t: VT_FILETIME },
      /*::[*/
      12: { n: "CreatedDate", t: VT_FILETIME },
      /*::[*/
      13: { n: "ModifiedDate", t: VT_FILETIME },
      /*::[*/
      14: { n: "PageCount", t: VT_I4 },
      /*::[*/
      15: { n: "WordCount", t: VT_I4 },
      /*::[*/
      16: { n: "CharCount", t: VT_I4 },
      /*::[*/
      17: { n: "Thumbnail", t: VT_CF },
      /*::[*/
      18: { n: "Application", t: VT_STRING },
      /*::[*/
      19: { n: "DocSecurity", t: VT_I4 },
      /*::[*/
      255: {},
      /* [MS-OLEPS] 2.18 */
      /*::[*/
      2147483648: { n: "Locale", t: VT_UI4 },
      /*::[*/
      2147483651: { n: "Behavior", t: VT_UI4 },
      /*::[*/
      1919054434: {}
    };
    function rgbify(arr) {
      return arr.map(function(x) {
        return [x >> 16 & 255, x >> 8 & 255, x & 255];
      });
    }
    var _XLSIcv = /* @__PURE__ */ rgbify([
      /* Color Constants */
      0,
      16777215,
      16711680,
      65280,
      255,
      16776960,
      16711935,
      65535,
      /* Overridable Defaults */
      0,
      16777215,
      16711680,
      65280,
      255,
      16776960,
      16711935,
      65535,
      8388608,
      32768,
      128,
      8421376,
      8388736,
      32896,
      12632256,
      8421504,
      10066431,
      10040166,
      16777164,
      13434879,
      6684774,
      16744576,
      26316,
      13421823,
      128,
      16711935,
      16776960,
      65535,
      8388736,
      8388608,
      32896,
      255,
      52479,
      13434879,
      13434828,
      16777113,
      10079487,
      16751052,
      13408767,
      16764057,
      3368703,
      3394764,
      10079232,
      16763904,
      16750848,
      16737792,
      6710937,
      9868950,
      13158,
      3381606,
      13056,
      3355392,
      10040064,
      10040166,
      3355545,
      3355443,
      /* Other entries to appease BIFF8/12 */
      16777215,
      /* 0x40 icvForeground ?? */
      0,
      /* 0x41 icvBackground ?? */
      0,
      /* 0x42 icvFrame ?? */
      0,
      /* 0x43 icv3D ?? */
      0,
      /* 0x44 icv3DText ?? */
      0,
      /* 0x45 icv3DHilite ?? */
      0,
      /* 0x46 icv3DShadow ?? */
      0,
      /* 0x47 icvHilite ?? */
      0,
      /* 0x48 icvCtlText ?? */
      0,
      /* 0x49 icvCtlScrl ?? */
      0,
      /* 0x4A icvCtlInv ?? */
      0,
      /* 0x4B icvCtlBody ?? */
      0,
      /* 0x4C icvCtlFrame ?? */
      0,
      /* 0x4D icvCtlFore ?? */
      0,
      /* 0x4E icvCtlBack ?? */
      0,
      /* 0x4F icvCtlNeutral */
      0,
      /* 0x50 icvInfoBk ?? */
      0
      /* 0x51 icvInfoText ?? */
    ]);
    var XLSIcv = /* @__PURE__ */ dup(_XLSIcv);
    var BErr = {
      /*::[*/
      0: "#NULL!",
      /*::[*/
      7: "#DIV/0!",
      /*::[*/
      15: "#VALUE!",
      /*::[*/
      23: "#REF!",
      /*::[*/
      29: "#NAME?",
      /*::[*/
      36: "#NUM!",
      /*::[*/
      42: "#N/A",
      /*::[*/
      43: "#GETTING_DATA",
      /*::[*/
      255: "#WTF?"
    };
    var ct2type = {
      /* Workbook */
      "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet.main+xml": "workbooks",
      "application/vnd.ms-excel.sheet.macroEnabled.main+xml": "workbooks",
      "application/vnd.ms-excel.sheet.binary.macroEnabled.main": "workbooks",
      "application/vnd.ms-excel.addin.macroEnabled.main+xml": "workbooks",
      "application/vnd.openxmlformats-officedocument.spreadsheetml.template.main+xml": "workbooks",
      /* Worksheet */
      "application/vnd.openxmlformats-officedocument.spreadsheetml.worksheet+xml": "sheets",
      "application/vnd.ms-excel.worksheet": "sheets",
      "application/vnd.ms-excel.binIndexWs": "TODO",
      /* Binary Index */
      /* Chartsheet */
      "application/vnd.openxmlformats-officedocument.spreadsheetml.chartsheet+xml": "charts",
      "application/vnd.ms-excel.chartsheet": "charts",
      /* Macrosheet */
      "application/vnd.ms-excel.macrosheet+xml": "macros",
      "application/vnd.ms-excel.macrosheet": "macros",
      "application/vnd.ms-excel.intlmacrosheet": "TODO",
      "application/vnd.ms-excel.binIndexMs": "TODO",
      /* Binary Index */
      /* Dialogsheet */
      "application/vnd.openxmlformats-officedocument.spreadsheetml.dialogsheet+xml": "dialogs",
      "application/vnd.ms-excel.dialogsheet": "dialogs",
      /* Shared Strings */
      "application/vnd.openxmlformats-officedocument.spreadsheetml.sharedStrings+xml": "strs",
      "application/vnd.ms-excel.sharedStrings": "strs",
      /* Styles */
      "application/vnd.openxmlformats-officedocument.spreadsheetml.styles+xml": "styles",
      "application/vnd.ms-excel.styles": "styles",
      /* File Properties */
      "application/vnd.openxmlformats-package.core-properties+xml": "coreprops",
      "application/vnd.openxmlformats-officedocument.custom-properties+xml": "custprops",
      "application/vnd.openxmlformats-officedocument.extended-properties+xml": "extprops",
      /* Custom Data Properties */
      "application/vnd.openxmlformats-officedocument.customXmlProperties+xml": "TODO",
      "application/vnd.openxmlformats-officedocument.spreadsheetml.customProperty": "TODO",
      /* Comments */
      "application/vnd.openxmlformats-officedocument.spreadsheetml.comments+xml": "comments",
      "application/vnd.ms-excel.comments": "comments",
      "application/vnd.ms-excel.threadedcomments+xml": "threadedcomments",
      "application/vnd.ms-excel.person+xml": "people",
      /* Metadata (Stock/Geography and Dynamic Array) */
      "application/vnd.openxmlformats-officedocument.spreadsheetml.sheetMetadata+xml": "metadata",
      "application/vnd.ms-excel.sheetMetadata": "metadata",
      /* PivotTable */
      "application/vnd.ms-excel.pivotTable": "TODO",
      "application/vnd.openxmlformats-officedocument.spreadsheetml.pivotTable+xml": "TODO",
      /* Chart Objects */
      "application/vnd.openxmlformats-officedocument.drawingml.chart+xml": "TODO",
      /* Chart Colors */
      "application/vnd.ms-office.chartcolorstyle+xml": "TODO",
      /* Chart Style */
      "application/vnd.ms-office.chartstyle+xml": "TODO",
      /* Chart Advanced */
      "application/vnd.ms-office.chartex+xml": "TODO",
      /* Calculation Chain */
      "application/vnd.ms-excel.calcChain": "calcchains",
      "application/vnd.openxmlformats-officedocument.spreadsheetml.calcChain+xml": "calcchains",
      /* Printer Settings */
      "application/vnd.openxmlformats-officedocument.spreadsheetml.printerSettings": "TODO",
      /* ActiveX */
      "application/vnd.ms-office.activeX": "TODO",
      "application/vnd.ms-office.activeX+xml": "TODO",
      /* Custom Toolbars */
      "application/vnd.ms-excel.attachedToolbars": "TODO",
      /* External Data Connections */
      "application/vnd.ms-excel.connections": "TODO",
      "application/vnd.openxmlformats-officedocument.spreadsheetml.connections+xml": "TODO",
      /* External Links */
      "application/vnd.ms-excel.externalLink": "links",
      "application/vnd.openxmlformats-officedocument.spreadsheetml.externalLink+xml": "links",
      /* PivotCache */
      "application/vnd.ms-excel.pivotCacheDefinition": "TODO",
      "application/vnd.ms-excel.pivotCacheRecords": "TODO",
      "application/vnd.openxmlformats-officedocument.spreadsheetml.pivotCacheDefinition+xml": "TODO",
      "application/vnd.openxmlformats-officedocument.spreadsheetml.pivotCacheRecords+xml": "TODO",
      /* Query Table */
      "application/vnd.ms-excel.queryTable": "TODO",
      "application/vnd.openxmlformats-officedocument.spreadsheetml.queryTable+xml": "TODO",
      /* Shared Workbook */
      "application/vnd.ms-excel.userNames": "TODO",
      "application/vnd.ms-excel.revisionHeaders": "TODO",
      "application/vnd.ms-excel.revisionLog": "TODO",
      "application/vnd.openxmlformats-officedocument.spreadsheetml.revisionHeaders+xml": "TODO",
      "application/vnd.openxmlformats-officedocument.spreadsheetml.revisionLog+xml": "TODO",
      "application/vnd.openxmlformats-officedocument.spreadsheetml.userNames+xml": "TODO",
      /* Single Cell Table */
      "application/vnd.ms-excel.tableSingleCells": "TODO",
      "application/vnd.openxmlformats-officedocument.spreadsheetml.tableSingleCells+xml": "TODO",
      /* Slicer */
      "application/vnd.ms-excel.slicer": "TODO",
      "application/vnd.ms-excel.slicerCache": "TODO",
      "application/vnd.ms-excel.slicer+xml": "TODO",
      "application/vnd.ms-excel.slicerCache+xml": "TODO",
      /* Sort Map */
      "application/vnd.ms-excel.wsSortMap": "TODO",
      /* Table */
      "application/vnd.ms-excel.table": "TODO",
      "application/vnd.openxmlformats-officedocument.spreadsheetml.table+xml": "TODO",
      /* Themes */
      "application/vnd.openxmlformats-officedocument.theme+xml": "themes",
      /* Theme Override */
      "application/vnd.openxmlformats-officedocument.themeOverride+xml": "TODO",
      /* Timeline */
      "application/vnd.ms-excel.Timeline+xml": "TODO",
      /* verify */
      "application/vnd.ms-excel.TimelineCache+xml": "TODO",
      /* verify */
      /* VBA */
      "application/vnd.ms-office.vbaProject": "vba",
      "application/vnd.ms-office.vbaProjectSignature": "TODO",
      /* Volatile Dependencies */
      "application/vnd.ms-office.volatileDependencies": "TODO",
      "application/vnd.openxmlformats-officedocument.spreadsheetml.volatileDependencies+xml": "TODO",
      /* Control Properties */
      "application/vnd.ms-excel.controlproperties+xml": "TODO",
      /* Data Model */
      "application/vnd.openxmlformats-officedocument.model+data": "TODO",
      /* Survey */
      "application/vnd.ms-excel.Survey+xml": "TODO",
      /* Drawing */
      "application/vnd.openxmlformats-officedocument.drawing+xml": "drawings",
      "application/vnd.openxmlformats-officedocument.drawingml.chartshapes+xml": "TODO",
      "application/vnd.openxmlformats-officedocument.drawingml.diagramColors+xml": "TODO",
      "application/vnd.openxmlformats-officedocument.drawingml.diagramData+xml": "TODO",
      "application/vnd.openxmlformats-officedocument.drawingml.diagramLayout+xml": "TODO",
      "application/vnd.openxmlformats-officedocument.drawingml.diagramStyle+xml": "TODO",
      /* VML */
      "application/vnd.openxmlformats-officedocument.vmlDrawing": "TODO",
      "application/vnd.openxmlformats-package.relationships+xml": "rels",
      "application/vnd.openxmlformats-officedocument.oleObject": "TODO",
      /* Image */
      "image/png": "TODO",
      "sheet": "js"
    };
    var CT_LIST = {
      workbooks: {
        xlsx: "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet.main+xml",
        xlsm: "application/vnd.ms-excel.sheet.macroEnabled.main+xml",
        xlsb: "application/vnd.ms-excel.sheet.binary.macroEnabled.main",
        xlam: "application/vnd.ms-excel.addin.macroEnabled.main+xml",
        xltx: "application/vnd.openxmlformats-officedocument.spreadsheetml.template.main+xml"
      },
      strs: {
        /* Shared Strings */
        xlsx: "application/vnd.openxmlformats-officedocument.spreadsheetml.sharedStrings+xml",
        xlsb: "application/vnd.ms-excel.sharedStrings"
      },
      comments: {
        /* Comments */
        xlsx: "application/vnd.openxmlformats-officedocument.spreadsheetml.comments+xml",
        xlsb: "application/vnd.ms-excel.comments"
      },
      sheets: {
        /* Worksheet */
        xlsx: "application/vnd.openxmlformats-officedocument.spreadsheetml.worksheet+xml",
        xlsb: "application/vnd.ms-excel.worksheet"
      },
      charts: {
        /* Chartsheet */
        xlsx: "application/vnd.openxmlformats-officedocument.spreadsheetml.chartsheet+xml",
        xlsb: "application/vnd.ms-excel.chartsheet"
      },
      dialogs: {
        /* Dialogsheet */
        xlsx: "application/vnd.openxmlformats-officedocument.spreadsheetml.dialogsheet+xml",
        xlsb: "application/vnd.ms-excel.dialogsheet"
      },
      macros: {
        /* Macrosheet (Excel 4.0 Macros) */
        xlsx: "application/vnd.ms-excel.macrosheet+xml",
        xlsb: "application/vnd.ms-excel.macrosheet"
      },
      metadata: {
        /* Metadata (Stock/Geography and Dynamic Array) */
        xlsx: "application/vnd.openxmlformats-officedocument.spreadsheetml.sheetMetadata+xml",
        xlsb: "application/vnd.ms-excel.sheetMetadata"
      },
      styles: {
        /* Styles */
        xlsx: "application/vnd.openxmlformats-officedocument.spreadsheetml.styles+xml",
        xlsb: "application/vnd.ms-excel.styles"
      }
    };
    function new_ct() {
      return {
        workbooks: [],
        sheets: [],
        charts: [],
        dialogs: [],
        macros: [],
        rels: [],
        strs: [],
        comments: [],
        threadedcomments: [],
        links: [],
        coreprops: [],
        extprops: [],
        custprops: [],
        themes: [],
        styles: [],
        calcchains: [],
        vba: [],
        drawings: [],
        metadata: [],
        people: [],
        TODO: [],
        xmlns: ""
      };
    }
    function write_ct(ct, opts) {
      var type2ct = evert_arr(ct2type);
      var o = [], v;
      o[o.length] = XML_HEADER;
      o[o.length] = writextag("Types", null, {
        "xmlns": XMLNS.CT,
        "xmlns:xsd": XMLNS.xsd,
        "xmlns:xsi": XMLNS.xsi
      });
      o = o.concat([
        ["xml", "application/xml"],
        ["bin", "application/vnd.ms-excel.sheet.binary.macroEnabled.main"],
        ["vml", "application/vnd.openxmlformats-officedocument.vmlDrawing"],
        ["data", "application/vnd.openxmlformats-officedocument.model+data"],
        /* from test files */
        ["bmp", "image/bmp"],
        ["png", "image/png"],
        ["gif", "image/gif"],
        ["emf", "image/x-emf"],
        ["wmf", "image/x-wmf"],
        ["jpg", "image/jpeg"],
        ["jpeg", "image/jpeg"],
        ["tif", "image/tiff"],
        ["tiff", "image/tiff"],
        ["pdf", "application/pdf"],
        ["rels", "application/vnd.openxmlformats-package.relationships+xml"]
      ].map(function(x) {
        return writextag("Default", null, { "Extension": x[0], "ContentType": x[1] });
      }));
      var f1 = function(w) {
        if (ct[w] && ct[w].length > 0) {
          v = ct[w][0];
          o[o.length] = writextag("Override", null, {
            "PartName": (v[0] == "/" ? "" : "/") + v,
            "ContentType": CT_LIST[w][opts.bookType] || CT_LIST[w]["xlsx"]
          });
        }
      };
      var f2 = function(w) {
        (ct[w] || []).forEach(function(v2) {
          o[o.length] = writextag("Override", null, {
            "PartName": (v2[0] == "/" ? "" : "/") + v2,
            "ContentType": CT_LIST[w][opts.bookType] || CT_LIST[w]["xlsx"]
          });
        });
      };
      var f3 = function(t) {
        (ct[t] || []).forEach(function(v2) {
          o[o.length] = writextag("Override", null, {
            "PartName": (v2[0] == "/" ? "" : "/") + v2,
            "ContentType": type2ct[t][0]
          });
        });
      };
      f1("workbooks");
      f2("sheets");
      f2("charts");
      f3("themes");
      ["strs", "styles"].forEach(f1);
      ["coreprops", "extprops", "custprops"].forEach(f3);
      f3("vba");
      f3("comments");
      f3("threadedcomments");
      f3("drawings");
      f2("metadata");
      f3("people");
      if (o.length > 2) {
        o[o.length] = "</Types>";
        o[1] = o[1].replace("/>", ">");
      }
      return o.join("");
    }
    var RELS = {
      WB: "http://schemas.openxmlformats.org/officeDocument/2006/relationships/officeDocument",
      HLINK: "http://schemas.openxmlformats.org/officeDocument/2006/relationships/hyperlink",
      VML: "http://schemas.openxmlformats.org/officeDocument/2006/relationships/vmlDrawing",
      XPATH: "http://schemas.openxmlformats.org/officeDocument/2006/relationships/externalLinkPath",
      XMISS: "http://schemas.microsoft.com/office/2006/relationships/xlExternalLinkPath/xlPathMissing",
      CMNT: "http://schemas.openxmlformats.org/officeDocument/2006/relationships/comments",
      CORE_PROPS: "http://schemas.openxmlformats.org/package/2006/relationships/metadata/core-properties",
      EXT_PROPS: "http://schemas.openxmlformats.org/officeDocument/2006/relationships/extended-properties",
      CUST_PROPS: "http://schemas.openxmlformats.org/officeDocument/2006/relationships/custom-properties",
      SST: "http://schemas.openxmlformats.org/officeDocument/2006/relationships/sharedStrings",
      STY: "http://schemas.openxmlformats.org/officeDocument/2006/relationships/styles",
      THEME: "http://schemas.openxmlformats.org/officeDocument/2006/relationships/theme",
      WS: [
        "http://schemas.openxmlformats.org/officeDocument/2006/relationships/worksheet",
        "http://purl.oclc.org/ooxml/officeDocument/relationships/worksheet"
      ],
      DRAW: "http://schemas.openxmlformats.org/officeDocument/2006/relationships/drawing",
      XLMETA: "http://schemas.openxmlformats.org/officeDocument/2006/relationships/sheetMetadata",
      TCMNT: "http://schemas.microsoft.com/office/2017/10/relationships/threadedComment",
      PEOPLE: "http://schemas.microsoft.com/office/2017/10/relationships/person",
      VBA: "http://schemas.microsoft.com/office/2006/relationships/vbaProject"
    };
    function get_rels_path(file) {
      var n = file.lastIndexOf("/");
      return file.slice(0, n + 1) + "_rels/" + file.slice(n + 1) + ".rels";
    }
    function write_rels(rels) {
      var o = [XML_HEADER, writextag("Relationships", null, {
        //'xmlns:ns0': XMLNS.RELS,
        "xmlns": XMLNS.RELS
      })];
      keys(rels["!id"]).forEach(function(rid) {
        o[o.length] = writextag("Relationship", null, rels["!id"][rid]);
      });
      if (o.length > 2) {
        o[o.length] = "</Relationships>";
        o[1] = o[1].replace("/>", ">");
      }
      return o.join("");
    }
    function add_rels(rels, rId, f, type, relobj, targetmode) {
      if (!relobj)
        relobj = {};
      if (!rels["!id"])
        rels["!id"] = {};
      if (!rels["!idx"])
        rels["!idx"] = 1;
      if (rId < 0)
        for (rId = rels["!idx"]; rels["!id"]["rId" + rId]; ++rId) {
        }
      rels["!idx"] = rId + 1;
      relobj.Id = "rId" + rId;
      relobj.Type = type;
      relobj.Target = f;
      if ([RELS.HLINK, RELS.XPATH, RELS.XMISS].indexOf(relobj.Type) > -1)
        relobj.TargetMode = "External";
      if (rels["!id"][relobj.Id])
        throw new Error("Cannot rewrite rId " + rId);
      rels["!id"][relobj.Id] = relobj;
      rels[("/" + relobj.Target).replace("//", "/")] = relobj;
      return rId;
    }
    function write_manifest(manifest) {
      var o = [XML_HEADER];
      o.push('<manifest:manifest xmlns:manifest="urn:oasis:names:tc:opendocument:xmlns:manifest:1.0" manifest:version="1.2">\n');
      o.push('  <manifest:file-entry manifest:full-path="/" manifest:version="1.2" manifest:media-type="application/vnd.oasis.opendocument.spreadsheet"/>\n');
      for (var i = 0; i < manifest.length; ++i)
        o.push('  <manifest:file-entry manifest:full-path="' + manifest[i][0] + '" manifest:media-type="' + manifest[i][1] + '"/>\n');
      o.push("</manifest:manifest>");
      return o.join("");
    }
    function write_rdf_type(file, res, tag) {
      return [
        '  <rdf:Description rdf:about="' + file + '">\n',
        '    <rdf:type rdf:resource="http://docs.oasis-open.org/ns/office/1.2/meta/' + (tag || "odf") + "#" + res + '"/>\n',
        "  </rdf:Description>\n"
      ].join("");
    }
    function write_rdf_has(base, file) {
      return [
        '  <rdf:Description rdf:about="' + base + '">\n',
        '    <ns0:hasPart xmlns:ns0="http://docs.oasis-open.org/ns/office/1.2/meta/pkg#" rdf:resource="' + file + '"/>\n',
        "  </rdf:Description>\n"
      ].join("");
    }
    function write_rdf(rdf) {
      var o = [XML_HEADER];
      o.push('<rdf:RDF xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#">\n');
      for (var i = 0; i != rdf.length; ++i) {
        o.push(write_rdf_type(rdf[i][0], rdf[i][1]));
        o.push(write_rdf_has("", rdf[i][0]));
      }
      o.push(write_rdf_type("", "Document", "pkg"));
      o.push("</rdf:RDF>");
      return o.join("");
    }
    function write_meta_ods() {
      return '<office:document-meta xmlns:office="urn:oasis:names:tc:opendocument:xmlns:office:1.0" xmlns:meta="urn:oasis:names:tc:opendocument:xmlns:meta:1.0" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:xlink="http://www.w3.org/1999/xlink" office:version="1.2"><office:meta><meta:generator>SheetJS ' + XLSX.version + "</meta:generator></office:meta></office:document-meta>";
    }
    var CORE_PROPS = [
      ["cp:category", "Category"],
      ["cp:contentStatus", "ContentStatus"],
      ["cp:keywords", "Keywords"],
      ["cp:lastModifiedBy", "LastAuthor"],
      ["cp:lastPrinted", "LastPrinted"],
      ["cp:revision", "RevNumber"],
      ["cp:version", "Version"],
      ["dc:creator", "Author"],
      ["dc:description", "Comments"],
      ["dc:identifier", "Identifier"],
      ["dc:language", "Language"],
      ["dc:subject", "Subject"],
      ["dc:title", "Title"],
      ["dcterms:created", "CreatedDate", "date"],
      ["dcterms:modified", "ModifiedDate", "date"]
    ];
    function cp_doit(f, g, h, o, p) {
      if (p[f] != null || g == null || g === "")
        return;
      p[f] = g;
      g = escapexml(g);
      o[o.length] = h ? writextag(f, g, h) : writetag(f, g);
    }
    function write_core_props(cp, _opts) {
      var opts = _opts || {};
      var o = [XML_HEADER, writextag("cp:coreProperties", null, {
        //'xmlns': XMLNS.CORE_PROPS,
        "xmlns:cp": XMLNS.CORE_PROPS,
        "xmlns:dc": XMLNS.dc,
        "xmlns:dcterms": XMLNS.dcterms,
        "xmlns:dcmitype": XMLNS.dcmitype,
        "xmlns:xsi": XMLNS.xsi
      })], p = {};
      if (!cp && !opts.Props)
        return o.join("");
      if (cp) {
        if (cp.CreatedDate != null)
          cp_doit("dcterms:created", typeof cp.CreatedDate === "string" ? cp.CreatedDate : write_w3cdtf(cp.CreatedDate, opts.WTF), { "xsi:type": "dcterms:W3CDTF" }, o, p);
        if (cp.ModifiedDate != null)
          cp_doit("dcterms:modified", typeof cp.ModifiedDate === "string" ? cp.ModifiedDate : write_w3cdtf(cp.ModifiedDate, opts.WTF), { "xsi:type": "dcterms:W3CDTF" }, o, p);
      }
      for (var i = 0; i != CORE_PROPS.length; ++i) {
        var f = CORE_PROPS[i];
        var v = opts.Props && opts.Props[f[1]] != null ? opts.Props[f[1]] : cp ? cp[f[1]] : null;
        if (v === true)
          v = "1";
        else if (v === false)
          v = "0";
        else if (typeof v == "number")
          v = String(v);
        if (v != null)
          cp_doit(f[0], v, null, o, p);
      }
      if (o.length > 2) {
        o[o.length] = "</cp:coreProperties>";
        o[1] = o[1].replace("/>", ">");
      }
      return o.join("");
    }
    var EXT_PROPS = [
      ["Application", "Application", "string"],
      ["AppVersion", "AppVersion", "string"],
      ["Company", "Company", "string"],
      ["DocSecurity", "DocSecurity", "string"],
      ["Manager", "Manager", "string"],
      ["HyperlinksChanged", "HyperlinksChanged", "bool"],
      ["SharedDoc", "SharedDoc", "bool"],
      ["LinksUpToDate", "LinksUpToDate", "bool"],
      ["ScaleCrop", "ScaleCrop", "bool"],
      ["HeadingPairs", "HeadingPairs", "raw"],
      ["TitlesOfParts", "TitlesOfParts", "raw"]
    ];
    var PseudoPropsPairs = [
      "Worksheets",
      "SheetNames",
      "NamedRanges",
      "DefinedNames",
      "Chartsheets",
      "ChartNames"
    ];
    function write_ext_props(cp) {
      var o = [], W = writextag;
      if (!cp)
        cp = {};
      cp.Application = "SheetJS";
      o[o.length] = XML_HEADER;
      o[o.length] = writextag("Properties", null, {
        "xmlns": XMLNS.EXT_PROPS,
        "xmlns:vt": XMLNS.vt
      });
      EXT_PROPS.forEach(function(f) {
        if (cp[f[1]] === void 0)
          return;
        var v;
        switch (f[2]) {
          case "string":
            v = escapexml(String(cp[f[1]]));
            break;
          case "bool":
            v = cp[f[1]] ? "true" : "false";
            break;
        }
        if (v !== void 0)
          o[o.length] = W(f[0], v);
      });
      o[o.length] = W("HeadingPairs", W("vt:vector", W("vt:variant", "<vt:lpstr>Worksheets</vt:lpstr>") + W("vt:variant", W("vt:i4", String(cp.Worksheets))), { size: 2, baseType: "variant" }));
      o[o.length] = W("TitlesOfParts", W("vt:vector", cp.SheetNames.map(function(s) {
        return "<vt:lpstr>" + escapexml(s) + "</vt:lpstr>";
      }).join(""), { size: cp.Worksheets, baseType: "lpstr" }));
      if (o.length > 2) {
        o[o.length] = "</Properties>";
        o[1] = o[1].replace("/>", ">");
      }
      return o.join("");
    }
    function write_cust_props(cp) {
      var o = [XML_HEADER, writextag("Properties", null, {
        "xmlns": XMLNS.CUST_PROPS,
        "xmlns:vt": XMLNS.vt
      })];
      if (!cp)
        return o.join("");
      var pid = 1;
      keys(cp).forEach(function custprop(k) {
        ++pid;
        o[o.length] = writextag("property", write_vt(cp[k]), {
          "fmtid": "{D5CDD505-2E9C-101B-9397-08002B2CF9AE}",
          "pid": pid,
          "name": escapexml(k)
        });
      });
      if (o.length > 2) {
        o[o.length] = "</Properties>";
        o[1] = o[1].replace("/>", ">");
      }
      return o.join("");
    }
    var XLMLDocPropsMap = {
      Title: "Title",
      Subject: "Subject",
      Author: "Author",
      Keywords: "Keywords",
      Comments: "Description",
      LastAuthor: "LastAuthor",
      RevNumber: "Revision",
      Application: "AppName",
      /* TotalTime: 'TotalTime', */
      LastPrinted: "LastPrinted",
      CreatedDate: "Created",
      ModifiedDate: "LastSaved",
      /* Pages */
      /* Words */
      /* Characters */
      Category: "Category",
      /* PresentationFormat */
      Manager: "Manager",
      Company: "Company",
      /* Guid */
      /* HyperlinkBase */
      /* Bytes */
      /* Lines */
      /* Paragraphs */
      /* CharactersWithSpaces */
      AppVersion: "Version",
      ContentStatus: "ContentStatus",
      /* NOTE: missing from schema */
      Identifier: "Identifier",
      /* NOTE: missing from schema */
      Language: "Language"
      /* NOTE: missing from schema */
    };
    function xlml_write_docprops(Props, opts) {
      var o = [];
      keys(XLMLDocPropsMap).map(function(m) {
        for (var i = 0; i < CORE_PROPS.length; ++i)
          if (CORE_PROPS[i][1] == m)
            return CORE_PROPS[i];
        for (i = 0; i < EXT_PROPS.length; ++i)
          if (EXT_PROPS[i][1] == m)
            return EXT_PROPS[i];
        throw m;
      }).forEach(function(p) {
        if (Props[p[1]] == null)
          return;
        var m = opts && opts.Props && opts.Props[p[1]] != null ? opts.Props[p[1]] : Props[p[1]];
        switch (p[2]) {
          case "date":
            m = new Date(m).toISOString().replace(/\.\d*Z/, "Z");
            break;
        }
        if (typeof m == "number")
          m = String(m);
        else if (m === true || m === false) {
          m = m ? "1" : "0";
        } else if (m instanceof Date)
          m = new Date(m).toISOString().replace(/\.\d*Z/, "");
        o.push(writetag(XLMLDocPropsMap[p[1]] || p[1], m));
      });
      return writextag("DocumentProperties", o.join(""), { xmlns: XLMLNS.o });
    }
    function xlml_write_custprops(Props, Custprops) {
      var BLACKLIST = ["Worksheets", "SheetNames"];
      var T = "CustomDocumentProperties";
      var o = [];
      if (Props)
        keys(Props).forEach(function(k) {
          if (!Object.prototype.hasOwnProperty.call(Props, k))
            return;
          for (var i = 0; i < CORE_PROPS.length; ++i)
            if (k == CORE_PROPS[i][1])
              return;
          for (i = 0; i < EXT_PROPS.length; ++i)
            if (k == EXT_PROPS[i][1])
              return;
          for (i = 0; i < BLACKLIST.length; ++i)
            if (k == BLACKLIST[i])
              return;
          var m = Props[k];
          var t = "string";
          if (typeof m == "number") {
            t = "float";
            m = String(m);
          } else if (m === true || m === false) {
            t = "boolean";
            m = m ? "1" : "0";
          } else
            m = String(m);
          o.push(writextag(escapexmltag(k), m, { "dt:dt": t }));
        });
      if (Custprops)
        keys(Custprops).forEach(function(k) {
          if (!Object.prototype.hasOwnProperty.call(Custprops, k))
            return;
          if (Props && Object.prototype.hasOwnProperty.call(Props, k))
            return;
          var m = Custprops[k];
          var t = "string";
          if (typeof m == "number") {
            t = "float";
            m = String(m);
          } else if (m === true || m === false) {
            t = "boolean";
            m = m ? "1" : "0";
          } else if (m instanceof Date) {
            t = "dateTime.tz";
            m = m.toISOString();
          } else
            m = String(m);
          o.push(writextag(escapexmltag(k), m, { "dt:dt": t }));
        });
      return "<" + T + ' xmlns="' + XLMLNS.o + '">' + o.join("") + "</" + T + ">";
    }
    function write_FILETIME(time) {
      var date = typeof time == "string" ? new Date(Date.parse(time)) : time;
      var t = date.getTime() / 1e3 + 11644473600;
      var l2 = t % Math.pow(2, 32), h = (t - l2) / Math.pow(2, 32);
      l2 *= 1e7;
      h *= 1e7;
      var w = l2 / Math.pow(2, 32) | 0;
      if (w > 0) {
        l2 = l2 % Math.pow(2, 32);
        h += w;
      }
      var o = new_buf(8);
      o.write_shift(4, l2);
      o.write_shift(4, h);
      return o;
    }
    function write_TypedPropertyValue(type, value) {
      var o = new_buf(4), p = new_buf(4);
      o.write_shift(4, type == 80 ? 31 : type);
      switch (type) {
        case 3:
          p.write_shift(-4, value);
          break;
        case 5:
          p = new_buf(8);
          p.write_shift(8, value, "f");
          break;
        case 11:
          p.write_shift(4, value ? 1 : 0);
          break;
        case 64:
          p = write_FILETIME(value);
          break;
        case 31:
        case 80:
          p = new_buf(4 + 2 * (value.length + 1) + (value.length % 2 ? 0 : 2));
          p.write_shift(4, value.length + 1);
          p.write_shift(0, value, "dbcs");
          while (p.l != p.length)
            p.write_shift(1, 0);
          break;
        default:
          throw new Error("TypedPropertyValue unrecognized type " + type + " " + value);
      }
      return bconcat([o, p]);
    }
    var XLSPSSkip = ["CodePage", "Thumbnail", "_PID_LINKBASE", "_PID_HLINKS", "SystemIdentifier", "FMTID"];
    function guess_property_type(val) {
      switch (typeof val) {
        case "boolean":
          return 11;
        case "number":
          return (val | 0) == val ? 3 : 5;
        case "string":
          return 31;
        case "object":
          if (val instanceof Date)
            return 64;
          break;
      }
      return -1;
    }
    function write_PropertySet(entries, RE, PIDSI) {
      var hdr = new_buf(8), piao = [], prop = [];
      var sz = 8, i = 0;
      var pr = new_buf(8), pio = new_buf(8);
      pr.write_shift(4, 2);
      pr.write_shift(4, 1200);
      pio.write_shift(4, 1);
      prop.push(pr);
      piao.push(pio);
      sz += 8 + pr.length;
      if (!RE) {
        pio = new_buf(8);
        pio.write_shift(4, 0);
        piao.unshift(pio);
        var bufs = [new_buf(4)];
        bufs[0].write_shift(4, entries.length);
        for (i = 0; i < entries.length; ++i) {
          var value = entries[i][0];
          pr = new_buf(4 + 4 + 2 * (value.length + 1) + (value.length % 2 ? 0 : 2));
          pr.write_shift(4, i + 2);
          pr.write_shift(4, value.length + 1);
          pr.write_shift(0, value, "dbcs");
          while (pr.l != pr.length)
            pr.write_shift(1, 0);
          bufs.push(pr);
        }
        pr = bconcat(bufs);
        prop.unshift(pr);
        sz += 8 + pr.length;
      }
      for (i = 0; i < entries.length; ++i) {
        if (RE && !RE[entries[i][0]])
          continue;
        if (XLSPSSkip.indexOf(entries[i][0]) > -1 || PseudoPropsPairs.indexOf(entries[i][0]) > -1)
          continue;
        if (entries[i][1] == null)
          continue;
        var val = entries[i][1], idx = 0;
        if (RE) {
          idx = +RE[entries[i][0]];
          var pinfo = PIDSI[idx];
          if (pinfo.p == "version" && typeof val == "string") {
            var arr = val.split(".");
            val = (+arr[0] << 16) + (+arr[1] || 0);
          }
          pr = write_TypedPropertyValue(pinfo.t, val);
        } else {
          var T = guess_property_type(val);
          if (T == -1) {
            T = 31;
            val = String(val);
          }
          pr = write_TypedPropertyValue(T, val);
        }
        prop.push(pr);
        pio = new_buf(8);
        pio.write_shift(4, !RE ? 2 + i : idx);
        piao.push(pio);
        sz += 8 + pr.length;
      }
      var w = 8 * (prop.length + 1);
      for (i = 0; i < prop.length; ++i) {
        piao[i].write_shift(4, w);
        w += prop[i].length;
      }
      hdr.write_shift(4, sz);
      hdr.write_shift(4, prop.length);
      return bconcat([hdr].concat(piao).concat(prop));
    }
    function write_PropertySetStream(entries, clsid, RE, PIDSI, entries2, clsid2) {
      var hdr = new_buf(entries2 ? 68 : 48);
      var bufs = [hdr];
      hdr.write_shift(2, 65534);
      hdr.write_shift(2, 0);
      hdr.write_shift(4, 842412599);
      hdr.write_shift(16, CFB.utils.consts.HEADER_CLSID, "hex");
      hdr.write_shift(4, entries2 ? 2 : 1);
      hdr.write_shift(16, clsid, "hex");
      hdr.write_shift(4, entries2 ? 68 : 48);
      var ps0 = write_PropertySet(entries, RE, PIDSI);
      bufs.push(ps0);
      if (entries2) {
        var ps1 = write_PropertySet(entries2, null, null);
        hdr.write_shift(16, clsid2, "hex");
        hdr.write_shift(4, 68 + ps0.length);
        bufs.push(ps1);
      }
      return bconcat(bufs);
    }
    function writezeroes(n, o) {
      if (!o)
        o = new_buf(n);
      for (var j = 0; j < n; ++j)
        o.write_shift(1, 0);
      return o;
    }
    function parsebool(blob, length) {
      return blob.read_shift(length) === 1;
    }
    function writebool(v, o) {
      if (!o)
        o = new_buf(2);
      o.write_shift(2, +!!v);
      return o;
    }
    function parseuint16(blob) {
      return blob.read_shift(2, "u");
    }
    function writeuint16(v, o) {
      if (!o)
        o = new_buf(2);
      o.write_shift(2, v);
      return o;
    }
    function write_Bes(v, t, o) {
      if (!o)
        o = new_buf(2);
      o.write_shift(1, t == "e" ? +v : +!!v);
      o.write_shift(1, t == "e" ? 1 : 0);
      return o;
    }
    function parse_ShortXLUnicodeString(blob, length, opts) {
      var cch = blob.read_shift(opts && opts.biff >= 12 ? 2 : 1);
      var encoding = "sbcs-cont";
      if (opts && opts.biff >= 8)
        ;
      if (!opts || opts.biff == 8) {
        var fHighByte = blob.read_shift(1);
        if (fHighByte) {
          encoding = "dbcs-cont";
        }
      } else if (opts.biff == 12) {
        encoding = "wstr";
      }
      if (opts.biff >= 2 && opts.biff <= 5)
        encoding = "cpstr";
      var o = cch ? blob.read_shift(cch, encoding) : "";
      return o;
    }
    function write_XLUnicodeRichExtendedString(xlstr) {
      var str = xlstr.t || "";
      var hdr = new_buf(3 + 0);
      hdr.write_shift(2, str.length);
      hdr.write_shift(1, 0 | 1);
      var otext = new_buf(2 * str.length);
      otext.write_shift(2 * str.length, str, "utf16le");
      var out = [hdr, otext];
      return bconcat(out);
    }
    function parse_XLUnicodeStringNoCch(blob, cch, opts) {
      var retval;
      if (opts) {
        if (opts.biff >= 2 && opts.biff <= 5)
          return blob.read_shift(cch, "cpstr");
        if (opts.biff >= 12)
          return blob.read_shift(cch, "dbcs-cont");
      }
      var fHighByte = blob.read_shift(1);
      if (fHighByte === 0) {
        retval = blob.read_shift(cch, "sbcs-cont");
      } else {
        retval = blob.read_shift(cch, "dbcs-cont");
      }
      return retval;
    }
    function parse_XLUnicodeString(blob, length, opts) {
      var cch = blob.read_shift(opts && opts.biff == 2 ? 1 : 2);
      if (cch === 0) {
        blob.l++;
        return "";
      }
      return parse_XLUnicodeStringNoCch(blob, cch, opts);
    }
    function parse_XLUnicodeString2(blob, length, opts) {
      if (opts.biff > 5)
        return parse_XLUnicodeString(blob, length, opts);
      var cch = blob.read_shift(1);
      if (cch === 0) {
        blob.l++;
        return "";
      }
      return blob.read_shift(cch, opts.biff <= 4 || !blob.lens ? "cpstr" : "sbcs-cont");
    }
    function write_XLUnicodeString(str, opts, o) {
      if (!o)
        o = new_buf(3 + 2 * str.length);
      o.write_shift(2, str.length);
      o.write_shift(1, 1);
      o.write_shift(31, str, "utf16le");
      return o;
    }
    function write_HyperlinkString(str, o) {
      if (!o)
        o = new_buf(6 + str.length * 2);
      o.write_shift(4, 1 + str.length);
      for (var i = 0; i < str.length; ++i)
        o.write_shift(2, str.charCodeAt(i));
      o.write_shift(2, 0);
      return o;
    }
    function write_Hyperlink(hl) {
      var out = new_buf(512), i = 0;
      var Target = hl.Target;
      if (Target.slice(0, 7) == "file://")
        Target = Target.slice(7);
      var hashidx = Target.indexOf("#");
      var F = hashidx > -1 ? 31 : 23;
      switch (Target.charAt(0)) {
        case "#":
          F = 28;
          break;
        case ".":
          F &= -3;
          break;
      }
      out.write_shift(4, 2);
      out.write_shift(4, F);
      var data = [8, 6815827, 6619237, 4849780, 83];
      for (i = 0; i < data.length; ++i)
        out.write_shift(4, data[i]);
      if (F == 28) {
        Target = Target.slice(1);
        write_HyperlinkString(Target, out);
      } else if (F & 2) {
        data = "e0 c9 ea 79 f9 ba ce 11 8c 82 00 aa 00 4b a9 0b".split(" ");
        for (i = 0; i < data.length; ++i)
          out.write_shift(1, parseInt(data[i], 16));
        var Pretarget = hashidx > -1 ? Target.slice(0, hashidx) : Target;
        out.write_shift(4, 2 * (Pretarget.length + 1));
        for (i = 0; i < Pretarget.length; ++i)
          out.write_shift(2, Pretarget.charCodeAt(i));
        out.write_shift(2, 0);
        if (F & 8)
          write_HyperlinkString(hashidx > -1 ? Target.slice(hashidx + 1) : "", out);
      } else {
        data = "03 03 00 00 00 00 00 00 c0 00 00 00 00 00 00 46".split(" ");
        for (i = 0; i < data.length; ++i)
          out.write_shift(1, parseInt(data[i], 16));
        var P = 0;
        while (Target.slice(P * 3, P * 3 + 3) == "../" || Target.slice(P * 3, P * 3 + 3) == "..\\")
          ++P;
        out.write_shift(2, P);
        out.write_shift(4, Target.length - 3 * P + 1);
        for (i = 0; i < Target.length - 3 * P; ++i)
          out.write_shift(1, Target.charCodeAt(i + 3 * P) & 255);
        out.write_shift(1, 0);
        out.write_shift(2, 65535);
        out.write_shift(2, 57005);
        for (i = 0; i < 6; ++i)
          out.write_shift(4, 0);
      }
      return out.slice(0, out.l);
    }
    function write_XLSCell(R, C, ixfe, o) {
      if (!o)
        o = new_buf(6);
      o.write_shift(2, R);
      o.write_shift(2, C);
      o.write_shift(2, ixfe || 0);
      return o;
    }
    function parse_XTI(blob, length, opts) {
      var w = opts.biff > 8 ? 4 : 2;
      var iSupBook = blob.read_shift(w), itabFirst = blob.read_shift(w, "i"), itabLast = blob.read_shift(w, "i");
      return [iSupBook, itabFirst, itabLast];
    }
    function parse_Ref8U(blob) {
      var rwFirst = blob.read_shift(2);
      var rwLast = blob.read_shift(2);
      var colFirst = blob.read_shift(2);
      var colLast = blob.read_shift(2);
      return { s: { c: colFirst, r: rwFirst }, e: { c: colLast, r: rwLast } };
    }
    function write_Ref8U(r, o) {
      if (!o)
        o = new_buf(8);
      o.write_shift(2, r.s.r);
      o.write_shift(2, r.e.r);
      o.write_shift(2, r.s.c);
      o.write_shift(2, r.e.c);
      return o;
    }
    function write_BOF(wb, t, o) {
      var h = 1536, w = 16;
      switch (o.bookType) {
        case "biff8":
          break;
        case "biff5":
          h = 1280;
          w = 8;
          break;
        case "biff4":
          h = 4;
          w = 6;
          break;
        case "biff3":
          h = 3;
          w = 6;
          break;
        case "biff2":
          h = 2;
          w = 4;
          break;
        case "xla":
          break;
        default:
          throw new Error("unsupported BIFF version");
      }
      var out = new_buf(w);
      out.write_shift(2, h);
      out.write_shift(2, t);
      if (w > 4)
        out.write_shift(2, 29282);
      if (w > 6)
        out.write_shift(2, 1997);
      if (w > 8) {
        out.write_shift(2, 49161);
        out.write_shift(2, 1);
        out.write_shift(2, 1798);
        out.write_shift(2, 0);
      }
      return out;
    }
    function write_WriteAccess(s, opts) {
      var b8 = !opts || opts.biff == 8;
      var o = new_buf(b8 ? 112 : 54);
      o.write_shift(opts.biff == 8 ? 2 : 1, 7);
      if (b8)
        o.write_shift(1, 0);
      o.write_shift(4, 859007059);
      o.write_shift(4, 5458548 | (b8 ? 0 : 536870912));
      while (o.l < o.length)
        o.write_shift(1, b8 ? 0 : 32);
      return o;
    }
    function write_BoundSheet8(data, opts) {
      var w = !opts || opts.biff >= 8 ? 2 : 1;
      var o = new_buf(8 + w * data.name.length);
      o.write_shift(4, data.pos);
      o.write_shift(1, data.hs || 0);
      o.write_shift(1, data.dt);
      o.write_shift(1, data.name.length);
      if (opts.biff >= 8)
        o.write_shift(1, 1);
      o.write_shift(w * data.name.length, data.name, opts.biff < 8 ? "sbcs" : "utf16le");
      var out = o.slice(0, o.l);
      out.l = o.l;
      return out;
    }
    function write_SST(sst, opts) {
      var header = new_buf(8);
      header.write_shift(4, sst.Count);
      header.write_shift(4, sst.Unique);
      var strs = [];
      for (var j = 0; j < sst.length; ++j)
        strs[j] = write_XLUnicodeRichExtendedString(sst[j]);
      var o = bconcat([header].concat(strs));
      o.parts = [header.length].concat(strs.map(function(str) {
        return str.length;
      }));
      return o;
    }
    function write_Window1() {
      var o = new_buf(18);
      o.write_shift(2, 0);
      o.write_shift(2, 0);
      o.write_shift(2, 29280);
      o.write_shift(2, 17600);
      o.write_shift(2, 56);
      o.write_shift(2, 0);
      o.write_shift(2, 0);
      o.write_shift(2, 1);
      o.write_shift(2, 500);
      return o;
    }
    function write_Window2(view) {
      var o = new_buf(18), f = 1718;
      if (view && view.RTL)
        f |= 64;
      o.write_shift(2, f);
      o.write_shift(4, 0);
      o.write_shift(4, 64);
      o.write_shift(4, 0);
      o.write_shift(4, 0);
      return o;
    }
    function write_Font(data, opts) {
      var name = data.name || "Arial";
      var b5 = opts && opts.biff == 5, w = b5 ? 15 + name.length : 16 + 2 * name.length;
      var o = new_buf(w);
      o.write_shift(2, data.sz * 20);
      o.write_shift(4, 0);
      o.write_shift(2, 400);
      o.write_shift(4, 0);
      o.write_shift(2, 0);
      o.write_shift(1, name.length);
      if (!b5)
        o.write_shift(1, 1);
      o.write_shift((b5 ? 1 : 2) * name.length, name, b5 ? "sbcs" : "utf16le");
      return o;
    }
    function write_LabelSst(R, C, v, os) {
      var o = new_buf(10);
      write_XLSCell(R, C, os, o);
      o.write_shift(4, v);
      return o;
    }
    function write_Label(R, C, v, os, opts) {
      var b8 = !opts || opts.biff == 8;
      var o = new_buf(6 + 2 + +b8 + (1 + b8) * v.length);
      write_XLSCell(R, C, os, o);
      o.write_shift(2, v.length);
      if (b8)
        o.write_shift(1, 1);
      o.write_shift((1 + b8) * v.length, v, b8 ? "utf16le" : "sbcs");
      return o;
    }
    function write_Format(i, f, opts, o) {
      var b5 = opts && opts.biff == 5;
      if (!o)
        o = new_buf(b5 ? 3 + f.length : 5 + 2 * f.length);
      o.write_shift(2, i);
      o.write_shift(b5 ? 1 : 2, f.length);
      if (!b5)
        o.write_shift(1, 1);
      o.write_shift((b5 ? 1 : 2) * f.length, f, b5 ? "sbcs" : "utf16le");
      var out = o.length > o.l ? o.slice(0, o.l) : o;
      if (out.l == null)
        out.l = out.length;
      return out;
    }
    function write_Dimensions(range, opts) {
      var w = opts.biff == 8 || !opts.biff ? 4 : 2;
      var o = new_buf(2 * w + 6);
      o.write_shift(w, range.s.r);
      o.write_shift(w, range.e.r + 1);
      o.write_shift(2, range.s.c);
      o.write_shift(2, range.e.c + 1);
      o.write_shift(2, 0);
      return o;
    }
    function write_XF(data, ixfeP, opts, o) {
      var b5 = opts && opts.biff == 5;
      if (!o)
        o = new_buf(b5 ? 16 : 20);
      o.write_shift(2, 0);
      if (data.style) {
        o.write_shift(2, data.numFmtId || 0);
        o.write_shift(2, 65524);
      } else {
        o.write_shift(2, data.numFmtId || 0);
        o.write_shift(2, ixfeP << 4);
      }
      var f = 0;
      if (data.numFmtId > 0 && b5)
        f |= 1024;
      o.write_shift(4, f);
      o.write_shift(4, 0);
      if (!b5)
        o.write_shift(4, 0);
      o.write_shift(2, 0);
      return o;
    }
    function write_Guts(guts) {
      var o = new_buf(8);
      o.write_shift(4, 0);
      o.write_shift(2, 0);
      o.write_shift(2, 0);
      return o;
    }
    function write_BoolErr(R, C, v, os, opts, t) {
      var o = new_buf(8);
      write_XLSCell(R, C, os, o);
      write_Bes(v, t, o);
      return o;
    }
    function write_Number(R, C, v, os) {
      var o = new_buf(14);
      write_XLSCell(R, C, os, o);
      write_Xnum(v, o);
      return o;
    }
    function parse_ExternSheet(blob, length, opts) {
      if (opts.biff < 8)
        return parse_BIFF5ExternSheet(blob, length, opts);
      var o = [], target = blob.l + length, len = blob.read_shift(opts.biff > 8 ? 4 : 2);
      while (len-- !== 0)
        o.push(parse_XTI(blob, opts.biff > 8 ? 12 : 6, opts));
      if (blob.l != target)
        throw new Error("Bad ExternSheet: " + blob.l + " != " + target);
      return o;
    }
    function parse_BIFF5ExternSheet(blob, length, opts) {
      if (blob[blob.l + 1] == 3)
        blob[blob.l]++;
      var o = parse_ShortXLUnicodeString(blob, length, opts);
      return o.charCodeAt(0) == 3 ? o.slice(1) : o;
    }
    function write_MergeCells(merges) {
      var o = new_buf(2 + merges.length * 8);
      o.write_shift(2, merges.length);
      for (var i = 0; i < merges.length; ++i)
        write_Ref8U(merges[i], o);
      return o;
    }
    function write_HLink(hl) {
      var O = new_buf(24);
      var ref = decode_cell(hl[0]);
      O.write_shift(2, ref.r);
      O.write_shift(2, ref.r);
      O.write_shift(2, ref.c);
      O.write_shift(2, ref.c);
      var clsid = "d0 c9 ea 79 f9 ba ce 11 8c 82 00 aa 00 4b a9 0b".split(" ");
      for (var i = 0; i < 16; ++i)
        O.write_shift(1, parseInt(clsid[i], 16));
      return bconcat([O, write_Hyperlink(hl[1])]);
    }
    function write_HLinkTooltip(hl) {
      var TT = hl[1].Tooltip;
      var O = new_buf(10 + 2 * (TT.length + 1));
      O.write_shift(2, 2048);
      var ref = decode_cell(hl[0]);
      O.write_shift(2, ref.r);
      O.write_shift(2, ref.r);
      O.write_shift(2, ref.c);
      O.write_shift(2, ref.c);
      for (var i = 0; i < TT.length; ++i)
        O.write_shift(2, TT.charCodeAt(i));
      O.write_shift(2, 0);
      return O;
    }
    function write_Country(o) {
      if (!o)
        o = new_buf(4);
      o.write_shift(2, 1);
      o.write_shift(2, 1);
      return o;
    }
    function parse_ColInfo(blob, length, opts) {
      if (!opts.cellStyles)
        return parsenoop(blob, length);
      var w = opts && opts.biff >= 12 ? 4 : 2;
      var colFirst = blob.read_shift(w);
      var colLast = blob.read_shift(w);
      var coldx = blob.read_shift(w);
      var ixfe = blob.read_shift(w);
      var flags = blob.read_shift(2);
      if (w == 2)
        blob.l += 2;
      var o = { s: colFirst, e: colLast, w: coldx, ixfe, flags };
      if (opts.biff >= 5 || !opts.biff)
        o.level = flags >> 8 & 7;
      return o;
    }
    function write_ColInfo(col, idx) {
      var o = new_buf(12);
      o.write_shift(2, idx);
      o.write_shift(2, idx);
      o.write_shift(2, col.width * 256);
      o.write_shift(2, 0);
      var f = 0;
      if (col.hidden)
        f |= 1;
      o.write_shift(1, f);
      f = col.level || 0;
      o.write_shift(1, f);
      o.write_shift(2, 0);
      return o;
    }
    function write_RRTabId(n) {
      var out = new_buf(2 * n);
      for (var i = 0; i < n; ++i)
        out.write_shift(2, i + 1);
      return out;
    }
    function write_BIFF2NUM(r, c, val) {
      var out = new_buf(15);
      write_BIFF2Cell(out, r, c);
      out.write_shift(8, val, "f");
      return out;
    }
    function write_BIFF2INT(r, c, val) {
      var out = new_buf(9);
      write_BIFF2Cell(out, r, c);
      out.write_shift(2, val);
      return out;
    }
    var DBF = /* @__PURE__ */ function() {
      var dbf_codepage_map = {
        /* Code Pages Supported by Visual FoxPro */
        /*::[*/
        1: 437,
        /*::[*/
        2: 850,
        /*::[*/
        3: 1252,
        /*::[*/
        4: 1e4,
        /*::[*/
        100: 852,
        /*::[*/
        101: 866,
        /*::[*/
        102: 865,
        /*::[*/
        103: 861,
        /*::[*/
        104: 895,
        /*::[*/
        105: 620,
        /*::[*/
        106: 737,
        /*::[*/
        107: 857,
        /*::[*/
        120: 950,
        /*::[*/
        121: 949,
        /*::[*/
        122: 936,
        /*::[*/
        123: 932,
        /*::[*/
        124: 874,
        /*::[*/
        125: 1255,
        /*::[*/
        126: 1256,
        /*::[*/
        150: 10007,
        /*::[*/
        151: 10029,
        /*::[*/
        152: 10006,
        /*::[*/
        200: 1250,
        /*::[*/
        201: 1251,
        /*::[*/
        202: 1254,
        /*::[*/
        203: 1253,
        /* shapefile DBF extension */
        /*::[*/
        0: 20127,
        /*::[*/
        8: 865,
        /*::[*/
        9: 437,
        /*::[*/
        10: 850,
        /*::[*/
        11: 437,
        /*::[*/
        13: 437,
        /*::[*/
        14: 850,
        /*::[*/
        15: 437,
        /*::[*/
        16: 850,
        /*::[*/
        17: 437,
        /*::[*/
        18: 850,
        /*::[*/
        19: 932,
        /*::[*/
        20: 850,
        /*::[*/
        21: 437,
        /*::[*/
        22: 850,
        /*::[*/
        23: 865,
        /*::[*/
        24: 437,
        /*::[*/
        25: 437,
        /*::[*/
        26: 850,
        /*::[*/
        27: 437,
        /*::[*/
        28: 863,
        /*::[*/
        29: 850,
        /*::[*/
        31: 852,
        /*::[*/
        34: 852,
        /*::[*/
        35: 852,
        /*::[*/
        36: 860,
        /*::[*/
        37: 850,
        /*::[*/
        38: 866,
        /*::[*/
        55: 850,
        /*::[*/
        64: 852,
        /*::[*/
        77: 936,
        /*::[*/
        78: 949,
        /*::[*/
        79: 950,
        /*::[*/
        80: 874,
        /*::[*/
        87: 1252,
        /*::[*/
        88: 1252,
        /*::[*/
        89: 1252,
        /*::[*/
        108: 863,
        /*::[*/
        134: 737,
        /*::[*/
        135: 852,
        /*::[*/
        136: 857,
        /*::[*/
        204: 1257,
        /*::[*/
        255: 16969
      };
      var dbf_reverse_map = evert({
        /*::[*/
        1: 437,
        /*::[*/
        2: 850,
        /*::[*/
        3: 1252,
        /*::[*/
        4: 1e4,
        /*::[*/
        100: 852,
        /*::[*/
        101: 866,
        /*::[*/
        102: 865,
        /*::[*/
        103: 861,
        /*::[*/
        104: 895,
        /*::[*/
        105: 620,
        /*::[*/
        106: 737,
        /*::[*/
        107: 857,
        /*::[*/
        120: 950,
        /*::[*/
        121: 949,
        /*::[*/
        122: 936,
        /*::[*/
        123: 932,
        /*::[*/
        124: 874,
        /*::[*/
        125: 1255,
        /*::[*/
        126: 1256,
        /*::[*/
        150: 10007,
        /*::[*/
        151: 10029,
        /*::[*/
        152: 10006,
        /*::[*/
        200: 1250,
        /*::[*/
        201: 1251,
        /*::[*/
        202: 1254,
        /*::[*/
        203: 1253,
        /*::[*/
        0: 20127
      });
      function dbf_to_aoa(buf, opts) {
        var out = [];
        var d = new_raw_buf(1);
        switch (opts.type) {
          case "base64":
            d = s2a(Base64_decode(buf));
            break;
          case "binary":
            d = s2a(buf);
            break;
          case "buffer":
          case "array":
            d = buf;
            break;
        }
        prep_blob(d, 0);
        var ft = d.read_shift(1);
        var memo = !!(ft & 136);
        var vfp = false, l7 = false;
        switch (ft) {
          case 2:
            break;
          case 3:
            break;
          case 48:
            vfp = true;
            memo = true;
            break;
          case 49:
            vfp = true;
            memo = true;
            break;
          case 131:
            break;
          case 139:
            break;
          case 140:
            l7 = true;
            break;
          case 245:
            break;
          default:
            throw new Error("DBF Unsupported Version: " + ft.toString(16));
        }
        var nrow = 0, fpos = 521;
        if (ft == 2)
          nrow = d.read_shift(2);
        d.l += 3;
        if (ft != 2)
          nrow = d.read_shift(4);
        if (nrow > 1048576)
          nrow = 1e6;
        if (ft != 2)
          fpos = d.read_shift(2);
        var rlen = d.read_shift(2);
        var current_cp = opts.codepage || 1252;
        if (ft != 2) {
          d.l += 16;
          d.read_shift(1);
          if (d[d.l] !== 0)
            current_cp = dbf_codepage_map[d[d.l]];
          d.l += 1;
          d.l += 2;
        }
        if (l7)
          d.l += 36;
        var fields = [], field = {};
        var hend = Math.min(d.length, ft == 2 ? 521 : fpos - 10 - (vfp ? 264 : 0));
        var ww = l7 ? 32 : 11;
        while (d.l < hend && d[d.l] != 13) {
          field = {};
          field.name = $cptable.utils.decode(current_cp, d.slice(d.l, d.l + ww)).replace(/[\u0000\r\n].*$/g, "");
          d.l += ww;
          field.type = String.fromCharCode(d.read_shift(1));
          if (ft != 2 && !l7)
            field.offset = d.read_shift(4);
          field.len = d.read_shift(1);
          if (ft == 2)
            field.offset = d.read_shift(2);
          field.dec = d.read_shift(1);
          if (field.name.length)
            fields.push(field);
          if (ft != 2)
            d.l += l7 ? 13 : 14;
          switch (field.type) {
            case "B":
              if ((!vfp || field.len != 8) && opts.WTF)
                console.log("Skipping " + field.name + ":" + field.type);
              break;
            case "G":
            case "P":
              if (opts.WTF)
                console.log("Skipping " + field.name + ":" + field.type);
              break;
            case "+":
            case "0":
            case "@":
            case "C":
            case "D":
            case "F":
            case "I":
            case "L":
            case "M":
            case "N":
            case "O":
            case "T":
            case "Y":
              break;
            default:
              throw new Error("Unknown Field Type: " + field.type);
          }
        }
        if (d[d.l] !== 13)
          d.l = fpos - 1;
        if (d.read_shift(1) !== 13)
          throw new Error("DBF Terminator not found " + d.l + " " + d[d.l]);
        d.l = fpos;
        var R = 0, C = 0;
        out[0] = [];
        for (C = 0; C != fields.length; ++C)
          out[0][C] = fields[C].name;
        while (nrow-- > 0) {
          if (d[d.l] === 42) {
            d.l += rlen;
            continue;
          }
          ++d.l;
          out[++R] = [];
          C = 0;
          for (C = 0; C != fields.length; ++C) {
            var dd = d.slice(d.l, d.l + fields[C].len);
            d.l += fields[C].len;
            prep_blob(dd, 0);
            var s = $cptable.utils.decode(current_cp, dd);
            switch (fields[C].type) {
              case "C":
                if (s.trim().length)
                  out[R][C] = s.replace(/\s+$/, "");
                break;
              case "D":
                if (s.length === 8)
                  out[R][C] = new Date(+s.slice(0, 4), +s.slice(4, 6) - 1, +s.slice(6, 8));
                else
                  out[R][C] = s;
                break;
              case "F":
                out[R][C] = parseFloat(s.trim());
                break;
              case "+":
              case "I":
                out[R][C] = l7 ? dd.read_shift(-4, "i") ^ 2147483648 : dd.read_shift(4, "i");
                break;
              case "L":
                switch (s.trim().toUpperCase()) {
                  case "Y":
                  case "T":
                    out[R][C] = true;
                    break;
                  case "N":
                  case "F":
                    out[R][C] = false;
                    break;
                  case "":
                  case "?":
                    break;
                  default:
                    throw new Error("DBF Unrecognized L:|" + s + "|");
                }
                break;
              case "M":
                if (!memo)
                  throw new Error("DBF Unexpected MEMO for type " + ft.toString(16));
                out[R][C] = "##MEMO##" + (l7 ? parseInt(s.trim(), 10) : dd.read_shift(4));
                break;
              case "N":
                s = s.replace(/\u0000/g, "").trim();
                if (s && s != ".")
                  out[R][C] = +s || 0;
                break;
              case "@":
                out[R][C] = new Date(dd.read_shift(-8, "f") - 621356832e5);
                break;
              case "T":
                out[R][C] = new Date((dd.read_shift(4) - 2440588) * 864e5 + dd.read_shift(4));
                break;
              case "Y":
                out[R][C] = dd.read_shift(4, "i") / 1e4 + dd.read_shift(4, "i") / 1e4 * Math.pow(2, 32);
                break;
              case "O":
                out[R][C] = -dd.read_shift(-8, "f");
                break;
              case "B":
                if (vfp && fields[C].len == 8) {
                  out[R][C] = dd.read_shift(8, "f");
                  break;
                }
              case "G":
              case "P":
                dd.l += fields[C].len;
                break;
              case "0":
                if (fields[C].name === "_NullFlags")
                  break;
              default:
                throw new Error("DBF Unsupported data type " + fields[C].type);
            }
          }
        }
        if (ft != 2) {
          if (d.l < d.length && d[d.l++] != 26)
            throw new Error("DBF EOF Marker missing " + (d.l - 1) + " of " + d.length + " " + d[d.l - 1].toString(16));
        }
        if (opts && opts.sheetRows)
          out = out.slice(0, opts.sheetRows);
        opts.DBF = fields;
        return out;
      }
      function dbf_to_sheet(buf, opts) {
        var o = opts || {};
        if (!o.dateNF)
          o.dateNF = "yyyymmdd";
        var ws = aoa_to_sheet(dbf_to_aoa(buf, o), o);
        ws["!cols"] = o.DBF.map(function(field) {
          return {
            wch: field.len,
            DBF: field
          };
        });
        delete o.DBF;
        return ws;
      }
      function dbf_to_workbook(buf, opts) {
        try {
          return sheet_to_workbook(dbf_to_sheet(buf, opts), opts);
        } catch (e) {
          if (opts && opts.WTF)
            throw e;
        }
        return { SheetNames: [], Sheets: {} };
      }
      var _RLEN = { "B": 8, "C": 250, "L": 1, "D": 8, "?": 0, "": 0 };
      function sheet_to_dbf(ws, opts) {
        var o = opts || {};
        if (+o.codepage >= 0)
          set_cp(+o.codepage);
        if (o.type == "string")
          throw new Error("Cannot write DBF to JS string");
        var ba = buf_array();
        var aoa = sheet_to_json(ws, { header: 1, raw: true, cellDates: true });
        var headers = aoa[0], data = aoa.slice(1), cols = ws["!cols"] || [];
        var i = 0, j = 0, hcnt = 0, rlen = 1;
        for (i = 0; i < headers.length; ++i) {
          if (((cols[i] || {}).DBF || {}).name) {
            headers[i] = cols[i].DBF.name;
            ++hcnt;
            continue;
          }
          if (headers[i] == null)
            continue;
          ++hcnt;
          if (typeof headers[i] === "number")
            headers[i] = headers[i].toString(10);
          if (typeof headers[i] !== "string")
            throw new Error("DBF Invalid column name " + headers[i] + " |" + typeof headers[i] + "|");
          if (headers.indexOf(headers[i]) !== i) {
            for (j = 0; j < 1024; ++j)
              if (headers.indexOf(headers[i] + "_" + j) == -1) {
                headers[i] += "_" + j;
                break;
              }
          }
        }
        var range = safe_decode_range(ws["!ref"]);
        var coltypes = [];
        var colwidths = [];
        var coldecimals = [];
        for (i = 0; i <= range.e.c - range.s.c; ++i) {
          var guess = "", _guess = "", maxlen = 0;
          var col = [];
          for (j = 0; j < data.length; ++j) {
            if (data[j][i] != null)
              col.push(data[j][i]);
          }
          if (col.length == 0 || headers[i] == null) {
            coltypes[i] = "?";
            continue;
          }
          for (j = 0; j < col.length; ++j) {
            switch (typeof col[j]) {
              case "number":
                _guess = "B";
                break;
              case "string":
                _guess = "C";
                break;
              case "boolean":
                _guess = "L";
                break;
              case "object":
                _guess = col[j] instanceof Date ? "D" : "C";
                break;
              default:
                _guess = "C";
            }
            maxlen = Math.max(maxlen, String(col[j]).length);
            guess = guess && guess != _guess ? "C" : _guess;
          }
          if (maxlen > 250)
            maxlen = 250;
          _guess = ((cols[i] || {}).DBF || {}).type;
          if (_guess == "C") {
            if (cols[i].DBF.len > maxlen)
              maxlen = cols[i].DBF.len;
          }
          if (guess == "B" && _guess == "N") {
            guess = "N";
            coldecimals[i] = cols[i].DBF.dec;
            maxlen = cols[i].DBF.len;
          }
          colwidths[i] = guess == "C" || _guess == "N" ? maxlen : _RLEN[guess] || 0;
          rlen += colwidths[i];
          coltypes[i] = guess;
        }
        var h = ba.next(32);
        h.write_shift(4, 318902576);
        h.write_shift(4, data.length);
        h.write_shift(2, 296 + 32 * hcnt);
        h.write_shift(2, rlen);
        for (i = 0; i < 4; ++i)
          h.write_shift(4, 0);
        h.write_shift(4, 0 | (+dbf_reverse_map[
          /*::String(*/
          current_ansi
          /*::)*/
        ] || 3) << 8);
        for (i = 0, j = 0; i < headers.length; ++i) {
          if (headers[i] == null)
            continue;
          var hf = ba.next(32);
          var _f = (headers[i].slice(-10) + "\0\0\0\0\0\0\0\0\0\0\0").slice(0, 11);
          hf.write_shift(1, _f, "sbcs");
          hf.write_shift(1, coltypes[i] == "?" ? "C" : coltypes[i], "sbcs");
          hf.write_shift(4, j);
          hf.write_shift(1, colwidths[i] || _RLEN[coltypes[i]] || 0);
          hf.write_shift(1, coldecimals[i] || 0);
          hf.write_shift(1, 2);
          hf.write_shift(4, 0);
          hf.write_shift(1, 0);
          hf.write_shift(4, 0);
          hf.write_shift(4, 0);
          j += colwidths[i] || _RLEN[coltypes[i]] || 0;
        }
        var hb = ba.next(264);
        hb.write_shift(4, 13);
        for (i = 0; i < 65; ++i)
          hb.write_shift(4, 0);
        for (i = 0; i < data.length; ++i) {
          var rout = ba.next(rlen);
          rout.write_shift(1, 0);
          for (j = 0; j < headers.length; ++j) {
            if (headers[j] == null)
              continue;
            switch (coltypes[j]) {
              case "L":
                rout.write_shift(1, data[i][j] == null ? 63 : data[i][j] ? 84 : 70);
                break;
              case "B":
                rout.write_shift(8, data[i][j] || 0, "f");
                break;
              case "N":
                var _n = "0";
                if (typeof data[i][j] == "number")
                  _n = data[i][j].toFixed(coldecimals[j] || 0);
                for (hcnt = 0; hcnt < colwidths[j] - _n.length; ++hcnt)
                  rout.write_shift(1, 32);
                rout.write_shift(1, _n, "sbcs");
                break;
              case "D":
                if (!data[i][j])
                  rout.write_shift(8, "00000000", "sbcs");
                else {
                  rout.write_shift(4, ("0000" + data[i][j].getFullYear()).slice(-4), "sbcs");
                  rout.write_shift(2, ("00" + (data[i][j].getMonth() + 1)).slice(-2), "sbcs");
                  rout.write_shift(2, ("00" + data[i][j].getDate()).slice(-2), "sbcs");
                }
                break;
              case "C":
                var _s = String(data[i][j] != null ? data[i][j] : "").slice(0, colwidths[j]);
                rout.write_shift(1, _s, "sbcs");
                for (hcnt = 0; hcnt < colwidths[j] - _s.length; ++hcnt)
                  rout.write_shift(1, 32);
                break;
            }
          }
        }
        ba.next(1).write_shift(1, 26);
        return ba.end();
      }
      return {
        to_workbook: dbf_to_workbook,
        to_sheet: dbf_to_sheet,
        from_sheet: sheet_to_dbf
      };
    }();
    var SYLK = /* @__PURE__ */ function() {
      var sylk_escapes = {
        AA: "\xC0",
        BA: "\xC1",
        CA: "\xC2",
        DA: 195,
        HA: "\xC4",
        JA: 197,
        AE: "\xC8",
        BE: "\xC9",
        CE: "\xCA",
        HE: "\xCB",
        AI: "\xCC",
        BI: "\xCD",
        CI: "\xCE",
        HI: "\xCF",
        AO: "\xD2",
        BO: "\xD3",
        CO: "\xD4",
        DO: 213,
        HO: "\xD6",
        AU: "\xD9",
        BU: "\xDA",
        CU: "\xDB",
        HU: "\xDC",
        Aa: "\xE0",
        Ba: "\xE1",
        Ca: "\xE2",
        Da: 227,
        Ha: "\xE4",
        Ja: 229,
        Ae: "\xE8",
        Be: "\xE9",
        Ce: "\xEA",
        He: "\xEB",
        Ai: "\xEC",
        Bi: "\xED",
        Ci: "\xEE",
        Hi: "\xEF",
        Ao: "\xF2",
        Bo: "\xF3",
        Co: "\xF4",
        Do: 245,
        Ho: "\xF6",
        Au: "\xF9",
        Bu: "\xFA",
        Cu: "\xFB",
        Hu: "\xFC",
        KC: "\xC7",
        Kc: "\xE7",
        q: "\xE6",
        z: "\u0153",
        a: "\xC6",
        j: "\u0152",
        DN: 209,
        Dn: 241,
        Hy: 255,
        S: 169,
        c: 170,
        R: 174,
        "B ": 180,
        /*::[*/
        0: 176,
        /*::[*/
        1: 177,
        /*::[*/
        2: 178,
        /*::[*/
        3: 179,
        /*::[*/
        5: 181,
        /*::[*/
        6: 182,
        /*::[*/
        7: 183,
        Q: 185,
        k: 186,
        b: 208,
        i: 216,
        l: 222,
        s: 240,
        y: 248,
        "!": 161,
        '"': 162,
        "#": 163,
        "(": 164,
        "%": 165,
        "'": 167,
        "H ": 168,
        "+": 171,
        ";": 187,
        "<": 188,
        "=": 189,
        ">": 190,
        "?": 191,
        "{": 223
      };
      var sylk_char_regex = new RegExp("\x1BN(" + keys(sylk_escapes).join("|").replace(/\|\|\|/, "|\\||").replace(/([?()+])/g, "\\$1") + "|\\|)", "gm");
      var sylk_char_fn = function(_2, $1) {
        var o = sylk_escapes[$1];
        return typeof o == "number" ? _getansi(o) : o;
      };
      var decode_sylk_char = function($$, $1, $2) {
        var newcc = $1.charCodeAt(0) - 32 << 4 | $2.charCodeAt(0) - 48;
        return newcc == 59 ? $$ : _getansi(newcc);
      };
      sylk_escapes["|"] = 254;
      function sylk_to_aoa(d, opts) {
        switch (opts.type) {
          case "base64":
            return sylk_to_aoa_str(Base64_decode(d), opts);
          case "binary":
            return sylk_to_aoa_str(d, opts);
          case "buffer":
            return sylk_to_aoa_str(has_buf && Buffer.isBuffer(d) ? d.toString("binary") : a2s(d), opts);
          case "array":
            return sylk_to_aoa_str(cc2str(d), opts);
        }
        throw new Error("Unrecognized type " + opts.type);
      }
      function sylk_to_aoa_str(str, opts) {
        var records = str.split(/[\n\r]+/), R = -1, C = -1, ri = 0, rj = 0, arr = [];
        var formats = [];
        var next_cell_format = null;
        var sht = {}, rowinfo = [], colinfo = [], cw = [];
        var Mval = 0, j;
        if (+opts.codepage >= 0)
          set_cp(+opts.codepage);
        for (; ri !== records.length; ++ri) {
          Mval = 0;
          var rstr = records[ri].trim().replace(/\x1B([\x20-\x2F])([\x30-\x3F])/g, decode_sylk_char).replace(sylk_char_regex, sylk_char_fn);
          var record = rstr.replace(/;;/g, "\0").split(";").map(function(x) {
            return x.replace(/\u0000/g, ";");
          });
          var RT = record[0], val;
          if (rstr.length > 0)
            switch (RT) {
              case "ID":
                break;
              case "E":
                break;
              case "B":
                break;
              case "O":
                break;
              case "W":
                break;
              case "P":
                if (record[1].charAt(0) == "P")
                  formats.push(rstr.slice(3).replace(/;;/g, ";"));
                break;
              case "C":
                var C_seen_K = false, C_seen_X = false, C_seen_S = false, C_seen_E = false, _R = -1, _C = -1;
                for (rj = 1; rj < record.length; ++rj)
                  switch (record[rj].charAt(0)) {
                    case "A":
                      break;
                    case "X":
                      C = parseInt(record[rj].slice(1)) - 1;
                      C_seen_X = true;
                      break;
                    case "Y":
                      R = parseInt(record[rj].slice(1)) - 1;
                      if (!C_seen_X)
                        C = 0;
                      for (j = arr.length; j <= R; ++j)
                        arr[j] = [];
                      break;
                    case "K":
                      val = record[rj].slice(1);
                      if (val.charAt(0) === '"')
                        val = val.slice(1, val.length - 1);
                      else if (val === "TRUE")
                        val = true;
                      else if (val === "FALSE")
                        val = false;
                      else if (!isNaN(fuzzynum(val))) {
                        val = fuzzynum(val);
                        if (next_cell_format !== null && fmt_is_date(next_cell_format))
                          val = numdate(val);
                      } else if (!isNaN(fuzzydate(val).getDate())) {
                        val = parseDate(val);
                      }
                      C_seen_K = true;
                      break;
                    case "E":
                      C_seen_E = true;
                      var formula = rc_to_a1(record[rj].slice(1), { r: R, c: C });
                      arr[R][C] = [arr[R][C], formula];
                      break;
                    case "S":
                      C_seen_S = true;
                      arr[R][C] = [arr[R][C], "S5S"];
                      break;
                    case "G":
                      break;
                    case "R":
                      _R = parseInt(record[rj].slice(1)) - 1;
                      break;
                    case "C":
                      _C = parseInt(record[rj].slice(1)) - 1;
                      break;
                    default:
                      if (opts && opts.WTF)
                        throw new Error("SYLK bad record " + rstr);
                  }
                if (C_seen_K) {
                  if (arr[R][C] && arr[R][C].length == 2)
                    arr[R][C][0] = val;
                  else
                    arr[R][C] = val;
                  next_cell_format = null;
                }
                if (C_seen_S) {
                  if (C_seen_E)
                    throw new Error("SYLK shared formula cannot have own formula");
                  var shrbase = _R > -1 && arr[_R][_C];
                  if (!shrbase || !shrbase[1])
                    throw new Error("SYLK shared formula cannot find base");
                  arr[R][C][1] = shift_formula_str(shrbase[1], { r: R - _R, c: C - _C });
                }
                break;
              case "F":
                var F_seen = 0;
                for (rj = 1; rj < record.length; ++rj)
                  switch (record[rj].charAt(0)) {
                    case "X":
                      C = parseInt(record[rj].slice(1)) - 1;
                      ++F_seen;
                      break;
                    case "Y":
                      R = parseInt(record[rj].slice(1)) - 1;
                      for (j = arr.length; j <= R; ++j)
                        arr[j] = [];
                      break;
                    case "M":
                      Mval = parseInt(record[rj].slice(1)) / 20;
                      break;
                    case "F":
                      break;
                    case "G":
                      break;
                    case "P":
                      next_cell_format = formats[parseInt(record[rj].slice(1))];
                      break;
                    case "S":
                      break;
                    case "D":
                      break;
                    case "N":
                      break;
                    case "W":
                      cw = record[rj].slice(1).split(" ");
                      for (j = parseInt(cw[0], 10); j <= parseInt(cw[1], 10); ++j) {
                        Mval = parseInt(cw[2], 10);
                        colinfo[j - 1] = Mval === 0 ? { hidden: true } : { wch: Mval };
                        process_col(colinfo[j - 1]);
                      }
                      break;
                    case "C":
                      C = parseInt(record[rj].slice(1)) - 1;
                      if (!colinfo[C])
                        colinfo[C] = {};
                      break;
                    case "R":
                      R = parseInt(record[rj].slice(1)) - 1;
                      if (!rowinfo[R])
                        rowinfo[R] = {};
                      if (Mval > 0) {
                        rowinfo[R].hpt = Mval;
                        rowinfo[R].hpx = pt2px(Mval);
                      } else if (Mval === 0)
                        rowinfo[R].hidden = true;
                      break;
                    default:
                      if (opts && opts.WTF)
                        throw new Error("SYLK bad record " + rstr);
                  }
                if (F_seen < 1)
                  next_cell_format = null;
                break;
              default:
                if (opts && opts.WTF)
                  throw new Error("SYLK bad record " + rstr);
            }
        }
        if (rowinfo.length > 0)
          sht["!rows"] = rowinfo;
        if (colinfo.length > 0)
          sht["!cols"] = colinfo;
        if (opts && opts.sheetRows)
          arr = arr.slice(0, opts.sheetRows);
        return [arr, sht];
      }
      function sylk_to_sheet(d, opts) {
        var aoasht = sylk_to_aoa(d, opts);
        var aoa = aoasht[0], ws = aoasht[1];
        var o = aoa_to_sheet(aoa, opts);
        keys(ws).forEach(function(k) {
          o[k] = ws[k];
        });
        return o;
      }
      function sylk_to_workbook(d, opts) {
        return sheet_to_workbook(sylk_to_sheet(d, opts), opts);
      }
      function write_ws_cell_sylk(cell, ws, R, C) {
        var o = "C;Y" + (R + 1) + ";X" + (C + 1) + ";K";
        switch (cell.t) {
          case "n":
            o += cell.v || 0;
            if (cell.f && !cell.F)
              o += ";E" + a1_to_rc(cell.f, { r: R, c: C });
            break;
          case "b":
            o += cell.v ? "TRUE" : "FALSE";
            break;
          case "e":
            o += cell.w || cell.v;
            break;
          case "d":
            o += '"' + (cell.w || cell.v) + '"';
            break;
          case "s":
            o += '"' + cell.v.replace(/"/g, "").replace(/;/g, ";;") + '"';
            break;
        }
        return o;
      }
      function write_ws_cols_sylk(out, cols) {
        cols.forEach(function(col, i) {
          var rec = "F;W" + (i + 1) + " " + (i + 1) + " ";
          if (col.hidden)
            rec += "0";
          else {
            if (typeof col.width == "number" && !col.wpx)
              col.wpx = width2px(col.width);
            if (typeof col.wpx == "number" && !col.wch)
              col.wch = px2char(col.wpx);
            if (typeof col.wch == "number")
              rec += Math.round(col.wch);
          }
          if (rec.charAt(rec.length - 1) != " ")
            out.push(rec);
        });
      }
      function write_ws_rows_sylk(out, rows) {
        rows.forEach(function(row, i) {
          var rec = "F;";
          if (row.hidden)
            rec += "M0;";
          else if (row.hpt)
            rec += "M" + 20 * row.hpt + ";";
          else if (row.hpx)
            rec += "M" + 20 * px2pt(row.hpx) + ";";
          if (rec.length > 2)
            out.push(rec + "R" + (i + 1));
        });
      }
      function sheet_to_sylk(ws, opts) {
        var preamble = ["ID;PWXL;N;E"], o = [];
        var r = safe_decode_range(ws["!ref"]), cell;
        var dense = Array.isArray(ws);
        var RS = "\r\n";
        preamble.push("P;PGeneral");
        preamble.push("F;P0;DG0G8;M255");
        if (ws["!cols"])
          write_ws_cols_sylk(preamble, ws["!cols"]);
        if (ws["!rows"])
          write_ws_rows_sylk(preamble, ws["!rows"]);
        preamble.push("B;Y" + (r.e.r - r.s.r + 1) + ";X" + (r.e.c - r.s.c + 1) + ";D" + [r.s.c, r.s.r, r.e.c, r.e.r].join(" "));
        for (var R = r.s.r; R <= r.e.r; ++R) {
          for (var C = r.s.c; C <= r.e.c; ++C) {
            var coord = encode_cell({ r: R, c: C });
            cell = dense ? (ws[R] || [])[C] : ws[coord];
            if (!cell || cell.v == null && (!cell.f || cell.F))
              continue;
            o.push(write_ws_cell_sylk(cell, ws, R, C));
          }
        }
        return preamble.join(RS) + RS + o.join(RS) + RS + "E" + RS;
      }
      return {
        to_workbook: sylk_to_workbook,
        to_sheet: sylk_to_sheet,
        from_sheet: sheet_to_sylk
      };
    }();
    var DIF = /* @__PURE__ */ function() {
      function dif_to_aoa(d, opts) {
        switch (opts.type) {
          case "base64":
            return dif_to_aoa_str(Base64_decode(d), opts);
          case "binary":
            return dif_to_aoa_str(d, opts);
          case "buffer":
            return dif_to_aoa_str(has_buf && Buffer.isBuffer(d) ? d.toString("binary") : a2s(d), opts);
          case "array":
            return dif_to_aoa_str(cc2str(d), opts);
        }
        throw new Error("Unrecognized type " + opts.type);
      }
      function dif_to_aoa_str(str, opts) {
        var records = str.split("\n"), R = -1, C = -1, ri = 0, arr = [];
        for (; ri !== records.length; ++ri) {
          if (records[ri].trim() === "BOT") {
            arr[++R] = [];
            C = 0;
            continue;
          }
          if (R < 0)
            continue;
          var metadata = records[ri].trim().split(",");
          var type = metadata[0], value = metadata[1];
          ++ri;
          var data = records[ri] || "";
          while ((data.match(/["]/g) || []).length & 1 && ri < records.length - 1)
            data += "\n" + records[++ri];
          data = data.trim();
          switch (+type) {
            case -1:
              if (data === "BOT") {
                arr[++R] = [];
                C = 0;
                continue;
              } else if (data !== "EOD")
                throw new Error("Unrecognized DIF special command " + data);
              break;
            case 0:
              if (data === "TRUE")
                arr[R][C] = true;
              else if (data === "FALSE")
                arr[R][C] = false;
              else if (!isNaN(fuzzynum(value)))
                arr[R][C] = fuzzynum(value);
              else if (!isNaN(fuzzydate(value).getDate()))
                arr[R][C] = parseDate(value);
              else
                arr[R][C] = value;
              ++C;
              break;
            case 1:
              data = data.slice(1, data.length - 1);
              data = data.replace(/""/g, '"');
              if (data && data.match(/^=".*"$/))
                data = data.slice(2, -1);
              arr[R][C++] = data !== "" ? data : null;
              break;
          }
          if (data === "EOD")
            break;
        }
        if (opts && opts.sheetRows)
          arr = arr.slice(0, opts.sheetRows);
        return arr;
      }
      function dif_to_sheet(str, opts) {
        return aoa_to_sheet(dif_to_aoa(str, opts), opts);
      }
      function dif_to_workbook(str, opts) {
        return sheet_to_workbook(dif_to_sheet(str, opts), opts);
      }
      var sheet_to_dif = /* @__PURE__ */ function() {
        var push_field = function pf(o, topic, v, n, s) {
          o.push(topic);
          o.push(v + "," + n);
          o.push('"' + s.replace(/"/g, '""') + '"');
        };
        var push_value = function po(o, type, v, s) {
          o.push(type + "," + v);
          o.push(type == 1 ? '"' + s.replace(/"/g, '""') + '"' : s);
        };
        return function sheet_to_dif2(ws) {
          var o = [];
          var r = safe_decode_range(ws["!ref"]), cell;
          var dense = Array.isArray(ws);
          push_field(o, "TABLE", 0, 1, "sheetjs");
          push_field(o, "VECTORS", 0, r.e.r - r.s.r + 1, "");
          push_field(o, "TUPLES", 0, r.e.c - r.s.c + 1, "");
          push_field(o, "DATA", 0, 0, "");
          for (var R = r.s.r; R <= r.e.r; ++R) {
            push_value(o, -1, 0, "BOT");
            for (var C = r.s.c; C <= r.e.c; ++C) {
              var coord = encode_cell({ r: R, c: C });
              cell = dense ? (ws[R] || [])[C] : ws[coord];
              if (!cell) {
                push_value(o, 1, 0, "");
                continue;
              }
              switch (cell.t) {
                case "n":
                  var val = cell.w;
                  if (!val && cell.v != null)
                    val = cell.v;
                  if (val == null) {
                    if (cell.f && !cell.F)
                      push_value(o, 1, 0, "=" + cell.f);
                    else
                      push_value(o, 1, 0, "");
                  } else
                    push_value(o, 0, val, "V");
                  break;
                case "b":
                  push_value(o, 0, cell.v ? 1 : 0, cell.v ? "TRUE" : "FALSE");
                  break;
                case "s":
                  push_value(o, 1, 0, isNaN(cell.v) ? cell.v : '="' + cell.v + '"');
                  break;
                case "d":
                  if (!cell.w)
                    cell.w = SSF_format(cell.z || table_fmt[14], datenum(parseDate(cell.v)));
                  push_value(o, 0, cell.w, "V");
                  break;
                default:
                  push_value(o, 1, 0, "");
              }
            }
          }
          push_value(o, -1, 0, "EOD");
          var RS = "\r\n";
          var oo = o.join(RS);
          return oo;
        };
      }();
      return {
        to_workbook: dif_to_workbook,
        to_sheet: dif_to_sheet,
        from_sheet: sheet_to_dif
      };
    }();
    var ETH = /* @__PURE__ */ function() {
      function decode(s) {
        return s.replace(/\\b/g, "\\").replace(/\\c/g, ":").replace(/\\n/g, "\n");
      }
      function encode2(s) {
        return s.replace(/\\/g, "\\b").replace(/:/g, "\\c").replace(/\n/g, "\\n");
      }
      function eth_to_aoa(str, opts) {
        var records = str.split("\n"), R = -1, C = -1, ri = 0, arr = [];
        for (; ri !== records.length; ++ri) {
          var record = records[ri].trim().split(":");
          if (record[0] !== "cell")
            continue;
          var addr = decode_cell(record[1]);
          if (arr.length <= addr.r) {
            for (R = arr.length; R <= addr.r; ++R)
              if (!arr[R])
                arr[R] = [];
          }
          R = addr.r;
          C = addr.c;
          switch (record[2]) {
            case "t":
              arr[R][C] = decode(record[3]);
              break;
            case "v":
              arr[R][C] = +record[3];
              break;
            case "vtf":
              var _f = record[record.length - 1];
            case "vtc":
              switch (record[3]) {
                case "nl":
                  arr[R][C] = +record[4] ? true : false;
                  break;
                default:
                  arr[R][C] = +record[4];
                  break;
              }
              if (record[2] == "vtf")
                arr[R][C] = [arr[R][C], _f];
          }
        }
        if (opts && opts.sheetRows)
          arr = arr.slice(0, opts.sheetRows);
        return arr;
      }
      function eth_to_sheet(d, opts) {
        return aoa_to_sheet(eth_to_aoa(d, opts), opts);
      }
      function eth_to_workbook(d, opts) {
        return sheet_to_workbook(eth_to_sheet(d, opts), opts);
      }
      var header = [
        "socialcalc:version:1.5",
        "MIME-Version: 1.0",
        "Content-Type: multipart/mixed; boundary=SocialCalcSpreadsheetControlSave"
      ].join("\n");
      var sep = [
        "--SocialCalcSpreadsheetControlSave",
        "Content-type: text/plain; charset=UTF-8"
      ].join("\n") + "\n";
      var meta = [
        "# SocialCalc Spreadsheet Control Save",
        "part:sheet"
      ].join("\n");
      var end = "--SocialCalcSpreadsheetControlSave--";
      function sheet_to_eth_data(ws) {
        if (!ws || !ws["!ref"])
          return "";
        var o = [], oo = [], cell, coord = "";
        var r = decode_range(ws["!ref"]);
        var dense = Array.isArray(ws);
        for (var R = r.s.r; R <= r.e.r; ++R) {
          for (var C = r.s.c; C <= r.e.c; ++C) {
            coord = encode_cell({ r: R, c: C });
            cell = dense ? (ws[R] || [])[C] : ws[coord];
            if (!cell || cell.v == null || cell.t === "z")
              continue;
            oo = ["cell", coord, "t"];
            switch (cell.t) {
              case "s":
              case "str":
                oo.push(encode2(cell.v));
                break;
              case "n":
                if (!cell.f) {
                  oo[2] = "v";
                  oo[3] = cell.v;
                } else {
                  oo[2] = "vtf";
                  oo[3] = "n";
                  oo[4] = cell.v;
                  oo[5] = encode2(cell.f);
                }
                break;
              case "b":
                oo[2] = "vt" + (cell.f ? "f" : "c");
                oo[3] = "nl";
                oo[4] = cell.v ? "1" : "0";
                oo[5] = encode2(cell.f || (cell.v ? "TRUE" : "FALSE"));
                break;
              case "d":
                var t = datenum(parseDate(cell.v));
                oo[2] = "vtc";
                oo[3] = "nd";
                oo[4] = "" + t;
                oo[5] = cell.w || SSF_format(cell.z || table_fmt[14], t);
                break;
              case "e":
                continue;
            }
            o.push(oo.join(":"));
          }
        }
        o.push("sheet:c:" + (r.e.c - r.s.c + 1) + ":r:" + (r.e.r - r.s.r + 1) + ":tvf:1");
        o.push("valueformat:1:text-wiki");
        return o.join("\n");
      }
      function sheet_to_eth(ws) {
        return [header, sep, meta, sep, sheet_to_eth_data(ws), end].join("\n");
      }
      return {
        to_workbook: eth_to_workbook,
        to_sheet: eth_to_sheet,
        from_sheet: sheet_to_eth
      };
    }();
    var PRN = /* @__PURE__ */ function() {
      function set_text_arr(data, arr, R, C, o) {
        if (o.raw)
          arr[R][C] = data;
        else if (data === "")
          ;
        else if (data === "TRUE")
          arr[R][C] = true;
        else if (data === "FALSE")
          arr[R][C] = false;
        else if (!isNaN(fuzzynum(data)))
          arr[R][C] = fuzzynum(data);
        else if (!isNaN(fuzzydate(data).getDate()))
          arr[R][C] = parseDate(data);
        else
          arr[R][C] = data;
      }
      function prn_to_aoa_str(f, opts) {
        var o = opts || {};
        var arr = [];
        if (!f || f.length === 0)
          return arr;
        var lines = f.split(/[\r\n]/);
        var L = lines.length - 1;
        while (L >= 0 && lines[L].length === 0)
          --L;
        var start = 10, idx = 0;
        var R = 0;
        for (; R <= L; ++R) {
          idx = lines[R].indexOf(" ");
          if (idx == -1)
            idx = lines[R].length;
          else
            idx++;
          start = Math.max(start, idx);
        }
        for (R = 0; R <= L; ++R) {
          arr[R] = [];
          var C = 0;
          set_text_arr(lines[R].slice(0, start).trim(), arr, R, C, o);
          for (C = 1; C <= (lines[R].length - start) / 10 + 1; ++C)
            set_text_arr(lines[R].slice(start + (C - 1) * 10, start + C * 10).trim(), arr, R, C, o);
        }
        if (o.sheetRows)
          arr = arr.slice(0, o.sheetRows);
        return arr;
      }
      var guess_seps = {
        /*::[*/
        44: ",",
        /*::[*/
        9: "	",
        /*::[*/
        59: ";",
        /*::[*/
        124: "|"
      };
      var guess_sep_weights = {
        /*::[*/
        44: 3,
        /*::[*/
        9: 2,
        /*::[*/
        59: 1,
        /*::[*/
        124: 0
      };
      function guess_sep(str) {
        var cnt = {}, instr = false, end = 0, cc = 0;
        for (; end < str.length; ++end) {
          if ((cc = str.charCodeAt(end)) == 34)
            instr = !instr;
          else if (!instr && cc in guess_seps)
            cnt[cc] = (cnt[cc] || 0) + 1;
        }
        cc = [];
        for (end in cnt)
          if (Object.prototype.hasOwnProperty.call(cnt, end)) {
            cc.push([cnt[end], end]);
          }
        if (!cc.length) {
          cnt = guess_sep_weights;
          for (end in cnt)
            if (Object.prototype.hasOwnProperty.call(cnt, end)) {
              cc.push([cnt[end], end]);
            }
        }
        cc.sort(function(a, b) {
          return a[0] - b[0] || guess_sep_weights[a[1]] - guess_sep_weights[b[1]];
        });
        return guess_seps[cc.pop()[1]] || 44;
      }
      function dsv_to_sheet_str(str, opts) {
        var o = opts || {};
        var sep = "";
        var ws = o.dense ? [] : {};
        var range = { s: { c: 0, r: 0 }, e: { c: 0, r: 0 } };
        if (str.slice(0, 4) == "sep=") {
          if (str.charCodeAt(5) == 13 && str.charCodeAt(6) == 10) {
            sep = str.charAt(4);
            str = str.slice(7);
          } else if (str.charCodeAt(5) == 13 || str.charCodeAt(5) == 10) {
            sep = str.charAt(4);
            str = str.slice(6);
          } else
            sep = guess_sep(str.slice(0, 1024));
        } else if (o && o.FS)
          sep = o.FS;
        else
          sep = guess_sep(str.slice(0, 1024));
        var R = 0, C = 0, v = 0;
        var start = 0, end = 0, sepcc = sep.charCodeAt(0), instr = false, cc = 0, startcc = str.charCodeAt(0);
        str = str.replace(/\r\n/mg, "\n");
        var _re = o.dateNF != null ? dateNF_regex(o.dateNF) : null;
        function finish_cell() {
          var s = str.slice(start, end);
          var cell = {};
          if (s.charAt(0) == '"' && s.charAt(s.length - 1) == '"')
            s = s.slice(1, -1).replace(/""/g, '"');
          if (s.length === 0)
            cell.t = "z";
          else if (o.raw) {
            cell.t = "s";
            cell.v = s;
          } else if (s.trim().length === 0) {
            cell.t = "s";
            cell.v = s;
          } else if (s.charCodeAt(0) == 61) {
            if (s.charCodeAt(1) == 34 && s.charCodeAt(s.length - 1) == 34) {
              cell.t = "s";
              cell.v = s.slice(2, -1).replace(/""/g, '"');
            } else if (fuzzyfmla(s)) {
              cell.t = "n";
              cell.f = s.slice(1);
            } else {
              cell.t = "s";
              cell.v = s;
            }
          } else if (s == "TRUE") {
            cell.t = "b";
            cell.v = true;
          } else if (s == "FALSE") {
            cell.t = "b";
            cell.v = false;
          } else if (!isNaN(v = fuzzynum(s))) {
            cell.t = "n";
            if (o.cellText !== false)
              cell.w = s;
            cell.v = v;
          } else if (!isNaN(fuzzydate(s).getDate()) || _re && s.match(_re)) {
            cell.z = o.dateNF || table_fmt[14];
            var k = 0;
            if (_re && s.match(_re)) {
              s = dateNF_fix(s, o.dateNF, s.match(_re) || []);
              k = 1;
            }
            if (o.cellDates) {
              cell.t = "d";
              cell.v = parseDate(s, k);
            } else {
              cell.t = "n";
              cell.v = datenum(parseDate(s, k));
            }
            if (o.cellText !== false)
              cell.w = SSF_format(cell.z, cell.v instanceof Date ? datenum(cell.v) : cell.v);
            if (!o.cellNF)
              delete cell.z;
          } else {
            cell.t = "s";
            cell.v = s;
          }
          if (cell.t == "z")
            ;
          else if (o.dense) {
            if (!ws[R])
              ws[R] = [];
            ws[R][C] = cell;
          } else
            ws[encode_cell({ c: C, r: R })] = cell;
          start = end + 1;
          startcc = str.charCodeAt(start);
          if (range.e.c < C)
            range.e.c = C;
          if (range.e.r < R)
            range.e.r = R;
          if (cc == sepcc)
            ++C;
          else {
            C = 0;
            ++R;
            if (o.sheetRows && o.sheetRows <= R)
              return true;
          }
        }
        outer:
          for (; end < str.length; ++end)
            switch (cc = str.charCodeAt(end)) {
              case 34:
                if (startcc === 34)
                  instr = !instr;
                break;
              case sepcc:
              case 10:
              case 13:
                if (!instr && finish_cell())
                  break outer;
                break;
            }
        if (end - start > 0)
          finish_cell();
        ws["!ref"] = encode_range(range);
        return ws;
      }
      function prn_to_sheet_str(str, opts) {
        if (!(opts && opts.PRN))
          return dsv_to_sheet_str(str, opts);
        if (opts.FS)
          return dsv_to_sheet_str(str, opts);
        if (str.slice(0, 4) == "sep=")
          return dsv_to_sheet_str(str, opts);
        if (str.indexOf("	") >= 0 || str.indexOf(",") >= 0 || str.indexOf(";") >= 0)
          return dsv_to_sheet_str(str, opts);
        return aoa_to_sheet(prn_to_aoa_str(str, opts), opts);
      }
      function prn_to_sheet(d, opts) {
        var str = "", bytes = opts.type == "string" ? [0, 0, 0, 0] : firstbyte(d, opts);
        switch (opts.type) {
          case "base64":
            str = Base64_decode(d);
            break;
          case "binary":
            str = d;
            break;
          case "buffer":
            if (opts.codepage == 65001)
              str = d.toString("utf8");
            else if (opts.codepage && false)
              ;
            else
              str = has_buf && Buffer.isBuffer(d) ? d.toString("binary") : a2s(d);
            break;
          case "array":
            str = cc2str(d);
            break;
          case "string":
            str = d;
            break;
          default:
            throw new Error("Unrecognized type " + opts.type);
        }
        if (bytes[0] == 239 && bytes[1] == 187 && bytes[2] == 191)
          str = utf8read(str.slice(3));
        else if (opts.type != "string" && opts.type != "buffer" && opts.codepage == 65001)
          str = utf8read(str);
        else if (opts.type == "binary" && false)
          ;
        if (str.slice(0, 19) == "socialcalc:version:")
          return ETH.to_sheet(opts.type == "string" ? str : utf8read(str), opts);
        return prn_to_sheet_str(str, opts);
      }
      function prn_to_workbook(d, opts) {
        return sheet_to_workbook(prn_to_sheet(d, opts), opts);
      }
      function sheet_to_prn(ws) {
        var o = [];
        var r = safe_decode_range(ws["!ref"]), cell;
        var dense = Array.isArray(ws);
        for (var R = r.s.r; R <= r.e.r; ++R) {
          var oo = [];
          for (var C = r.s.c; C <= r.e.c; ++C) {
            var coord = encode_cell({ r: R, c: C });
            cell = dense ? (ws[R] || [])[C] : ws[coord];
            if (!cell || cell.v == null) {
              oo.push("          ");
              continue;
            }
            var w = (cell.w || (format_cell(cell), cell.w) || "").slice(0, 10);
            while (w.length < 10)
              w += " ";
            oo.push(w + (C === 0 ? " " : ""));
          }
          o.push(oo.join(""));
        }
        return o.join("\n");
      }
      return {
        to_workbook: prn_to_workbook,
        to_sheet: prn_to_sheet,
        from_sheet: sheet_to_prn
      };
    }();
    var WK_ = /* @__PURE__ */ function() {
      function lotushopper(data, cb, opts) {
        if (!data)
          return;
        prep_blob(data, data.l || 0);
        var Enum = opts.Enum || WK1Enum;
        while (data.l < data.length) {
          var RT = data.read_shift(2);
          var R = Enum[RT] || Enum[65535];
          var length = data.read_shift(2);
          var tgt = data.l + length;
          var d = R.f && R.f(data, length, opts);
          data.l = tgt;
          if (cb(d, R, RT))
            return;
        }
      }
      function lotus_to_workbook(d, opts) {
        switch (opts.type) {
          case "base64":
            return lotus_to_workbook_buf(s2a(Base64_decode(d)), opts);
          case "binary":
            return lotus_to_workbook_buf(s2a(d), opts);
          case "buffer":
          case "array":
            return lotus_to_workbook_buf(d, opts);
        }
        throw "Unsupported type " + opts.type;
      }
      function lotus_to_workbook_buf(d, opts) {
        if (!d)
          return d;
        var o = opts || {};
        var s = o.dense ? [] : {}, n = "Sheet1", next_n = "", sidx = 0;
        var sheets = {}, snames = [], realnames = [];
        var refguess = { s: { r: 0, c: 0 }, e: { r: 0, c: 0 } };
        var sheetRows = o.sheetRows || 0;
        if (d[2] == 0) {
          if (d[3] == 8 || d[3] == 9) {
            if (d.length >= 16 && d[14] == 5 && d[15] === 108)
              throw new Error("Unsupported Works 3 for Mac file");
          }
        }
        if (d[2] == 2) {
          o.Enum = WK1Enum;
          lotushopper(d, function(val, R, RT) {
            switch (RT) {
              case 0:
                o.vers = val;
                if (val >= 4096)
                  o.qpro = true;
                break;
              case 6:
                refguess = val;
                break;
              case 204:
                if (val)
                  next_n = val;
                break;
              case 222:
                next_n = val;
                break;
              case 15:
              case 51:
                if (!o.qpro)
                  val[1].v = val[1].v.slice(1);
              case 13:
              case 14:
              case 16:
                if (RT == 14 && (val[2] & 112) == 112 && (val[2] & 15) > 1 && (val[2] & 15) < 15) {
                  val[1].z = o.dateNF || table_fmt[14];
                  if (o.cellDates) {
                    val[1].t = "d";
                    val[1].v = numdate(val[1].v);
                  }
                }
                if (o.qpro) {
                  if (val[3] > sidx) {
                    s["!ref"] = encode_range(refguess);
                    sheets[n] = s;
                    snames.push(n);
                    s = o.dense ? [] : {};
                    refguess = { s: { r: 0, c: 0 }, e: { r: 0, c: 0 } };
                    sidx = val[3];
                    n = next_n || "Sheet" + (sidx + 1);
                    next_n = "";
                  }
                }
                var tmpcell = o.dense ? (s[val[0].r] || [])[val[0].c] : s[encode_cell(val[0])];
                if (tmpcell) {
                  tmpcell.t = val[1].t;
                  tmpcell.v = val[1].v;
                  if (val[1].z != null)
                    tmpcell.z = val[1].z;
                  if (val[1].f != null)
                    tmpcell.f = val[1].f;
                  break;
                }
                if (o.dense) {
                  if (!s[val[0].r])
                    s[val[0].r] = [];
                  s[val[0].r][val[0].c] = val[1];
                } else
                  s[encode_cell(val[0])] = val[1];
                break;
            }
          }, o);
        } else if (d[2] == 26 || d[2] == 14) {
          o.Enum = WK3Enum;
          if (d[2] == 14) {
            o.qpro = true;
            d.l = 0;
          }
          lotushopper(d, function(val, R, RT) {
            switch (RT) {
              case 204:
                n = val;
                break;
              case 22:
                val[1].v = val[1].v.slice(1);
              case 23:
              case 24:
              case 25:
              case 37:
              case 39:
              case 40:
                if (val[3] > sidx) {
                  s["!ref"] = encode_range(refguess);
                  sheets[n] = s;
                  snames.push(n);
                  s = o.dense ? [] : {};
                  refguess = { s: { r: 0, c: 0 }, e: { r: 0, c: 0 } };
                  sidx = val[3];
                  n = "Sheet" + (sidx + 1);
                }
                if (sheetRows > 0 && val[0].r >= sheetRows)
                  break;
                if (o.dense) {
                  if (!s[val[0].r])
                    s[val[0].r] = [];
                  s[val[0].r][val[0].c] = val[1];
                } else
                  s[encode_cell(val[0])] = val[1];
                if (refguess.e.c < val[0].c)
                  refguess.e.c = val[0].c;
                if (refguess.e.r < val[0].r)
                  refguess.e.r = val[0].r;
                break;
              case 27:
                if (val[14e3])
                  realnames[val[14e3][0]] = val[14e3][1];
                break;
              case 1537:
                realnames[val[0]] = val[1];
                if (val[0] == sidx)
                  n = val[1];
                break;
            }
          }, o);
        } else
          throw new Error("Unrecognized LOTUS BOF " + d[2]);
        s["!ref"] = encode_range(refguess);
        sheets[next_n || n] = s;
        snames.push(next_n || n);
        if (!realnames.length)
          return { SheetNames: snames, Sheets: sheets };
        var osheets = {}, rnames = [];
        for (var i = 0; i < realnames.length; ++i)
          if (sheets[snames[i]]) {
            rnames.push(realnames[i] || snames[i]);
            osheets[realnames[i]] = sheets[realnames[i]] || sheets[snames[i]];
          } else {
            rnames.push(realnames[i]);
            osheets[realnames[i]] = { "!ref": "A1" };
          }
        return { SheetNames: rnames, Sheets: osheets };
      }
      function sheet_to_wk1(ws, opts) {
        var o = opts || {};
        if (+o.codepage >= 0)
          set_cp(+o.codepage);
        if (o.type == "string")
          throw new Error("Cannot write WK1 to JS string");
        var ba = buf_array();
        var range = safe_decode_range(ws["!ref"]);
        var dense = Array.isArray(ws);
        var cols = [];
        write_biff_rec(ba, 0, write_BOF_WK1(1030));
        write_biff_rec(ba, 6, write_RANGE(range));
        var max_R = Math.min(range.e.r, 8191);
        for (var R = range.s.r; R <= max_R; ++R) {
          var rr = encode_row(R);
          for (var C = range.s.c; C <= range.e.c; ++C) {
            if (R === range.s.r)
              cols[C] = encode_col(C);
            var ref = cols[C] + rr;
            var cell = dense ? (ws[R] || [])[C] : ws[ref];
            if (!cell || cell.t == "z")
              continue;
            if (cell.t == "n") {
              if ((cell.v | 0) == cell.v && cell.v >= -32768 && cell.v <= 32767)
                write_biff_rec(ba, 13, write_INTEGER(R, C, cell.v));
              else
                write_biff_rec(ba, 14, write_NUMBER(R, C, cell.v));
            } else {
              var str = format_cell(cell);
              write_biff_rec(ba, 15, write_LABEL(R, C, str.slice(0, 239)));
            }
          }
        }
        write_biff_rec(ba, 1);
        return ba.end();
      }
      function book_to_wk3(wb, opts) {
        var o = opts || {};
        if (+o.codepage >= 0)
          set_cp(+o.codepage);
        if (o.type == "string")
          throw new Error("Cannot write WK3 to JS string");
        var ba = buf_array();
        write_biff_rec(ba, 0, write_BOF_WK3(wb));
        for (var i = 0, cnt = 0; i < wb.SheetNames.length; ++i)
          if ((wb.Sheets[wb.SheetNames[i]] || {})["!ref"])
            write_biff_rec(ba, 27, write_XFORMAT_SHEETNAME(wb.SheetNames[i], cnt++));
        var wsidx = 0;
        for (i = 0; i < wb.SheetNames.length; ++i) {
          var ws = wb.Sheets[wb.SheetNames[i]];
          if (!ws || !ws["!ref"])
            continue;
          var range = safe_decode_range(ws["!ref"]);
          var dense = Array.isArray(ws);
          var cols = [];
          var max_R = Math.min(range.e.r, 8191);
          for (var R = range.s.r; R <= max_R; ++R) {
            var rr = encode_row(R);
            for (var C = range.s.c; C <= range.e.c; ++C) {
              if (R === range.s.r)
                cols[C] = encode_col(C);
              var ref = cols[C] + rr;
              var cell = dense ? (ws[R] || [])[C] : ws[ref];
              if (!cell || cell.t == "z")
                continue;
              if (cell.t == "n") {
                write_biff_rec(ba, 23, write_NUMBER_17(R, C, wsidx, cell.v));
              } else {
                var str = format_cell(cell);
                write_biff_rec(ba, 22, write_LABEL_16(R, C, wsidx, str.slice(0, 239)));
              }
            }
          }
          ++wsidx;
        }
        write_biff_rec(ba, 1);
        return ba.end();
      }
      function write_BOF_WK1(v) {
        var out = new_buf(2);
        out.write_shift(2, v);
        return out;
      }
      function write_BOF_WK3(wb) {
        var out = new_buf(26);
        out.write_shift(2, 4096);
        out.write_shift(2, 4);
        out.write_shift(4, 0);
        var rows = 0, cols = 0, wscnt = 0;
        for (var i = 0; i < wb.SheetNames.length; ++i) {
          var name = wb.SheetNames[i];
          var ws = wb.Sheets[name];
          if (!ws || !ws["!ref"])
            continue;
          ++wscnt;
          var range = decode_range(ws["!ref"]);
          if (rows < range.e.r)
            rows = range.e.r;
          if (cols < range.e.c)
            cols = range.e.c;
        }
        if (rows > 8191)
          rows = 8191;
        out.write_shift(2, rows);
        out.write_shift(1, wscnt);
        out.write_shift(1, cols);
        out.write_shift(2, 0);
        out.write_shift(2, 0);
        out.write_shift(1, 1);
        out.write_shift(1, 2);
        out.write_shift(4, 0);
        out.write_shift(4, 0);
        return out;
      }
      function parse_RANGE(blob, length, opts) {
        var o = { s: { c: 0, r: 0 }, e: { c: 0, r: 0 } };
        if (length == 8 && opts.qpro) {
          o.s.c = blob.read_shift(1);
          blob.l++;
          o.s.r = blob.read_shift(2);
          o.e.c = blob.read_shift(1);
          blob.l++;
          o.e.r = blob.read_shift(2);
          return o;
        }
        o.s.c = blob.read_shift(2);
        o.s.r = blob.read_shift(2);
        if (length == 12 && opts.qpro)
          blob.l += 2;
        o.e.c = blob.read_shift(2);
        o.e.r = blob.read_shift(2);
        if (length == 12 && opts.qpro)
          blob.l += 2;
        if (o.s.c == 65535)
          o.s.c = o.e.c = o.s.r = o.e.r = 0;
        return o;
      }
      function write_RANGE(range) {
        var out = new_buf(8);
        out.write_shift(2, range.s.c);
        out.write_shift(2, range.s.r);
        out.write_shift(2, range.e.c);
        out.write_shift(2, range.e.r);
        return out;
      }
      function parse_cell(blob, length, opts) {
        var o = [{ c: 0, r: 0 }, { t: "n", v: 0 }, 0, 0];
        if (opts.qpro && opts.vers != 20768) {
          o[0].c = blob.read_shift(1);
          o[3] = blob.read_shift(1);
          o[0].r = blob.read_shift(2);
          blob.l += 2;
        } else {
          o[2] = blob.read_shift(1);
          o[0].c = blob.read_shift(2);
          o[0].r = blob.read_shift(2);
        }
        return o;
      }
      function parse_LABEL(blob, length, opts) {
        var tgt = blob.l + length;
        var o = parse_cell(blob, length, opts);
        o[1].t = "s";
        if (opts.vers == 20768) {
          blob.l++;
          var len = blob.read_shift(1);
          o[1].v = blob.read_shift(len, "utf8");
          return o;
        }
        if (opts.qpro)
          blob.l++;
        o[1].v = blob.read_shift(tgt - blob.l, "cstr");
        return o;
      }
      function write_LABEL(R, C, s) {
        var o = new_buf(7 + s.length);
        o.write_shift(1, 255);
        o.write_shift(2, C);
        o.write_shift(2, R);
        o.write_shift(1, 39);
        for (var i = 0; i < o.length; ++i) {
          var cc = s.charCodeAt(i);
          o.write_shift(1, cc >= 128 ? 95 : cc);
        }
        o.write_shift(1, 0);
        return o;
      }
      function parse_INTEGER(blob, length, opts) {
        var o = parse_cell(blob, length, opts);
        o[1].v = blob.read_shift(2, "i");
        return o;
      }
      function write_INTEGER(R, C, v) {
        var o = new_buf(7);
        o.write_shift(1, 255);
        o.write_shift(2, C);
        o.write_shift(2, R);
        o.write_shift(2, v, "i");
        return o;
      }
      function parse_NUMBER(blob, length, opts) {
        var o = parse_cell(blob, length, opts);
        o[1].v = blob.read_shift(8, "f");
        return o;
      }
      function write_NUMBER(R, C, v) {
        var o = new_buf(13);
        o.write_shift(1, 255);
        o.write_shift(2, C);
        o.write_shift(2, R);
        o.write_shift(8, v, "f");
        return o;
      }
      function parse_FORMULA(blob, length, opts) {
        var tgt = blob.l + length;
        var o = parse_cell(blob, length, opts);
        o[1].v = blob.read_shift(8, "f");
        if (opts.qpro)
          blob.l = tgt;
        else {
          var flen = blob.read_shift(2);
          wk1_fmla_to_csf(blob.slice(blob.l, blob.l + flen), o);
          blob.l += flen;
        }
        return o;
      }
      function wk1_parse_rc(B, V, col) {
        var rel = V & 32768;
        V &= -32769;
        V = (rel ? B : 0) + (V >= 8192 ? V - 16384 : V);
        return (rel ? "" : "$") + (col ? encode_col(V) : encode_row(V));
      }
      var FuncTab = {
        51: ["FALSE", 0],
        52: ["TRUE", 0],
        70: ["LEN", 1],
        80: ["SUM", 69],
        81: ["AVERAGEA", 69],
        82: ["COUNTA", 69],
        83: ["MINA", 69],
        84: ["MAXA", 69],
        111: ["T", 1]
      };
      var BinOpTab = [
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        // eslint-disable-line no-mixed-spaces-and-tabs
        "",
        "+",
        "-",
        "*",
        "/",
        "^",
        "=",
        "<>",
        // eslint-disable-line no-mixed-spaces-and-tabs
        "<=",
        ">=",
        "<",
        ">",
        "",
        "",
        "",
        "",
        // eslint-disable-line no-mixed-spaces-and-tabs
        "&",
        "",
        "",
        "",
        "",
        "",
        "",
        ""
        // eslint-disable-line no-mixed-spaces-and-tabs
      ];
      function wk1_fmla_to_csf(blob, o) {
        prep_blob(blob, 0);
        var out = [], argc = 0, R = "", C = "", argL = "", argR = "";
        while (blob.l < blob.length) {
          var cc = blob[blob.l++];
          switch (cc) {
            case 0:
              out.push(blob.read_shift(8, "f"));
              break;
            case 1:
              {
                C = wk1_parse_rc(o[0].c, blob.read_shift(2), true);
                R = wk1_parse_rc(o[0].r, blob.read_shift(2), false);
                out.push(C + R);
              }
              break;
            case 2:
              {
                var c = wk1_parse_rc(o[0].c, blob.read_shift(2), true);
                var r = wk1_parse_rc(o[0].r, blob.read_shift(2), false);
                C = wk1_parse_rc(o[0].c, blob.read_shift(2), true);
                R = wk1_parse_rc(o[0].r, blob.read_shift(2), false);
                out.push(c + r + ":" + C + R);
              }
              break;
            case 3:
              if (blob.l < blob.length) {
                console.error("WK1 premature formula end");
                return;
              }
              break;
            case 4:
              out.push("(" + out.pop() + ")");
              break;
            case 5:
              out.push(blob.read_shift(2));
              break;
            case 6:
              {
                var Z = "";
                while (cc = blob[blob.l++])
                  Z += String.fromCharCode(cc);
                out.push('"' + Z.replace(/"/g, '""') + '"');
              }
              break;
            case 8:
              out.push("-" + out.pop());
              break;
            case 23:
              out.push("+" + out.pop());
              break;
            case 22:
              out.push("NOT(" + out.pop() + ")");
              break;
            case 20:
            case 21:
              {
                argR = out.pop();
                argL = out.pop();
                out.push(["AND", "OR"][cc - 20] + "(" + argL + "," + argR + ")");
              }
              break;
            default:
              if (cc < 32 && BinOpTab[cc]) {
                argR = out.pop();
                argL = out.pop();
                out.push(argL + BinOpTab[cc] + argR);
              } else if (FuncTab[cc]) {
                argc = FuncTab[cc][1];
                if (argc == 69)
                  argc = blob[blob.l++];
                if (argc > out.length) {
                  console.error("WK1 bad formula parse 0x" + cc.toString(16) + ":|" + out.join("|") + "|");
                  return;
                }
                var args = out.slice(-argc);
                out.length -= argc;
                out.push(FuncTab[cc][0] + "(" + args.join(",") + ")");
              } else if (cc <= 7)
                return console.error("WK1 invalid opcode " + cc.toString(16));
              else if (cc <= 24)
                return console.error("WK1 unsupported op " + cc.toString(16));
              else if (cc <= 30)
                return console.error("WK1 invalid opcode " + cc.toString(16));
              else if (cc <= 115)
                return console.error("WK1 unsupported function opcode " + cc.toString(16));
              else
                return console.error("WK1 unrecognized opcode " + cc.toString(16));
          }
        }
        if (out.length == 1)
          o[1].f = "" + out[0];
        else
          console.error("WK1 bad formula parse |" + out.join("|") + "|");
      }
      function parse_cell_3(blob) {
        var o = [{ c: 0, r: 0 }, { t: "n", v: 0 }, 0];
        o[0].r = blob.read_shift(2);
        o[3] = blob[blob.l++];
        o[0].c = blob[blob.l++];
        return o;
      }
      function parse_LABEL_16(blob, length) {
        var o = parse_cell_3(blob);
        o[1].t = "s";
        o[1].v = blob.read_shift(length - 4, "cstr");
        return o;
      }
      function write_LABEL_16(R, C, wsidx, s) {
        var o = new_buf(6 + s.length);
        o.write_shift(2, R);
        o.write_shift(1, wsidx);
        o.write_shift(1, C);
        o.write_shift(1, 39);
        for (var i = 0; i < s.length; ++i) {
          var cc = s.charCodeAt(i);
          o.write_shift(1, cc >= 128 ? 95 : cc);
        }
        o.write_shift(1, 0);
        return o;
      }
      function parse_NUMBER_18(blob, length) {
        var o = parse_cell_3(blob);
        o[1].v = blob.read_shift(2);
        var v = o[1].v >> 1;
        if (o[1].v & 1) {
          switch (v & 7) {
            case 0:
              v = (v >> 3) * 5e3;
              break;
            case 1:
              v = (v >> 3) * 500;
              break;
            case 2:
              v = (v >> 3) / 20;
              break;
            case 3:
              v = (v >> 3) / 200;
              break;
            case 4:
              v = (v >> 3) / 2e3;
              break;
            case 5:
              v = (v >> 3) / 2e4;
              break;
            case 6:
              v = (v >> 3) / 16;
              break;
            case 7:
              v = (v >> 3) / 64;
              break;
          }
        }
        o[1].v = v;
        return o;
      }
      function parse_NUMBER_17(blob, length) {
        var o = parse_cell_3(blob);
        var v12 = blob.read_shift(4);
        var v2 = blob.read_shift(4);
        var e = blob.read_shift(2);
        if (e == 65535) {
          if (v12 === 0 && v2 === 3221225472) {
            o[1].t = "e";
            o[1].v = 15;
          } else if (v12 === 0 && v2 === 3489660928) {
            o[1].t = "e";
            o[1].v = 42;
          } else
            o[1].v = 0;
          return o;
        }
        var s = e & 32768;
        e = (e & 32767) - 16446;
        o[1].v = (1 - s * 2) * (v2 * Math.pow(2, e + 32) + v12 * Math.pow(2, e));
        return o;
      }
      function write_NUMBER_17(R, C, wsidx, v) {
        var o = new_buf(14);
        o.write_shift(2, R);
        o.write_shift(1, wsidx);
        o.write_shift(1, C);
        if (v == 0) {
          o.write_shift(4, 0);
          o.write_shift(4, 0);
          o.write_shift(2, 65535);
          return o;
        }
        var s = 0, e = 0, v12 = 0, v2 = 0;
        if (v < 0) {
          s = 1;
          v = -v;
        }
        e = Math.log2(v) | 0;
        v /= Math.pow(2, e - 31);
        v2 = v >>> 0;
        if ((v2 & 2147483648) == 0) {
          v /= 2;
          ++e;
          v2 = v >>> 0;
        }
        v -= v2;
        v2 |= 2147483648;
        v2 >>>= 0;
        v *= Math.pow(2, 32);
        v12 = v >>> 0;
        o.write_shift(4, v12);
        o.write_shift(4, v2);
        e += 16383 + (s ? 32768 : 0);
        o.write_shift(2, e);
        return o;
      }
      function parse_FORMULA_19(blob, length) {
        var o = parse_NUMBER_17(blob);
        blob.l += length - 14;
        return o;
      }
      function parse_NUMBER_25(blob, length) {
        var o = parse_cell_3(blob);
        var v12 = blob.read_shift(4);
        o[1].v = v12 >> 6;
        return o;
      }
      function parse_NUMBER_27(blob, length) {
        var o = parse_cell_3(blob);
        var v12 = blob.read_shift(8, "f");
        o[1].v = v12;
        return o;
      }
      function parse_FORMULA_28(blob, length) {
        var o = parse_NUMBER_27(blob);
        blob.l += length - 10;
        return o;
      }
      function parse_SHEETNAMECS(blob, length) {
        return blob[blob.l + length - 1] == 0 ? blob.read_shift(length, "cstr") : "";
      }
      function parse_SHEETNAMELP(blob, length) {
        var len = blob[blob.l++];
        if (len > length - 1)
          len = length - 1;
        var o = "";
        while (o.length < len)
          o += String.fromCharCode(blob[blob.l++]);
        return o;
      }
      function parse_SHEETINFOQP(blob, length, opts) {
        if (!opts.qpro || length < 21)
          return;
        var id = blob.read_shift(1);
        blob.l += 17;
        blob.l += 1;
        blob.l += 2;
        var nm = blob.read_shift(length - 21, "cstr");
        return [id, nm];
      }
      function parse_XFORMAT(blob, length) {
        var o = {}, tgt = blob.l + length;
        while (blob.l < tgt) {
          var dt = blob.read_shift(2);
          if (dt == 14e3) {
            o[dt] = [0, ""];
            o[dt][0] = blob.read_shift(2);
            while (blob[blob.l]) {
              o[dt][1] += String.fromCharCode(blob[blob.l]);
              blob.l++;
            }
            blob.l++;
          }
        }
        return o;
      }
      function write_XFORMAT_SHEETNAME(name, wsidx) {
        var out = new_buf(5 + name.length);
        out.write_shift(2, 14e3);
        out.write_shift(2, wsidx);
        for (var i = 0; i < name.length; ++i) {
          var cc = name.charCodeAt(i);
          out[out.l++] = cc > 127 ? 95 : cc;
        }
        out[out.l++] = 0;
        return out;
      }
      var WK1Enum = {
        /*::[*/
        0: { n: "BOF", f: parseuint16 },
        /*::[*/
        1: { n: "EOF" },
        /*::[*/
        2: { n: "CALCMODE" },
        /*::[*/
        3: { n: "CALCORDER" },
        /*::[*/
        4: { n: "SPLIT" },
        /*::[*/
        5: { n: "SYNC" },
        /*::[*/
        6: { n: "RANGE", f: parse_RANGE },
        /*::[*/
        7: { n: "WINDOW1" },
        /*::[*/
        8: { n: "COLW1" },
        /*::[*/
        9: { n: "WINTWO" },
        /*::[*/
        10: { n: "COLW2" },
        /*::[*/
        11: { n: "NAME" },
        /*::[*/
        12: { n: "BLANK" },
        /*::[*/
        13: { n: "INTEGER", f: parse_INTEGER },
        /*::[*/
        14: { n: "NUMBER", f: parse_NUMBER },
        /*::[*/
        15: { n: "LABEL", f: parse_LABEL },
        /*::[*/
        16: { n: "FORMULA", f: parse_FORMULA },
        /*::[*/
        24: { n: "TABLE" },
        /*::[*/
        25: { n: "ORANGE" },
        /*::[*/
        26: { n: "PRANGE" },
        /*::[*/
        27: { n: "SRANGE" },
        /*::[*/
        28: { n: "FRANGE" },
        /*::[*/
        29: { n: "KRANGE1" },
        /*::[*/
        32: { n: "HRANGE" },
        /*::[*/
        35: { n: "KRANGE2" },
        /*::[*/
        36: { n: "PROTEC" },
        /*::[*/
        37: { n: "FOOTER" },
        /*::[*/
        38: { n: "HEADER" },
        /*::[*/
        39: { n: "SETUP" },
        /*::[*/
        40: { n: "MARGINS" },
        /*::[*/
        41: { n: "LABELFMT" },
        /*::[*/
        42: { n: "TITLES" },
        /*::[*/
        43: { n: "SHEETJS" },
        /*::[*/
        45: { n: "GRAPH" },
        /*::[*/
        46: { n: "NGRAPH" },
        /*::[*/
        47: { n: "CALCCOUNT" },
        /*::[*/
        48: { n: "UNFORMATTED" },
        /*::[*/
        49: { n: "CURSORW12" },
        /*::[*/
        50: { n: "WINDOW" },
        /*::[*/
        51: { n: "STRING", f: parse_LABEL },
        /*::[*/
        55: { n: "PASSWORD" },
        /*::[*/
        56: { n: "LOCKED" },
        /*::[*/
        60: { n: "QUERY" },
        /*::[*/
        61: { n: "QUERYNAME" },
        /*::[*/
        62: { n: "PRINT" },
        /*::[*/
        63: { n: "PRINTNAME" },
        /*::[*/
        64: { n: "GRAPH2" },
        /*::[*/
        65: { n: "GRAPHNAME" },
        /*::[*/
        66: { n: "ZOOM" },
        /*::[*/
        67: { n: "SYMSPLIT" },
        /*::[*/
        68: { n: "NSROWS" },
        /*::[*/
        69: { n: "NSCOLS" },
        /*::[*/
        70: { n: "RULER" },
        /*::[*/
        71: { n: "NNAME" },
        /*::[*/
        72: { n: "ACOMM" },
        /*::[*/
        73: { n: "AMACRO" },
        /*::[*/
        74: { n: "PARSE" },
        /*::[*/
        102: { n: "PRANGES??" },
        /*::[*/
        103: { n: "RRANGES??" },
        /*::[*/
        104: { n: "FNAME??" },
        /*::[*/
        105: { n: "MRANGES??" },
        /*::[*/
        204: { n: "SHEETNAMECS", f: parse_SHEETNAMECS },
        /*::[*/
        222: { n: "SHEETNAMELP", f: parse_SHEETNAMELP },
        /*::[*/
        65535: { n: "" }
      };
      var WK3Enum = {
        /*::[*/
        0: { n: "BOF" },
        /*::[*/
        1: { n: "EOF" },
        /*::[*/
        2: { n: "PASSWORD" },
        /*::[*/
        3: { n: "CALCSET" },
        /*::[*/
        4: { n: "WINDOWSET" },
        /*::[*/
        5: { n: "SHEETCELLPTR" },
        /*::[*/
        6: { n: "SHEETLAYOUT" },
        /*::[*/
        7: { n: "COLUMNWIDTH" },
        /*::[*/
        8: { n: "HIDDENCOLUMN" },
        /*::[*/
        9: { n: "USERRANGE" },
        /*::[*/
        10: { n: "SYSTEMRANGE" },
        /*::[*/
        11: { n: "ZEROFORCE" },
        /*::[*/
        12: { n: "SORTKEYDIR" },
        /*::[*/
        13: { n: "FILESEAL" },
        /*::[*/
        14: { n: "DATAFILLNUMS" },
        /*::[*/
        15: { n: "PRINTMAIN" },
        /*::[*/
        16: { n: "PRINTSTRING" },
        /*::[*/
        17: { n: "GRAPHMAIN" },
        /*::[*/
        18: { n: "GRAPHSTRING" },
        /*::[*/
        19: { n: "??" },
        /*::[*/
        20: { n: "ERRCELL" },
        /*::[*/
        21: { n: "NACELL" },
        /*::[*/
        22: { n: "LABEL16", f: parse_LABEL_16 },
        /*::[*/
        23: { n: "NUMBER17", f: parse_NUMBER_17 },
        /*::[*/
        24: { n: "NUMBER18", f: parse_NUMBER_18 },
        /*::[*/
        25: { n: "FORMULA19", f: parse_FORMULA_19 },
        /*::[*/
        26: { n: "FORMULA1A" },
        /*::[*/
        27: { n: "XFORMAT", f: parse_XFORMAT },
        /*::[*/
        28: { n: "DTLABELMISC" },
        /*::[*/
        29: { n: "DTLABELCELL" },
        /*::[*/
        30: { n: "GRAPHWINDOW" },
        /*::[*/
        31: { n: "CPA" },
        /*::[*/
        32: { n: "LPLAUTO" },
        /*::[*/
        33: { n: "QUERY" },
        /*::[*/
        34: { n: "HIDDENSHEET" },
        /*::[*/
        35: { n: "??" },
        /*::[*/
        37: { n: "NUMBER25", f: parse_NUMBER_25 },
        /*::[*/
        38: { n: "??" },
        /*::[*/
        39: { n: "NUMBER27", f: parse_NUMBER_27 },
        /*::[*/
        40: { n: "FORMULA28", f: parse_FORMULA_28 },
        /*::[*/
        142: { n: "??" },
        /*::[*/
        147: { n: "??" },
        /*::[*/
        150: { n: "??" },
        /*::[*/
        151: { n: "??" },
        /*::[*/
        152: { n: "??" },
        /*::[*/
        153: { n: "??" },
        /*::[*/
        154: { n: "??" },
        /*::[*/
        155: { n: "??" },
        /*::[*/
        156: { n: "??" },
        /*::[*/
        163: { n: "??" },
        /*::[*/
        174: { n: "??" },
        /*::[*/
        175: { n: "??" },
        /*::[*/
        176: { n: "??" },
        /*::[*/
        177: { n: "??" },
        /*::[*/
        184: { n: "??" },
        /*::[*/
        185: { n: "??" },
        /*::[*/
        186: { n: "??" },
        /*::[*/
        187: { n: "??" },
        /*::[*/
        188: { n: "??" },
        /*::[*/
        195: { n: "??" },
        /*::[*/
        201: { n: "??" },
        /*::[*/
        204: { n: "SHEETNAMECS", f: parse_SHEETNAMECS },
        /*::[*/
        205: { n: "??" },
        /*::[*/
        206: { n: "??" },
        /*::[*/
        207: { n: "??" },
        /*::[*/
        208: { n: "??" },
        /*::[*/
        256: { n: "??" },
        /*::[*/
        259: { n: "??" },
        /*::[*/
        260: { n: "??" },
        /*::[*/
        261: { n: "??" },
        /*::[*/
        262: { n: "??" },
        /*::[*/
        263: { n: "??" },
        /*::[*/
        265: { n: "??" },
        /*::[*/
        266: { n: "??" },
        /*::[*/
        267: { n: "??" },
        /*::[*/
        268: { n: "??" },
        /*::[*/
        270: { n: "??" },
        /*::[*/
        271: { n: "??" },
        /*::[*/
        384: { n: "??" },
        /*::[*/
        389: { n: "??" },
        /*::[*/
        390: { n: "??" },
        /*::[*/
        393: { n: "??" },
        /*::[*/
        396: { n: "??" },
        /*::[*/
        512: { n: "??" },
        /*::[*/
        514: { n: "??" },
        /*::[*/
        513: { n: "??" },
        /*::[*/
        516: { n: "??" },
        /*::[*/
        517: { n: "??" },
        /*::[*/
        640: { n: "??" },
        /*::[*/
        641: { n: "??" },
        /*::[*/
        642: { n: "??" },
        /*::[*/
        643: { n: "??" },
        /*::[*/
        644: { n: "??" },
        /*::[*/
        645: { n: "??" },
        /*::[*/
        646: { n: "??" },
        /*::[*/
        647: { n: "??" },
        /*::[*/
        648: { n: "??" },
        /*::[*/
        658: { n: "??" },
        /*::[*/
        659: { n: "??" },
        /*::[*/
        660: { n: "??" },
        /*::[*/
        661: { n: "??" },
        /*::[*/
        662: { n: "??" },
        /*::[*/
        665: { n: "??" },
        /*::[*/
        666: { n: "??" },
        /*::[*/
        768: { n: "??" },
        /*::[*/
        772: { n: "??" },
        /*::[*/
        1537: { n: "SHEETINFOQP", f: parse_SHEETINFOQP },
        /*::[*/
        1600: { n: "??" },
        /*::[*/
        1602: { n: "??" },
        /*::[*/
        1793: { n: "??" },
        /*::[*/
        1794: { n: "??" },
        /*::[*/
        1795: { n: "??" },
        /*::[*/
        1796: { n: "??" },
        /*::[*/
        1920: { n: "??" },
        /*::[*/
        2048: { n: "??" },
        /*::[*/
        2049: { n: "??" },
        /*::[*/
        2052: { n: "??" },
        /*::[*/
        2688: { n: "??" },
        /*::[*/
        10998: { n: "??" },
        /*::[*/
        12849: { n: "??" },
        /*::[*/
        28233: { n: "??" },
        /*::[*/
        28484: { n: "??" },
        /*::[*/
        65535: { n: "" }
      };
      return {
        sheet_to_wk1,
        book_to_wk3,
        to_workbook: lotus_to_workbook
      };
    }();
    var straywsregex = /^\s|\s$|[\t\n\r]/;
    function write_sst_xml(sst, opts) {
      if (!opts.bookSST)
        return "";
      var o = [XML_HEADER];
      o[o.length] = writextag("sst", null, {
        xmlns: XMLNS_main[0],
        count: sst.Count,
        uniqueCount: sst.Unique
      });
      for (var i = 0; i != sst.length; ++i) {
        if (sst[i] == null)
          continue;
        var s = sst[i];
        var sitag = "<si>";
        if (s.r)
          sitag += s.r;
        else {
          sitag += "<t";
          if (!s.t)
            s.t = "";
          if (s.t.match(straywsregex))
            sitag += ' xml:space="preserve"';
          sitag += ">" + escapexml(s.t) + "</t>";
        }
        sitag += "</si>";
        o[o.length] = sitag;
      }
      if (o.length > 2) {
        o[o.length] = "</sst>";
        o[1] = o[1].replace("/>", ">");
      }
      return o.join("");
    }
    function parse_BrtBeginSst(data) {
      return [data.read_shift(4), data.read_shift(4)];
    }
    function write_BrtBeginSst(sst, o) {
      if (!o)
        o = new_buf(8);
      o.write_shift(4, sst.Count);
      o.write_shift(4, sst.Unique);
      return o;
    }
    var write_BrtSSTItem = write_RichStr;
    function write_sst_bin(sst) {
      var ba = buf_array();
      write_record(ba, 159, write_BrtBeginSst(sst));
      for (var i = 0; i < sst.length; ++i)
        write_record(ba, 19, write_BrtSSTItem(sst[i]));
      write_record(
        ba,
        160
        /* BrtEndSst */
      );
      return ba.end();
    }
    function _JS2ANSI(str) {
      var o = [], oo = str.split("");
      for (var i = 0; i < oo.length; ++i)
        o[i] = oo[i].charCodeAt(0);
      return o;
    }
    function crypto_CreatePasswordVerifier_Method1(Password) {
      var Verifier = 0, PasswordArray;
      var PasswordDecoded = _JS2ANSI(Password);
      var len = PasswordDecoded.length + 1, i, PasswordByte;
      var Intermediate1, Intermediate2, Intermediate3;
      PasswordArray = new_raw_buf(len);
      PasswordArray[0] = PasswordDecoded.length;
      for (i = 1; i != len; ++i)
        PasswordArray[i] = PasswordDecoded[i - 1];
      for (i = len - 1; i >= 0; --i) {
        PasswordByte = PasswordArray[i];
        Intermediate1 = (Verifier & 16384) === 0 ? 0 : 1;
        Intermediate2 = Verifier << 1 & 32767;
        Intermediate3 = Intermediate1 | Intermediate2;
        Verifier = Intermediate3 ^ PasswordByte;
      }
      return Verifier ^ 52811;
    }
    var RTF = /* @__PURE__ */ function() {
      function rtf_to_sheet(d, opts) {
        switch (opts.type) {
          case "base64":
            return rtf_to_sheet_str(Base64_decode(d), opts);
          case "binary":
            return rtf_to_sheet_str(d, opts);
          case "buffer":
            return rtf_to_sheet_str(has_buf && Buffer.isBuffer(d) ? d.toString("binary") : a2s(d), opts);
          case "array":
            return rtf_to_sheet_str(cc2str(d), opts);
        }
        throw new Error("Unrecognized type " + opts.type);
      }
      function rtf_to_sheet_str(str, opts) {
        var o = opts || {};
        var ws = o.dense ? [] : {};
        var rows = str.match(/\\trowd.*?\\row\b/g);
        if (!rows.length)
          throw new Error("RTF missing table");
        var range = { s: { c: 0, r: 0 }, e: { c: 0, r: rows.length - 1 } };
        rows.forEach(function(rowtf, R) {
          if (Array.isArray(ws))
            ws[R] = [];
          var rtfre = /\\\w+\b/g;
          var last_index = 0;
          var res;
          var C = -1;
          while (res = rtfre.exec(rowtf)) {
            switch (res[0]) {
              case "\\cell":
                var data = rowtf.slice(last_index, rtfre.lastIndex - res[0].length);
                if (data[0] == " ")
                  data = data.slice(1);
                ++C;
                if (data.length) {
                  var cell = { v: data, t: "s" };
                  if (Array.isArray(ws))
                    ws[R][C] = cell;
                  else
                    ws[encode_cell({ r: R, c: C })] = cell;
                }
                break;
            }
            last_index = rtfre.lastIndex;
          }
          if (C > range.e.c)
            range.e.c = C;
        });
        ws["!ref"] = encode_range(range);
        return ws;
      }
      function rtf_to_workbook(d, opts) {
        return sheet_to_workbook(rtf_to_sheet(d, opts), opts);
      }
      function sheet_to_rtf(ws) {
        var o = ["{\\rtf1\\ansi"];
        var r = safe_decode_range(ws["!ref"]), cell;
        var dense = Array.isArray(ws);
        for (var R = r.s.r; R <= r.e.r; ++R) {
          o.push("\\trowd\\trautofit1");
          for (var C = r.s.c; C <= r.e.c; ++C)
            o.push("\\cellx" + (C + 1));
          o.push("\\pard\\intbl");
          for (C = r.s.c; C <= r.e.c; ++C) {
            var coord = encode_cell({ r: R, c: C });
            cell = dense ? (ws[R] || [])[C] : ws[coord];
            if (!cell || cell.v == null && (!cell.f || cell.F))
              continue;
            o.push(" " + (cell.w || (format_cell(cell), cell.w)));
            o.push("\\cell");
          }
          o.push("\\pard\\intbl\\row");
        }
        return o.join("") + "}";
      }
      return {
        to_workbook: rtf_to_workbook,
        to_sheet: rtf_to_sheet,
        from_sheet: sheet_to_rtf
      };
    }();
    function rgb2Hex(rgb) {
      for (var i = 0, o = 1; i != 3; ++i)
        o = o * 256 + (rgb[i] > 255 ? 255 : rgb[i] < 0 ? 0 : rgb[i]);
      return o.toString(16).toUpperCase().slice(1);
    }
    var DEF_MDW = 6;
    var MDW = DEF_MDW;
    function width2px(width) {
      return Math.floor((width + Math.round(128 / MDW) / 256) * MDW);
    }
    function px2char(px) {
      return Math.floor((px - 5) / MDW * 100 + 0.5) / 100;
    }
    function char2width(chr) {
      return Math.round((chr * MDW + 5) / MDW * 256) / 256;
    }
    function process_col(coll) {
      if (coll.width) {
        coll.wpx = width2px(coll.width);
        coll.wch = px2char(coll.wpx);
        coll.MDW = MDW;
      } else if (coll.wpx) {
        coll.wch = px2char(coll.wpx);
        coll.width = char2width(coll.wch);
        coll.MDW = MDW;
      } else if (typeof coll.wch == "number") {
        coll.width = char2width(coll.wch);
        coll.wpx = width2px(coll.width);
        coll.MDW = MDW;
      }
      if (coll.customWidth)
        delete coll.customWidth;
    }
    var DEF_PPI = 96;
    var PPI = DEF_PPI;
    function px2pt(px) {
      return px * 96 / PPI;
    }
    function pt2px(pt) {
      return pt * PPI / 96;
    }
    function write_numFmts(NF) {
      var o = ["<numFmts>"];
      [[5, 8], [23, 26], [41, 44], [
        /*63*/
        50,
        /*66],[164,*/
        392
      ]].forEach(function(r) {
        for (var i = r[0]; i <= r[1]; ++i)
          if (NF[i] != null)
            o[o.length] = writextag("numFmt", null, { numFmtId: i, formatCode: escapexml(NF[i]) });
      });
      if (o.length === 1)
        return "";
      o[o.length] = "</numFmts>";
      o[0] = writextag("numFmts", null, { count: o.length - 2 }).replace("/>", ">");
      return o.join("");
    }
    function write_cellXfs(cellXfs) {
      var o = [];
      o[o.length] = writextag("cellXfs", null);
      cellXfs.forEach(function(c) {
        o[o.length] = writextag("xf", null, c);
      });
      o[o.length] = "</cellXfs>";
      if (o.length === 2)
        return "";
      o[0] = writextag("cellXfs", null, { count: o.length - 2 }).replace("/>", ">");
      return o.join("");
    }
    function write_sty_xml(wb, opts) {
      var o = [XML_HEADER, writextag("styleSheet", null, {
        "xmlns": XMLNS_main[0],
        "xmlns:vt": XMLNS.vt
      })], w;
      if (wb.SSF && (w = write_numFmts(wb.SSF)) != null)
        o[o.length] = w;
      o[o.length] = '<fonts count="1"><font><sz val="12"/><color theme="1"/><name val="Calibri"/><family val="2"/><scheme val="minor"/></font></fonts>';
      o[o.length] = '<fills count="2"><fill><patternFill patternType="none"/></fill><fill><patternFill patternType="gray125"/></fill></fills>';
      o[o.length] = '<borders count="1"><border><left/><right/><top/><bottom/><diagonal/></border></borders>';
      o[o.length] = '<cellStyleXfs count="1"><xf numFmtId="0" fontId="0" fillId="0" borderId="0"/></cellStyleXfs>';
      if (w = write_cellXfs(opts.cellXfs))
        o[o.length] = w;
      o[o.length] = '<cellStyles count="1"><cellStyle name="Normal" xfId="0" builtinId="0"/></cellStyles>';
      o[o.length] = '<dxfs count="0"/>';
      o[o.length] = '<tableStyles count="0" defaultTableStyle="TableStyleMedium9" defaultPivotStyle="PivotStyleMedium4"/>';
      if (o.length > 2) {
        o[o.length] = "</styleSheet>";
        o[1] = o[1].replace("/>", ">");
      }
      return o.join("");
    }
    function parse_BrtFmt(data, length) {
      var numFmtId = data.read_shift(2);
      var stFmtCode = parse_XLWideString(data);
      return [numFmtId, stFmtCode];
    }
    function write_BrtFmt(i, f, o) {
      if (!o)
        o = new_buf(6 + 4 * f.length);
      o.write_shift(2, i);
      write_XLWideString(f, o);
      var out = o.length > o.l ? o.slice(0, o.l) : o;
      if (o.l == null)
        o.l = o.length;
      return out;
    }
    function parse_BrtFont(data, length, opts) {
      var out = {};
      out.sz = data.read_shift(2) / 20;
      var grbit = parse_FontFlags(data);
      if (grbit.fItalic)
        out.italic = 1;
      if (grbit.fCondense)
        out.condense = 1;
      if (grbit.fExtend)
        out.extend = 1;
      if (grbit.fShadow)
        out.shadow = 1;
      if (grbit.fOutline)
        out.outline = 1;
      if (grbit.fStrikeout)
        out.strike = 1;
      var bls = data.read_shift(2);
      if (bls === 700)
        out.bold = 1;
      switch (data.read_shift(2)) {
        case 1:
          out.vertAlign = "superscript";
          break;
        case 2:
          out.vertAlign = "subscript";
          break;
      }
      var underline = data.read_shift(1);
      if (underline != 0)
        out.underline = underline;
      var family = data.read_shift(1);
      if (family > 0)
        out.family = family;
      var bCharSet = data.read_shift(1);
      if (bCharSet > 0)
        out.charset = bCharSet;
      data.l++;
      out.color = parse_BrtColor(data);
      switch (data.read_shift(1)) {
        case 1:
          out.scheme = "major";
          break;
        case 2:
          out.scheme = "minor";
          break;
      }
      out.name = parse_XLWideString(data);
      return out;
    }
    function write_BrtFont(font, o) {
      if (!o)
        o = new_buf(25 + 4 * 32);
      o.write_shift(2, font.sz * 20);
      write_FontFlags(font, o);
      o.write_shift(2, font.bold ? 700 : 400);
      var sss = 0;
      if (font.vertAlign == "superscript")
        sss = 1;
      else if (font.vertAlign == "subscript")
        sss = 2;
      o.write_shift(2, sss);
      o.write_shift(1, font.underline || 0);
      o.write_shift(1, font.family || 0);
      o.write_shift(1, font.charset || 0);
      o.write_shift(1, 0);
      write_BrtColor(font.color, o);
      var scheme = 0;
      scheme = 2;
      o.write_shift(1, scheme);
      write_XLWideString(font.name, o);
      return o.length > o.l ? o.slice(0, o.l) : o;
    }
    var XLSBFillPTNames = [
      "none",
      "solid",
      "mediumGray",
      "darkGray",
      "lightGray",
      "darkHorizontal",
      "darkVertical",
      "darkDown",
      "darkUp",
      "darkGrid",
      "darkTrellis",
      "lightHorizontal",
      "lightVertical",
      "lightDown",
      "lightUp",
      "lightGrid",
      "lightTrellis",
      "gray125",
      "gray0625"
    ];
    var rev_XLSBFillPTNames;
    var parse_BrtFill = parsenoop;
    function write_BrtFill(fill2, o) {
      if (!o)
        o = new_buf(4 * 3 + 8 * 7 + 16 * 1);
      if (!rev_XLSBFillPTNames)
        rev_XLSBFillPTNames = evert(XLSBFillPTNames);
      var fls = rev_XLSBFillPTNames[fill2.patternType];
      if (fls == null)
        fls = 40;
      o.write_shift(4, fls);
      var j = 0;
      if (fls != 40) {
        write_BrtColor({ auto: 1 }, o);
        write_BrtColor({ auto: 1 }, o);
        for (; j < 12; ++j)
          o.write_shift(4, 0);
      } else {
        for (; j < 4; ++j)
          o.write_shift(4, 0);
        for (; j < 12; ++j)
          o.write_shift(4, 0);
      }
      return o.length > o.l ? o.slice(0, o.l) : o;
    }
    function parse_BrtXF(data, length) {
      var tgt = data.l + length;
      var ixfeParent = data.read_shift(2);
      var ifmt = data.read_shift(2);
      data.l = tgt;
      return { ixfe: ixfeParent, numFmtId: ifmt };
    }
    function write_BrtXF(data, ixfeP, o) {
      if (!o)
        o = new_buf(16);
      o.write_shift(2, ixfeP || 0);
      o.write_shift(2, data.numFmtId || 0);
      o.write_shift(2, 0);
      o.write_shift(2, 0);
      o.write_shift(2, 0);
      o.write_shift(1, 0);
      o.write_shift(1, 0);
      var flow = 0;
      o.write_shift(1, flow);
      o.write_shift(1, 0);
      o.write_shift(1, 0);
      o.write_shift(1, 0);
      return o;
    }
    function write_Blxf(data, o) {
      if (!o)
        o = new_buf(10);
      o.write_shift(1, 0);
      o.write_shift(1, 0);
      o.write_shift(4, 0);
      o.write_shift(4, 0);
      return o;
    }
    var parse_BrtBorder = parsenoop;
    function write_BrtBorder(border, o) {
      if (!o)
        o = new_buf(51);
      o.write_shift(1, 0);
      write_Blxf(null, o);
      write_Blxf(null, o);
      write_Blxf(null, o);
      write_Blxf(null, o);
      write_Blxf(null, o);
      return o.length > o.l ? o.slice(0, o.l) : o;
    }
    function write_BrtStyle(style, o) {
      if (!o)
        o = new_buf(12 + 4 * 10);
      o.write_shift(4, style.xfId);
      o.write_shift(2, 1);
      o.write_shift(1, 0);
      o.write_shift(1, 0);
      write_XLNullableWideString(style.name || "", o);
      return o.length > o.l ? o.slice(0, o.l) : o;
    }
    function write_BrtBeginTableStyles(cnt, defTableStyle, defPivotStyle) {
      var o = new_buf(4 + 256 * 2 * 4);
      o.write_shift(4, cnt);
      write_XLNullableWideString(defTableStyle, o);
      write_XLNullableWideString(defPivotStyle, o);
      return o.length > o.l ? o.slice(0, o.l) : o;
    }
    function write_FMTS_bin(ba, NF) {
      if (!NF)
        return;
      var cnt = 0;
      [[5, 8], [23, 26], [41, 44], [
        /*63*/
        50,
        /*66],[164,*/
        392
      ]].forEach(function(r) {
        for (var i = r[0]; i <= r[1]; ++i)
          if (NF[i] != null)
            ++cnt;
      });
      if (cnt == 0)
        return;
      write_record(ba, 615, write_UInt32LE(cnt));
      [[5, 8], [23, 26], [41, 44], [
        /*63*/
        50,
        /*66],[164,*/
        392
      ]].forEach(function(r) {
        for (var i = r[0]; i <= r[1]; ++i)
          if (NF[i] != null)
            write_record(ba, 44, write_BrtFmt(i, NF[i]));
      });
      write_record(
        ba,
        616
        /* BrtEndFmts */
      );
    }
    function write_FONTS_bin(ba) {
      var cnt = 1;
      write_record(ba, 611, write_UInt32LE(cnt));
      write_record(ba, 43, write_BrtFont({
        sz: 12,
        color: { theme: 1 },
        name: "Calibri",
        family: 2
      }));
      write_record(
        ba,
        612
        /* BrtEndFonts */
      );
    }
    function write_FILLS_bin(ba) {
      var cnt = 2;
      write_record(ba, 603, write_UInt32LE(cnt));
      write_record(ba, 45, write_BrtFill({ patternType: "none" }));
      write_record(ba, 45, write_BrtFill({ patternType: "gray125" }));
      write_record(
        ba,
        604
        /* BrtEndFills */
      );
    }
    function write_BORDERS_bin(ba) {
      var cnt = 1;
      write_record(ba, 613, write_UInt32LE(cnt));
      write_record(ba, 46, write_BrtBorder());
      write_record(
        ba,
        614
        /* BrtEndBorders */
      );
    }
    function write_CELLSTYLEXFS_bin(ba) {
      var cnt = 1;
      write_record(ba, 626, write_UInt32LE(cnt));
      write_record(ba, 47, write_BrtXF({
        numFmtId: 0
      }, 65535));
      write_record(
        ba,
        627
        /* BrtEndCellStyleXFs */
      );
    }
    function write_CELLXFS_bin(ba, data) {
      write_record(ba, 617, write_UInt32LE(data.length));
      data.forEach(function(c) {
        write_record(ba, 47, write_BrtXF(c, 0));
      });
      write_record(
        ba,
        618
        /* BrtEndCellXFs */
      );
    }
    function write_STYLES_bin(ba) {
      var cnt = 1;
      write_record(ba, 619, write_UInt32LE(cnt));
      write_record(ba, 48, write_BrtStyle({
        xfId: 0,
        name: "Normal"
      }));
      write_record(
        ba,
        620
        /* BrtEndStyles */
      );
    }
    function write_DXFS_bin(ba) {
      var cnt = 0;
      write_record(ba, 505, write_UInt32LE(cnt));
      write_record(
        ba,
        506
        /* BrtEndDXFs */
      );
    }
    function write_TABLESTYLES_bin(ba) {
      var cnt = 0;
      write_record(ba, 508, write_BrtBeginTableStyles(cnt, "TableStyleMedium9", "PivotStyleMedium4"));
      write_record(
        ba,
        509
        /* BrtEndTableStyles */
      );
    }
    function write_sty_bin(wb, opts) {
      var ba = buf_array();
      write_record(
        ba,
        278
        /* BrtBeginStyleSheet */
      );
      write_FMTS_bin(ba, wb.SSF);
      write_FONTS_bin(ba);
      write_FILLS_bin(ba);
      write_BORDERS_bin(ba);
      write_CELLSTYLEXFS_bin(ba);
      write_CELLXFS_bin(ba, opts.cellXfs);
      write_STYLES_bin(ba);
      write_DXFS_bin(ba);
      write_TABLESTYLES_bin(ba);
      write_record(
        ba,
        279
        /* BrtEndStyleSheet */
      );
      return ba.end();
    }
    function write_theme(Themes, opts) {
      if (opts && opts.themeXLSX)
        return opts.themeXLSX;
      if (Themes && typeof Themes.raw == "string")
        return Themes.raw;
      var o = [XML_HEADER];
      o[o.length] = '<a:theme xmlns:a="http://schemas.openxmlformats.org/drawingml/2006/main" name="Office Theme">';
      o[o.length] = "<a:themeElements>";
      o[o.length] = '<a:clrScheme name="Office">';
      o[o.length] = '<a:dk1><a:sysClr val="windowText" lastClr="000000"/></a:dk1>';
      o[o.length] = '<a:lt1><a:sysClr val="window" lastClr="FFFFFF"/></a:lt1>';
      o[o.length] = '<a:dk2><a:srgbClr val="1F497D"/></a:dk2>';
      o[o.length] = '<a:lt2><a:srgbClr val="EEECE1"/></a:lt2>';
      o[o.length] = '<a:accent1><a:srgbClr val="4F81BD"/></a:accent1>';
      o[o.length] = '<a:accent2><a:srgbClr val="C0504D"/></a:accent2>';
      o[o.length] = '<a:accent3><a:srgbClr val="9BBB59"/></a:accent3>';
      o[o.length] = '<a:accent4><a:srgbClr val="8064A2"/></a:accent4>';
      o[o.length] = '<a:accent5><a:srgbClr val="4BACC6"/></a:accent5>';
      o[o.length] = '<a:accent6><a:srgbClr val="F79646"/></a:accent6>';
      o[o.length] = '<a:hlink><a:srgbClr val="0000FF"/></a:hlink>';
      o[o.length] = '<a:folHlink><a:srgbClr val="800080"/></a:folHlink>';
      o[o.length] = "</a:clrScheme>";
      o[o.length] = '<a:fontScheme name="Office">';
      o[o.length] = "<a:majorFont>";
      o[o.length] = '<a:latin typeface="Cambria"/>';
      o[o.length] = '<a:ea typeface=""/>';
      o[o.length] = '<a:cs typeface=""/>';
      o[o.length] = '<a:font script="Jpan" typeface="\uFF2D\uFF33 \uFF30\u30B4\u30B7\u30C3\u30AF"/>';
      o[o.length] = '<a:font script="Hang" typeface="\uB9D1\uC740 \uACE0\uB515"/>';
      o[o.length] = '<a:font script="Hans" typeface="\u5B8B\u4F53"/>';
      o[o.length] = '<a:font script="Hant" typeface="\u65B0\u7D30\u660E\u9AD4"/>';
      o[o.length] = '<a:font script="Arab" typeface="Times New Roman"/>';
      o[o.length] = '<a:font script="Hebr" typeface="Times New Roman"/>';
      o[o.length] = '<a:font script="Thai" typeface="Tahoma"/>';
      o[o.length] = '<a:font script="Ethi" typeface="Nyala"/>';
      o[o.length] = '<a:font script="Beng" typeface="Vrinda"/>';
      o[o.length] = '<a:font script="Gujr" typeface="Shruti"/>';
      o[o.length] = '<a:font script="Khmr" typeface="MoolBoran"/>';
      o[o.length] = '<a:font script="Knda" typeface="Tunga"/>';
      o[o.length] = '<a:font script="Guru" typeface="Raavi"/>';
      o[o.length] = '<a:font script="Cans" typeface="Euphemia"/>';
      o[o.length] = '<a:font script="Cher" typeface="Plantagenet Cherokee"/>';
      o[o.length] = '<a:font script="Yiii" typeface="Microsoft Yi Baiti"/>';
      o[o.length] = '<a:font script="Tibt" typeface="Microsoft Himalaya"/>';
      o[o.length] = '<a:font script="Thaa" typeface="MV Boli"/>';
      o[o.length] = '<a:font script="Deva" typeface="Mangal"/>';
      o[o.length] = '<a:font script="Telu" typeface="Gautami"/>';
      o[o.length] = '<a:font script="Taml" typeface="Latha"/>';
      o[o.length] = '<a:font script="Syrc" typeface="Estrangelo Edessa"/>';
      o[o.length] = '<a:font script="Orya" typeface="Kalinga"/>';
      o[o.length] = '<a:font script="Mlym" typeface="Kartika"/>';
      o[o.length] = '<a:font script="Laoo" typeface="DokChampa"/>';
      o[o.length] = '<a:font script="Sinh" typeface="Iskoola Pota"/>';
      o[o.length] = '<a:font script="Mong" typeface="Mongolian Baiti"/>';
      o[o.length] = '<a:font script="Viet" typeface="Times New Roman"/>';
      o[o.length] = '<a:font script="Uigh" typeface="Microsoft Uighur"/>';
      o[o.length] = '<a:font script="Geor" typeface="Sylfaen"/>';
      o[o.length] = "</a:majorFont>";
      o[o.length] = "<a:minorFont>";
      o[o.length] = '<a:latin typeface="Calibri"/>';
      o[o.length] = '<a:ea typeface=""/>';
      o[o.length] = '<a:cs typeface=""/>';
      o[o.length] = '<a:font script="Jpan" typeface="\uFF2D\uFF33 \uFF30\u30B4\u30B7\u30C3\u30AF"/>';
      o[o.length] = '<a:font script="Hang" typeface="\uB9D1\uC740 \uACE0\uB515"/>';
      o[o.length] = '<a:font script="Hans" typeface="\u5B8B\u4F53"/>';
      o[o.length] = '<a:font script="Hant" typeface="\u65B0\u7D30\u660E\u9AD4"/>';
      o[o.length] = '<a:font script="Arab" typeface="Arial"/>';
      o[o.length] = '<a:font script="Hebr" typeface="Arial"/>';
      o[o.length] = '<a:font script="Thai" typeface="Tahoma"/>';
      o[o.length] = '<a:font script="Ethi" typeface="Nyala"/>';
      o[o.length] = '<a:font script="Beng" typeface="Vrinda"/>';
      o[o.length] = '<a:font script="Gujr" typeface="Shruti"/>';
      o[o.length] = '<a:font script="Khmr" typeface="DaunPenh"/>';
      o[o.length] = '<a:font script="Knda" typeface="Tunga"/>';
      o[o.length] = '<a:font script="Guru" typeface="Raavi"/>';
      o[o.length] = '<a:font script="Cans" typeface="Euphemia"/>';
      o[o.length] = '<a:font script="Cher" typeface="Plantagenet Cherokee"/>';
      o[o.length] = '<a:font script="Yiii" typeface="Microsoft Yi Baiti"/>';
      o[o.length] = '<a:font script="Tibt" typeface="Microsoft Himalaya"/>';
      o[o.length] = '<a:font script="Thaa" typeface="MV Boli"/>';
      o[o.length] = '<a:font script="Deva" typeface="Mangal"/>';
      o[o.length] = '<a:font script="Telu" typeface="Gautami"/>';
      o[o.length] = '<a:font script="Taml" typeface="Latha"/>';
      o[o.length] = '<a:font script="Syrc" typeface="Estrangelo Edessa"/>';
      o[o.length] = '<a:font script="Orya" typeface="Kalinga"/>';
      o[o.length] = '<a:font script="Mlym" typeface="Kartika"/>';
      o[o.length] = '<a:font script="Laoo" typeface="DokChampa"/>';
      o[o.length] = '<a:font script="Sinh" typeface="Iskoola Pota"/>';
      o[o.length] = '<a:font script="Mong" typeface="Mongolian Baiti"/>';
      o[o.length] = '<a:font script="Viet" typeface="Arial"/>';
      o[o.length] = '<a:font script="Uigh" typeface="Microsoft Uighur"/>';
      o[o.length] = '<a:font script="Geor" typeface="Sylfaen"/>';
      o[o.length] = "</a:minorFont>";
      o[o.length] = "</a:fontScheme>";
      o[o.length] = '<a:fmtScheme name="Office">';
      o[o.length] = "<a:fillStyleLst>";
      o[o.length] = '<a:solidFill><a:schemeClr val="phClr"/></a:solidFill>';
      o[o.length] = '<a:gradFill rotWithShape="1">';
      o[o.length] = "<a:gsLst>";
      o[o.length] = '<a:gs pos="0"><a:schemeClr val="phClr"><a:tint val="50000"/><a:satMod val="300000"/></a:schemeClr></a:gs>';
      o[o.length] = '<a:gs pos="35000"><a:schemeClr val="phClr"><a:tint val="37000"/><a:satMod val="300000"/></a:schemeClr></a:gs>';
      o[o.length] = '<a:gs pos="100000"><a:schemeClr val="phClr"><a:tint val="15000"/><a:satMod val="350000"/></a:schemeClr></a:gs>';
      o[o.length] = "</a:gsLst>";
      o[o.length] = '<a:lin ang="16200000" scaled="1"/>';
      o[o.length] = "</a:gradFill>";
      o[o.length] = '<a:gradFill rotWithShape="1">';
      o[o.length] = "<a:gsLst>";
      o[o.length] = '<a:gs pos="0"><a:schemeClr val="phClr"><a:tint val="100000"/><a:shade val="100000"/><a:satMod val="130000"/></a:schemeClr></a:gs>';
      o[o.length] = '<a:gs pos="100000"><a:schemeClr val="phClr"><a:tint val="50000"/><a:shade val="100000"/><a:satMod val="350000"/></a:schemeClr></a:gs>';
      o[o.length] = "</a:gsLst>";
      o[o.length] = '<a:lin ang="16200000" scaled="0"/>';
      o[o.length] = "</a:gradFill>";
      o[o.length] = "</a:fillStyleLst>";
      o[o.length] = "<a:lnStyleLst>";
      o[o.length] = '<a:ln w="9525" cap="flat" cmpd="sng" algn="ctr"><a:solidFill><a:schemeClr val="phClr"><a:shade val="95000"/><a:satMod val="105000"/></a:schemeClr></a:solidFill><a:prstDash val="solid"/></a:ln>';
      o[o.length] = '<a:ln w="25400" cap="flat" cmpd="sng" algn="ctr"><a:solidFill><a:schemeClr val="phClr"/></a:solidFill><a:prstDash val="solid"/></a:ln>';
      o[o.length] = '<a:ln w="38100" cap="flat" cmpd="sng" algn="ctr"><a:solidFill><a:schemeClr val="phClr"/></a:solidFill><a:prstDash val="solid"/></a:ln>';
      o[o.length] = "</a:lnStyleLst>";
      o[o.length] = "<a:effectStyleLst>";
      o[o.length] = "<a:effectStyle>";
      o[o.length] = "<a:effectLst>";
      o[o.length] = '<a:outerShdw blurRad="40000" dist="20000" dir="5400000" rotWithShape="0"><a:srgbClr val="000000"><a:alpha val="38000"/></a:srgbClr></a:outerShdw>';
      o[o.length] = "</a:effectLst>";
      o[o.length] = "</a:effectStyle>";
      o[o.length] = "<a:effectStyle>";
      o[o.length] = "<a:effectLst>";
      o[o.length] = '<a:outerShdw blurRad="40000" dist="23000" dir="5400000" rotWithShape="0"><a:srgbClr val="000000"><a:alpha val="35000"/></a:srgbClr></a:outerShdw>';
      o[o.length] = "</a:effectLst>";
      o[o.length] = "</a:effectStyle>";
      o[o.length] = "<a:effectStyle>";
      o[o.length] = "<a:effectLst>";
      o[o.length] = '<a:outerShdw blurRad="40000" dist="23000" dir="5400000" rotWithShape="0"><a:srgbClr val="000000"><a:alpha val="35000"/></a:srgbClr></a:outerShdw>';
      o[o.length] = "</a:effectLst>";
      o[o.length] = '<a:scene3d><a:camera prst="orthographicFront"><a:rot lat="0" lon="0" rev="0"/></a:camera><a:lightRig rig="threePt" dir="t"><a:rot lat="0" lon="0" rev="1200000"/></a:lightRig></a:scene3d>';
      o[o.length] = '<a:sp3d><a:bevelT w="63500" h="25400"/></a:sp3d>';
      o[o.length] = "</a:effectStyle>";
      o[o.length] = "</a:effectStyleLst>";
      o[o.length] = "<a:bgFillStyleLst>";
      o[o.length] = '<a:solidFill><a:schemeClr val="phClr"/></a:solidFill>';
      o[o.length] = '<a:gradFill rotWithShape="1">';
      o[o.length] = "<a:gsLst>";
      o[o.length] = '<a:gs pos="0"><a:schemeClr val="phClr"><a:tint val="40000"/><a:satMod val="350000"/></a:schemeClr></a:gs>';
      o[o.length] = '<a:gs pos="40000"><a:schemeClr val="phClr"><a:tint val="45000"/><a:shade val="99000"/><a:satMod val="350000"/></a:schemeClr></a:gs>';
      o[o.length] = '<a:gs pos="100000"><a:schemeClr val="phClr"><a:shade val="20000"/><a:satMod val="255000"/></a:schemeClr></a:gs>';
      o[o.length] = "</a:gsLst>";
      o[o.length] = '<a:path path="circle"><a:fillToRect l="50000" t="-80000" r="50000" b="180000"/></a:path>';
      o[o.length] = "</a:gradFill>";
      o[o.length] = '<a:gradFill rotWithShape="1">';
      o[o.length] = "<a:gsLst>";
      o[o.length] = '<a:gs pos="0"><a:schemeClr val="phClr"><a:tint val="80000"/><a:satMod val="300000"/></a:schemeClr></a:gs>';
      o[o.length] = '<a:gs pos="100000"><a:schemeClr val="phClr"><a:shade val="30000"/><a:satMod val="200000"/></a:schemeClr></a:gs>';
      o[o.length] = "</a:gsLst>";
      o[o.length] = '<a:path path="circle"><a:fillToRect l="50000" t="50000" r="50000" b="50000"/></a:path>';
      o[o.length] = "</a:gradFill>";
      o[o.length] = "</a:bgFillStyleLst>";
      o[o.length] = "</a:fmtScheme>";
      o[o.length] = "</a:themeElements>";
      o[o.length] = "<a:objectDefaults>";
      o[o.length] = "<a:spDef>";
      o[o.length] = '<a:spPr/><a:bodyPr/><a:lstStyle/><a:style><a:lnRef idx="1"><a:schemeClr val="accent1"/></a:lnRef><a:fillRef idx="3"><a:schemeClr val="accent1"/></a:fillRef><a:effectRef idx="2"><a:schemeClr val="accent1"/></a:effectRef><a:fontRef idx="minor"><a:schemeClr val="lt1"/></a:fontRef></a:style>';
      o[o.length] = "</a:spDef>";
      o[o.length] = "<a:lnDef>";
      o[o.length] = '<a:spPr/><a:bodyPr/><a:lstStyle/><a:style><a:lnRef idx="2"><a:schemeClr val="accent1"/></a:lnRef><a:fillRef idx="0"><a:schemeClr val="accent1"/></a:fillRef><a:effectRef idx="1"><a:schemeClr val="accent1"/></a:effectRef><a:fontRef idx="minor"><a:schemeClr val="tx1"/></a:fontRef></a:style>';
      o[o.length] = "</a:lnDef>";
      o[o.length] = "</a:objectDefaults>";
      o[o.length] = "<a:extraClrSchemeLst/>";
      o[o.length] = "</a:theme>";
      return o.join("");
    }
    function parse_BrtMdtinfo(data, length) {
      return {
        flags: data.read_shift(4),
        version: data.read_shift(4),
        name: parse_XLWideString(data)
      };
    }
    function write_BrtMdtinfo(data) {
      var o = new_buf(12 + 2 * data.name.length);
      o.write_shift(4, data.flags);
      o.write_shift(4, data.version);
      write_XLWideString(data.name, o);
      return o.slice(0, o.l);
    }
    function parse_BrtMdb(data) {
      var out = [];
      var cnt = data.read_shift(4);
      while (cnt-- > 0)
        out.push([data.read_shift(4), data.read_shift(4)]);
      return out;
    }
    function write_BrtMdb(mdb) {
      var o = new_buf(4 + 8 * mdb.length);
      o.write_shift(4, mdb.length);
      for (var i = 0; i < mdb.length; ++i) {
        o.write_shift(4, mdb[i][0]);
        o.write_shift(4, mdb[i][1]);
      }
      return o;
    }
    function write_BrtBeginEsfmd(cnt, name) {
      var o = new_buf(8 + 2 * name.length);
      o.write_shift(4, cnt);
      write_XLWideString(name, o);
      return o.slice(0, o.l);
    }
    function parse_BrtBeginEsmdb(data) {
      data.l += 4;
      return data.read_shift(4) != 0;
    }
    function write_BrtBeginEsmdb(cnt, cm) {
      var o = new_buf(8);
      o.write_shift(4, cnt);
      o.write_shift(4, 1);
      return o;
    }
    function write_xlmeta_bin() {
      var ba = buf_array();
      write_record(ba, 332);
      write_record(ba, 334, write_UInt32LE(1));
      write_record(ba, 335, write_BrtMdtinfo({
        name: "XLDAPR",
        version: 12e4,
        flags: 3496657072
      }));
      write_record(ba, 336);
      write_record(ba, 339, write_BrtBeginEsfmd(1, "XLDAPR"));
      write_record(ba, 52);
      write_record(ba, 35, write_UInt32LE(514));
      write_record(ba, 4096, write_UInt32LE(0));
      write_record(ba, 4097, writeuint16(1));
      write_record(ba, 36);
      write_record(ba, 53);
      write_record(ba, 340);
      write_record(ba, 337, write_BrtBeginEsmdb(1));
      write_record(ba, 51, write_BrtMdb([[1, 0]]));
      write_record(ba, 338);
      write_record(ba, 333);
      return ba.end();
    }
    function write_xlmeta_xml() {
      var o = [XML_HEADER];
      o.push('<metadata xmlns="http://schemas.openxmlformats.org/spreadsheetml/2006/main" xmlns:xlrd="http://schemas.microsoft.com/office/spreadsheetml/2017/richdata" xmlns:xda="http://schemas.microsoft.com/office/spreadsheetml/2017/dynamicarray">\n  <metadataTypes count="1">\n    <metadataType name="XLDAPR" minSupportedVersion="120000" copy="1" pasteAll="1" pasteValues="1" merge="1" splitFirst="1" rowColShift="1" clearFormats="1" clearComments="1" assign="1" coerce="1" cellMeta="1"/>\n  </metadataTypes>\n  <futureMetadata name="XLDAPR" count="1">\n    <bk>\n      <extLst>\n        <ext uri="{bdbb8cdc-fa1e-496e-a857-3c3f30c029c3}">\n          <xda:dynamicArrayProperties fDynamic="1" fCollapsed="0"/>\n        </ext>\n      </extLst>\n    </bk>\n  </futureMetadata>\n  <cellMetadata count="1">\n    <bk>\n      <rc t="1" v="0"/>\n    </bk>\n  </cellMetadata>\n</metadata>');
      return o.join("");
    }
    function parse_BrtCalcChainItem$(data) {
      var out = {};
      out.i = data.read_shift(4);
      var cell = {};
      cell.r = data.read_shift(4);
      cell.c = data.read_shift(4);
      out.r = encode_cell(cell);
      var flags = data.read_shift(1);
      if (flags & 2)
        out.l = "1";
      if (flags & 8)
        out.a = "1";
      return out;
    }
    var _shapeid = 1024;
    function write_comments_vml(rId, comments) {
      var csize = [21600, 21600];
      var bbox = ["m0,0l0", csize[1], csize[0], csize[1], csize[0], "0xe"].join(",");
      var o = [
        writextag("xml", null, { "xmlns:v": XLMLNS.v, "xmlns:o": XLMLNS.o, "xmlns:x": XLMLNS.x, "xmlns:mv": XLMLNS.mv }).replace(/\/>/, ">"),
        writextag("o:shapelayout", writextag("o:idmap", null, { "v:ext": "edit", "data": rId }), { "v:ext": "edit" }),
        writextag("v:shapetype", [
          writextag("v:stroke", null, { joinstyle: "miter" }),
          writextag("v:path", null, { gradientshapeok: "t", "o:connecttype": "rect" })
        ].join(""), { id: "_x0000_t202", "o:spt": 202, coordsize: csize.join(","), path: bbox })
      ];
      while (_shapeid < rId * 1e3)
        _shapeid += 1e3;
      comments.forEach(function(x) {
        var c = decode_cell(x[0]);
        var fillopts = (
          /*::(*/
          { "color2": "#BEFF82", "type": "gradient" }
        );
        if (fillopts.type == "gradient")
          fillopts.angle = "-180";
        var fillparm = fillopts.type == "gradient" ? writextag("o:fill", null, { type: "gradientUnscaled", "v:ext": "view" }) : null;
        var fillxml = writextag("v:fill", fillparm, fillopts);
        var shadata = { on: "t", "obscured": "t" };
        ++_shapeid;
        o = o.concat([
          "<v:shape" + wxt_helper({
            id: "_x0000_s" + _shapeid,
            type: "#_x0000_t202",
            style: "position:absolute; margin-left:80pt;margin-top:5pt;width:104pt;height:64pt;z-index:10" + (x[1].hidden ? ";visibility:hidden" : ""),
            fillcolor: "#ECFAD4",
            strokecolor: "#edeaa1"
          }) + ">",
          fillxml,
          writextag("v:shadow", null, shadata),
          writextag("v:path", null, { "o:connecttype": "none" }),
          '<v:textbox><div style="text-align:left"></div></v:textbox>',
          '<x:ClientData ObjectType="Note">',
          "<x:MoveWithCells/>",
          "<x:SizeWithCells/>",
          /* Part 4 19.4.2.3 Anchor (Anchor) */
          writetag("x:Anchor", [c.c + 1, 0, c.r + 1, 0, c.c + 3, 20, c.r + 5, 20].join(",")),
          writetag("x:AutoFill", "False"),
          writetag("x:Row", String(c.r)),
          writetag("x:Column", String(c.c)),
          x[1].hidden ? "" : "<x:Visible/>",
          "</x:ClientData>",
          "</v:shape>"
        ]);
      });
      o.push("</xml>");
      return o.join("");
    }
    function write_comments_xml(data) {
      var o = [XML_HEADER, writextag("comments", null, { "xmlns": XMLNS_main[0] })];
      var iauthor = [];
      o.push("<authors>");
      data.forEach(function(x) {
        x[1].forEach(function(w) {
          var a = escapexml(w.a);
          if (iauthor.indexOf(a) == -1) {
            iauthor.push(a);
            o.push("<author>" + a + "</author>");
          }
          if (w.T && w.ID && iauthor.indexOf("tc=" + w.ID) == -1) {
            iauthor.push("tc=" + w.ID);
            o.push("<author>tc=" + w.ID + "</author>");
          }
        });
      });
      if (iauthor.length == 0) {
        iauthor.push("SheetJ5");
        o.push("<author>SheetJ5</author>");
      }
      o.push("</authors>");
      o.push("<commentList>");
      data.forEach(function(d) {
        var lastauthor = 0, ts = [];
        if (d[1][0] && d[1][0].T && d[1][0].ID)
          lastauthor = iauthor.indexOf("tc=" + d[1][0].ID);
        else
          d[1].forEach(function(c) {
            if (c.a)
              lastauthor = iauthor.indexOf(escapexml(c.a));
            ts.push(c.t || "");
          });
        o.push('<comment ref="' + d[0] + '" authorId="' + lastauthor + '"><text>');
        if (ts.length <= 1)
          o.push(writetag("t", escapexml(ts[0] || "")));
        else {
          var t = "Comment:\n    " + ts[0] + "\n";
          for (var i = 1; i < ts.length; ++i)
            t += "Reply:\n    " + ts[i] + "\n";
          o.push(writetag("t", escapexml(t)));
        }
        o.push("</text></comment>");
      });
      o.push("</commentList>");
      if (o.length > 2) {
        o[o.length] = "</comments>";
        o[1] = o[1].replace("/>", ">");
      }
      return o.join("");
    }
    function write_tcmnt_xml(comments, people, opts) {
      var o = [XML_HEADER, writextag("ThreadedComments", null, { "xmlns": XMLNS.TCMNT }).replace(/[\/]>/, ">")];
      comments.forEach(function(carr) {
        var rootid = "";
        (carr[1] || []).forEach(function(c, idx) {
          if (!c.T) {
            delete c.ID;
            return;
          }
          if (c.a && people.indexOf(c.a) == -1)
            people.push(c.a);
          var tcopts = {
            ref: carr[0],
            id: "{54EE7951-7262-4200-6969-" + ("000000000000" + opts.tcid++).slice(-12) + "}"
          };
          if (idx == 0)
            rootid = tcopts.id;
          else
            tcopts.parentId = rootid;
          c.ID = tcopts.id;
          if (c.a)
            tcopts.personId = "{54EE7950-7262-4200-6969-" + ("000000000000" + people.indexOf(c.a)).slice(-12) + "}";
          o.push(writextag("threadedComment", writetag("text", c.t || ""), tcopts));
        });
      });
      o.push("</ThreadedComments>");
      return o.join("");
    }
    function write_people_xml(people) {
      var o = [XML_HEADER, writextag("personList", null, {
        "xmlns": XMLNS.TCMNT,
        "xmlns:x": XMLNS_main[0]
      }).replace(/[\/]>/, ">")];
      people.forEach(function(person, idx) {
        o.push(writextag("person", null, {
          displayName: person,
          id: "{54EE7950-7262-4200-6969-" + ("000000000000" + idx).slice(-12) + "}",
          userId: person,
          providerId: "None"
        }));
      });
      o.push("</personList>");
      return o.join("");
    }
    function parse_BrtBeginComment(data) {
      var out = {};
      out.iauthor = data.read_shift(4);
      var rfx = parse_UncheckedRfX(data);
      out.rfx = rfx.s;
      out.ref = encode_cell(rfx.s);
      data.l += 16;
      return out;
    }
    function write_BrtBeginComment(data, o) {
      if (o == null)
        o = new_buf(36);
      o.write_shift(4, data[1].iauthor);
      write_UncheckedRfX(data[0], o);
      o.write_shift(4, 0);
      o.write_shift(4, 0);
      o.write_shift(4, 0);
      o.write_shift(4, 0);
      return o;
    }
    var parse_BrtCommentAuthor = parse_XLWideString;
    function write_BrtCommentAuthor(data) {
      return write_XLWideString(data.slice(0, 54));
    }
    function write_comments_bin(data) {
      var ba = buf_array();
      var iauthor = [];
      write_record(
        ba,
        628
        /* BrtBeginComments */
      );
      write_record(
        ba,
        630
        /* BrtBeginCommentAuthors */
      );
      data.forEach(function(comment) {
        comment[1].forEach(function(c) {
          if (iauthor.indexOf(c.a) > -1)
            return;
          iauthor.push(c.a.slice(0, 54));
          write_record(ba, 632, write_BrtCommentAuthor(c.a));
        });
      });
      write_record(
        ba,
        631
        /* BrtEndCommentAuthors */
      );
      write_record(
        ba,
        633
        /* BrtBeginCommentList */
      );
      data.forEach(function(comment) {
        comment[1].forEach(function(c) {
          c.iauthor = iauthor.indexOf(c.a);
          var range = { s: decode_cell(comment[0]), e: decode_cell(comment[0]) };
          write_record(ba, 635, write_BrtBeginComment([range, c]));
          if (c.t && c.t.length > 0)
            write_record(ba, 637, write_BrtCommentText(c));
          write_record(
            ba,
            636
            /* BrtEndComment */
          );
          delete c.iauthor;
        });
      });
      write_record(
        ba,
        634
        /* BrtEndCommentList */
      );
      write_record(
        ba,
        629
        /* BrtEndComments */
      );
      return ba.end();
    }
    function fill_vba_xls(cfb, vba) {
      vba.FullPaths.forEach(function(p, i) {
        if (i == 0)
          return;
        var newpath = p.replace(/[^\/]*[\/]/, "/_VBA_PROJECT_CUR/");
        if (newpath.slice(-1) !== "/")
          CFB.utils.cfb_add(cfb, newpath, vba.FileIndex[i].content);
      });
    }
    var VBAFMTS = ["xlsb", "xlsm", "xlam", "biff8", "xla"];
    var rc_to_a1 = /* @__PURE__ */ function() {
      var rcregex = /(^|[^A-Za-z_])R(\[?-?\d+\]|[1-9]\d*|)C(\[?-?\d+\]|[1-9]\d*|)(?![A-Za-z0-9_])/g;
      var rcbase = { r: 0, c: 0 };
      function rcfunc($$, $1, $2, $3) {
        var cRel = false, rRel = false;
        if ($2.length == 0)
          rRel = true;
        else if ($2.charAt(0) == "[") {
          rRel = true;
          $2 = $2.slice(1, -1);
        }
        if ($3.length == 0)
          cRel = true;
        else if ($3.charAt(0) == "[") {
          cRel = true;
          $3 = $3.slice(1, -1);
        }
        var R = $2.length > 0 ? parseInt($2, 10) | 0 : 0, C = $3.length > 0 ? parseInt($3, 10) | 0 : 0;
        if (cRel)
          C += rcbase.c;
        else
          --C;
        if (rRel)
          R += rcbase.r;
        else
          --R;
        return $1 + (cRel ? "" : "$") + encode_col(C) + (rRel ? "" : "$") + encode_row(R);
      }
      return function rc_to_a12(fstr, base) {
        rcbase = base;
        return fstr.replace(rcregex, rcfunc);
      };
    }();
    var crefregex = /(^|[^._A-Z0-9])([$]?)([A-Z]{1,2}|[A-W][A-Z]{2}|X[A-E][A-Z]|XF[A-D])([$]?)(10[0-3]\d{4}|104[0-7]\d{3}|1048[0-4]\d{2}|10485[0-6]\d|104857[0-6]|[1-9]\d{0,5})(?![_.\(A-Za-z0-9])/g;
    var a1_to_rc = /* @__PURE__ */ function() {
      return function a1_to_rc2(fstr, base) {
        return fstr.replace(crefregex, function($0, $1, $2, $3, $4, $5) {
          var c = decode_col($3) - ($2 ? 0 : base.c);
          var r = decode_row($5) - ($4 ? 0 : base.r);
          var R = r == 0 ? "" : !$4 ? "[" + r + "]" : r + 1;
          var C = c == 0 ? "" : !$2 ? "[" + c + "]" : c + 1;
          return $1 + "R" + R + "C" + C;
        });
      };
    }();
    function shift_formula_str(f, delta) {
      return f.replace(crefregex, function($0, $1, $2, $3, $4, $5) {
        return $1 + ($2 == "$" ? $2 + $3 : encode_col(decode_col($3) + delta.c)) + ($4 == "$" ? $4 + $5 : encode_row(decode_row($5) + delta.r));
      });
    }
    function fuzzyfmla(f) {
      if (f.length == 1)
        return false;
      return true;
    }
    function parseread1(blob) {
      blob.l += 1;
      return;
    }
    function parse_ColRelU(blob, length) {
      var c = blob.read_shift(2);
      return [c & 16383, c >> 14 & 1, c >> 15 & 1];
    }
    function parse_RgceArea(blob, length, opts) {
      var w = 2;
      if (opts) {
        if (opts.biff >= 2 && opts.biff <= 5)
          return parse_RgceArea_BIFF2(blob);
        else if (opts.biff == 12)
          w = 4;
      }
      var r = blob.read_shift(w), R = blob.read_shift(w);
      var c = parse_ColRelU(blob);
      var C = parse_ColRelU(blob);
      return { s: { r, c: c[0], cRel: c[1], rRel: c[2] }, e: { r: R, c: C[0], cRel: C[1], rRel: C[2] } };
    }
    function parse_RgceArea_BIFF2(blob) {
      var r = parse_ColRelU(blob), R = parse_ColRelU(blob);
      var c = blob.read_shift(1);
      var C = blob.read_shift(1);
      return { s: { r: r[0], c, cRel: r[1], rRel: r[2] }, e: { r: R[0], c: C, cRel: R[1], rRel: R[2] } };
    }
    function parse_RgceAreaRel(blob, length, opts) {
      if (opts.biff < 8)
        return parse_RgceArea_BIFF2(blob);
      var r = blob.read_shift(opts.biff == 12 ? 4 : 2), R = blob.read_shift(opts.biff == 12 ? 4 : 2);
      var c = parse_ColRelU(blob);
      var C = parse_ColRelU(blob);
      return { s: { r, c: c[0], cRel: c[1], rRel: c[2] }, e: { r: R, c: C[0], cRel: C[1], rRel: C[2] } };
    }
    function parse_RgceLoc(blob, length, opts) {
      if (opts && opts.biff >= 2 && opts.biff <= 5)
        return parse_RgceLoc_BIFF2(blob);
      var r = blob.read_shift(opts && opts.biff == 12 ? 4 : 2);
      var c = parse_ColRelU(blob);
      return { r, c: c[0], cRel: c[1], rRel: c[2] };
    }
    function parse_RgceLoc_BIFF2(blob) {
      var r = parse_ColRelU(blob);
      var c = blob.read_shift(1);
      return { r: r[0], c, cRel: r[1], rRel: r[2] };
    }
    function parse_RgceElfLoc(blob) {
      var r = blob.read_shift(2);
      var c = blob.read_shift(2);
      return { r, c: c & 255, fQuoted: !!(c & 16384), cRel: c >> 15, rRel: c >> 15 };
    }
    function parse_RgceLocRel(blob, length, opts) {
      var biff = opts && opts.biff ? opts.biff : 8;
      if (biff >= 2 && biff <= 5)
        return parse_RgceLocRel_BIFF2(blob);
      var r = blob.read_shift(biff >= 12 ? 4 : 2);
      var cl = blob.read_shift(2);
      var cRel = (cl & 16384) >> 14, rRel = (cl & 32768) >> 15;
      cl &= 16383;
      if (rRel == 1)
        while (r > 524287)
          r -= 1048576;
      if (cRel == 1)
        while (cl > 8191)
          cl = cl - 16384;
      return { r, c: cl, cRel, rRel };
    }
    function parse_RgceLocRel_BIFF2(blob) {
      var rl = blob.read_shift(2);
      var c = blob.read_shift(1);
      var rRel = (rl & 32768) >> 15, cRel = (rl & 16384) >> 14;
      rl &= 16383;
      if (rRel == 1 && rl >= 8192)
        rl = rl - 16384;
      if (cRel == 1 && c >= 128)
        c = c - 256;
      return { r: rl, c, cRel, rRel };
    }
    function parse_PtgArea(blob, length, opts) {
      var type = (blob[blob.l++] & 96) >> 5;
      var area = parse_RgceArea(blob, opts.biff >= 2 && opts.biff <= 5 ? 6 : 8, opts);
      return [type, area];
    }
    function parse_PtgArea3d(blob, length, opts) {
      var type = (blob[blob.l++] & 96) >> 5;
      var ixti = blob.read_shift(2, "i");
      var w = 8;
      if (opts)
        switch (opts.biff) {
          case 5:
            blob.l += 12;
            w = 6;
            break;
          case 12:
            w = 12;
            break;
        }
      var area = parse_RgceArea(blob, w, opts);
      return [type, ixti, area];
    }
    function parse_PtgAreaErr(blob, length, opts) {
      var type = (blob[blob.l++] & 96) >> 5;
      blob.l += opts && opts.biff > 8 ? 12 : opts.biff < 8 ? 6 : 8;
      return [type];
    }
    function parse_PtgAreaErr3d(blob, length, opts) {
      var type = (blob[blob.l++] & 96) >> 5;
      var ixti = blob.read_shift(2);
      var w = 8;
      if (opts)
        switch (opts.biff) {
          case 5:
            blob.l += 12;
            w = 6;
            break;
          case 12:
            w = 12;
            break;
        }
      blob.l += w;
      return [type, ixti];
    }
    function parse_PtgAreaN(blob, length, opts) {
      var type = (blob[blob.l++] & 96) >> 5;
      var area = parse_RgceAreaRel(blob, length - 1, opts);
      return [type, area];
    }
    function parse_PtgArray(blob, length, opts) {
      var type = (blob[blob.l++] & 96) >> 5;
      blob.l += opts.biff == 2 ? 6 : opts.biff == 12 ? 14 : 7;
      return [type];
    }
    function parse_PtgAttrBaxcel(blob) {
      var bitSemi = blob[blob.l + 1] & 1;
      var bitBaxcel = 1;
      blob.l += 4;
      return [bitSemi, bitBaxcel];
    }
    function parse_PtgAttrChoose(blob, length, opts) {
      blob.l += 2;
      var offset = blob.read_shift(opts && opts.biff == 2 ? 1 : 2);
      var o = [];
      for (var i = 0; i <= offset; ++i)
        o.push(blob.read_shift(opts && opts.biff == 2 ? 1 : 2));
      return o;
    }
    function parse_PtgAttrGoto(blob, length, opts) {
      var bitGoto = blob[blob.l + 1] & 255 ? 1 : 0;
      blob.l += 2;
      return [bitGoto, blob.read_shift(opts && opts.biff == 2 ? 1 : 2)];
    }
    function parse_PtgAttrIf(blob, length, opts) {
      var bitIf = blob[blob.l + 1] & 255 ? 1 : 0;
      blob.l += 2;
      return [bitIf, blob.read_shift(opts && opts.biff == 2 ? 1 : 2)];
    }
    function parse_PtgAttrIfError(blob) {
      var bitIf = blob[blob.l + 1] & 255 ? 1 : 0;
      blob.l += 2;
      return [bitIf, blob.read_shift(2)];
    }
    function parse_PtgAttrSemi(blob, length, opts) {
      var bitSemi = blob[blob.l + 1] & 255 ? 1 : 0;
      blob.l += opts && opts.biff == 2 ? 3 : 4;
      return [bitSemi];
    }
    function parse_PtgAttrSpaceType(blob) {
      var type = blob.read_shift(1), cch = blob.read_shift(1);
      return [type, cch];
    }
    function parse_PtgAttrSpace(blob) {
      blob.read_shift(2);
      return parse_PtgAttrSpaceType(blob);
    }
    function parse_PtgAttrSpaceSemi(blob) {
      blob.read_shift(2);
      return parse_PtgAttrSpaceType(blob);
    }
    function parse_PtgRef(blob, length, opts) {
      var type = (blob[blob.l] & 96) >> 5;
      blob.l += 1;
      var loc = parse_RgceLoc(blob, 0, opts);
      return [type, loc];
    }
    function parse_PtgRefN(blob, length, opts) {
      var type = (blob[blob.l] & 96) >> 5;
      blob.l += 1;
      var loc = parse_RgceLocRel(blob, 0, opts);
      return [type, loc];
    }
    function parse_PtgRef3d(blob, length, opts) {
      var type = (blob[blob.l] & 96) >> 5;
      blob.l += 1;
      var ixti = blob.read_shift(2);
      if (opts && opts.biff == 5)
        blob.l += 12;
      var loc = parse_RgceLoc(blob, 0, opts);
      return [type, ixti, loc];
    }
    function parse_PtgFunc(blob, length, opts) {
      var type = (blob[blob.l] & 96) >> 5;
      blob.l += 1;
      var iftab = blob.read_shift(opts && opts.biff <= 3 ? 1 : 2);
      return [FtabArgc[iftab], Ftab[iftab], type];
    }
    function parse_PtgFuncVar(blob, length, opts) {
      var type = blob[blob.l++];
      var cparams = blob.read_shift(1), tab = opts && opts.biff <= 3 ? [type == 88 ? -1 : 0, blob.read_shift(1)] : parsetab(blob);
      return [cparams, (tab[0] === 0 ? Ftab : Cetab)[tab[1]]];
    }
    function parsetab(blob) {
      return [blob[blob.l + 1] >> 7, blob.read_shift(2) & 32767];
    }
    function parse_PtgAttrSum(blob, length, opts) {
      blob.l += opts && opts.biff == 2 ? 3 : 4;
      return;
    }
    function parse_PtgExp(blob, length, opts) {
      blob.l++;
      if (opts && opts.biff == 12)
        return [blob.read_shift(4, "i"), 0];
      var row = blob.read_shift(2);
      var col = blob.read_shift(opts && opts.biff == 2 ? 1 : 2);
      return [row, col];
    }
    function parse_PtgErr(blob) {
      blob.l++;
      return BErr[blob.read_shift(1)];
    }
    function parse_PtgInt(blob) {
      blob.l++;
      return blob.read_shift(2);
    }
    function parse_PtgBool(blob) {
      blob.l++;
      return blob.read_shift(1) !== 0;
    }
    function parse_PtgNum(blob) {
      blob.l++;
      return parse_Xnum(blob);
    }
    function parse_PtgStr(blob, length, opts) {
      blob.l++;
      return parse_ShortXLUnicodeString(blob, length - 1, opts);
    }
    function parse_SerAr(blob, biff) {
      var val = [blob.read_shift(1)];
      if (biff == 12)
        switch (val[0]) {
          case 2:
            val[0] = 4;
            break;
          case 4:
            val[0] = 16;
            break;
          case 0:
            val[0] = 1;
            break;
          case 1:
            val[0] = 2;
            break;
        }
      switch (val[0]) {
        case 4:
          val[1] = parsebool(blob, 1) ? "TRUE" : "FALSE";
          if (biff != 12)
            blob.l += 7;
          break;
        case 37:
        case 16:
          val[1] = BErr[blob[blob.l]];
          blob.l += biff == 12 ? 4 : 8;
          break;
        case 0:
          blob.l += 8;
          break;
        case 1:
          val[1] = parse_Xnum(blob);
          break;
        case 2:
          val[1] = parse_XLUnicodeString2(blob, 0, { biff: biff > 0 && biff < 8 ? 2 : biff });
          break;
        default:
          throw new Error("Bad SerAr: " + val[0]);
      }
      return val;
    }
    function parse_PtgExtraMem(blob, cce, opts) {
      var count = blob.read_shift(opts.biff == 12 ? 4 : 2);
      var out = [];
      for (var i = 0; i != count; ++i)
        out.push((opts.biff == 12 ? parse_UncheckedRfX : parse_Ref8U)(blob));
      return out;
    }
    function parse_PtgExtraArray(blob, length, opts) {
      var rows = 0, cols = 0;
      if (opts.biff == 12) {
        rows = blob.read_shift(4);
        cols = blob.read_shift(4);
      } else {
        cols = 1 + blob.read_shift(1);
        rows = 1 + blob.read_shift(2);
      }
      if (opts.biff >= 2 && opts.biff < 8) {
        --rows;
        if (--cols == 0)
          cols = 256;
      }
      for (var i = 0, o = []; i != rows && (o[i] = []); ++i)
        for (var j = 0; j != cols; ++j)
          o[i][j] = parse_SerAr(blob, opts.biff);
      return o;
    }
    function parse_PtgName(blob, length, opts) {
      var type = blob.read_shift(1) >>> 5 & 3;
      var w = !opts || opts.biff >= 8 ? 4 : 2;
      var nameindex = blob.read_shift(w);
      switch (opts.biff) {
        case 2:
          blob.l += 5;
          break;
        case 3:
        case 4:
          blob.l += 8;
          break;
        case 5:
          blob.l += 12;
          break;
      }
      return [type, 0, nameindex];
    }
    function parse_PtgNameX(blob, length, opts) {
      if (opts.biff == 5)
        return parse_PtgNameX_BIFF5(blob);
      var type = blob.read_shift(1) >>> 5 & 3;
      var ixti = blob.read_shift(2);
      var nameindex = blob.read_shift(4);
      return [type, ixti, nameindex];
    }
    function parse_PtgNameX_BIFF5(blob) {
      var type = blob.read_shift(1) >>> 5 & 3;
      var ixti = blob.read_shift(2, "i");
      blob.l += 8;
      var nameindex = blob.read_shift(2);
      blob.l += 12;
      return [type, ixti, nameindex];
    }
    function parse_PtgMemArea(blob, length, opts) {
      var type = blob.read_shift(1) >>> 5 & 3;
      blob.l += opts && opts.biff == 2 ? 3 : 4;
      var cce = blob.read_shift(opts && opts.biff == 2 ? 1 : 2);
      return [type, cce];
    }
    function parse_PtgMemFunc(blob, length, opts) {
      var type = blob.read_shift(1) >>> 5 & 3;
      var cce = blob.read_shift(opts && opts.biff == 2 ? 1 : 2);
      return [type, cce];
    }
    function parse_PtgRefErr(blob, length, opts) {
      var type = blob.read_shift(1) >>> 5 & 3;
      blob.l += 4;
      if (opts.biff < 8)
        blob.l--;
      if (opts.biff == 12)
        blob.l += 2;
      return [type];
    }
    function parse_PtgRefErr3d(blob, length, opts) {
      var type = (blob[blob.l++] & 96) >> 5;
      var ixti = blob.read_shift(2);
      var w = 4;
      if (opts)
        switch (opts.biff) {
          case 5:
            w = 15;
            break;
          case 12:
            w = 6;
            break;
        }
      blob.l += w;
      return [type, ixti];
    }
    var parse_PtgMemErr = parsenoop;
    var parse_PtgMemNoMem = parsenoop;
    var parse_PtgTbl = parsenoop;
    function parse_PtgElfLoc(blob, length, opts) {
      blob.l += 2;
      return [parse_RgceElfLoc(blob)];
    }
    function parse_PtgElfNoop(blob) {
      blob.l += 6;
      return [];
    }
    var parse_PtgElfCol = parse_PtgElfLoc;
    var parse_PtgElfColS = parse_PtgElfNoop;
    var parse_PtgElfColSV = parse_PtgElfNoop;
    var parse_PtgElfColV = parse_PtgElfLoc;
    function parse_PtgElfLel(blob) {
      blob.l += 2;
      return [parseuint16(blob), blob.read_shift(2) & 1];
    }
    var parse_PtgElfRadical = parse_PtgElfLoc;
    var parse_PtgElfRadicalLel = parse_PtgElfLel;
    var parse_PtgElfRadicalS = parse_PtgElfNoop;
    var parse_PtgElfRw = parse_PtgElfLoc;
    var parse_PtgElfRwV = parse_PtgElfLoc;
    var PtgListRT = [
      "Data",
      "All",
      "Headers",
      "??",
      "?Data2",
      "??",
      "?DataHeaders",
      "??",
      "Totals",
      "??",
      "??",
      "??",
      "?DataTotals",
      "??",
      "??",
      "??",
      "?Current"
    ];
    function parse_PtgList(blob) {
      blob.l += 2;
      var ixti = blob.read_shift(2);
      var flags = blob.read_shift(2);
      var idx = blob.read_shift(4);
      var c = blob.read_shift(2);
      var C = blob.read_shift(2);
      var rt = PtgListRT[flags >> 2 & 31];
      return { ixti, coltype: flags & 3, rt, idx, c, C };
    }
    function parse_PtgSxName(blob) {
      blob.l += 2;
      return [blob.read_shift(4)];
    }
    function parse_PtgSheet(blob, length, opts) {
      blob.l += 5;
      blob.l += 2;
      blob.l += opts.biff == 2 ? 1 : 4;
      return ["PTGSHEET"];
    }
    function parse_PtgEndSheet(blob, length, opts) {
      blob.l += opts.biff == 2 ? 4 : 5;
      return ["PTGENDSHEET"];
    }
    function parse_PtgMemAreaN(blob) {
      var type = blob.read_shift(1) >>> 5 & 3;
      var cce = blob.read_shift(2);
      return [type, cce];
    }
    function parse_PtgMemNoMemN(blob) {
      var type = blob.read_shift(1) >>> 5 & 3;
      var cce = blob.read_shift(2);
      return [type, cce];
    }
    function parse_PtgAttrNoop(blob) {
      blob.l += 4;
      return [0, 0];
    }
    var PtgTypes = {
      /*::[*/
      1: { n: "PtgExp", f: parse_PtgExp },
      /*::[*/
      2: { n: "PtgTbl", f: parse_PtgTbl },
      /*::[*/
      3: { n: "PtgAdd", f: parseread1 },
      /*::[*/
      4: { n: "PtgSub", f: parseread1 },
      /*::[*/
      5: { n: "PtgMul", f: parseread1 },
      /*::[*/
      6: { n: "PtgDiv", f: parseread1 },
      /*::[*/
      7: { n: "PtgPower", f: parseread1 },
      /*::[*/
      8: { n: "PtgConcat", f: parseread1 },
      /*::[*/
      9: { n: "PtgLt", f: parseread1 },
      /*::[*/
      10: { n: "PtgLe", f: parseread1 },
      /*::[*/
      11: { n: "PtgEq", f: parseread1 },
      /*::[*/
      12: { n: "PtgGe", f: parseread1 },
      /*::[*/
      13: { n: "PtgGt", f: parseread1 },
      /*::[*/
      14: { n: "PtgNe", f: parseread1 },
      /*::[*/
      15: { n: "PtgIsect", f: parseread1 },
      /*::[*/
      16: { n: "PtgUnion", f: parseread1 },
      /*::[*/
      17: { n: "PtgRange", f: parseread1 },
      /*::[*/
      18: { n: "PtgUplus", f: parseread1 },
      /*::[*/
      19: { n: "PtgUminus", f: parseread1 },
      /*::[*/
      20: { n: "PtgPercent", f: parseread1 },
      /*::[*/
      21: { n: "PtgParen", f: parseread1 },
      /*::[*/
      22: { n: "PtgMissArg", f: parseread1 },
      /*::[*/
      23: { n: "PtgStr", f: parse_PtgStr },
      /*::[*/
      26: { n: "PtgSheet", f: parse_PtgSheet },
      /*::[*/
      27: { n: "PtgEndSheet", f: parse_PtgEndSheet },
      /*::[*/
      28: { n: "PtgErr", f: parse_PtgErr },
      /*::[*/
      29: { n: "PtgBool", f: parse_PtgBool },
      /*::[*/
      30: { n: "PtgInt", f: parse_PtgInt },
      /*::[*/
      31: { n: "PtgNum", f: parse_PtgNum },
      /*::[*/
      32: { n: "PtgArray", f: parse_PtgArray },
      /*::[*/
      33: { n: "PtgFunc", f: parse_PtgFunc },
      /*::[*/
      34: { n: "PtgFuncVar", f: parse_PtgFuncVar },
      /*::[*/
      35: { n: "PtgName", f: parse_PtgName },
      /*::[*/
      36: { n: "PtgRef", f: parse_PtgRef },
      /*::[*/
      37: { n: "PtgArea", f: parse_PtgArea },
      /*::[*/
      38: { n: "PtgMemArea", f: parse_PtgMemArea },
      /*::[*/
      39: { n: "PtgMemErr", f: parse_PtgMemErr },
      /*::[*/
      40: { n: "PtgMemNoMem", f: parse_PtgMemNoMem },
      /*::[*/
      41: { n: "PtgMemFunc", f: parse_PtgMemFunc },
      /*::[*/
      42: { n: "PtgRefErr", f: parse_PtgRefErr },
      /*::[*/
      43: { n: "PtgAreaErr", f: parse_PtgAreaErr },
      /*::[*/
      44: { n: "PtgRefN", f: parse_PtgRefN },
      /*::[*/
      45: { n: "PtgAreaN", f: parse_PtgAreaN },
      /*::[*/
      46: { n: "PtgMemAreaN", f: parse_PtgMemAreaN },
      /*::[*/
      47: { n: "PtgMemNoMemN", f: parse_PtgMemNoMemN },
      /*::[*/
      57: { n: "PtgNameX", f: parse_PtgNameX },
      /*::[*/
      58: { n: "PtgRef3d", f: parse_PtgRef3d },
      /*::[*/
      59: { n: "PtgArea3d", f: parse_PtgArea3d },
      /*::[*/
      60: { n: "PtgRefErr3d", f: parse_PtgRefErr3d },
      /*::[*/
      61: { n: "PtgAreaErr3d", f: parse_PtgAreaErr3d },
      /*::[*/
      255: {}
    };
    var PtgDupes = {
      /*::[*/
      64: 32,
      /*::[*/
      96: 32,
      /*::[*/
      65: 33,
      /*::[*/
      97: 33,
      /*::[*/
      66: 34,
      /*::[*/
      98: 34,
      /*::[*/
      67: 35,
      /*::[*/
      99: 35,
      /*::[*/
      68: 36,
      /*::[*/
      100: 36,
      /*::[*/
      69: 37,
      /*::[*/
      101: 37,
      /*::[*/
      70: 38,
      /*::[*/
      102: 38,
      /*::[*/
      71: 39,
      /*::[*/
      103: 39,
      /*::[*/
      72: 40,
      /*::[*/
      104: 40,
      /*::[*/
      73: 41,
      /*::[*/
      105: 41,
      /*::[*/
      74: 42,
      /*::[*/
      106: 42,
      /*::[*/
      75: 43,
      /*::[*/
      107: 43,
      /*::[*/
      76: 44,
      /*::[*/
      108: 44,
      /*::[*/
      77: 45,
      /*::[*/
      109: 45,
      /*::[*/
      78: 46,
      /*::[*/
      110: 46,
      /*::[*/
      79: 47,
      /*::[*/
      111: 47,
      /*::[*/
      88: 34,
      /*::[*/
      120: 34,
      /*::[*/
      89: 57,
      /*::[*/
      121: 57,
      /*::[*/
      90: 58,
      /*::[*/
      122: 58,
      /*::[*/
      91: 59,
      /*::[*/
      123: 59,
      /*::[*/
      92: 60,
      /*::[*/
      124: 60,
      /*::[*/
      93: 61,
      /*::[*/
      125: 61
    };
    var Ptg18 = {
      /*::[*/
      1: { n: "PtgElfLel", f: parse_PtgElfLel },
      /*::[*/
      2: { n: "PtgElfRw", f: parse_PtgElfRw },
      /*::[*/
      3: { n: "PtgElfCol", f: parse_PtgElfCol },
      /*::[*/
      6: { n: "PtgElfRwV", f: parse_PtgElfRwV },
      /*::[*/
      7: { n: "PtgElfColV", f: parse_PtgElfColV },
      /*::[*/
      10: { n: "PtgElfRadical", f: parse_PtgElfRadical },
      /*::[*/
      11: { n: "PtgElfRadicalS", f: parse_PtgElfRadicalS },
      /*::[*/
      13: { n: "PtgElfColS", f: parse_PtgElfColS },
      /*::[*/
      15: { n: "PtgElfColSV", f: parse_PtgElfColSV },
      /*::[*/
      16: { n: "PtgElfRadicalLel", f: parse_PtgElfRadicalLel },
      /*::[*/
      25: { n: "PtgList", f: parse_PtgList },
      /*::[*/
      29: { n: "PtgSxName", f: parse_PtgSxName },
      /*::[*/
      255: {}
    };
    var Ptg19 = {
      /*::[*/
      0: { n: "PtgAttrNoop", f: parse_PtgAttrNoop },
      /*::[*/
      1: { n: "PtgAttrSemi", f: parse_PtgAttrSemi },
      /*::[*/
      2: { n: "PtgAttrIf", f: parse_PtgAttrIf },
      /*::[*/
      4: { n: "PtgAttrChoose", f: parse_PtgAttrChoose },
      /*::[*/
      8: { n: "PtgAttrGoto", f: parse_PtgAttrGoto },
      /*::[*/
      16: { n: "PtgAttrSum", f: parse_PtgAttrSum },
      /*::[*/
      32: { n: "PtgAttrBaxcel", f: parse_PtgAttrBaxcel },
      /*::[*/
      33: { n: "PtgAttrBaxcel", f: parse_PtgAttrBaxcel },
      /*::[*/
      64: { n: "PtgAttrSpace", f: parse_PtgAttrSpace },
      /*::[*/
      65: { n: "PtgAttrSpaceSemi", f: parse_PtgAttrSpaceSemi },
      /*::[*/
      128: { n: "PtgAttrIfError", f: parse_PtgAttrIfError },
      /*::[*/
      255: {}
    };
    function parse_RgbExtra(blob, length, rgce, opts) {
      if (opts.biff < 8)
        return parsenoop(blob, length);
      var target = blob.l + length;
      var o = [];
      for (var i = 0; i !== rgce.length; ++i) {
        switch (rgce[i][0]) {
          case "PtgArray":
            rgce[i][1] = parse_PtgExtraArray(blob, 0, opts);
            o.push(rgce[i][1]);
            break;
          case "PtgMemArea":
            rgce[i][2] = parse_PtgExtraMem(blob, rgce[i][1], opts);
            o.push(rgce[i][2]);
            break;
          case "PtgExp":
            if (opts && opts.biff == 12) {
              rgce[i][1][1] = blob.read_shift(4);
              o.push(rgce[i][1]);
            }
            break;
          case "PtgList":
          case "PtgElfRadicalS":
          case "PtgElfColS":
          case "PtgElfColSV":
            throw "Unsupported " + rgce[i][0];
        }
      }
      length = target - blob.l;
      if (length !== 0)
        o.push(parsenoop(blob, length));
      return o;
    }
    function parse_Rgce(blob, length, opts) {
      var target = blob.l + length;
      var R, id, ptgs = [];
      while (target != blob.l) {
        length = target - blob.l;
        id = blob[blob.l];
        R = PtgTypes[id] || PtgTypes[PtgDupes[id]];
        if (id === 24 || id === 25)
          R = (id === 24 ? Ptg18 : Ptg19)[blob[blob.l + 1]];
        if (!R || !R.f) {
          parsenoop(blob, length);
        } else {
          ptgs.push([R.n, R.f(blob, length, opts)]);
        }
      }
      return ptgs;
    }
    function stringify_array(f) {
      var o = [];
      for (var i = 0; i < f.length; ++i) {
        var x = f[i], r = [];
        for (var j = 0; j < x.length; ++j) {
          var y = x[j];
          if (y)
            switch (y[0]) {
              case 2:
                r.push('"' + y[1].replace(/"/g, '""') + '"');
                break;
              default:
                r.push(y[1]);
            }
          else
            r.push("");
        }
        o.push(r.join(","));
      }
      return o.join(";");
    }
    var PtgBinOp = {
      PtgAdd: "+",
      PtgConcat: "&",
      PtgDiv: "/",
      PtgEq: "=",
      PtgGe: ">=",
      PtgGt: ">",
      PtgLe: "<=",
      PtgLt: "<",
      PtgMul: "*",
      PtgNe: "<>",
      PtgPower: "^",
      PtgSub: "-"
    };
    function formula_quote_sheet_name(sname, opts) {
      if (!sname && !(opts && opts.biff <= 5 && opts.biff >= 2))
        throw new Error("empty sheet name");
      if (/[^\w\u4E00-\u9FFF\u3040-\u30FF]/.test(sname))
        return "'" + sname + "'";
      return sname;
    }
    function get_ixti_raw(supbooks, ixti, opts) {
      if (!supbooks)
        return "SH33TJSERR0";
      if (opts.biff > 8 && (!supbooks.XTI || !supbooks.XTI[ixti]))
        return supbooks.SheetNames[ixti];
      if (!supbooks.XTI)
        return "SH33TJSERR6";
      var XTI = supbooks.XTI[ixti];
      if (opts.biff < 8) {
        if (ixti > 1e4)
          ixti -= 65536;
        if (ixti < 0)
          ixti = -ixti;
        return ixti == 0 ? "" : supbooks.XTI[ixti - 1];
      }
      if (!XTI)
        return "SH33TJSERR1";
      var o = "";
      if (opts.biff > 8)
        switch (supbooks[XTI[0]][0]) {
          case 357:
            o = XTI[1] == -1 ? "#REF" : supbooks.SheetNames[XTI[1]];
            return XTI[1] == XTI[2] ? o : o + ":" + supbooks.SheetNames[XTI[2]];
          case 358:
            if (opts.SID != null)
              return supbooks.SheetNames[opts.SID];
            return "SH33TJSSAME" + supbooks[XTI[0]][0];
          case 355:
          default:
            return "SH33TJSSRC" + supbooks[XTI[0]][0];
        }
      switch (supbooks[XTI[0]][0][0]) {
        case 1025:
          o = XTI[1] == -1 ? "#REF" : supbooks.SheetNames[XTI[1]] || "SH33TJSERR3";
          return XTI[1] == XTI[2] ? o : o + ":" + supbooks.SheetNames[XTI[2]];
        case 14849:
          return supbooks[XTI[0]].slice(1).map(function(name) {
            return name.Name;
          }).join(";;");
        default:
          if (!supbooks[XTI[0]][0][3])
            return "SH33TJSERR2";
          o = XTI[1] == -1 ? "#REF" : supbooks[XTI[0]][0][3][XTI[1]] || "SH33TJSERR4";
          return XTI[1] == XTI[2] ? o : o + ":" + supbooks[XTI[0]][0][3][XTI[2]];
      }
    }
    function get_ixti(supbooks, ixti, opts) {
      var ixtiraw = get_ixti_raw(supbooks, ixti, opts);
      return ixtiraw == "#REF" ? ixtiraw : formula_quote_sheet_name(ixtiraw, opts);
    }
    function stringify_formula(formula, range, cell, supbooks, opts) {
      var biff = opts && opts.biff || 8;
      var _range = (
        /*range != null ? range :*/
        { s: { c: 0, r: 0 } }
      );
      var stack = [], e1, e2, c, ixti = 0, nameidx = 0, r, sname = "";
      if (!formula[0] || !formula[0][0])
        return "";
      var last_sp = -1, sp = "";
      for (var ff = 0, fflen = formula[0].length; ff < fflen; ++ff) {
        var f = formula[0][ff];
        switch (f[0]) {
          case "PtgUminus":
            stack.push("-" + stack.pop());
            break;
          case "PtgUplus":
            stack.push("+" + stack.pop());
            break;
          case "PtgPercent":
            stack.push(stack.pop() + "%");
            break;
          case "PtgAdd":
          case "PtgConcat":
          case "PtgDiv":
          case "PtgEq":
          case "PtgGe":
          case "PtgGt":
          case "PtgLe":
          case "PtgLt":
          case "PtgMul":
          case "PtgNe":
          case "PtgPower":
          case "PtgSub":
            e1 = stack.pop();
            e2 = stack.pop();
            if (last_sp >= 0) {
              switch (formula[0][last_sp][1][0]) {
                case 0:
                  sp = fill(" ", formula[0][last_sp][1][1]);
                  break;
                case 1:
                  sp = fill("\r", formula[0][last_sp][1][1]);
                  break;
                default:
                  sp = "";
                  if (opts.WTF)
                    throw new Error("Unexpected PtgAttrSpaceType " + formula[0][last_sp][1][0]);
              }
              e2 = e2 + sp;
              last_sp = -1;
            }
            stack.push(e2 + PtgBinOp[f[0]] + e1);
            break;
          case "PtgIsect":
            e1 = stack.pop();
            e2 = stack.pop();
            stack.push(e2 + " " + e1);
            break;
          case "PtgUnion":
            e1 = stack.pop();
            e2 = stack.pop();
            stack.push(e2 + "," + e1);
            break;
          case "PtgRange":
            e1 = stack.pop();
            e2 = stack.pop();
            stack.push(e2 + ":" + e1);
            break;
          case "PtgAttrChoose":
            break;
          case "PtgAttrGoto":
            break;
          case "PtgAttrIf":
            break;
          case "PtgAttrIfError":
            break;
          case "PtgRef":
            c = shift_cell_xls(f[1][1], _range, opts);
            stack.push(encode_cell_xls(c, biff));
            break;
          case "PtgRefN":
            c = cell ? shift_cell_xls(f[1][1], cell, opts) : f[1][1];
            stack.push(encode_cell_xls(c, biff));
            break;
          case "PtgRef3d":
            ixti = /*::Number(*/
            f[1][1];
            c = shift_cell_xls(f[1][2], _range, opts);
            sname = get_ixti(supbooks, ixti, opts);
            stack.push(sname + "!" + encode_cell_xls(c, biff));
            break;
          case "PtgFunc":
          case "PtgFuncVar":
            var argc = f[1][0], func = f[1][1];
            if (!argc)
              argc = 0;
            argc &= 127;
            var args = argc == 0 ? [] : stack.slice(-argc);
            stack.length -= argc;
            if (func === "User")
              func = args.shift();
            stack.push(func + "(" + args.join(",") + ")");
            break;
          case "PtgBool":
            stack.push(f[1] ? "TRUE" : "FALSE");
            break;
          case "PtgInt":
            stack.push(
              /*::String(*/
              f[1]
              /*::)*/
            );
            break;
          case "PtgNum":
            stack.push(String(f[1]));
            break;
          case "PtgStr":
            stack.push('"' + f[1].replace(/"/g, '""') + '"');
            break;
          case "PtgErr":
            stack.push(
              /*::String(*/
              f[1]
              /*::)*/
            );
            break;
          case "PtgAreaN":
            r = shift_range_xls(f[1][1], cell ? { s: cell } : _range, opts);
            stack.push(encode_range_xls(r, opts));
            break;
          case "PtgArea":
            r = shift_range_xls(f[1][1], _range, opts);
            stack.push(encode_range_xls(r, opts));
            break;
          case "PtgArea3d":
            ixti = /*::Number(*/
            f[1][1];
            r = f[1][2];
            sname = get_ixti(supbooks, ixti, opts);
            stack.push(sname + "!" + encode_range_xls(r, opts));
            break;
          case "PtgAttrSum":
            stack.push("SUM(" + stack.pop() + ")");
            break;
          case "PtgAttrBaxcel":
          case "PtgAttrSemi":
            break;
          case "PtgName":
            nameidx = f[1][2];
            var lbl = (supbooks.names || [])[nameidx - 1] || (supbooks[0] || [])[nameidx];
            var name = lbl ? lbl.Name : "SH33TJSNAME" + String(nameidx);
            if (name && name.slice(0, 6) == "_xlfn." && !opts.xlfn)
              name = name.slice(6);
            stack.push(name);
            break;
          case "PtgNameX":
            var bookidx = f[1][1];
            nameidx = f[1][2];
            var externbook;
            if (opts.biff <= 5) {
              if (bookidx < 0)
                bookidx = -bookidx;
              if (supbooks[bookidx])
                externbook = supbooks[bookidx][nameidx];
            } else {
              var o = "";
              if (((supbooks[bookidx] || [])[0] || [])[0] == 14849)
                ;
              else if (((supbooks[bookidx] || [])[0] || [])[0] == 1025) {
                if (supbooks[bookidx][nameidx] && supbooks[bookidx][nameidx].itab > 0) {
                  o = supbooks.SheetNames[supbooks[bookidx][nameidx].itab - 1] + "!";
                }
              } else
                o = supbooks.SheetNames[nameidx - 1] + "!";
              if (supbooks[bookidx] && supbooks[bookidx][nameidx])
                o += supbooks[bookidx][nameidx].Name;
              else if (supbooks[0] && supbooks[0][nameidx])
                o += supbooks[0][nameidx].Name;
              else {
                var ixtidata = (get_ixti_raw(supbooks, bookidx, opts) || "").split(";;");
                if (ixtidata[nameidx - 1])
                  o = ixtidata[nameidx - 1];
                else
                  o += "SH33TJSERRX";
              }
              stack.push(o);
              break;
            }
            if (!externbook)
              externbook = { Name: "SH33TJSERRY" };
            stack.push(externbook.Name);
            break;
          case "PtgParen":
            var lp = "(", rp = ")";
            if (last_sp >= 0) {
              sp = "";
              switch (formula[0][last_sp][1][0]) {
                case 2:
                  lp = fill(" ", formula[0][last_sp][1][1]) + lp;
                  break;
                case 3:
                  lp = fill("\r", formula[0][last_sp][1][1]) + lp;
                  break;
                case 4:
                  rp = fill(" ", formula[0][last_sp][1][1]) + rp;
                  break;
                case 5:
                  rp = fill("\r", formula[0][last_sp][1][1]) + rp;
                  break;
                default:
                  if (opts.WTF)
                    throw new Error("Unexpected PtgAttrSpaceType " + formula[0][last_sp][1][0]);
              }
              last_sp = -1;
            }
            stack.push(lp + stack.pop() + rp);
            break;
          case "PtgRefErr":
            stack.push("#REF!");
            break;
          case "PtgRefErr3d":
            stack.push("#REF!");
            break;
          case "PtgExp":
            c = { c: f[1][1], r: f[1][0] };
            var q = { c: cell.c, r: cell.r };
            if (supbooks.sharedf[encode_cell(c)]) {
              var parsedf = supbooks.sharedf[encode_cell(c)];
              stack.push(stringify_formula(parsedf, _range, q, supbooks, opts));
            } else {
              var fnd = false;
              for (e1 = 0; e1 != supbooks.arrayf.length; ++e1) {
                e2 = supbooks.arrayf[e1];
                if (c.c < e2[0].s.c || c.c > e2[0].e.c)
                  continue;
                if (c.r < e2[0].s.r || c.r > e2[0].e.r)
                  continue;
                stack.push(stringify_formula(e2[1], _range, q, supbooks, opts));
                fnd = true;
                break;
              }
              if (!fnd)
                stack.push(
                  /*::String(*/
                  f[1]
                  /*::)*/
                );
            }
            break;
          case "PtgArray":
            stack.push("{" + stringify_array(
              /*::(*/
              f[1]
              /*:: :any)*/
            ) + "}");
            break;
          case "PtgMemArea":
            break;
          case "PtgAttrSpace":
          case "PtgAttrSpaceSemi":
            last_sp = ff;
            break;
          case "PtgTbl":
            break;
          case "PtgMemErr":
            break;
          case "PtgMissArg":
            stack.push("");
            break;
          case "PtgAreaErr":
            stack.push("#REF!");
            break;
          case "PtgAreaErr3d":
            stack.push("#REF!");
            break;
          case "PtgList":
            stack.push("Table" + f[1].idx + "[#" + f[1].rt + "]");
            break;
          case "PtgMemAreaN":
          case "PtgMemNoMemN":
          case "PtgAttrNoop":
          case "PtgSheet":
          case "PtgEndSheet":
            break;
          case "PtgMemFunc":
            break;
          case "PtgMemNoMem":
            break;
          case "PtgElfCol":
          case "PtgElfColS":
          case "PtgElfColSV":
          case "PtgElfColV":
          case "PtgElfLel":
          case "PtgElfRadical":
          case "PtgElfRadicalLel":
          case "PtgElfRadicalS":
          case "PtgElfRw":
          case "PtgElfRwV":
            throw new Error("Unsupported ELFs");
          case "PtgSxName":
            throw new Error("Unrecognized Formula Token: " + String(f));
          default:
            throw new Error("Unrecognized Formula Token: " + String(f));
        }
        var PtgNonDisp = ["PtgAttrSpace", "PtgAttrSpaceSemi", "PtgAttrGoto"];
        if (opts.biff != 3) {
          if (last_sp >= 0 && PtgNonDisp.indexOf(formula[0][ff][0]) == -1) {
            f = formula[0][last_sp];
            var _left = true;
            switch (f[1][0]) {
              case 4:
                _left = false;
              case 0:
                sp = fill(" ", f[1][1]);
                break;
              case 5:
                _left = false;
              case 1:
                sp = fill("\r", f[1][1]);
                break;
              default:
                sp = "";
                if (opts.WTF)
                  throw new Error("Unexpected PtgAttrSpaceType " + f[1][0]);
            }
            stack.push((_left ? sp : "") + stack.pop() + (_left ? "" : sp));
            last_sp = -1;
          }
        }
      }
      if (stack.length > 1 && opts.WTF)
        throw new Error("bad formula stack");
      return stack[0];
    }
    function write_FormulaValue(value) {
      if (value == null) {
        var o = new_buf(8);
        o.write_shift(1, 3);
        o.write_shift(1, 0);
        o.write_shift(2, 0);
        o.write_shift(2, 0);
        o.write_shift(2, 65535);
        return o;
      } else if (typeof value == "number")
        return write_Xnum(value);
      return write_Xnum(0);
    }
    function write_Formula(cell, R, C, opts, os) {
      var o1 = write_XLSCell(R, C, os);
      var o2 = write_FormulaValue(cell.v);
      var o3 = new_buf(6);
      var flags = 1 | 32;
      o3.write_shift(2, flags);
      o3.write_shift(4, 0);
      var bf = new_buf(cell.bf.length);
      for (var i = 0; i < cell.bf.length; ++i)
        bf[i] = cell.bf[i];
      var out = bconcat([o1, o2, o3, bf]);
      return out;
    }
    function parse_XLSBParsedFormula(data, length, opts) {
      var cce = data.read_shift(4);
      var rgce = parse_Rgce(data, cce, opts);
      var cb = data.read_shift(4);
      var rgcb = cb > 0 ? parse_RgbExtra(data, cb, rgce, opts) : null;
      return [rgce, rgcb];
    }
    var parse_XLSBArrayParsedFormula = parse_XLSBParsedFormula;
    var parse_XLSBCellParsedFormula = parse_XLSBParsedFormula;
    var parse_XLSBNameParsedFormula = parse_XLSBParsedFormula;
    var parse_XLSBSharedParsedFormula = parse_XLSBParsedFormula;
    var Cetab = {
      0: "BEEP",
      1: "OPEN",
      2: "OPEN.LINKS",
      3: "CLOSE.ALL",
      4: "SAVE",
      5: "SAVE.AS",
      6: "FILE.DELETE",
      7: "PAGE.SETUP",
      8: "PRINT",
      9: "PRINTER.SETUP",
      10: "QUIT",
      11: "NEW.WINDOW",
      12: "ARRANGE.ALL",
      13: "WINDOW.SIZE",
      14: "WINDOW.MOVE",
      15: "FULL",
      16: "CLOSE",
      17: "RUN",
      22: "SET.PRINT.AREA",
      23: "SET.PRINT.TITLES",
      24: "SET.PAGE.BREAK",
      25: "REMOVE.PAGE.BREAK",
      26: "FONT",
      27: "DISPLAY",
      28: "PROTECT.DOCUMENT",
      29: "PRECISION",
      30: "A1.R1C1",
      31: "CALCULATE.NOW",
      32: "CALCULATION",
      34: "DATA.FIND",
      35: "EXTRACT",
      36: "DATA.DELETE",
      37: "SET.DATABASE",
      38: "SET.CRITERIA",
      39: "SORT",
      40: "DATA.SERIES",
      41: "TABLE",
      42: "FORMAT.NUMBER",
      43: "ALIGNMENT",
      44: "STYLE",
      45: "BORDER",
      46: "CELL.PROTECTION",
      47: "COLUMN.WIDTH",
      48: "UNDO",
      49: "CUT",
      50: "COPY",
      51: "PASTE",
      52: "CLEAR",
      53: "PASTE.SPECIAL",
      54: "EDIT.DELETE",
      55: "INSERT",
      56: "FILL.RIGHT",
      57: "FILL.DOWN",
      61: "DEFINE.NAME",
      62: "CREATE.NAMES",
      63: "FORMULA.GOTO",
      64: "FORMULA.FIND",
      65: "SELECT.LAST.CELL",
      66: "SHOW.ACTIVE.CELL",
      67: "GALLERY.AREA",
      68: "GALLERY.BAR",
      69: "GALLERY.COLUMN",
      70: "GALLERY.LINE",
      71: "GALLERY.PIE",
      72: "GALLERY.SCATTER",
      73: "COMBINATION",
      74: "PREFERRED",
      75: "ADD.OVERLAY",
      76: "GRIDLINES",
      77: "SET.PREFERRED",
      78: "AXES",
      79: "LEGEND",
      80: "ATTACH.TEXT",
      81: "ADD.ARROW",
      82: "SELECT.CHART",
      83: "SELECT.PLOT.AREA",
      84: "PATTERNS",
      85: "MAIN.CHART",
      86: "OVERLAY",
      87: "SCALE",
      88: "FORMAT.LEGEND",
      89: "FORMAT.TEXT",
      90: "EDIT.REPEAT",
      91: "PARSE",
      92: "JUSTIFY",
      93: "HIDE",
      94: "UNHIDE",
      95: "WORKSPACE",
      96: "FORMULA",
      97: "FORMULA.FILL",
      98: "FORMULA.ARRAY",
      99: "DATA.FIND.NEXT",
      100: "DATA.FIND.PREV",
      101: "FORMULA.FIND.NEXT",
      102: "FORMULA.FIND.PREV",
      103: "ACTIVATE",
      104: "ACTIVATE.NEXT",
      105: "ACTIVATE.PREV",
      106: "UNLOCKED.NEXT",
      107: "UNLOCKED.PREV",
      108: "COPY.PICTURE",
      109: "SELECT",
      110: "DELETE.NAME",
      111: "DELETE.FORMAT",
      112: "VLINE",
      113: "HLINE",
      114: "VPAGE",
      115: "HPAGE",
      116: "VSCROLL",
      117: "HSCROLL",
      118: "ALERT",
      119: "NEW",
      120: "CANCEL.COPY",
      121: "SHOW.CLIPBOARD",
      122: "MESSAGE",
      124: "PASTE.LINK",
      125: "APP.ACTIVATE",
      126: "DELETE.ARROW",
      127: "ROW.HEIGHT",
      128: "FORMAT.MOVE",
      129: "FORMAT.SIZE",
      130: "FORMULA.REPLACE",
      131: "SEND.KEYS",
      132: "SELECT.SPECIAL",
      133: "APPLY.NAMES",
      134: "REPLACE.FONT",
      135: "FREEZE.PANES",
      136: "SHOW.INFO",
      137: "SPLIT",
      138: "ON.WINDOW",
      139: "ON.DATA",
      140: "DISABLE.INPUT",
      142: "OUTLINE",
      143: "LIST.NAMES",
      144: "FILE.CLOSE",
      145: "SAVE.WORKBOOK",
      146: "DATA.FORM",
      147: "COPY.CHART",
      148: "ON.TIME",
      149: "WAIT",
      150: "FORMAT.FONT",
      151: "FILL.UP",
      152: "FILL.LEFT",
      153: "DELETE.OVERLAY",
      155: "SHORT.MENUS",
      159: "SET.UPDATE.STATUS",
      161: "COLOR.PALETTE",
      162: "DELETE.STYLE",
      163: "WINDOW.RESTORE",
      164: "WINDOW.MAXIMIZE",
      166: "CHANGE.LINK",
      167: "CALCULATE.DOCUMENT",
      168: "ON.KEY",
      169: "APP.RESTORE",
      170: "APP.MOVE",
      171: "APP.SIZE",
      172: "APP.MINIMIZE",
      173: "APP.MAXIMIZE",
      174: "BRING.TO.FRONT",
      175: "SEND.TO.BACK",
      185: "MAIN.CHART.TYPE",
      186: "OVERLAY.CHART.TYPE",
      187: "SELECT.END",
      188: "OPEN.MAIL",
      189: "SEND.MAIL",
      190: "STANDARD.FONT",
      191: "CONSOLIDATE",
      192: "SORT.SPECIAL",
      193: "GALLERY.3D.AREA",
      194: "GALLERY.3D.COLUMN",
      195: "GALLERY.3D.LINE",
      196: "GALLERY.3D.PIE",
      197: "VIEW.3D",
      198: "GOAL.SEEK",
      199: "WORKGROUP",
      200: "FILL.GROUP",
      201: "UPDATE.LINK",
      202: "PROMOTE",
      203: "DEMOTE",
      204: "SHOW.DETAIL",
      206: "UNGROUP",
      207: "OBJECT.PROPERTIES",
      208: "SAVE.NEW.OBJECT",
      209: "SHARE",
      210: "SHARE.NAME",
      211: "DUPLICATE",
      212: "APPLY.STYLE",
      213: "ASSIGN.TO.OBJECT",
      214: "OBJECT.PROTECTION",
      215: "HIDE.OBJECT",
      216: "SET.EXTRACT",
      217: "CREATE.PUBLISHER",
      218: "SUBSCRIBE.TO",
      219: "ATTRIBUTES",
      220: "SHOW.TOOLBAR",
      222: "PRINT.PREVIEW",
      223: "EDIT.COLOR",
      224: "SHOW.LEVELS",
      225: "FORMAT.MAIN",
      226: "FORMAT.OVERLAY",
      227: "ON.RECALC",
      228: "EDIT.SERIES",
      229: "DEFINE.STYLE",
      240: "LINE.PRINT",
      243: "ENTER.DATA",
      249: "GALLERY.RADAR",
      250: "MERGE.STYLES",
      251: "EDITION.OPTIONS",
      252: "PASTE.PICTURE",
      253: "PASTE.PICTURE.LINK",
      254: "SPELLING",
      256: "ZOOM",
      259: "INSERT.OBJECT",
      260: "WINDOW.MINIMIZE",
      265: "SOUND.NOTE",
      266: "SOUND.PLAY",
      267: "FORMAT.SHAPE",
      268: "EXTEND.POLYGON",
      269: "FORMAT.AUTO",
      272: "GALLERY.3D.BAR",
      273: "GALLERY.3D.SURFACE",
      274: "FILL.AUTO",
      276: "CUSTOMIZE.TOOLBAR",
      277: "ADD.TOOL",
      278: "EDIT.OBJECT",
      279: "ON.DOUBLECLICK",
      280: "ON.ENTRY",
      281: "WORKBOOK.ADD",
      282: "WORKBOOK.MOVE",
      283: "WORKBOOK.COPY",
      284: "WORKBOOK.OPTIONS",
      285: "SAVE.WORKSPACE",
      288: "CHART.WIZARD",
      289: "DELETE.TOOL",
      290: "MOVE.TOOL",
      291: "WORKBOOK.SELECT",
      292: "WORKBOOK.ACTIVATE",
      293: "ASSIGN.TO.TOOL",
      295: "COPY.TOOL",
      296: "RESET.TOOL",
      297: "CONSTRAIN.NUMERIC",
      298: "PASTE.TOOL",
      302: "WORKBOOK.NEW",
      305: "SCENARIO.CELLS",
      306: "SCENARIO.DELETE",
      307: "SCENARIO.ADD",
      308: "SCENARIO.EDIT",
      309: "SCENARIO.SHOW",
      310: "SCENARIO.SHOW.NEXT",
      311: "SCENARIO.SUMMARY",
      312: "PIVOT.TABLE.WIZARD",
      313: "PIVOT.FIELD.PROPERTIES",
      314: "PIVOT.FIELD",
      315: "PIVOT.ITEM",
      316: "PIVOT.ADD.FIELDS",
      318: "OPTIONS.CALCULATION",
      319: "OPTIONS.EDIT",
      320: "OPTIONS.VIEW",
      321: "ADDIN.MANAGER",
      322: "MENU.EDITOR",
      323: "ATTACH.TOOLBARS",
      324: "VBAActivate",
      325: "OPTIONS.CHART",
      328: "VBA.INSERT.FILE",
      330: "VBA.PROCEDURE.DEFINITION",
      336: "ROUTING.SLIP",
      338: "ROUTE.DOCUMENT",
      339: "MAIL.LOGON",
      342: "INSERT.PICTURE",
      343: "EDIT.TOOL",
      344: "GALLERY.DOUGHNUT",
      350: "CHART.TREND",
      352: "PIVOT.ITEM.PROPERTIES",
      354: "WORKBOOK.INSERT",
      355: "OPTIONS.TRANSITION",
      356: "OPTIONS.GENERAL",
      370: "FILTER.ADVANCED",
      373: "MAIL.ADD.MAILER",
      374: "MAIL.DELETE.MAILER",
      375: "MAIL.REPLY",
      376: "MAIL.REPLY.ALL",
      377: "MAIL.FORWARD",
      378: "MAIL.NEXT.LETTER",
      379: "DATA.LABEL",
      380: "INSERT.TITLE",
      381: "FONT.PROPERTIES",
      382: "MACRO.OPTIONS",
      383: "WORKBOOK.HIDE",
      384: "WORKBOOK.UNHIDE",
      385: "WORKBOOK.DELETE",
      386: "WORKBOOK.NAME",
      388: "GALLERY.CUSTOM",
      390: "ADD.CHART.AUTOFORMAT",
      391: "DELETE.CHART.AUTOFORMAT",
      392: "CHART.ADD.DATA",
      393: "AUTO.OUTLINE",
      394: "TAB.ORDER",
      395: "SHOW.DIALOG",
      396: "SELECT.ALL",
      397: "UNGROUP.SHEETS",
      398: "SUBTOTAL.CREATE",
      399: "SUBTOTAL.REMOVE",
      400: "RENAME.OBJECT",
      412: "WORKBOOK.SCROLL",
      413: "WORKBOOK.NEXT",
      414: "WORKBOOK.PREV",
      415: "WORKBOOK.TAB.SPLIT",
      416: "FULL.SCREEN",
      417: "WORKBOOK.PROTECT",
      420: "SCROLLBAR.PROPERTIES",
      421: "PIVOT.SHOW.PAGES",
      422: "TEXT.TO.COLUMNS",
      423: "FORMAT.CHARTTYPE",
      424: "LINK.FORMAT",
      425: "TRACER.DISPLAY",
      430: "TRACER.NAVIGATE",
      431: "TRACER.CLEAR",
      432: "TRACER.ERROR",
      433: "PIVOT.FIELD.GROUP",
      434: "PIVOT.FIELD.UNGROUP",
      435: "CHECKBOX.PROPERTIES",
      436: "LABEL.PROPERTIES",
      437: "LISTBOX.PROPERTIES",
      438: "EDITBOX.PROPERTIES",
      439: "PIVOT.REFRESH",
      440: "LINK.COMBO",
      441: "OPEN.TEXT",
      442: "HIDE.DIALOG",
      443: "SET.DIALOG.FOCUS",
      444: "ENABLE.OBJECT",
      445: "PUSHBUTTON.PROPERTIES",
      446: "SET.DIALOG.DEFAULT",
      447: "FILTER",
      448: "FILTER.SHOW.ALL",
      449: "CLEAR.OUTLINE",
      450: "FUNCTION.WIZARD",
      451: "ADD.LIST.ITEM",
      452: "SET.LIST.ITEM",
      453: "REMOVE.LIST.ITEM",
      454: "SELECT.LIST.ITEM",
      455: "SET.CONTROL.VALUE",
      456: "SAVE.COPY.AS",
      458: "OPTIONS.LISTS.ADD",
      459: "OPTIONS.LISTS.DELETE",
      460: "SERIES.AXES",
      461: "SERIES.X",
      462: "SERIES.Y",
      463: "ERRORBAR.X",
      464: "ERRORBAR.Y",
      465: "FORMAT.CHART",
      466: "SERIES.ORDER",
      467: "MAIL.LOGOFF",
      468: "CLEAR.ROUTING.SLIP",
      469: "APP.ACTIVATE.MICROSOFT",
      470: "MAIL.EDIT.MAILER",
      471: "ON.SHEET",
      472: "STANDARD.WIDTH",
      473: "SCENARIO.MERGE",
      474: "SUMMARY.INFO",
      475: "FIND.FILE",
      476: "ACTIVE.CELL.FONT",
      477: "ENABLE.TIPWIZARD",
      478: "VBA.MAKE.ADDIN",
      480: "INSERTDATATABLE",
      481: "WORKGROUP.OPTIONS",
      482: "MAIL.SEND.MAILER",
      485: "AUTOCORRECT",
      489: "POST.DOCUMENT",
      491: "PICKLIST",
      493: "VIEW.SHOW",
      494: "VIEW.DEFINE",
      495: "VIEW.DELETE",
      509: "SHEET.BACKGROUND",
      510: "INSERT.MAP.OBJECT",
      511: "OPTIONS.MENONO",
      517: "MSOCHECKS",
      518: "NORMAL",
      519: "LAYOUT",
      520: "RM.PRINT.AREA",
      521: "CLEAR.PRINT.AREA",
      522: "ADD.PRINT.AREA",
      523: "MOVE.BRK",
      545: "HIDECURR.NOTE",
      546: "HIDEALL.NOTES",
      547: "DELETE.NOTE",
      548: "TRAVERSE.NOTES",
      549: "ACTIVATE.NOTES",
      620: "PROTECT.REVISIONS",
      621: "UNPROTECT.REVISIONS",
      647: "OPTIONS.ME",
      653: "WEB.PUBLISH",
      667: "NEWWEBQUERY",
      673: "PIVOT.TABLE.CHART",
      753: "OPTIONS.SAVE",
      755: "OPTIONS.SPELL",
      808: "HIDEALL.INKANNOTS"
    };
    var Ftab = {
      0: "COUNT",
      1: "IF",
      2: "ISNA",
      3: "ISERROR",
      4: "SUM",
      5: "AVERAGE",
      6: "MIN",
      7: "MAX",
      8: "ROW",
      9: "COLUMN",
      10: "NA",
      11: "NPV",
      12: "STDEV",
      13: "DOLLAR",
      14: "FIXED",
      15: "SIN",
      16: "COS",
      17: "TAN",
      18: "ATAN",
      19: "PI",
      20: "SQRT",
      21: "EXP",
      22: "LN",
      23: "LOG10",
      24: "ABS",
      25: "INT",
      26: "SIGN",
      27: "ROUND",
      28: "LOOKUP",
      29: "INDEX",
      30: "REPT",
      31: "MID",
      32: "LEN",
      33: "VALUE",
      34: "TRUE",
      35: "FALSE",
      36: "AND",
      37: "OR",
      38: "NOT",
      39: "MOD",
      40: "DCOUNT",
      41: "DSUM",
      42: "DAVERAGE",
      43: "DMIN",
      44: "DMAX",
      45: "DSTDEV",
      46: "VAR",
      47: "DVAR",
      48: "TEXT",
      49: "LINEST",
      50: "TREND",
      51: "LOGEST",
      52: "GROWTH",
      53: "GOTO",
      54: "HALT",
      55: "RETURN",
      56: "PV",
      57: "FV",
      58: "NPER",
      59: "PMT",
      60: "RATE",
      61: "MIRR",
      62: "IRR",
      63: "RAND",
      64: "MATCH",
      65: "DATE",
      66: "TIME",
      67: "DAY",
      68: "MONTH",
      69: "YEAR",
      70: "WEEKDAY",
      71: "HOUR",
      72: "MINUTE",
      73: "SECOND",
      74: "NOW",
      75: "AREAS",
      76: "ROWS",
      77: "COLUMNS",
      78: "OFFSET",
      79: "ABSREF",
      80: "RELREF",
      81: "ARGUMENT",
      82: "SEARCH",
      83: "TRANSPOSE",
      84: "ERROR",
      85: "STEP",
      86: "TYPE",
      87: "ECHO",
      88: "SET.NAME",
      89: "CALLER",
      90: "DEREF",
      91: "WINDOWS",
      92: "SERIES",
      93: "DOCUMENTS",
      94: "ACTIVE.CELL",
      95: "SELECTION",
      96: "RESULT",
      97: "ATAN2",
      98: "ASIN",
      99: "ACOS",
      100: "CHOOSE",
      101: "HLOOKUP",
      102: "VLOOKUP",
      103: "LINKS",
      104: "INPUT",
      105: "ISREF",
      106: "GET.FORMULA",
      107: "GET.NAME",
      108: "SET.VALUE",
      109: "LOG",
      110: "EXEC",
      111: "CHAR",
      112: "LOWER",
      113: "UPPER",
      114: "PROPER",
      115: "LEFT",
      116: "RIGHT",
      117: "EXACT",
      118: "TRIM",
      119: "REPLACE",
      120: "SUBSTITUTE",
      121: "CODE",
      122: "NAMES",
      123: "DIRECTORY",
      124: "FIND",
      125: "CELL",
      126: "ISERR",
      127: "ISTEXT",
      128: "ISNUMBER",
      129: "ISBLANK",
      130: "T",
      131: "N",
      132: "FOPEN",
      133: "FCLOSE",
      134: "FSIZE",
      135: "FREADLN",
      136: "FREAD",
      137: "FWRITELN",
      138: "FWRITE",
      139: "FPOS",
      140: "DATEVALUE",
      141: "TIMEVALUE",
      142: "SLN",
      143: "SYD",
      144: "DDB",
      145: "GET.DEF",
      146: "REFTEXT",
      147: "TEXTREF",
      148: "INDIRECT",
      149: "REGISTER",
      150: "CALL",
      151: "ADD.BAR",
      152: "ADD.MENU",
      153: "ADD.COMMAND",
      154: "ENABLE.COMMAND",
      155: "CHECK.COMMAND",
      156: "RENAME.COMMAND",
      157: "SHOW.BAR",
      158: "DELETE.MENU",
      159: "DELETE.COMMAND",
      160: "GET.CHART.ITEM",
      161: "DIALOG.BOX",
      162: "CLEAN",
      163: "MDETERM",
      164: "MINVERSE",
      165: "MMULT",
      166: "FILES",
      167: "IPMT",
      168: "PPMT",
      169: "COUNTA",
      170: "CANCEL.KEY",
      171: "FOR",
      172: "WHILE",
      173: "BREAK",
      174: "NEXT",
      175: "INITIATE",
      176: "REQUEST",
      177: "POKE",
      178: "EXECUTE",
      179: "TERMINATE",
      180: "RESTART",
      181: "HELP",
      182: "GET.BAR",
      183: "PRODUCT",
      184: "FACT",
      185: "GET.CELL",
      186: "GET.WORKSPACE",
      187: "GET.WINDOW",
      188: "GET.DOCUMENT",
      189: "DPRODUCT",
      190: "ISNONTEXT",
      191: "GET.NOTE",
      192: "NOTE",
      193: "STDEVP",
      194: "VARP",
      195: "DSTDEVP",
      196: "DVARP",
      197: "TRUNC",
      198: "ISLOGICAL",
      199: "DCOUNTA",
      200: "DELETE.BAR",
      201: "UNREGISTER",
      204: "USDOLLAR",
      205: "FINDB",
      206: "SEARCHB",
      207: "REPLACEB",
      208: "LEFTB",
      209: "RIGHTB",
      210: "MIDB",
      211: "LENB",
      212: "ROUNDUP",
      213: "ROUNDDOWN",
      214: "ASC",
      215: "DBCS",
      216: "RANK",
      219: "ADDRESS",
      220: "DAYS360",
      221: "TODAY",
      222: "VDB",
      223: "ELSE",
      224: "ELSE.IF",
      225: "END.IF",
      226: "FOR.CELL",
      227: "MEDIAN",
      228: "SUMPRODUCT",
      229: "SINH",
      230: "COSH",
      231: "TANH",
      232: "ASINH",
      233: "ACOSH",
      234: "ATANH",
      235: "DGET",
      236: "CREATE.OBJECT",
      237: "VOLATILE",
      238: "LAST.ERROR",
      239: "CUSTOM.UNDO",
      240: "CUSTOM.REPEAT",
      241: "FORMULA.CONVERT",
      242: "GET.LINK.INFO",
      243: "TEXT.BOX",
      244: "INFO",
      245: "GROUP",
      246: "GET.OBJECT",
      247: "DB",
      248: "PAUSE",
      251: "RESUME",
      252: "FREQUENCY",
      253: "ADD.TOOLBAR",
      254: "DELETE.TOOLBAR",
      255: "User",
      256: "RESET.TOOLBAR",
      257: "EVALUATE",
      258: "GET.TOOLBAR",
      259: "GET.TOOL",
      260: "SPELLING.CHECK",
      261: "ERROR.TYPE",
      262: "APP.TITLE",
      263: "WINDOW.TITLE",
      264: "SAVE.TOOLBAR",
      265: "ENABLE.TOOL",
      266: "PRESS.TOOL",
      267: "REGISTER.ID",
      268: "GET.WORKBOOK",
      269: "AVEDEV",
      270: "BETADIST",
      271: "GAMMALN",
      272: "BETAINV",
      273: "BINOMDIST",
      274: "CHIDIST",
      275: "CHIINV",
      276: "COMBIN",
      277: "CONFIDENCE",
      278: "CRITBINOM",
      279: "EVEN",
      280: "EXPONDIST",
      281: "FDIST",
      282: "FINV",
      283: "FISHER",
      284: "FISHERINV",
      285: "FLOOR",
      286: "GAMMADIST",
      287: "GAMMAINV",
      288: "CEILING",
      289: "HYPGEOMDIST",
      290: "LOGNORMDIST",
      291: "LOGINV",
      292: "NEGBINOMDIST",
      293: "NORMDIST",
      294: "NORMSDIST",
      295: "NORMINV",
      296: "NORMSINV",
      297: "STANDARDIZE",
      298: "ODD",
      299: "PERMUT",
      300: "POISSON",
      301: "TDIST",
      302: "WEIBULL",
      303: "SUMXMY2",
      304: "SUMX2MY2",
      305: "SUMX2PY2",
      306: "CHITEST",
      307: "CORREL",
      308: "COVAR",
      309: "FORECAST",
      310: "FTEST",
      311: "INTERCEPT",
      312: "PEARSON",
      313: "RSQ",
      314: "STEYX",
      315: "SLOPE",
      316: "TTEST",
      317: "PROB",
      318: "DEVSQ",
      319: "GEOMEAN",
      320: "HARMEAN",
      321: "SUMSQ",
      322: "KURT",
      323: "SKEW",
      324: "ZTEST",
      325: "LARGE",
      326: "SMALL",
      327: "QUARTILE",
      328: "PERCENTILE",
      329: "PERCENTRANK",
      330: "MODE",
      331: "TRIMMEAN",
      332: "TINV",
      334: "MOVIE.COMMAND",
      335: "GET.MOVIE",
      336: "CONCATENATE",
      337: "POWER",
      338: "PIVOT.ADD.DATA",
      339: "GET.PIVOT.TABLE",
      340: "GET.PIVOT.FIELD",
      341: "GET.PIVOT.ITEM",
      342: "RADIANS",
      343: "DEGREES",
      344: "SUBTOTAL",
      345: "SUMIF",
      346: "COUNTIF",
      347: "COUNTBLANK",
      348: "SCENARIO.GET",
      349: "OPTIONS.LISTS.GET",
      350: "ISPMT",
      351: "DATEDIF",
      352: "DATESTRING",
      353: "NUMBERSTRING",
      354: "ROMAN",
      355: "OPEN.DIALOG",
      356: "SAVE.DIALOG",
      357: "VIEW.GET",
      358: "GETPIVOTDATA",
      359: "HYPERLINK",
      360: "PHONETIC",
      361: "AVERAGEA",
      362: "MAXA",
      363: "MINA",
      364: "STDEVPA",
      365: "VARPA",
      366: "STDEVA",
      367: "VARA",
      368: "BAHTTEXT",
      369: "THAIDAYOFWEEK",
      370: "THAIDIGIT",
      371: "THAIMONTHOFYEAR",
      372: "THAINUMSOUND",
      373: "THAINUMSTRING",
      374: "THAISTRINGLENGTH",
      375: "ISTHAIDIGIT",
      376: "ROUNDBAHTDOWN",
      377: "ROUNDBAHTUP",
      378: "THAIYEAR",
      379: "RTD",
      380: "CUBEVALUE",
      381: "CUBEMEMBER",
      382: "CUBEMEMBERPROPERTY",
      383: "CUBERANKEDMEMBER",
      384: "HEX2BIN",
      385: "HEX2DEC",
      386: "HEX2OCT",
      387: "DEC2BIN",
      388: "DEC2HEX",
      389: "DEC2OCT",
      390: "OCT2BIN",
      391: "OCT2HEX",
      392: "OCT2DEC",
      393: "BIN2DEC",
      394: "BIN2OCT",
      395: "BIN2HEX",
      396: "IMSUB",
      397: "IMDIV",
      398: "IMPOWER",
      399: "IMABS",
      400: "IMSQRT",
      401: "IMLN",
      402: "IMLOG2",
      403: "IMLOG10",
      404: "IMSIN",
      405: "IMCOS",
      406: "IMEXP",
      407: "IMARGUMENT",
      408: "IMCONJUGATE",
      409: "IMAGINARY",
      410: "IMREAL",
      411: "COMPLEX",
      412: "IMSUM",
      413: "IMPRODUCT",
      414: "SERIESSUM",
      415: "FACTDOUBLE",
      416: "SQRTPI",
      417: "QUOTIENT",
      418: "DELTA",
      419: "GESTEP",
      420: "ISEVEN",
      421: "ISODD",
      422: "MROUND",
      423: "ERF",
      424: "ERFC",
      425: "BESSELJ",
      426: "BESSELK",
      427: "BESSELY",
      428: "BESSELI",
      429: "XIRR",
      430: "XNPV",
      431: "PRICEMAT",
      432: "YIELDMAT",
      433: "INTRATE",
      434: "RECEIVED",
      435: "DISC",
      436: "PRICEDISC",
      437: "YIELDDISC",
      438: "TBILLEQ",
      439: "TBILLPRICE",
      440: "TBILLYIELD",
      441: "PRICE",
      442: "YIELD",
      443: "DOLLARDE",
      444: "DOLLARFR",
      445: "NOMINAL",
      446: "EFFECT",
      447: "CUMPRINC",
      448: "CUMIPMT",
      449: "EDATE",
      450: "EOMONTH",
      451: "YEARFRAC",
      452: "COUPDAYBS",
      453: "COUPDAYS",
      454: "COUPDAYSNC",
      455: "COUPNCD",
      456: "COUPNUM",
      457: "COUPPCD",
      458: "DURATION",
      459: "MDURATION",
      460: "ODDLPRICE",
      461: "ODDLYIELD",
      462: "ODDFPRICE",
      463: "ODDFYIELD",
      464: "RANDBETWEEN",
      465: "WEEKNUM",
      466: "AMORDEGRC",
      467: "AMORLINC",
      468: "CONVERT",
      724: "SHEETJS",
      469: "ACCRINT",
      470: "ACCRINTM",
      471: "WORKDAY",
      472: "NETWORKDAYS",
      473: "GCD",
      474: "MULTINOMIAL",
      475: "LCM",
      476: "FVSCHEDULE",
      477: "CUBEKPIMEMBER",
      478: "CUBESET",
      479: "CUBESETCOUNT",
      480: "IFERROR",
      481: "COUNTIFS",
      482: "SUMIFS",
      483: "AVERAGEIF",
      484: "AVERAGEIFS"
    };
    var FtabArgc = {
      2: 1,
      3: 1,
      10: 0,
      15: 1,
      16: 1,
      17: 1,
      18: 1,
      19: 0,
      20: 1,
      21: 1,
      22: 1,
      23: 1,
      24: 1,
      25: 1,
      26: 1,
      27: 2,
      30: 2,
      31: 3,
      32: 1,
      33: 1,
      34: 0,
      35: 0,
      38: 1,
      39: 2,
      40: 3,
      41: 3,
      42: 3,
      43: 3,
      44: 3,
      45: 3,
      47: 3,
      48: 2,
      53: 1,
      61: 3,
      63: 0,
      65: 3,
      66: 3,
      67: 1,
      68: 1,
      69: 1,
      70: 1,
      71: 1,
      72: 1,
      73: 1,
      74: 0,
      75: 1,
      76: 1,
      77: 1,
      79: 2,
      80: 2,
      83: 1,
      85: 0,
      86: 1,
      89: 0,
      90: 1,
      94: 0,
      95: 0,
      97: 2,
      98: 1,
      99: 1,
      101: 3,
      102: 3,
      105: 1,
      106: 1,
      108: 2,
      111: 1,
      112: 1,
      113: 1,
      114: 1,
      117: 2,
      118: 1,
      119: 4,
      121: 1,
      126: 1,
      127: 1,
      128: 1,
      129: 1,
      130: 1,
      131: 1,
      133: 1,
      134: 1,
      135: 1,
      136: 2,
      137: 2,
      138: 2,
      140: 1,
      141: 1,
      142: 3,
      143: 4,
      144: 4,
      161: 1,
      162: 1,
      163: 1,
      164: 1,
      165: 2,
      172: 1,
      175: 2,
      176: 2,
      177: 3,
      178: 2,
      179: 1,
      184: 1,
      186: 1,
      189: 3,
      190: 1,
      195: 3,
      196: 3,
      197: 1,
      198: 1,
      199: 3,
      201: 1,
      207: 4,
      210: 3,
      211: 1,
      212: 2,
      213: 2,
      214: 1,
      215: 1,
      225: 0,
      229: 1,
      230: 1,
      231: 1,
      232: 1,
      233: 1,
      234: 1,
      235: 3,
      244: 1,
      247: 4,
      252: 2,
      257: 1,
      261: 1,
      271: 1,
      273: 4,
      274: 2,
      275: 2,
      276: 2,
      277: 3,
      278: 3,
      279: 1,
      280: 3,
      281: 3,
      282: 3,
      283: 1,
      284: 1,
      285: 2,
      286: 4,
      287: 3,
      288: 2,
      289: 4,
      290: 3,
      291: 3,
      292: 3,
      293: 4,
      294: 1,
      295: 3,
      296: 1,
      297: 3,
      298: 1,
      299: 2,
      300: 3,
      301: 3,
      302: 4,
      303: 2,
      304: 2,
      305: 2,
      306: 2,
      307: 2,
      308: 2,
      309: 3,
      310: 2,
      311: 2,
      312: 2,
      313: 2,
      314: 2,
      315: 2,
      316: 4,
      325: 2,
      326: 2,
      327: 2,
      328: 2,
      331: 2,
      332: 2,
      337: 2,
      342: 1,
      343: 1,
      346: 2,
      347: 1,
      350: 4,
      351: 3,
      352: 1,
      353: 2,
      360: 1,
      368: 1,
      369: 1,
      370: 1,
      371: 1,
      372: 1,
      373: 1,
      374: 1,
      375: 1,
      376: 1,
      377: 1,
      378: 1,
      382: 3,
      385: 1,
      392: 1,
      393: 1,
      396: 2,
      397: 2,
      398: 2,
      399: 1,
      400: 1,
      401: 1,
      402: 1,
      403: 1,
      404: 1,
      405: 1,
      406: 1,
      407: 1,
      408: 1,
      409: 1,
      410: 1,
      414: 4,
      415: 1,
      416: 1,
      417: 2,
      420: 1,
      421: 1,
      422: 2,
      424: 1,
      425: 2,
      426: 2,
      427: 2,
      428: 2,
      430: 3,
      438: 3,
      439: 3,
      440: 3,
      443: 2,
      444: 2,
      445: 2,
      446: 2,
      447: 6,
      448: 6,
      449: 2,
      450: 2,
      464: 2,
      468: 3,
      476: 2,
      479: 1,
      480: 2,
      65535: 0
    };
    function csf_to_ods_formula(f) {
      var o = "of:=" + f.replace(crefregex, "$1[.$2$3$4$5]").replace(/\]:\[/g, ":");
      return o.replace(/;/g, "|").replace(/,/g, ";");
    }
    function csf_to_ods_3D(r) {
      return r.replace(/\./, "!");
    }
    var browser_has_Map = typeof Map !== "undefined";
    function get_sst_id(sst, str, rev) {
      var i = 0, len = sst.length;
      if (rev) {
        if (browser_has_Map ? rev.has(str) : Object.prototype.hasOwnProperty.call(rev, str)) {
          var revarr = browser_has_Map ? rev.get(str) : rev[str];
          for (; i < revarr.length; ++i) {
            if (sst[revarr[i]].t === str) {
              sst.Count++;
              return revarr[i];
            }
          }
        }
      } else
        for (; i < len; ++i) {
          if (sst[i].t === str) {
            sst.Count++;
            return i;
          }
        }
      sst[len] = { t: str };
      sst.Count++;
      sst.Unique++;
      if (rev) {
        if (browser_has_Map) {
          if (!rev.has(str))
            rev.set(str, []);
          rev.get(str).push(len);
        } else {
          if (!Object.prototype.hasOwnProperty.call(rev, str))
            rev[str] = [];
          rev[str].push(len);
        }
      }
      return len;
    }
    function col_obj_w(C, col) {
      var p = { min: C + 1, max: C + 1 };
      var wch = -1;
      if (col.MDW)
        MDW = col.MDW;
      if (col.width != null)
        p.customWidth = 1;
      else if (col.wpx != null)
        wch = px2char(col.wpx);
      else if (col.wch != null)
        wch = col.wch;
      if (wch > -1) {
        p.width = char2width(wch);
        p.customWidth = 1;
      } else if (col.width != null)
        p.width = col.width;
      if (col.hidden)
        p.hidden = true;
      if (col.level != null) {
        p.outlineLevel = p.level = col.level;
      }
      return p;
    }
    function default_margins(margins, mode) {
      if (!margins)
        return;
      var defs = [0.7, 0.7, 0.75, 0.75, 0.3, 0.3];
      if (margins.left == null)
        margins.left = defs[0];
      if (margins.right == null)
        margins.right = defs[1];
      if (margins.top == null)
        margins.top = defs[2];
      if (margins.bottom == null)
        margins.bottom = defs[3];
      if (margins.header == null)
        margins.header = defs[4];
      if (margins.footer == null)
        margins.footer = defs[5];
    }
    function get_cell_style(styles, cell, opts) {
      var z = opts.revssf[cell.z != null ? cell.z : "General"];
      var i = 60, len = styles.length;
      if (z == null && opts.ssf) {
        for (; i < 392; ++i)
          if (opts.ssf[i] == null) {
            SSF_load(cell.z, i);
            opts.ssf[i] = cell.z;
            opts.revssf[cell.z] = z = i;
            break;
          }
      }
      for (i = 0; i != len; ++i)
        if (styles[i].numFmtId === z)
          return i;
      styles[len] = {
        numFmtId: z,
        fontId: 0,
        fillId: 0,
        borderId: 0,
        xfId: 0,
        applyNumberFormat: 1
      };
      return len;
    }
    function check_ws(ws, sname, i) {
      if (ws && ws["!ref"]) {
        var range = safe_decode_range(ws["!ref"]);
        if (range.e.c < range.s.c || range.e.r < range.s.r)
          throw new Error("Bad range (" + i + "): " + ws["!ref"]);
      }
    }
    function write_ws_xml_merges(merges) {
      if (merges.length === 0)
        return "";
      var o = '<mergeCells count="' + merges.length + '">';
      for (var i = 0; i != merges.length; ++i)
        o += '<mergeCell ref="' + encode_range(merges[i]) + '"/>';
      return o + "</mergeCells>";
    }
    function write_ws_xml_sheetpr(ws, wb, idx, opts, o) {
      var needed = false;
      var props = {}, payload = null;
      if (opts.bookType !== "xlsx" && wb.vbaraw) {
        var cname = wb.SheetNames[idx];
        try {
          if (wb.Workbook)
            cname = wb.Workbook.Sheets[idx].CodeName || cname;
        } catch (e) {
        }
        needed = true;
        props.codeName = utf8write(escapexml(cname));
      }
      if (ws && ws["!outline"]) {
        var outlineprops = { summaryBelow: 1, summaryRight: 1 };
        if (ws["!outline"].above)
          outlineprops.summaryBelow = 0;
        if (ws["!outline"].left)
          outlineprops.summaryRight = 0;
        payload = (payload || "") + writextag("outlinePr", null, outlineprops);
      }
      if (!needed && !payload)
        return;
      o[o.length] = writextag("sheetPr", payload, props);
    }
    var sheetprot_deffalse = ["objects", "scenarios", "selectLockedCells", "selectUnlockedCells"];
    var sheetprot_deftrue = [
      "formatColumns",
      "formatRows",
      "formatCells",
      "insertColumns",
      "insertRows",
      "insertHyperlinks",
      "deleteColumns",
      "deleteRows",
      "sort",
      "autoFilter",
      "pivotTables"
    ];
    function write_ws_xml_protection(sp) {
      var o = { sheet: 1 };
      sheetprot_deffalse.forEach(function(n) {
        if (sp[n] != null && sp[n])
          o[n] = "1";
      });
      sheetprot_deftrue.forEach(function(n) {
        if (sp[n] != null && !sp[n])
          o[n] = "0";
      });
      if (sp.password)
        o.password = crypto_CreatePasswordVerifier_Method1(sp.password).toString(16).toUpperCase();
      return writextag("sheetProtection", null, o);
    }
    function write_ws_xml_margins(margin) {
      default_margins(margin);
      return writextag("pageMargins", null, margin);
    }
    function write_ws_xml_cols(ws, cols) {
      var o = ["<cols>"], col;
      for (var i = 0; i != cols.length; ++i) {
        if (!(col = cols[i]))
          continue;
        o[o.length] = writextag("col", null, col_obj_w(i, col));
      }
      o[o.length] = "</cols>";
      return o.join("");
    }
    function write_ws_xml_autofilter(data, ws, wb, idx) {
      var ref = typeof data.ref == "string" ? data.ref : encode_range(data.ref);
      if (!wb.Workbook)
        wb.Workbook = { Sheets: [] };
      if (!wb.Workbook.Names)
        wb.Workbook.Names = [];
      var names = wb.Workbook.Names;
      var range = decode_range(ref);
      if (range.s.r == range.e.r) {
        range.e.r = decode_range(ws["!ref"]).e.r;
        ref = encode_range(range);
      }
      for (var i = 0; i < names.length; ++i) {
        var name = names[i];
        if (name.Name != "_xlnm._FilterDatabase")
          continue;
        if (name.Sheet != idx)
          continue;
        name.Ref = "'" + wb.SheetNames[idx] + "'!" + ref;
        break;
      }
      if (i == names.length)
        names.push({ Name: "_xlnm._FilterDatabase", Sheet: idx, Ref: "'" + wb.SheetNames[idx] + "'!" + ref });
      return writextag("autoFilter", null, { ref });
    }
    function write_ws_xml_sheetviews(ws, opts, idx, wb) {
      var sview = { workbookViewId: "0" };
      if ((((wb || {}).Workbook || {}).Views || [])[0])
        sview.rightToLeft = wb.Workbook.Views[0].RTL ? "1" : "0";
      return writextag("sheetViews", writextag("sheetView", null, sview), {});
    }
    function write_ws_xml_cell(cell, ref, ws, opts) {
      if (cell.c)
        ws["!comments"].push([ref, cell.c]);
      if (cell.v === void 0 && typeof cell.f !== "string" || cell.t === "z" && !cell.f)
        return "";
      var vv = "";
      var oldt = cell.t, oldv = cell.v;
      if (cell.t !== "z")
        switch (cell.t) {
          case "b":
            vv = cell.v ? "1" : "0";
            break;
          case "n":
            vv = "" + cell.v;
            break;
          case "e":
            vv = BErr[cell.v];
            break;
          case "d":
            if (opts && opts.cellDates)
              vv = parseDate(cell.v, -1).toISOString();
            else {
              cell = dup(cell);
              cell.t = "n";
              vv = "" + (cell.v = datenum(parseDate(cell.v)));
            }
            if (typeof cell.z === "undefined")
              cell.z = table_fmt[14];
            break;
          default:
            vv = cell.v;
            break;
        }
      var v = writetag("v", escapexml(vv)), o = { r: ref };
      var os = get_cell_style(opts.cellXfs, cell, opts);
      if (os !== 0)
        o.s = os;
      switch (cell.t) {
        case "n":
          break;
        case "d":
          o.t = "d";
          break;
        case "b":
          o.t = "b";
          break;
        case "e":
          o.t = "e";
          break;
        case "z":
          break;
        default:
          if (cell.v == null) {
            delete cell.t;
            break;
          }
          if (cell.v.length > 32767)
            throw new Error("Text length must not exceed 32767 characters");
          if (opts && opts.bookSST) {
            v = writetag("v", "" + get_sst_id(opts.Strings, cell.v, opts.revStrings));
            o.t = "s";
            break;
          }
          o.t = "str";
          break;
      }
      if (cell.t != oldt) {
        cell.t = oldt;
        cell.v = oldv;
      }
      if (typeof cell.f == "string" && cell.f) {
        var ff = cell.F && cell.F.slice(0, ref.length) == ref ? { t: "array", ref: cell.F } : null;
        v = writextag("f", escapexml(cell.f), ff) + (cell.v != null ? v : "");
      }
      if (cell.l)
        ws["!links"].push([ref, cell.l]);
      if (cell.D)
        o.cm = 1;
      return writextag("c", v, o);
    }
    function write_ws_xml_data(ws, opts, idx, wb) {
      var o = [], r = [], range = safe_decode_range(ws["!ref"]), cell = "", ref, rr = "", cols = [], R = 0, C = 0, rows = ws["!rows"];
      var dense = Array.isArray(ws);
      var params = { r: rr }, row, height = -1;
      for (C = range.s.c; C <= range.e.c; ++C)
        cols[C] = encode_col(C);
      for (R = range.s.r; R <= range.e.r; ++R) {
        r = [];
        rr = encode_row(R);
        for (C = range.s.c; C <= range.e.c; ++C) {
          ref = cols[C] + rr;
          var _cell = dense ? (ws[R] || [])[C] : ws[ref];
          if (_cell === void 0)
            continue;
          if ((cell = write_ws_xml_cell(_cell, ref, ws, opts)) != null)
            r.push(cell);
        }
        if (r.length > 0 || rows && rows[R]) {
          params = { r: rr };
          if (rows && rows[R]) {
            row = rows[R];
            if (row.hidden)
              params.hidden = 1;
            height = -1;
            if (row.hpx)
              height = px2pt(row.hpx);
            else if (row.hpt)
              height = row.hpt;
            if (height > -1) {
              params.ht = height;
              params.customHeight = 1;
            }
            if (row.level) {
              params.outlineLevel = row.level;
            }
          }
          o[o.length] = writextag("row", r.join(""), params);
        }
      }
      if (rows)
        for (; R < rows.length; ++R) {
          if (rows && rows[R]) {
            params = { r: R + 1 };
            row = rows[R];
            if (row.hidden)
              params.hidden = 1;
            height = -1;
            if (row.hpx)
              height = px2pt(row.hpx);
            else if (row.hpt)
              height = row.hpt;
            if (height > -1) {
              params.ht = height;
              params.customHeight = 1;
            }
            if (row.level) {
              params.outlineLevel = row.level;
            }
            o[o.length] = writextag("row", "", params);
          }
        }
      return o.join("");
    }
    function write_ws_xml(idx, opts, wb, rels) {
      var o = [XML_HEADER, writextag("worksheet", null, {
        "xmlns": XMLNS_main[0],
        "xmlns:r": XMLNS.r
      })];
      var s = wb.SheetNames[idx], sidx = 0, rdata = "";
      var ws = wb.Sheets[s];
      if (ws == null)
        ws = {};
      var ref = ws["!ref"] || "A1";
      var range = safe_decode_range(ref);
      if (range.e.c > 16383 || range.e.r > 1048575) {
        if (opts.WTF)
          throw new Error("Range " + ref + " exceeds format limit A1:XFD1048576");
        range.e.c = Math.min(range.e.c, 16383);
        range.e.r = Math.min(range.e.c, 1048575);
        ref = encode_range(range);
      }
      if (!rels)
        rels = {};
      ws["!comments"] = [];
      var _drawing = [];
      write_ws_xml_sheetpr(ws, wb, idx, opts, o);
      o[o.length] = writextag("dimension", null, { "ref": ref });
      o[o.length] = write_ws_xml_sheetviews(ws, opts, idx, wb);
      if (opts.sheetFormat)
        o[o.length] = writextag("sheetFormatPr", null, {
          defaultRowHeight: opts.sheetFormat.defaultRowHeight || "16",
          baseColWidth: opts.sheetFormat.baseColWidth || "10",
          outlineLevelRow: opts.sheetFormat.outlineLevelRow || "7"
        });
      if (ws["!cols"] != null && ws["!cols"].length > 0)
        o[o.length] = write_ws_xml_cols(ws, ws["!cols"]);
      o[sidx = o.length] = "<sheetData/>";
      ws["!links"] = [];
      if (ws["!ref"] != null) {
        rdata = write_ws_xml_data(ws, opts);
        if (rdata.length > 0)
          o[o.length] = rdata;
      }
      if (o.length > sidx + 1) {
        o[o.length] = "</sheetData>";
        o[sidx] = o[sidx].replace("/>", ">");
      }
      if (ws["!protect"])
        o[o.length] = write_ws_xml_protection(ws["!protect"]);
      if (ws["!autofilter"] != null)
        o[o.length] = write_ws_xml_autofilter(ws["!autofilter"], ws, wb, idx);
      if (ws["!merges"] != null && ws["!merges"].length > 0)
        o[o.length] = write_ws_xml_merges(ws["!merges"]);
      var relc = -1, rel, rId = -1;
      if (
        /*::(*/
        ws["!links"].length > 0
      ) {
        o[o.length] = "<hyperlinks>";
        ws["!links"].forEach(function(l2) {
          if (!l2[1].Target)
            return;
          rel = { "ref": l2[0] };
          if (l2[1].Target.charAt(0) != "#") {
            rId = add_rels(rels, -1, escapexml(l2[1].Target).replace(/#.*$/, ""), RELS.HLINK);
            rel["r:id"] = "rId" + rId;
          }
          if ((relc = l2[1].Target.indexOf("#")) > -1)
            rel.location = escapexml(l2[1].Target.slice(relc + 1));
          if (l2[1].Tooltip)
            rel.tooltip = escapexml(l2[1].Tooltip);
          o[o.length] = writextag("hyperlink", null, rel);
        });
        o[o.length] = "</hyperlinks>";
      }
      delete ws["!links"];
      if (ws["!margins"] != null)
        o[o.length] = write_ws_xml_margins(ws["!margins"]);
      if (!opts || opts.ignoreEC || opts.ignoreEC == void 0)
        o[o.length] = writetag("ignoredErrors", writextag("ignoredError", null, { numberStoredAsText: 1, sqref: ref }));
      if (_drawing.length > 0) {
        rId = add_rels(rels, -1, "../drawings/drawing" + (idx + 1) + ".xml", RELS.DRAW);
        o[o.length] = writextag("drawing", null, { "r:id": "rId" + rId });
        ws["!drawing"] = _drawing;
      }
      if (ws["!comments"].length > 0) {
        rId = add_rels(rels, -1, "../drawings/vmlDrawing" + (idx + 1) + ".vml", RELS.VML);
        o[o.length] = writextag("legacyDrawing", null, { "r:id": "rId" + rId });
        ws["!legacy"] = rId;
      }
      if (o.length > 1) {
        o[o.length] = "</worksheet>";
        o[1] = o[1].replace("/>", ">");
      }
      return o.join("");
    }
    function parse_BrtRowHdr(data, length) {
      var z = {};
      var tgt = data.l + length;
      z.r = data.read_shift(4);
      data.l += 4;
      var miyRw = data.read_shift(2);
      data.l += 1;
      var flags = data.read_shift(1);
      data.l = tgt;
      if (flags & 7)
        z.level = flags & 7;
      if (flags & 16)
        z.hidden = true;
      if (flags & 32)
        z.hpt = miyRw / 20;
      return z;
    }
    function write_BrtRowHdr(R, range, ws) {
      var o = new_buf(17 + 8 * 16);
      var row = (ws["!rows"] || [])[R] || {};
      o.write_shift(4, R);
      o.write_shift(4, 0);
      var miyRw = 320;
      if (row.hpx)
        miyRw = px2pt(row.hpx) * 20;
      else if (row.hpt)
        miyRw = row.hpt * 20;
      o.write_shift(2, miyRw);
      o.write_shift(1, 0);
      var flags = 0;
      if (row.level)
        flags |= row.level;
      if (row.hidden)
        flags |= 16;
      if (row.hpx || row.hpt)
        flags |= 32;
      o.write_shift(1, flags);
      o.write_shift(1, 0);
      var ncolspan = 0, lcs = o.l;
      o.l += 4;
      var caddr = { r: R, c: 0 };
      for (var i = 0; i < 16; ++i) {
        if (range.s.c > i + 1 << 10 || range.e.c < i << 10)
          continue;
        var first = -1, last = -1;
        for (var j = i << 10; j < i + 1 << 10; ++j) {
          caddr.c = j;
          var cell = Array.isArray(ws) ? (ws[caddr.r] || [])[caddr.c] : ws[encode_cell(caddr)];
          if (cell) {
            if (first < 0)
              first = j;
            last = j;
          }
        }
        if (first < 0)
          continue;
        ++ncolspan;
        o.write_shift(4, first);
        o.write_shift(4, last);
      }
      var l2 = o.l;
      o.l = lcs;
      o.write_shift(4, ncolspan);
      o.l = l2;
      return o.length > o.l ? o.slice(0, o.l) : o;
    }
    function write_row_header(ba, ws, range, R) {
      var o = write_BrtRowHdr(R, range, ws);
      if (o.length > 17 || (ws["!rows"] || [])[R])
        write_record(ba, 0, o);
    }
    var parse_BrtWsDim = parse_UncheckedRfX;
    var write_BrtWsDim = write_UncheckedRfX;
    function parse_BrtWsFmtInfo() {
    }
    function parse_BrtWsProp(data, length) {
      var z = {};
      var f = data[data.l];
      ++data.l;
      z.above = !(f & 64);
      z.left = !(f & 128);
      data.l += 18;
      z.name = parse_XLSBCodeName(data);
      return z;
    }
    function write_BrtWsProp(str, outl, o) {
      if (o == null)
        o = new_buf(84 + 4 * str.length);
      var f = 192;
      if (outl) {
        if (outl.above)
          f &= -65;
        if (outl.left)
          f &= -129;
      }
      o.write_shift(1, f);
      for (var i = 1; i < 3; ++i)
        o.write_shift(1, 0);
      write_BrtColor({ auto: 1 }, o);
      o.write_shift(-4, -1);
      o.write_shift(-4, -1);
      write_XLSBCodeName(str, o);
      return o.slice(0, o.l);
    }
    function parse_BrtCellBlank(data) {
      var cell = parse_XLSBCell(data);
      return [cell];
    }
    function write_BrtCellBlank(cell, ncell, o) {
      if (o == null)
        o = new_buf(8);
      return write_XLSBCell(ncell, o);
    }
    function parse_BrtShortBlank(data) {
      var cell = parse_XLSBShortCell(data);
      return [cell];
    }
    function write_BrtShortBlank(cell, ncell, o) {
      if (o == null)
        o = new_buf(4);
      return write_XLSBShortCell(ncell, o);
    }
    function parse_BrtCellBool(data) {
      var cell = parse_XLSBCell(data);
      var fBool = data.read_shift(1);
      return [cell, fBool, "b"];
    }
    function write_BrtCellBool(cell, ncell, o) {
      if (o == null)
        o = new_buf(9);
      write_XLSBCell(ncell, o);
      o.write_shift(1, cell.v ? 1 : 0);
      return o;
    }
    function parse_BrtShortBool(data) {
      var cell = parse_XLSBShortCell(data);
      var fBool = data.read_shift(1);
      return [cell, fBool, "b"];
    }
    function write_BrtShortBool(cell, ncell, o) {
      if (o == null)
        o = new_buf(5);
      write_XLSBShortCell(ncell, o);
      o.write_shift(1, cell.v ? 1 : 0);
      return o;
    }
    function parse_BrtCellError(data) {
      var cell = parse_XLSBCell(data);
      var bError = data.read_shift(1);
      return [cell, bError, "e"];
    }
    function write_BrtCellError(cell, ncell, o) {
      if (o == null)
        o = new_buf(9);
      write_XLSBCell(ncell, o);
      o.write_shift(1, cell.v);
      return o;
    }
    function parse_BrtShortError(data) {
      var cell = parse_XLSBShortCell(data);
      var bError = data.read_shift(1);
      return [cell, bError, "e"];
    }
    function write_BrtShortError(cell, ncell, o) {
      if (o == null)
        o = new_buf(8);
      write_XLSBShortCell(ncell, o);
      o.write_shift(1, cell.v);
      o.write_shift(2, 0);
      o.write_shift(1, 0);
      return o;
    }
    function parse_BrtCellIsst(data) {
      var cell = parse_XLSBCell(data);
      var isst = data.read_shift(4);
      return [cell, isst, "s"];
    }
    function write_BrtCellIsst(cell, ncell, o) {
      if (o == null)
        o = new_buf(12);
      write_XLSBCell(ncell, o);
      o.write_shift(4, ncell.v);
      return o;
    }
    function parse_BrtShortIsst(data) {
      var cell = parse_XLSBShortCell(data);
      var isst = data.read_shift(4);
      return [cell, isst, "s"];
    }
    function write_BrtShortIsst(cell, ncell, o) {
      if (o == null)
        o = new_buf(8);
      write_XLSBShortCell(ncell, o);
      o.write_shift(4, ncell.v);
      return o;
    }
    function parse_BrtCellReal(data) {
      var cell = parse_XLSBCell(data);
      var value = parse_Xnum(data);
      return [cell, value, "n"];
    }
    function write_BrtCellReal(cell, ncell, o) {
      if (o == null)
        o = new_buf(16);
      write_XLSBCell(ncell, o);
      write_Xnum(cell.v, o);
      return o;
    }
    function parse_BrtShortReal(data) {
      var cell = parse_XLSBShortCell(data);
      var value = parse_Xnum(data);
      return [cell, value, "n"];
    }
    function write_BrtShortReal(cell, ncell, o) {
      if (o == null)
        o = new_buf(12);
      write_XLSBShortCell(ncell, o);
      write_Xnum(cell.v, o);
      return o;
    }
    function parse_BrtCellRk(data) {
      var cell = parse_XLSBCell(data);
      var value = parse_RkNumber(data);
      return [cell, value, "n"];
    }
    function write_BrtCellRk(cell, ncell, o) {
      if (o == null)
        o = new_buf(12);
      write_XLSBCell(ncell, o);
      write_RkNumber(cell.v, o);
      return o;
    }
    function parse_BrtShortRk(data) {
      var cell = parse_XLSBShortCell(data);
      var value = parse_RkNumber(data);
      return [cell, value, "n"];
    }
    function write_BrtShortRk(cell, ncell, o) {
      if (o == null)
        o = new_buf(8);
      write_XLSBShortCell(ncell, o);
      write_RkNumber(cell.v, o);
      return o;
    }
    function parse_BrtCellRString(data) {
      var cell = parse_XLSBCell(data);
      var value = parse_RichStr(data);
      return [cell, value, "is"];
    }
    function parse_BrtCellSt(data) {
      var cell = parse_XLSBCell(data);
      var value = parse_XLWideString(data);
      return [cell, value, "str"];
    }
    function write_BrtCellSt(cell, ncell, o) {
      if (o == null)
        o = new_buf(12 + 4 * cell.v.length);
      write_XLSBCell(ncell, o);
      write_XLWideString(cell.v, o);
      return o.length > o.l ? o.slice(0, o.l) : o;
    }
    function parse_BrtShortSt(data) {
      var cell = parse_XLSBShortCell(data);
      var value = parse_XLWideString(data);
      return [cell, value, "str"];
    }
    function write_BrtShortSt(cell, ncell, o) {
      if (o == null)
        o = new_buf(8 + 4 * cell.v.length);
      write_XLSBShortCell(ncell, o);
      write_XLWideString(cell.v, o);
      return o.length > o.l ? o.slice(0, o.l) : o;
    }
    function parse_BrtFmlaBool(data, length, opts) {
      var end = data.l + length;
      var cell = parse_XLSBCell(data);
      cell.r = opts["!row"];
      var value = data.read_shift(1);
      var o = [cell, value, "b"];
      if (opts.cellFormula) {
        data.l += 2;
        var formula = parse_XLSBCellParsedFormula(data, end - data.l, opts);
        o[3] = stringify_formula(formula, null, cell, opts.supbooks, opts);
      } else
        data.l = end;
      return o;
    }
    function parse_BrtFmlaError(data, length, opts) {
      var end = data.l + length;
      var cell = parse_XLSBCell(data);
      cell.r = opts["!row"];
      var value = data.read_shift(1);
      var o = [cell, value, "e"];
      if (opts.cellFormula) {
        data.l += 2;
        var formula = parse_XLSBCellParsedFormula(data, end - data.l, opts);
        o[3] = stringify_formula(formula, null, cell, opts.supbooks, opts);
      } else
        data.l = end;
      return o;
    }
    function parse_BrtFmlaNum(data, length, opts) {
      var end = data.l + length;
      var cell = parse_XLSBCell(data);
      cell.r = opts["!row"];
      var value = parse_Xnum(data);
      var o = [cell, value, "n"];
      if (opts.cellFormula) {
        data.l += 2;
        var formula = parse_XLSBCellParsedFormula(data, end - data.l, opts);
        o[3] = stringify_formula(formula, null, cell, opts.supbooks, opts);
      } else
        data.l = end;
      return o;
    }
    function parse_BrtFmlaString(data, length, opts) {
      var end = data.l + length;
      var cell = parse_XLSBCell(data);
      cell.r = opts["!row"];
      var value = parse_XLWideString(data);
      var o = [cell, value, "str"];
      if (opts.cellFormula) {
        data.l += 2;
        var formula = parse_XLSBCellParsedFormula(data, end - data.l, opts);
        o[3] = stringify_formula(formula, null, cell, opts.supbooks, opts);
      } else
        data.l = end;
      return o;
    }
    var parse_BrtMergeCell = parse_UncheckedRfX;
    var write_BrtMergeCell = write_UncheckedRfX;
    function write_BrtBeginMergeCells(cnt, o) {
      if (o == null)
        o = new_buf(4);
      o.write_shift(4, cnt);
      return o;
    }
    function parse_BrtHLink(data, length) {
      var end = data.l + length;
      var rfx = parse_UncheckedRfX(data);
      var relId = parse_XLNullableWideString(data);
      var loc = parse_XLWideString(data);
      var tooltip = parse_XLWideString(data);
      var display = parse_XLWideString(data);
      data.l = end;
      var o = { rfx, relId, loc, display };
      if (tooltip)
        o.Tooltip = tooltip;
      return o;
    }
    function write_BrtHLink(l2, rId) {
      var o = new_buf(50 + 4 * (l2[1].Target.length + (l2[1].Tooltip || "").length));
      write_UncheckedRfX({ s: decode_cell(l2[0]), e: decode_cell(l2[0]) }, o);
      write_RelID("rId" + rId, o);
      var locidx = l2[1].Target.indexOf("#");
      var loc = locidx == -1 ? "" : l2[1].Target.slice(locidx + 1);
      write_XLWideString(loc || "", o);
      write_XLWideString(l2[1].Tooltip || "", o);
      write_XLWideString("", o);
      return o.slice(0, o.l);
    }
    function parse_BrtPane() {
    }
    function parse_BrtArrFmla(data, length, opts) {
      var end = data.l + length;
      var rfx = parse_RfX(data);
      var fAlwaysCalc = data.read_shift(1);
      var o = [rfx];
      o[2] = fAlwaysCalc;
      if (opts.cellFormula) {
        var formula = parse_XLSBArrayParsedFormula(data, end - data.l, opts);
        o[1] = formula;
      } else
        data.l = end;
      return o;
    }
    function parse_BrtShrFmla(data, length, opts) {
      var end = data.l + length;
      var rfx = parse_UncheckedRfX(data);
      var o = [rfx];
      if (opts.cellFormula) {
        var formula = parse_XLSBSharedParsedFormula(data, end - data.l, opts);
        o[1] = formula;
        data.l = end;
      } else
        data.l = end;
      return o;
    }
    function write_BrtColInfo(C, col, o) {
      if (o == null)
        o = new_buf(18);
      var p = col_obj_w(C, col);
      o.write_shift(-4, C);
      o.write_shift(-4, C);
      o.write_shift(4, (p.width || 10) * 256);
      o.write_shift(
        4,
        0
        /*ixfe*/
      );
      var flags = 0;
      if (col.hidden)
        flags |= 1;
      if (typeof p.width == "number")
        flags |= 2;
      if (col.level)
        flags |= col.level << 8;
      o.write_shift(2, flags);
      return o;
    }
    var BrtMarginKeys = ["left", "right", "top", "bottom", "header", "footer"];
    function parse_BrtMargins(data) {
      var margins = {};
      BrtMarginKeys.forEach(function(k) {
        margins[k] = parse_Xnum(data);
      });
      return margins;
    }
    function write_BrtMargins(margins, o) {
      if (o == null)
        o = new_buf(6 * 8);
      default_margins(margins);
      BrtMarginKeys.forEach(function(k) {
        write_Xnum(margins[k], o);
      });
      return o;
    }
    function parse_BrtBeginWsView(data) {
      var f = data.read_shift(2);
      data.l += 28;
      return { RTL: f & 32 };
    }
    function write_BrtBeginWsView(ws, Workbook, o) {
      if (o == null)
        o = new_buf(30);
      var f = 924;
      if ((((Workbook || {}).Views || [])[0] || {}).RTL)
        f |= 32;
      o.write_shift(2, f);
      o.write_shift(4, 0);
      o.write_shift(4, 0);
      o.write_shift(4, 0);
      o.write_shift(1, 0);
      o.write_shift(1, 0);
      o.write_shift(2, 0);
      o.write_shift(2, 100);
      o.write_shift(2, 0);
      o.write_shift(2, 0);
      o.write_shift(2, 0);
      o.write_shift(4, 0);
      return o;
    }
    function write_BrtCellIgnoreEC(ref) {
      var o = new_buf(24);
      o.write_shift(4, 4);
      o.write_shift(4, 1);
      write_UncheckedRfX(ref, o);
      return o;
    }
    function write_BrtSheetProtection(sp, o) {
      if (o == null)
        o = new_buf(16 * 4 + 2);
      o.write_shift(2, sp.password ? crypto_CreatePasswordVerifier_Method1(sp.password) : 0);
      o.write_shift(4, 1);
      [
        ["objects", false],
        // fObjects
        ["scenarios", false],
        // fScenarios
        ["formatCells", true],
        // fFormatCells
        ["formatColumns", true],
        // fFormatColumns
        ["formatRows", true],
        // fFormatRows
        ["insertColumns", true],
        // fInsertColumns
        ["insertRows", true],
        // fInsertRows
        ["insertHyperlinks", true],
        // fInsertHyperlinks
        ["deleteColumns", true],
        // fDeleteColumns
        ["deleteRows", true],
        // fDeleteRows
        ["selectLockedCells", false],
        // fSelLockedCells
        ["sort", true],
        // fSort
        ["autoFilter", true],
        // fAutoFilter
        ["pivotTables", true],
        // fPivotTables
        ["selectUnlockedCells", false]
        // fSelUnlockedCells
      ].forEach(function(n) {
        if (n[1])
          o.write_shift(4, sp[n[0]] != null && !sp[n[0]] ? 1 : 0);
        else
          o.write_shift(4, sp[n[0]] != null && sp[n[0]] ? 0 : 1);
      });
      return o;
    }
    function parse_BrtDVal() {
    }
    function parse_BrtDVal14() {
    }
    function write_ws_bin_cell(ba, cell, R, C, opts, ws, last_seen) {
      if (cell.v === void 0)
        return false;
      var vv = "";
      switch (cell.t) {
        case "b":
          vv = cell.v ? "1" : "0";
          break;
        case "d":
          cell = dup(cell);
          cell.z = cell.z || table_fmt[14];
          cell.v = datenum(parseDate(cell.v));
          cell.t = "n";
          break;
        case "n":
        case "e":
          vv = "" + cell.v;
          break;
        default:
          vv = cell.v;
          break;
      }
      var o = { r: R, c: C };
      o.s = get_cell_style(opts.cellXfs, cell, opts);
      if (cell.l)
        ws["!links"].push([encode_cell(o), cell.l]);
      if (cell.c)
        ws["!comments"].push([encode_cell(o), cell.c]);
      switch (cell.t) {
        case "s":
        case "str":
          if (opts.bookSST) {
            vv = get_sst_id(opts.Strings, cell.v, opts.revStrings);
            o.t = "s";
            o.v = vv;
            if (last_seen)
              write_record(ba, 18, write_BrtShortIsst(cell, o));
            else
              write_record(ba, 7, write_BrtCellIsst(cell, o));
          } else {
            o.t = "str";
            if (last_seen)
              write_record(ba, 17, write_BrtShortSt(cell, o));
            else
              write_record(ba, 6, write_BrtCellSt(cell, o));
          }
          return true;
        case "n":
          if (cell.v == (cell.v | 0) && cell.v > -1e3 && cell.v < 1e3) {
            if (last_seen)
              write_record(ba, 13, write_BrtShortRk(cell, o));
            else
              write_record(ba, 2, write_BrtCellRk(cell, o));
          } else {
            if (last_seen)
              write_record(ba, 16, write_BrtShortReal(cell, o));
            else
              write_record(ba, 5, write_BrtCellReal(cell, o));
          }
          return true;
        case "b":
          o.t = "b";
          if (last_seen)
            write_record(ba, 15, write_BrtShortBool(cell, o));
          else
            write_record(ba, 4, write_BrtCellBool(cell, o));
          return true;
        case "e":
          o.t = "e";
          if (last_seen)
            write_record(ba, 14, write_BrtShortError(cell, o));
          else
            write_record(ba, 3, write_BrtCellError(cell, o));
          return true;
      }
      if (last_seen)
        write_record(ba, 12, write_BrtShortBlank(cell, o));
      else
        write_record(ba, 1, write_BrtCellBlank(cell, o));
      return true;
    }
    function write_CELLTABLE(ba, ws, idx, opts) {
      var range = safe_decode_range(ws["!ref"] || "A1"), ref, rr = "", cols = [];
      write_record(
        ba,
        145
        /* BrtBeginSheetData */
      );
      var dense = Array.isArray(ws);
      var cap = range.e.r;
      if (ws["!rows"])
        cap = Math.max(range.e.r, ws["!rows"].length - 1);
      for (var R = range.s.r; R <= cap; ++R) {
        rr = encode_row(R);
        write_row_header(ba, ws, range, R);
        var last_seen = false;
        if (R <= range.e.r)
          for (var C = range.s.c; C <= range.e.c; ++C) {
            if (R === range.s.r)
              cols[C] = encode_col(C);
            ref = cols[C] + rr;
            var cell = dense ? (ws[R] || [])[C] : ws[ref];
            if (!cell) {
              last_seen = false;
              continue;
            }
            last_seen = write_ws_bin_cell(ba, cell, R, C, opts, ws, last_seen);
          }
      }
      write_record(
        ba,
        146
        /* BrtEndSheetData */
      );
    }
    function write_MERGECELLS(ba, ws) {
      if (!ws || !ws["!merges"])
        return;
      write_record(ba, 177, write_BrtBeginMergeCells(ws["!merges"].length));
      ws["!merges"].forEach(function(m) {
        write_record(ba, 176, write_BrtMergeCell(m));
      });
      write_record(
        ba,
        178
        /* BrtEndMergeCells */
      );
    }
    function write_COLINFOS(ba, ws) {
      if (!ws || !ws["!cols"])
        return;
      write_record(
        ba,
        390
        /* BrtBeginColInfos */
      );
      ws["!cols"].forEach(function(m, i) {
        if (m)
          write_record(ba, 60, write_BrtColInfo(i, m));
      });
      write_record(
        ba,
        391
        /* BrtEndColInfos */
      );
    }
    function write_IGNOREECS(ba, ws) {
      if (!ws || !ws["!ref"])
        return;
      write_record(
        ba,
        648
        /* BrtBeginCellIgnoreECs */
      );
      write_record(ba, 649, write_BrtCellIgnoreEC(safe_decode_range(ws["!ref"])));
      write_record(
        ba,
        650
        /* BrtEndCellIgnoreECs */
      );
    }
    function write_HLINKS(ba, ws, rels) {
      ws["!links"].forEach(function(l2) {
        if (!l2[1].Target)
          return;
        var rId = add_rels(rels, -1, l2[1].Target.replace(/#.*$/, ""), RELS.HLINK);
        write_record(ba, 494, write_BrtHLink(l2, rId));
      });
      delete ws["!links"];
    }
    function write_LEGACYDRAWING(ba, ws, idx, rels) {
      if (ws["!comments"].length > 0) {
        var rId = add_rels(rels, -1, "../drawings/vmlDrawing" + (idx + 1) + ".vml", RELS.VML);
        write_record(ba, 551, write_RelID("rId" + rId));
        ws["!legacy"] = rId;
      }
    }
    function write_AUTOFILTER(ba, ws, wb, idx) {
      if (!ws["!autofilter"])
        return;
      var data = ws["!autofilter"];
      var ref = typeof data.ref === "string" ? data.ref : encode_range(data.ref);
      if (!wb.Workbook)
        wb.Workbook = { Sheets: [] };
      if (!wb.Workbook.Names)
        wb.Workbook.Names = [];
      var names = wb.Workbook.Names;
      var range = decode_range(ref);
      if (range.s.r == range.e.r) {
        range.e.r = decode_range(ws["!ref"]).e.r;
        ref = encode_range(range);
      }
      for (var i = 0; i < names.length; ++i) {
        var name = names[i];
        if (name.Name != "_xlnm._FilterDatabase")
          continue;
        if (name.Sheet != idx)
          continue;
        name.Ref = "'" + wb.SheetNames[idx] + "'!" + ref;
        break;
      }
      if (i == names.length)
        names.push({ Name: "_xlnm._FilterDatabase", Sheet: idx, Ref: "'" + wb.SheetNames[idx] + "'!" + ref });
      write_record(ba, 161, write_UncheckedRfX(safe_decode_range(ref)));
      write_record(
        ba,
        162
        /* BrtEndAFilter */
      );
    }
    function write_WSVIEWS2(ba, ws, Workbook) {
      write_record(
        ba,
        133
        /* BrtBeginWsViews */
      );
      {
        write_record(ba, 137, write_BrtBeginWsView(ws, Workbook));
        write_record(
          ba,
          138
          /* BrtEndWsView */
        );
      }
      write_record(
        ba,
        134
        /* BrtEndWsViews */
      );
    }
    function write_SHEETPROTECT(ba, ws) {
      if (!ws["!protect"])
        return;
      write_record(ba, 535, write_BrtSheetProtection(ws["!protect"]));
    }
    function write_ws_bin(idx, opts, wb, rels) {
      var ba = buf_array();
      var s = wb.SheetNames[idx], ws = wb.Sheets[s] || {};
      var c = s;
      try {
        if (wb && wb.Workbook)
          c = wb.Workbook.Sheets[idx].CodeName || c;
      } catch (e) {
      }
      var r = safe_decode_range(ws["!ref"] || "A1");
      if (r.e.c > 16383 || r.e.r > 1048575) {
        if (opts.WTF)
          throw new Error("Range " + (ws["!ref"] || "A1") + " exceeds format limit A1:XFD1048576");
        r.e.c = Math.min(r.e.c, 16383);
        r.e.r = Math.min(r.e.c, 1048575);
      }
      ws["!links"] = [];
      ws["!comments"] = [];
      write_record(
        ba,
        129
        /* BrtBeginSheet */
      );
      if (wb.vbaraw || ws["!outline"])
        write_record(ba, 147, write_BrtWsProp(c, ws["!outline"]));
      write_record(ba, 148, write_BrtWsDim(r));
      write_WSVIEWS2(ba, ws, wb.Workbook);
      write_COLINFOS(ba, ws);
      write_CELLTABLE(ba, ws, idx, opts);
      write_SHEETPROTECT(ba, ws);
      write_AUTOFILTER(ba, ws, wb, idx);
      write_MERGECELLS(ba, ws);
      write_HLINKS(ba, ws, rels);
      if (ws["!margins"])
        write_record(ba, 476, write_BrtMargins(ws["!margins"]));
      if (!opts || opts.ignoreEC || opts.ignoreEC == void 0)
        write_IGNOREECS(ba, ws);
      write_LEGACYDRAWING(ba, ws, idx, rels);
      write_record(
        ba,
        130
        /* BrtEndSheet */
      );
      return ba.end();
    }
    function parse_BrtCsProp(data, length) {
      data.l += 10;
      var name = parse_XLWideString(data);
      return { name };
    }
    var WBPropsDef = [
      ["allowRefreshQuery", false, "bool"],
      ["autoCompressPictures", true, "bool"],
      ["backupFile", false, "bool"],
      ["checkCompatibility", false, "bool"],
      ["CodeName", ""],
      ["date1904", false, "bool"],
      ["defaultThemeVersion", 0, "int"],
      ["filterPrivacy", false, "bool"],
      ["hidePivotFieldList", false, "bool"],
      ["promptedSolutions", false, "bool"],
      ["publishItems", false, "bool"],
      ["refreshAllConnections", false, "bool"],
      ["saveExternalLinkValues", true, "bool"],
      ["showBorderUnselectedTables", true, "bool"],
      ["showInkAnnotation", true, "bool"],
      ["showObjects", "all"],
      ["showPivotChartFilter", false, "bool"],
      ["updateLinks", "userSet"]
    ];
    function safe1904(wb) {
      if (!wb.Workbook)
        return "false";
      if (!wb.Workbook.WBProps)
        return "false";
      return parsexmlbool(wb.Workbook.WBProps.date1904) ? "true" : "false";
    }
    var badchars = /* @__PURE__ */ "][*?/\\".split("");
    function check_ws_name(n, safe) {
      if (n.length > 31) {
        throw new Error("Sheet names cannot exceed 31 chars");
      }
      var _good = true;
      badchars.forEach(function(c) {
        if (n.indexOf(c) == -1)
          return;
        throw new Error("Sheet name cannot contain : \\ / ? * [ ]");
      });
      return _good;
    }
    function check_wb_names(N, S, codes) {
      N.forEach(function(n, i) {
        check_ws_name(n);
        for (var j = 0; j < i; ++j)
          if (n == N[j])
            throw new Error("Duplicate Sheet Name: " + n);
        if (codes) {
          var cn = S && S[i] && S[i].CodeName || n;
          if (cn.charCodeAt(0) == 95 && cn.length > 22)
            throw new Error("Bad Code Name: Worksheet" + cn);
        }
      });
    }
    function check_wb(wb) {
      if (!wb || !wb.SheetNames || !wb.Sheets)
        throw new Error("Invalid Workbook");
      if (!wb.SheetNames.length)
        throw new Error("Workbook is empty");
      var Sheets = wb.Workbook && wb.Workbook.Sheets || [];
      check_wb_names(wb.SheetNames, Sheets, !!wb.vbaraw);
      for (var i = 0; i < wb.SheetNames.length; ++i)
        check_ws(wb.Sheets[wb.SheetNames[i]], wb.SheetNames[i], i);
    }
    function write_wb_xml(wb) {
      var o = [XML_HEADER];
      o[o.length] = writextag("workbook", null, {
        "xmlns": XMLNS_main[0],
        //'xmlns:mx': XMLNS.mx,
        //'xmlns:s': XMLNS_main[0],
        "xmlns:r": XMLNS.r
      });
      var write_names = wb.Workbook && (wb.Workbook.Names || []).length > 0;
      var workbookPr = { codeName: "ThisWorkbook" };
      if (wb.Workbook && wb.Workbook.WBProps) {
        WBPropsDef.forEach(function(x) {
          if (wb.Workbook.WBProps[x[0]] == null)
            return;
          if (wb.Workbook.WBProps[x[0]] == x[1])
            return;
          workbookPr[x[0]] = wb.Workbook.WBProps[x[0]];
        });
        if (wb.Workbook.WBProps.CodeName) {
          workbookPr.codeName = wb.Workbook.WBProps.CodeName;
          delete workbookPr.CodeName;
        }
      }
      o[o.length] = writextag("workbookPr", null, workbookPr);
      var sheets = wb.Workbook && wb.Workbook.Sheets || [];
      var i = 0;
      if (sheets && sheets[0] && !!sheets[0].Hidden) {
        o[o.length] = "<bookViews>";
        for (i = 0; i != wb.SheetNames.length; ++i) {
          if (!sheets[i])
            break;
          if (!sheets[i].Hidden)
            break;
        }
        if (i == wb.SheetNames.length)
          i = 0;
        o[o.length] = '<workbookView firstSheet="' + i + '" activeTab="' + i + '"/>';
        o[o.length] = "</bookViews>";
      }
      o[o.length] = "<sheets>";
      for (i = 0; i != wb.SheetNames.length; ++i) {
        var sht = { name: escapexml(wb.SheetNames[i].slice(0, 31)) };
        sht.sheetId = "" + (i + 1);
        sht["r:id"] = "rId" + (i + 1);
        if (sheets[i])
          switch (sheets[i].Hidden) {
            case 1:
              sht.state = "hidden";
              break;
            case 2:
              sht.state = "veryHidden";
              break;
          }
        o[o.length] = writextag("sheet", null, sht);
      }
      o[o.length] = "</sheets>";
      if (write_names) {
        o[o.length] = "<definedNames>";
        if (wb.Workbook && wb.Workbook.Names)
          wb.Workbook.Names.forEach(function(n) {
            var d = { name: n.Name };
            if (n.Comment)
              d.comment = n.Comment;
            if (n.Sheet != null)
              d.localSheetId = "" + n.Sheet;
            if (n.Hidden)
              d.hidden = "1";
            if (!n.Ref)
              return;
            o[o.length] = writextag("definedName", escapexml(n.Ref), d);
          });
        o[o.length] = "</definedNames>";
      }
      if (o.length > 2) {
        o[o.length] = "</workbook>";
        o[1] = o[1].replace("/>", ">");
      }
      return o.join("");
    }
    function parse_BrtBundleSh(data, length) {
      var z = {};
      z.Hidden = data.read_shift(4);
      z.iTabID = data.read_shift(4);
      z.strRelID = parse_RelID(data);
      z.name = parse_XLWideString(data);
      return z;
    }
    function write_BrtBundleSh(data, o) {
      if (!o)
        o = new_buf(127);
      o.write_shift(4, data.Hidden);
      o.write_shift(4, data.iTabID);
      write_RelID(data.strRelID, o);
      write_XLWideString(data.name.slice(0, 31), o);
      return o.length > o.l ? o.slice(0, o.l) : o;
    }
    function parse_BrtWbProp(data, length) {
      var o = {};
      var flags = data.read_shift(4);
      o.defaultThemeVersion = data.read_shift(4);
      var strName = length > 8 ? parse_XLWideString(data) : "";
      if (strName.length > 0)
        o.CodeName = strName;
      o.autoCompressPictures = !!(flags & 65536);
      o.backupFile = !!(flags & 64);
      o.checkCompatibility = !!(flags & 4096);
      o.date1904 = !!(flags & 1);
      o.filterPrivacy = !!(flags & 8);
      o.hidePivotFieldList = !!(flags & 1024);
      o.promptedSolutions = !!(flags & 16);
      o.publishItems = !!(flags & 2048);
      o.refreshAllConnections = !!(flags & 262144);
      o.saveExternalLinkValues = !!(flags & 128);
      o.showBorderUnselectedTables = !!(flags & 4);
      o.showInkAnnotation = !!(flags & 32);
      o.showObjects = ["all", "placeholders", "none"][flags >> 13 & 3];
      o.showPivotChartFilter = !!(flags & 32768);
      o.updateLinks = ["userSet", "never", "always"][flags >> 8 & 3];
      return o;
    }
    function write_BrtWbProp(data, o) {
      if (!o)
        o = new_buf(72);
      var flags = 0;
      if (data) {
        if (data.filterPrivacy)
          flags |= 8;
      }
      o.write_shift(4, flags);
      o.write_shift(4, 0);
      write_XLSBCodeName(data && data.CodeName || "ThisWorkbook", o);
      return o.slice(0, o.l);
    }
    function parse_BrtName(data, length, opts) {
      var end = data.l + length;
      data.l += 4;
      data.l += 1;
      var itab = data.read_shift(4);
      var name = parse_XLNameWideString(data);
      var formula = parse_XLSBNameParsedFormula(data, 0, opts);
      var comment = parse_XLNullableWideString(data);
      data.l = end;
      var out = { Name: name, Ptg: formula };
      if (itab < 268435455)
        out.Sheet = itab;
      if (comment)
        out.Comment = comment;
      return out;
    }
    function write_BUNDLESHS(ba, wb) {
      write_record(
        ba,
        143
        /* BrtBeginBundleShs */
      );
      for (var idx = 0; idx != wb.SheetNames.length; ++idx) {
        var viz = wb.Workbook && wb.Workbook.Sheets && wb.Workbook.Sheets[idx] && wb.Workbook.Sheets[idx].Hidden || 0;
        var d = { Hidden: viz, iTabID: idx + 1, strRelID: "rId" + (idx + 1), name: wb.SheetNames[idx] };
        write_record(ba, 156, write_BrtBundleSh(d));
      }
      write_record(
        ba,
        144
        /* BrtEndBundleShs */
      );
    }
    function write_BrtFileVersion(data, o) {
      if (!o)
        o = new_buf(127);
      for (var i = 0; i != 4; ++i)
        o.write_shift(4, 0);
      write_XLWideString("SheetJS", o);
      write_XLWideString(XLSX.version, o);
      write_XLWideString(XLSX.version, o);
      write_XLWideString("7262", o);
      return o.length > o.l ? o.slice(0, o.l) : o;
    }
    function write_BrtBookView(idx, o) {
      if (!o)
        o = new_buf(29);
      o.write_shift(-4, 0);
      o.write_shift(-4, 460);
      o.write_shift(4, 28800);
      o.write_shift(4, 17600);
      o.write_shift(4, 500);
      o.write_shift(4, idx);
      o.write_shift(4, idx);
      var flags = 120;
      o.write_shift(1, flags);
      return o.length > o.l ? o.slice(0, o.l) : o;
    }
    function write_BOOKVIEWS(ba, wb) {
      if (!wb.Workbook || !wb.Workbook.Sheets)
        return;
      var sheets = wb.Workbook.Sheets;
      var i = 0, vistab = -1, hidden = -1;
      for (; i < sheets.length; ++i) {
        if (!sheets[i] || !sheets[i].Hidden && vistab == -1)
          vistab = i;
        else if (sheets[i].Hidden == 1 && hidden == -1)
          hidden = i;
      }
      if (hidden > vistab)
        return;
      write_record(
        ba,
        135
        /* BrtBeginBookViews */
      );
      write_record(ba, 158, write_BrtBookView(vistab));
      write_record(
        ba,
        136
        /* BrtEndBookViews */
      );
    }
    function write_wb_bin(wb, opts) {
      var ba = buf_array();
      write_record(
        ba,
        131
        /* BrtBeginBook */
      );
      write_record(ba, 128, write_BrtFileVersion());
      write_record(ba, 153, write_BrtWbProp(wb.Workbook && wb.Workbook.WBProps || null));
      write_BOOKVIEWS(ba, wb);
      write_BUNDLESHS(ba, wb);
      write_record(
        ba,
        132
        /* BrtEndBook */
      );
      return ba.end();
    }
    function write_wb(wb, name, opts) {
      return (name.slice(-4) === ".bin" ? write_wb_bin : write_wb_xml)(wb);
    }
    function write_ws(data, name, opts, wb, rels) {
      return (name.slice(-4) === ".bin" ? write_ws_bin : write_ws_xml)(data, opts, wb, rels);
    }
    function write_sty(data, name, opts) {
      return (name.slice(-4) === ".bin" ? write_sty_bin : write_sty_xml)(data, opts);
    }
    function write_sst(data, name, opts) {
      return (name.slice(-4) === ".bin" ? write_sst_bin : write_sst_xml)(data, opts);
    }
    function write_cmnt(data, name, opts) {
      return (name.slice(-4) === ".bin" ? write_comments_bin : write_comments_xml)(data);
    }
    function write_xlmeta(name) {
      return (name.slice(-4) === ".bin" ? write_xlmeta_bin : write_xlmeta_xml)();
    }
    function write_props_xlml(wb, opts) {
      var o = [];
      if (wb.Props)
        o.push(xlml_write_docprops(wb.Props, opts));
      if (wb.Custprops)
        o.push(xlml_write_custprops(wb.Props, wb.Custprops));
      return o.join("");
    }
    function write_wb_xlml() {
      return "";
    }
    function write_sty_xlml(wb, opts) {
      var styles = ['<Style ss:ID="Default" ss:Name="Normal"><NumberFormat/></Style>'];
      opts.cellXfs.forEach(function(xf, id) {
        var payload = [];
        payload.push(writextag("NumberFormat", null, { "ss:Format": escapexml(table_fmt[xf.numFmtId]) }));
        var o = (
          /*::(*/
          { "ss:ID": "s" + (21 + id) }
        );
        styles.push(writextag("Style", payload.join(""), o));
      });
      return writextag("Styles", styles.join(""));
    }
    function write_name_xlml(n) {
      return writextag("NamedRange", null, { "ss:Name": n.Name, "ss:RefersTo": "=" + a1_to_rc(n.Ref, { r: 0, c: 0 }) });
    }
    function write_names_xlml(wb) {
      if (!((wb || {}).Workbook || {}).Names)
        return "";
      var names = wb.Workbook.Names;
      var out = [];
      for (var i = 0; i < names.length; ++i) {
        var n = names[i];
        if (n.Sheet != null)
          continue;
        if (n.Name.match(/^_xlfn\./))
          continue;
        out.push(write_name_xlml(n));
      }
      return writextag("Names", out.join(""));
    }
    function write_ws_xlml_names(ws, opts, idx, wb) {
      if (!ws)
        return "";
      if (!((wb || {}).Workbook || {}).Names)
        return "";
      var names = wb.Workbook.Names;
      var out = [];
      for (var i = 0; i < names.length; ++i) {
        var n = names[i];
        if (n.Sheet != idx)
          continue;
        if (n.Name.match(/^_xlfn\./))
          continue;
        out.push(write_name_xlml(n));
      }
      return out.join("");
    }
    function write_ws_xlml_wsopts(ws, opts, idx, wb) {
      if (!ws)
        return "";
      var o = [];
      if (ws["!margins"]) {
        o.push("<PageSetup>");
        if (ws["!margins"].header)
          o.push(writextag("Header", null, { "x:Margin": ws["!margins"].header }));
        if (ws["!margins"].footer)
          o.push(writextag("Footer", null, { "x:Margin": ws["!margins"].footer }));
        o.push(writextag("PageMargins", null, {
          "x:Bottom": ws["!margins"].bottom || "0.75",
          "x:Left": ws["!margins"].left || "0.7",
          "x:Right": ws["!margins"].right || "0.7",
          "x:Top": ws["!margins"].top || "0.75"
        }));
        o.push("</PageSetup>");
      }
      if (wb && wb.Workbook && wb.Workbook.Sheets && wb.Workbook.Sheets[idx]) {
        if (wb.Workbook.Sheets[idx].Hidden)
          o.push(writextag("Visible", wb.Workbook.Sheets[idx].Hidden == 1 ? "SheetHidden" : "SheetVeryHidden", {}));
        else {
          for (var i = 0; i < idx; ++i)
            if (wb.Workbook.Sheets[i] && !wb.Workbook.Sheets[i].Hidden)
              break;
          if (i == idx)
            o.push("<Selected/>");
        }
      }
      if (((((wb || {}).Workbook || {}).Views || [])[0] || {}).RTL)
        o.push("<DisplayRightToLeft/>");
      if (ws["!protect"]) {
        o.push(writetag("ProtectContents", "True"));
        if (ws["!protect"].objects)
          o.push(writetag("ProtectObjects", "True"));
        if (ws["!protect"].scenarios)
          o.push(writetag("ProtectScenarios", "True"));
        if (ws["!protect"].selectLockedCells != null && !ws["!protect"].selectLockedCells)
          o.push(writetag("EnableSelection", "NoSelection"));
        else if (ws["!protect"].selectUnlockedCells != null && !ws["!protect"].selectUnlockedCells)
          o.push(writetag("EnableSelection", "UnlockedCells"));
        [
          ["formatCells", "AllowFormatCells"],
          ["formatColumns", "AllowSizeCols"],
          ["formatRows", "AllowSizeRows"],
          ["insertColumns", "AllowInsertCols"],
          ["insertRows", "AllowInsertRows"],
          ["insertHyperlinks", "AllowInsertHyperlinks"],
          ["deleteColumns", "AllowDeleteCols"],
          ["deleteRows", "AllowDeleteRows"],
          ["sort", "AllowSort"],
          ["autoFilter", "AllowFilter"],
          ["pivotTables", "AllowUsePivotTables"]
        ].forEach(function(x) {
          if (ws["!protect"][x[0]])
            o.push("<" + x[1] + "/>");
        });
      }
      if (o.length == 0)
        return "";
      return writextag("WorksheetOptions", o.join(""), { xmlns: XLMLNS.x });
    }
    function write_ws_xlml_comment(comments) {
      return comments.map(function(c) {
        var t = xlml_unfixstr(c.t || "");
        var d = writextag("ss:Data", t, { "xmlns": "http://www.w3.org/TR/REC-html40" });
        return writextag("Comment", d, { "ss:Author": c.a });
      }).join("");
    }
    function write_ws_xlml_cell(cell, ref, ws, opts, idx, wb, addr) {
      if (!cell || cell.v == void 0 && cell.f == void 0)
        return "";
      var attr = {};
      if (cell.f)
        attr["ss:Formula"] = "=" + escapexml(a1_to_rc(cell.f, addr));
      if (cell.F && cell.F.slice(0, ref.length) == ref) {
        var end = decode_cell(cell.F.slice(ref.length + 1));
        attr["ss:ArrayRange"] = "RC:R" + (end.r == addr.r ? "" : "[" + (end.r - addr.r) + "]") + "C" + (end.c == addr.c ? "" : "[" + (end.c - addr.c) + "]");
      }
      if (cell.l && cell.l.Target) {
        attr["ss:HRef"] = escapexml(cell.l.Target);
        if (cell.l.Tooltip)
          attr["x:HRefScreenTip"] = escapexml(cell.l.Tooltip);
      }
      if (ws["!merges"]) {
        var marr = ws["!merges"];
        for (var mi = 0; mi != marr.length; ++mi) {
          if (marr[mi].s.c != addr.c || marr[mi].s.r != addr.r)
            continue;
          if (marr[mi].e.c > marr[mi].s.c)
            attr["ss:MergeAcross"] = marr[mi].e.c - marr[mi].s.c;
          if (marr[mi].e.r > marr[mi].s.r)
            attr["ss:MergeDown"] = marr[mi].e.r - marr[mi].s.r;
        }
      }
      var t = "", p = "";
      switch (cell.t) {
        case "z":
          if (!opts.sheetStubs)
            return "";
          break;
        case "n":
          t = "Number";
          p = String(cell.v);
          break;
        case "b":
          t = "Boolean";
          p = cell.v ? "1" : "0";
          break;
        case "e":
          t = "Error";
          p = BErr[cell.v];
          break;
        case "d":
          t = "DateTime";
          p = new Date(cell.v).toISOString();
          if (cell.z == null)
            cell.z = cell.z || table_fmt[14];
          break;
        case "s":
          t = "String";
          p = escapexlml(cell.v || "");
          break;
      }
      var os = get_cell_style(opts.cellXfs, cell, opts);
      attr["ss:StyleID"] = "s" + (21 + os);
      attr["ss:Index"] = addr.c + 1;
      var _v = cell.v != null ? p : "";
      var m = cell.t == "z" ? "" : '<Data ss:Type="' + t + '">' + _v + "</Data>";
      if ((cell.c || []).length > 0)
        m += write_ws_xlml_comment(cell.c);
      return writextag("Cell", m, attr);
    }
    function write_ws_xlml_row(R, row) {
      var o = '<Row ss:Index="' + (R + 1) + '"';
      if (row) {
        if (row.hpt && !row.hpx)
          row.hpx = pt2px(row.hpt);
        if (row.hpx)
          o += ' ss:AutoFitHeight="0" ss:Height="' + row.hpx + '"';
        if (row.hidden)
          o += ' ss:Hidden="1"';
      }
      return o + ">";
    }
    function write_ws_xlml_table(ws, opts, idx, wb) {
      if (!ws["!ref"])
        return "";
      var range = safe_decode_range(ws["!ref"]);
      var marr = ws["!merges"] || [], mi = 0;
      var o = [];
      if (ws["!cols"])
        ws["!cols"].forEach(function(n, i) {
          process_col(n);
          var w = !!n.width;
          var p = col_obj_w(i, n);
          var k = { "ss:Index": i + 1 };
          if (w)
            k["ss:Width"] = width2px(p.width);
          if (n.hidden)
            k["ss:Hidden"] = "1";
          o.push(writextag("Column", null, k));
        });
      var dense = Array.isArray(ws);
      for (var R = range.s.r; R <= range.e.r; ++R) {
        var row = [write_ws_xlml_row(R, (ws["!rows"] || [])[R])];
        for (var C = range.s.c; C <= range.e.c; ++C) {
          var skip = false;
          for (mi = 0; mi != marr.length; ++mi) {
            if (marr[mi].s.c > C)
              continue;
            if (marr[mi].s.r > R)
              continue;
            if (marr[mi].e.c < C)
              continue;
            if (marr[mi].e.r < R)
              continue;
            if (marr[mi].s.c != C || marr[mi].s.r != R)
              skip = true;
            break;
          }
          if (skip)
            continue;
          var addr = { r: R, c: C };
          var ref = encode_cell(addr), cell = dense ? (ws[R] || [])[C] : ws[ref];
          row.push(write_ws_xlml_cell(cell, ref, ws, opts, idx, wb, addr));
        }
        row.push("</Row>");
        if (row.length > 2)
          o.push(row.join(""));
      }
      return o.join("");
    }
    function write_ws_xlml(idx, opts, wb) {
      var o = [];
      var s = wb.SheetNames[idx];
      var ws = wb.Sheets[s];
      var t = ws ? write_ws_xlml_names(ws, opts, idx, wb) : "";
      if (t.length > 0)
        o.push("<Names>" + t + "</Names>");
      t = ws ? write_ws_xlml_table(ws, opts, idx, wb) : "";
      if (t.length > 0)
        o.push("<Table>" + t + "</Table>");
      o.push(write_ws_xlml_wsopts(ws, opts, idx, wb));
      return o.join("");
    }
    function write_xlml(wb, opts) {
      if (!opts)
        opts = {};
      if (!wb.SSF)
        wb.SSF = dup(table_fmt);
      if (wb.SSF) {
        make_ssf();
        SSF_load_table(wb.SSF);
        opts.revssf = evert_num(wb.SSF);
        opts.revssf[wb.SSF[65535]] = 0;
        opts.ssf = wb.SSF;
        opts.cellXfs = [];
        get_cell_style(opts.cellXfs, {}, { revssf: { "General": 0 } });
      }
      var d = [];
      d.push(write_props_xlml(wb, opts));
      d.push(write_wb_xlml());
      d.push("");
      d.push("");
      for (var i = 0; i < wb.SheetNames.length; ++i)
        d.push(writextag("Worksheet", write_ws_xlml(i, opts, wb), { "ss:Name": escapexml(wb.SheetNames[i]) }));
      d[2] = write_sty_xlml(wb, opts);
      d[3] = write_names_xlml(wb);
      return XML_HEADER + writextag("Workbook", d.join(""), {
        "xmlns": XLMLNS.ss,
        "xmlns:o": XLMLNS.o,
        "xmlns:x": XLMLNS.x,
        "xmlns:ss": XLMLNS.ss,
        "xmlns:dt": XLMLNS.dt,
        "xmlns:html": XLMLNS.html
      });
    }
    var PSCLSID = {
      SI: "e0859ff2f94f6810ab9108002b27b3d9",
      DSI: "02d5cdd59c2e1b10939708002b2cf9ae",
      UDI: "05d5cdd59c2e1b10939708002b2cf9ae"
    };
    function write_xls_props(wb, cfb) {
      var DSEntries = [], SEntries = [], CEntries = [];
      var i = 0, Keys;
      var DocSummaryRE = evert_key(DocSummaryPIDDSI, "n");
      var SummaryRE = evert_key(SummaryPIDSI, "n");
      if (wb.Props) {
        Keys = keys(wb.Props);
        for (i = 0; i < Keys.length; ++i)
          (Object.prototype.hasOwnProperty.call(DocSummaryRE, Keys[i]) ? DSEntries : Object.prototype.hasOwnProperty.call(SummaryRE, Keys[i]) ? SEntries : CEntries).push([Keys[i], wb.Props[Keys[i]]]);
      }
      if (wb.Custprops) {
        Keys = keys(wb.Custprops);
        for (i = 0; i < Keys.length; ++i)
          if (!Object.prototype.hasOwnProperty.call(wb.Props || {}, Keys[i]))
            (Object.prototype.hasOwnProperty.call(DocSummaryRE, Keys[i]) ? DSEntries : Object.prototype.hasOwnProperty.call(SummaryRE, Keys[i]) ? SEntries : CEntries).push([Keys[i], wb.Custprops[Keys[i]]]);
      }
      var CEntries2 = [];
      for (i = 0; i < CEntries.length; ++i) {
        if (XLSPSSkip.indexOf(CEntries[i][0]) > -1 || PseudoPropsPairs.indexOf(CEntries[i][0]) > -1)
          continue;
        if (CEntries[i][1] == null)
          continue;
        CEntries2.push(CEntries[i]);
      }
      if (SEntries.length)
        CFB.utils.cfb_add(cfb, "/SummaryInformation", write_PropertySetStream(SEntries, PSCLSID.SI, SummaryRE, SummaryPIDSI));
      if (DSEntries.length || CEntries2.length)
        CFB.utils.cfb_add(cfb, "/DocumentSummaryInformation", write_PropertySetStream(DSEntries, PSCLSID.DSI, DocSummaryRE, DocSummaryPIDDSI, CEntries2.length ? CEntries2 : null, PSCLSID.UDI));
    }
    function write_xlscfb(wb, opts) {
      var o = opts || {};
      var cfb = CFB.utils.cfb_new({ root: "R" });
      var wbpath = "/Workbook";
      switch (o.bookType || "xls") {
        case "xls":
          o.bookType = "biff8";
        case "xla":
          if (!o.bookType)
            o.bookType = "xla";
        case "biff8":
          wbpath = "/Workbook";
          o.biff = 8;
          break;
        case "biff5":
          wbpath = "/Book";
          o.biff = 5;
          break;
        default:
          throw new Error("invalid type " + o.bookType + " for XLS CFB");
      }
      CFB.utils.cfb_add(cfb, wbpath, write_biff_buf(wb, o));
      if (o.biff == 8 && (wb.Props || wb.Custprops))
        write_xls_props(wb, cfb);
      if (o.biff == 8 && wb.vbaraw)
        fill_vba_xls(cfb, CFB.read(wb.vbaraw, { type: typeof wb.vbaraw == "string" ? "binary" : "buffer" }));
      return cfb;
    }
    var XLSBRecordEnum = {
      /*::[*/
      0: {
        /* n:"BrtRowHdr", */
        f: parse_BrtRowHdr
      },
      /*::[*/
      1: {
        /* n:"BrtCellBlank", */
        f: parse_BrtCellBlank
      },
      /*::[*/
      2: {
        /* n:"BrtCellRk", */
        f: parse_BrtCellRk
      },
      /*::[*/
      3: {
        /* n:"BrtCellError", */
        f: parse_BrtCellError
      },
      /*::[*/
      4: {
        /* n:"BrtCellBool", */
        f: parse_BrtCellBool
      },
      /*::[*/
      5: {
        /* n:"BrtCellReal", */
        f: parse_BrtCellReal
      },
      /*::[*/
      6: {
        /* n:"BrtCellSt", */
        f: parse_BrtCellSt
      },
      /*::[*/
      7: {
        /* n:"BrtCellIsst", */
        f: parse_BrtCellIsst
      },
      /*::[*/
      8: {
        /* n:"BrtFmlaString", */
        f: parse_BrtFmlaString
      },
      /*::[*/
      9: {
        /* n:"BrtFmlaNum", */
        f: parse_BrtFmlaNum
      },
      /*::[*/
      10: {
        /* n:"BrtFmlaBool", */
        f: parse_BrtFmlaBool
      },
      /*::[*/
      11: {
        /* n:"BrtFmlaError", */
        f: parse_BrtFmlaError
      },
      /*::[*/
      12: {
        /* n:"BrtShortBlank", */
        f: parse_BrtShortBlank
      },
      /*::[*/
      13: {
        /* n:"BrtShortRk", */
        f: parse_BrtShortRk
      },
      /*::[*/
      14: {
        /* n:"BrtShortError", */
        f: parse_BrtShortError
      },
      /*::[*/
      15: {
        /* n:"BrtShortBool", */
        f: parse_BrtShortBool
      },
      /*::[*/
      16: {
        /* n:"BrtShortReal", */
        f: parse_BrtShortReal
      },
      /*::[*/
      17: {
        /* n:"BrtShortSt", */
        f: parse_BrtShortSt
      },
      /*::[*/
      18: {
        /* n:"BrtShortIsst", */
        f: parse_BrtShortIsst
      },
      /*::[*/
      19: {
        /* n:"BrtSSTItem", */
        f: parse_RichStr
      },
      /*::[*/
      20: {
        /* n:"BrtPCDIMissing" */
      },
      /*::[*/
      21: {
        /* n:"BrtPCDINumber" */
      },
      /*::[*/
      22: {
        /* n:"BrtPCDIBoolean" */
      },
      /*::[*/
      23: {
        /* n:"BrtPCDIError" */
      },
      /*::[*/
      24: {
        /* n:"BrtPCDIString" */
      },
      /*::[*/
      25: {
        /* n:"BrtPCDIDatetime" */
      },
      /*::[*/
      26: {
        /* n:"BrtPCDIIndex" */
      },
      /*::[*/
      27: {
        /* n:"BrtPCDIAMissing" */
      },
      /*::[*/
      28: {
        /* n:"BrtPCDIANumber" */
      },
      /*::[*/
      29: {
        /* n:"BrtPCDIABoolean" */
      },
      /*::[*/
      30: {
        /* n:"BrtPCDIAError" */
      },
      /*::[*/
      31: {
        /* n:"BrtPCDIAString" */
      },
      /*::[*/
      32: {
        /* n:"BrtPCDIADatetime" */
      },
      /*::[*/
      33: {
        /* n:"BrtPCRRecord" */
      },
      /*::[*/
      34: {
        /* n:"BrtPCRRecordDt" */
      },
      /*::[*/
      35: {
        /* n:"BrtFRTBegin", */
        T: 1
      },
      /*::[*/
      36: {
        /* n:"BrtFRTEnd", */
        T: -1
      },
      /*::[*/
      37: {
        /* n:"BrtACBegin", */
        T: 1
      },
      /*::[*/
      38: {
        /* n:"BrtACEnd", */
        T: -1
      },
      /*::[*/
      39: {
        /* n:"BrtName", */
        f: parse_BrtName
      },
      /*::[*/
      40: {
        /* n:"BrtIndexRowBlock" */
      },
      /*::[*/
      42: {
        /* n:"BrtIndexBlock" */
      },
      /*::[*/
      43: {
        /* n:"BrtFont", */
        f: parse_BrtFont
      },
      /*::[*/
      44: {
        /* n:"BrtFmt", */
        f: parse_BrtFmt
      },
      /*::[*/
      45: {
        /* n:"BrtFill", */
        f: parse_BrtFill
      },
      /*::[*/
      46: {
        /* n:"BrtBorder", */
        f: parse_BrtBorder
      },
      /*::[*/
      47: {
        /* n:"BrtXF", */
        f: parse_BrtXF
      },
      /*::[*/
      48: {
        /* n:"BrtStyle" */
      },
      /*::[*/
      49: {
        /* n:"BrtCellMeta", */
        f: parse_Int32LE
      },
      /*::[*/
      50: {
        /* n:"BrtValueMeta" */
      },
      /*::[*/
      51: {
        /* n:"BrtMdb" */
        f: parse_BrtMdb
      },
      /*::[*/
      52: {
        /* n:"BrtBeginFmd", */
        T: 1
      },
      /*::[*/
      53: {
        /* n:"BrtEndFmd", */
        T: -1
      },
      /*::[*/
      54: {
        /* n:"BrtBeginMdx", */
        T: 1
      },
      /*::[*/
      55: {
        /* n:"BrtEndMdx", */
        T: -1
      },
      /*::[*/
      56: {
        /* n:"BrtBeginMdxTuple", */
        T: 1
      },
      /*::[*/
      57: {
        /* n:"BrtEndMdxTuple", */
        T: -1
      },
      /*::[*/
      58: {
        /* n:"BrtMdxMbrIstr" */
      },
      /*::[*/
      59: {
        /* n:"BrtStr" */
      },
      /*::[*/
      60: {
        /* n:"BrtColInfo", */
        f: parse_ColInfo
      },
      /*::[*/
      62: {
        /* n:"BrtCellRString", */
        f: parse_BrtCellRString
      },
      /*::[*/
      63: {
        /* n:"BrtCalcChainItem$", */
        f: parse_BrtCalcChainItem$
      },
      /*::[*/
      64: {
        /* n:"BrtDVal", */
        f: parse_BrtDVal
      },
      /*::[*/
      65: {
        /* n:"BrtSxvcellNum" */
      },
      /*::[*/
      66: {
        /* n:"BrtSxvcellStr" */
      },
      /*::[*/
      67: {
        /* n:"BrtSxvcellBool" */
      },
      /*::[*/
      68: {
        /* n:"BrtSxvcellErr" */
      },
      /*::[*/
      69: {
        /* n:"BrtSxvcellDate" */
      },
      /*::[*/
      70: {
        /* n:"BrtSxvcellNil" */
      },
      /*::[*/
      128: {
        /* n:"BrtFileVersion" */
      },
      /*::[*/
      129: {
        /* n:"BrtBeginSheet", */
        T: 1
      },
      /*::[*/
      130: {
        /* n:"BrtEndSheet", */
        T: -1
      },
      /*::[*/
      131: {
        /* n:"BrtBeginBook", */
        T: 1,
        f: parsenoop,
        p: 0
      },
      /*::[*/
      132: {
        /* n:"BrtEndBook", */
        T: -1
      },
      /*::[*/
      133: {
        /* n:"BrtBeginWsViews", */
        T: 1
      },
      /*::[*/
      134: {
        /* n:"BrtEndWsViews", */
        T: -1
      },
      /*::[*/
      135: {
        /* n:"BrtBeginBookViews", */
        T: 1
      },
      /*::[*/
      136: {
        /* n:"BrtEndBookViews", */
        T: -1
      },
      /*::[*/
      137: {
        /* n:"BrtBeginWsView", */
        T: 1,
        f: parse_BrtBeginWsView
      },
      /*::[*/
      138: {
        /* n:"BrtEndWsView", */
        T: -1
      },
      /*::[*/
      139: {
        /* n:"BrtBeginCsViews", */
        T: 1
      },
      /*::[*/
      140: {
        /* n:"BrtEndCsViews", */
        T: -1
      },
      /*::[*/
      141: {
        /* n:"BrtBeginCsView", */
        T: 1
      },
      /*::[*/
      142: {
        /* n:"BrtEndCsView", */
        T: -1
      },
      /*::[*/
      143: {
        /* n:"BrtBeginBundleShs", */
        T: 1
      },
      /*::[*/
      144: {
        /* n:"BrtEndBundleShs", */
        T: -1
      },
      /*::[*/
      145: {
        /* n:"BrtBeginSheetData", */
        T: 1
      },
      /*::[*/
      146: {
        /* n:"BrtEndSheetData", */
        T: -1
      },
      /*::[*/
      147: {
        /* n:"BrtWsProp", */
        f: parse_BrtWsProp
      },
      /*::[*/
      148: {
        /* n:"BrtWsDim", */
        f: parse_BrtWsDim,
        p: 16
      },
      /*::[*/
      151: {
        /* n:"BrtPane", */
        f: parse_BrtPane
      },
      /*::[*/
      152: {
        /* n:"BrtSel" */
      },
      /*::[*/
      153: {
        /* n:"BrtWbProp", */
        f: parse_BrtWbProp
      },
      /*::[*/
      154: {
        /* n:"BrtWbFactoid" */
      },
      /*::[*/
      155: {
        /* n:"BrtFileRecover" */
      },
      /*::[*/
      156: {
        /* n:"BrtBundleSh", */
        f: parse_BrtBundleSh
      },
      /*::[*/
      157: {
        /* n:"BrtCalcProp" */
      },
      /*::[*/
      158: {
        /* n:"BrtBookView" */
      },
      /*::[*/
      159: {
        /* n:"BrtBeginSst", */
        T: 1,
        f: parse_BrtBeginSst
      },
      /*::[*/
      160: {
        /* n:"BrtEndSst", */
        T: -1
      },
      /*::[*/
      161: {
        /* n:"BrtBeginAFilter", */
        T: 1,
        f: parse_UncheckedRfX
      },
      /*::[*/
      162: {
        /* n:"BrtEndAFilter", */
        T: -1
      },
      /*::[*/
      163: {
        /* n:"BrtBeginFilterColumn", */
        T: 1
      },
      /*::[*/
      164: {
        /* n:"BrtEndFilterColumn", */
        T: -1
      },
      /*::[*/
      165: {
        /* n:"BrtBeginFilters", */
        T: 1
      },
      /*::[*/
      166: {
        /* n:"BrtEndFilters", */
        T: -1
      },
      /*::[*/
      167: {
        /* n:"BrtFilter" */
      },
      /*::[*/
      168: {
        /* n:"BrtColorFilter" */
      },
      /*::[*/
      169: {
        /* n:"BrtIconFilter" */
      },
      /*::[*/
      170: {
        /* n:"BrtTop10Filter" */
      },
      /*::[*/
      171: {
        /* n:"BrtDynamicFilter" */
      },
      /*::[*/
      172: {
        /* n:"BrtBeginCustomFilters", */
        T: 1
      },
      /*::[*/
      173: {
        /* n:"BrtEndCustomFilters", */
        T: -1
      },
      /*::[*/
      174: {
        /* n:"BrtCustomFilter" */
      },
      /*::[*/
      175: {
        /* n:"BrtAFilterDateGroupItem" */
      },
      /*::[*/
      176: {
        /* n:"BrtMergeCell", */
        f: parse_BrtMergeCell
      },
      /*::[*/
      177: {
        /* n:"BrtBeginMergeCells", */
        T: 1
      },
      /*::[*/
      178: {
        /* n:"BrtEndMergeCells", */
        T: -1
      },
      /*::[*/
      179: {
        /* n:"BrtBeginPivotCacheDef", */
        T: 1
      },
      /*::[*/
      180: {
        /* n:"BrtEndPivotCacheDef", */
        T: -1
      },
      /*::[*/
      181: {
        /* n:"BrtBeginPCDFields", */
        T: 1
      },
      /*::[*/
      182: {
        /* n:"BrtEndPCDFields", */
        T: -1
      },
      /*::[*/
      183: {
        /* n:"BrtBeginPCDField", */
        T: 1
      },
      /*::[*/
      184: {
        /* n:"BrtEndPCDField", */
        T: -1
      },
      /*::[*/
      185: {
        /* n:"BrtBeginPCDSource", */
        T: 1
      },
      /*::[*/
      186: {
        /* n:"BrtEndPCDSource", */
        T: -1
      },
      /*::[*/
      187: {
        /* n:"BrtBeginPCDSRange", */
        T: 1
      },
      /*::[*/
      188: {
        /* n:"BrtEndPCDSRange", */
        T: -1
      },
      /*::[*/
      189: {
        /* n:"BrtBeginPCDFAtbl", */
        T: 1
      },
      /*::[*/
      190: {
        /* n:"BrtEndPCDFAtbl", */
        T: -1
      },
      /*::[*/
      191: {
        /* n:"BrtBeginPCDIRun", */
        T: 1
      },
      /*::[*/
      192: {
        /* n:"BrtEndPCDIRun", */
        T: -1
      },
      /*::[*/
      193: {
        /* n:"BrtBeginPivotCacheRecords", */
        T: 1
      },
      /*::[*/
      194: {
        /* n:"BrtEndPivotCacheRecords", */
        T: -1
      },
      /*::[*/
      195: {
        /* n:"BrtBeginPCDHierarchies", */
        T: 1
      },
      /*::[*/
      196: {
        /* n:"BrtEndPCDHierarchies", */
        T: -1
      },
      /*::[*/
      197: {
        /* n:"BrtBeginPCDHierarchy", */
        T: 1
      },
      /*::[*/
      198: {
        /* n:"BrtEndPCDHierarchy", */
        T: -1
      },
      /*::[*/
      199: {
        /* n:"BrtBeginPCDHFieldsUsage", */
        T: 1
      },
      /*::[*/
      200: {
        /* n:"BrtEndPCDHFieldsUsage", */
        T: -1
      },
      /*::[*/
      201: {
        /* n:"BrtBeginExtConnection", */
        T: 1
      },
      /*::[*/
      202: {
        /* n:"BrtEndExtConnection", */
        T: -1
      },
      /*::[*/
      203: {
        /* n:"BrtBeginECDbProps", */
        T: 1
      },
      /*::[*/
      204: {
        /* n:"BrtEndECDbProps", */
        T: -1
      },
      /*::[*/
      205: {
        /* n:"BrtBeginECOlapProps", */
        T: 1
      },
      /*::[*/
      206: {
        /* n:"BrtEndECOlapProps", */
        T: -1
      },
      /*::[*/
      207: {
        /* n:"BrtBeginPCDSConsol", */
        T: 1
      },
      /*::[*/
      208: {
        /* n:"BrtEndPCDSConsol", */
        T: -1
      },
      /*::[*/
      209: {
        /* n:"BrtBeginPCDSCPages", */
        T: 1
      },
      /*::[*/
      210: {
        /* n:"BrtEndPCDSCPages", */
        T: -1
      },
      /*::[*/
      211: {
        /* n:"BrtBeginPCDSCPage", */
        T: 1
      },
      /*::[*/
      212: {
        /* n:"BrtEndPCDSCPage", */
        T: -1
      },
      /*::[*/
      213: {
        /* n:"BrtBeginPCDSCPItem", */
        T: 1
      },
      /*::[*/
      214: {
        /* n:"BrtEndPCDSCPItem", */
        T: -1
      },
      /*::[*/
      215: {
        /* n:"BrtBeginPCDSCSets", */
        T: 1
      },
      /*::[*/
      216: {
        /* n:"BrtEndPCDSCSets", */
        T: -1
      },
      /*::[*/
      217: {
        /* n:"BrtBeginPCDSCSet", */
        T: 1
      },
      /*::[*/
      218: {
        /* n:"BrtEndPCDSCSet", */
        T: -1
      },
      /*::[*/
      219: {
        /* n:"BrtBeginPCDFGroup", */
        T: 1
      },
      /*::[*/
      220: {
        /* n:"BrtEndPCDFGroup", */
        T: -1
      },
      /*::[*/
      221: {
        /* n:"BrtBeginPCDFGItems", */
        T: 1
      },
      /*::[*/
      222: {
        /* n:"BrtEndPCDFGItems", */
        T: -1
      },
      /*::[*/
      223: {
        /* n:"BrtBeginPCDFGRange", */
        T: 1
      },
      /*::[*/
      224: {
        /* n:"BrtEndPCDFGRange", */
        T: -1
      },
      /*::[*/
      225: {
        /* n:"BrtBeginPCDFGDiscrete", */
        T: 1
      },
      /*::[*/
      226: {
        /* n:"BrtEndPCDFGDiscrete", */
        T: -1
      },
      /*::[*/
      227: {
        /* n:"BrtBeginPCDSDTupleCache", */
        T: 1
      },
      /*::[*/
      228: {
        /* n:"BrtEndPCDSDTupleCache", */
        T: -1
      },
      /*::[*/
      229: {
        /* n:"BrtBeginPCDSDTCEntries", */
        T: 1
      },
      /*::[*/
      230: {
        /* n:"BrtEndPCDSDTCEntries", */
        T: -1
      },
      /*::[*/
      231: {
        /* n:"BrtBeginPCDSDTCEMembers", */
        T: 1
      },
      /*::[*/
      232: {
        /* n:"BrtEndPCDSDTCEMembers", */
        T: -1
      },
      /*::[*/
      233: {
        /* n:"BrtBeginPCDSDTCEMember", */
        T: 1
      },
      /*::[*/
      234: {
        /* n:"BrtEndPCDSDTCEMember", */
        T: -1
      },
      /*::[*/
      235: {
        /* n:"BrtBeginPCDSDTCQueries", */
        T: 1
      },
      /*::[*/
      236: {
        /* n:"BrtEndPCDSDTCQueries", */
        T: -1
      },
      /*::[*/
      237: {
        /* n:"BrtBeginPCDSDTCQuery", */
        T: 1
      },
      /*::[*/
      238: {
        /* n:"BrtEndPCDSDTCQuery", */
        T: -1
      },
      /*::[*/
      239: {
        /* n:"BrtBeginPCDSDTCSets", */
        T: 1
      },
      /*::[*/
      240: {
        /* n:"BrtEndPCDSDTCSets", */
        T: -1
      },
      /*::[*/
      241: {
        /* n:"BrtBeginPCDSDTCSet", */
        T: 1
      },
      /*::[*/
      242: {
        /* n:"BrtEndPCDSDTCSet", */
        T: -1
      },
      /*::[*/
      243: {
        /* n:"BrtBeginPCDCalcItems", */
        T: 1
      },
      /*::[*/
      244: {
        /* n:"BrtEndPCDCalcItems", */
        T: -1
      },
      /*::[*/
      245: {
        /* n:"BrtBeginPCDCalcItem", */
        T: 1
      },
      /*::[*/
      246: {
        /* n:"BrtEndPCDCalcItem", */
        T: -1
      },
      /*::[*/
      247: {
        /* n:"BrtBeginPRule", */
        T: 1
      },
      /*::[*/
      248: {
        /* n:"BrtEndPRule", */
        T: -1
      },
      /*::[*/
      249: {
        /* n:"BrtBeginPRFilters", */
        T: 1
      },
      /*::[*/
      250: {
        /* n:"BrtEndPRFilters", */
        T: -1
      },
      /*::[*/
      251: {
        /* n:"BrtBeginPRFilter", */
        T: 1
      },
      /*::[*/
      252: {
        /* n:"BrtEndPRFilter", */
        T: -1
      },
      /*::[*/
      253: {
        /* n:"BrtBeginPNames", */
        T: 1
      },
      /*::[*/
      254: {
        /* n:"BrtEndPNames", */
        T: -1
      },
      /*::[*/
      255: {
        /* n:"BrtBeginPName", */
        T: 1
      },
      /*::[*/
      256: {
        /* n:"BrtEndPName", */
        T: -1
      },
      /*::[*/
      257: {
        /* n:"BrtBeginPNPairs", */
        T: 1
      },
      /*::[*/
      258: {
        /* n:"BrtEndPNPairs", */
        T: -1
      },
      /*::[*/
      259: {
        /* n:"BrtBeginPNPair", */
        T: 1
      },
      /*::[*/
      260: {
        /* n:"BrtEndPNPair", */
        T: -1
      },
      /*::[*/
      261: {
        /* n:"BrtBeginECWebProps", */
        T: 1
      },
      /*::[*/
      262: {
        /* n:"BrtEndECWebProps", */
        T: -1
      },
      /*::[*/
      263: {
        /* n:"BrtBeginEcWpTables", */
        T: 1
      },
      /*::[*/
      264: {
        /* n:"BrtEndECWPTables", */
        T: -1
      },
      /*::[*/
      265: {
        /* n:"BrtBeginECParams", */
        T: 1
      },
      /*::[*/
      266: {
        /* n:"BrtEndECParams", */
        T: -1
      },
      /*::[*/
      267: {
        /* n:"BrtBeginECParam", */
        T: 1
      },
      /*::[*/
      268: {
        /* n:"BrtEndECParam", */
        T: -1
      },
      /*::[*/
      269: {
        /* n:"BrtBeginPCDKPIs", */
        T: 1
      },
      /*::[*/
      270: {
        /* n:"BrtEndPCDKPIs", */
        T: -1
      },
      /*::[*/
      271: {
        /* n:"BrtBeginPCDKPI", */
        T: 1
      },
      /*::[*/
      272: {
        /* n:"BrtEndPCDKPI", */
        T: -1
      },
      /*::[*/
      273: {
        /* n:"BrtBeginDims", */
        T: 1
      },
      /*::[*/
      274: {
        /* n:"BrtEndDims", */
        T: -1
      },
      /*::[*/
      275: {
        /* n:"BrtBeginDim", */
        T: 1
      },
      /*::[*/
      276: {
        /* n:"BrtEndDim", */
        T: -1
      },
      /*::[*/
      277: {
        /* n:"BrtIndexPartEnd" */
      },
      /*::[*/
      278: {
        /* n:"BrtBeginStyleSheet", */
        T: 1
      },
      /*::[*/
      279: {
        /* n:"BrtEndStyleSheet", */
        T: -1
      },
      /*::[*/
      280: {
        /* n:"BrtBeginSXView", */
        T: 1
      },
      /*::[*/
      281: {
        /* n:"BrtEndSXVI", */
        T: -1
      },
      /*::[*/
      282: {
        /* n:"BrtBeginSXVI", */
        T: 1
      },
      /*::[*/
      283: {
        /* n:"BrtBeginSXVIs", */
        T: 1
      },
      /*::[*/
      284: {
        /* n:"BrtEndSXVIs", */
        T: -1
      },
      /*::[*/
      285: {
        /* n:"BrtBeginSXVD", */
        T: 1
      },
      /*::[*/
      286: {
        /* n:"BrtEndSXVD", */
        T: -1
      },
      /*::[*/
      287: {
        /* n:"BrtBeginSXVDs", */
        T: 1
      },
      /*::[*/
      288: {
        /* n:"BrtEndSXVDs", */
        T: -1
      },
      /*::[*/
      289: {
        /* n:"BrtBeginSXPI", */
        T: 1
      },
      /*::[*/
      290: {
        /* n:"BrtEndSXPI", */
        T: -1
      },
      /*::[*/
      291: {
        /* n:"BrtBeginSXPIs", */
        T: 1
      },
      /*::[*/
      292: {
        /* n:"BrtEndSXPIs", */
        T: -1
      },
      /*::[*/
      293: {
        /* n:"BrtBeginSXDI", */
        T: 1
      },
      /*::[*/
      294: {
        /* n:"BrtEndSXDI", */
        T: -1
      },
      /*::[*/
      295: {
        /* n:"BrtBeginSXDIs", */
        T: 1
      },
      /*::[*/
      296: {
        /* n:"BrtEndSXDIs", */
        T: -1
      },
      /*::[*/
      297: {
        /* n:"BrtBeginSXLI", */
        T: 1
      },
      /*::[*/
      298: {
        /* n:"BrtEndSXLI", */
        T: -1
      },
      /*::[*/
      299: {
        /* n:"BrtBeginSXLIRws", */
        T: 1
      },
      /*::[*/
      300: {
        /* n:"BrtEndSXLIRws", */
        T: -1
      },
      /*::[*/
      301: {
        /* n:"BrtBeginSXLICols", */
        T: 1
      },
      /*::[*/
      302: {
        /* n:"BrtEndSXLICols", */
        T: -1
      },
      /*::[*/
      303: {
        /* n:"BrtBeginSXFormat", */
        T: 1
      },
      /*::[*/
      304: {
        /* n:"BrtEndSXFormat", */
        T: -1
      },
      /*::[*/
      305: {
        /* n:"BrtBeginSXFormats", */
        T: 1
      },
      /*::[*/
      306: {
        /* n:"BrtEndSxFormats", */
        T: -1
      },
      /*::[*/
      307: {
        /* n:"BrtBeginSxSelect", */
        T: 1
      },
      /*::[*/
      308: {
        /* n:"BrtEndSxSelect", */
        T: -1
      },
      /*::[*/
      309: {
        /* n:"BrtBeginISXVDRws", */
        T: 1
      },
      /*::[*/
      310: {
        /* n:"BrtEndISXVDRws", */
        T: -1
      },
      /*::[*/
      311: {
        /* n:"BrtBeginISXVDCols", */
        T: 1
      },
      /*::[*/
      312: {
        /* n:"BrtEndISXVDCols", */
        T: -1
      },
      /*::[*/
      313: {
        /* n:"BrtEndSXLocation", */
        T: -1
      },
      /*::[*/
      314: {
        /* n:"BrtBeginSXLocation", */
        T: 1
      },
      /*::[*/
      315: {
        /* n:"BrtEndSXView", */
        T: -1
      },
      /*::[*/
      316: {
        /* n:"BrtBeginSXTHs", */
        T: 1
      },
      /*::[*/
      317: {
        /* n:"BrtEndSXTHs", */
        T: -1
      },
      /*::[*/
      318: {
        /* n:"BrtBeginSXTH", */
        T: 1
      },
      /*::[*/
      319: {
        /* n:"BrtEndSXTH", */
        T: -1
      },
      /*::[*/
      320: {
        /* n:"BrtBeginISXTHRws", */
        T: 1
      },
      /*::[*/
      321: {
        /* n:"BrtEndISXTHRws", */
        T: -1
      },
      /*::[*/
      322: {
        /* n:"BrtBeginISXTHCols", */
        T: 1
      },
      /*::[*/
      323: {
        /* n:"BrtEndISXTHCols", */
        T: -1
      },
      /*::[*/
      324: {
        /* n:"BrtBeginSXTDMPS", */
        T: 1
      },
      /*::[*/
      325: {
        /* n:"BrtEndSXTDMPs", */
        T: -1
      },
      /*::[*/
      326: {
        /* n:"BrtBeginSXTDMP", */
        T: 1
      },
      /*::[*/
      327: {
        /* n:"BrtEndSXTDMP", */
        T: -1
      },
      /*::[*/
      328: {
        /* n:"BrtBeginSXTHItems", */
        T: 1
      },
      /*::[*/
      329: {
        /* n:"BrtEndSXTHItems", */
        T: -1
      },
      /*::[*/
      330: {
        /* n:"BrtBeginSXTHItem", */
        T: 1
      },
      /*::[*/
      331: {
        /* n:"BrtEndSXTHItem", */
        T: -1
      },
      /*::[*/
      332: {
        /* n:"BrtBeginMetadata", */
        T: 1
      },
      /*::[*/
      333: {
        /* n:"BrtEndMetadata", */
        T: -1
      },
      /*::[*/
      334: {
        /* n:"BrtBeginEsmdtinfo", */
        T: 1
      },
      /*::[*/
      335: {
        /* n:"BrtMdtinfo", */
        f: parse_BrtMdtinfo
      },
      /*::[*/
      336: {
        /* n:"BrtEndEsmdtinfo", */
        T: -1
      },
      /*::[*/
      337: {
        /* n:"BrtBeginEsmdb", */
        f: parse_BrtBeginEsmdb,
        T: 1
      },
      /*::[*/
      338: {
        /* n:"BrtEndEsmdb", */
        T: -1
      },
      /*::[*/
      339: {
        /* n:"BrtBeginEsfmd", */
        T: 1
      },
      /*::[*/
      340: {
        /* n:"BrtEndEsfmd", */
        T: -1
      },
      /*::[*/
      341: {
        /* n:"BrtBeginSingleCells", */
        T: 1
      },
      /*::[*/
      342: {
        /* n:"BrtEndSingleCells", */
        T: -1
      },
      /*::[*/
      343: {
        /* n:"BrtBeginList", */
        T: 1
      },
      /*::[*/
      344: {
        /* n:"BrtEndList", */
        T: -1
      },
      /*::[*/
      345: {
        /* n:"BrtBeginListCols", */
        T: 1
      },
      /*::[*/
      346: {
        /* n:"BrtEndListCols", */
        T: -1
      },
      /*::[*/
      347: {
        /* n:"BrtBeginListCol", */
        T: 1
      },
      /*::[*/
      348: {
        /* n:"BrtEndListCol", */
        T: -1
      },
      /*::[*/
      349: {
        /* n:"BrtBeginListXmlCPr", */
        T: 1
      },
      /*::[*/
      350: {
        /* n:"BrtEndListXmlCPr", */
        T: -1
      },
      /*::[*/
      351: {
        /* n:"BrtListCCFmla" */
      },
      /*::[*/
      352: {
        /* n:"BrtListTrFmla" */
      },
      /*::[*/
      353: {
        /* n:"BrtBeginExternals", */
        T: 1
      },
      /*::[*/
      354: {
        /* n:"BrtEndExternals", */
        T: -1
      },
      /*::[*/
      355: {
        /* n:"BrtSupBookSrc", */
        f: parse_RelID
      },
      /*::[*/
      357: {
        /* n:"BrtSupSelf" */
      },
      /*::[*/
      358: {
        /* n:"BrtSupSame" */
      },
      /*::[*/
      359: {
        /* n:"BrtSupTabs" */
      },
      /*::[*/
      360: {
        /* n:"BrtBeginSupBook", */
        T: 1
      },
      /*::[*/
      361: {
        /* n:"BrtPlaceholderName" */
      },
      /*::[*/
      362: {
        /* n:"BrtExternSheet", */
        f: parse_ExternSheet
      },
      /*::[*/
      363: {
        /* n:"BrtExternTableStart" */
      },
      /*::[*/
      364: {
        /* n:"BrtExternTableEnd" */
      },
      /*::[*/
      366: {
        /* n:"BrtExternRowHdr" */
      },
      /*::[*/
      367: {
        /* n:"BrtExternCellBlank" */
      },
      /*::[*/
      368: {
        /* n:"BrtExternCellReal" */
      },
      /*::[*/
      369: {
        /* n:"BrtExternCellBool" */
      },
      /*::[*/
      370: {
        /* n:"BrtExternCellError" */
      },
      /*::[*/
      371: {
        /* n:"BrtExternCellString" */
      },
      /*::[*/
      372: {
        /* n:"BrtBeginEsmdx", */
        T: 1
      },
      /*::[*/
      373: {
        /* n:"BrtEndEsmdx", */
        T: -1
      },
      /*::[*/
      374: {
        /* n:"BrtBeginMdxSet", */
        T: 1
      },
      /*::[*/
      375: {
        /* n:"BrtEndMdxSet", */
        T: -1
      },
      /*::[*/
      376: {
        /* n:"BrtBeginMdxMbrProp", */
        T: 1
      },
      /*::[*/
      377: {
        /* n:"BrtEndMdxMbrProp", */
        T: -1
      },
      /*::[*/
      378: {
        /* n:"BrtBeginMdxKPI", */
        T: 1
      },
      /*::[*/
      379: {
        /* n:"BrtEndMdxKPI", */
        T: -1
      },
      /*::[*/
      380: {
        /* n:"BrtBeginEsstr", */
        T: 1
      },
      /*::[*/
      381: {
        /* n:"BrtEndEsstr", */
        T: -1
      },
      /*::[*/
      382: {
        /* n:"BrtBeginPRFItem", */
        T: 1
      },
      /*::[*/
      383: {
        /* n:"BrtEndPRFItem", */
        T: -1
      },
      /*::[*/
      384: {
        /* n:"BrtBeginPivotCacheIDs", */
        T: 1
      },
      /*::[*/
      385: {
        /* n:"BrtEndPivotCacheIDs", */
        T: -1
      },
      /*::[*/
      386: {
        /* n:"BrtBeginPivotCacheID", */
        T: 1
      },
      /*::[*/
      387: {
        /* n:"BrtEndPivotCacheID", */
        T: -1
      },
      /*::[*/
      388: {
        /* n:"BrtBeginISXVIs", */
        T: 1
      },
      /*::[*/
      389: {
        /* n:"BrtEndISXVIs", */
        T: -1
      },
      /*::[*/
      390: {
        /* n:"BrtBeginColInfos", */
        T: 1
      },
      /*::[*/
      391: {
        /* n:"BrtEndColInfos", */
        T: -1
      },
      /*::[*/
      392: {
        /* n:"BrtBeginRwBrk", */
        T: 1
      },
      /*::[*/
      393: {
        /* n:"BrtEndRwBrk", */
        T: -1
      },
      /*::[*/
      394: {
        /* n:"BrtBeginColBrk", */
        T: 1
      },
      /*::[*/
      395: {
        /* n:"BrtEndColBrk", */
        T: -1
      },
      /*::[*/
      396: {
        /* n:"BrtBrk" */
      },
      /*::[*/
      397: {
        /* n:"BrtUserBookView" */
      },
      /*::[*/
      398: {
        /* n:"BrtInfo" */
      },
      /*::[*/
      399: {
        /* n:"BrtCUsr" */
      },
      /*::[*/
      400: {
        /* n:"BrtUsr" */
      },
      /*::[*/
      401: {
        /* n:"BrtBeginUsers", */
        T: 1
      },
      /*::[*/
      403: {
        /* n:"BrtEOF" */
      },
      /*::[*/
      404: {
        /* n:"BrtUCR" */
      },
      /*::[*/
      405: {
        /* n:"BrtRRInsDel" */
      },
      /*::[*/
      406: {
        /* n:"BrtRREndInsDel" */
      },
      /*::[*/
      407: {
        /* n:"BrtRRMove" */
      },
      /*::[*/
      408: {
        /* n:"BrtRREndMove" */
      },
      /*::[*/
      409: {
        /* n:"BrtRRChgCell" */
      },
      /*::[*/
      410: {
        /* n:"BrtRREndChgCell" */
      },
      /*::[*/
      411: {
        /* n:"BrtRRHeader" */
      },
      /*::[*/
      412: {
        /* n:"BrtRRUserView" */
      },
      /*::[*/
      413: {
        /* n:"BrtRRRenSheet" */
      },
      /*::[*/
      414: {
        /* n:"BrtRRInsertSh" */
      },
      /*::[*/
      415: {
        /* n:"BrtRRDefName" */
      },
      /*::[*/
      416: {
        /* n:"BrtRRNote" */
      },
      /*::[*/
      417: {
        /* n:"BrtRRConflict" */
      },
      /*::[*/
      418: {
        /* n:"BrtRRTQSIF" */
      },
      /*::[*/
      419: {
        /* n:"BrtRRFormat" */
      },
      /*::[*/
      420: {
        /* n:"BrtRREndFormat" */
      },
      /*::[*/
      421: {
        /* n:"BrtRRAutoFmt" */
      },
      /*::[*/
      422: {
        /* n:"BrtBeginUserShViews", */
        T: 1
      },
      /*::[*/
      423: {
        /* n:"BrtBeginUserShView", */
        T: 1
      },
      /*::[*/
      424: {
        /* n:"BrtEndUserShView", */
        T: -1
      },
      /*::[*/
      425: {
        /* n:"BrtEndUserShViews", */
        T: -1
      },
      /*::[*/
      426: {
        /* n:"BrtArrFmla", */
        f: parse_BrtArrFmla
      },
      /*::[*/
      427: {
        /* n:"BrtShrFmla", */
        f: parse_BrtShrFmla
      },
      /*::[*/
      428: {
        /* n:"BrtTable" */
      },
      /*::[*/
      429: {
        /* n:"BrtBeginExtConnections", */
        T: 1
      },
      /*::[*/
      430: {
        /* n:"BrtEndExtConnections", */
        T: -1
      },
      /*::[*/
      431: {
        /* n:"BrtBeginPCDCalcMems", */
        T: 1
      },
      /*::[*/
      432: {
        /* n:"BrtEndPCDCalcMems", */
        T: -1
      },
      /*::[*/
      433: {
        /* n:"BrtBeginPCDCalcMem", */
        T: 1
      },
      /*::[*/
      434: {
        /* n:"BrtEndPCDCalcMem", */
        T: -1
      },
      /*::[*/
      435: {
        /* n:"BrtBeginPCDHGLevels", */
        T: 1
      },
      /*::[*/
      436: {
        /* n:"BrtEndPCDHGLevels", */
        T: -1
      },
      /*::[*/
      437: {
        /* n:"BrtBeginPCDHGLevel", */
        T: 1
      },
      /*::[*/
      438: {
        /* n:"BrtEndPCDHGLevel", */
        T: -1
      },
      /*::[*/
      439: {
        /* n:"BrtBeginPCDHGLGroups", */
        T: 1
      },
      /*::[*/
      440: {
        /* n:"BrtEndPCDHGLGroups", */
        T: -1
      },
      /*::[*/
      441: {
        /* n:"BrtBeginPCDHGLGroup", */
        T: 1
      },
      /*::[*/
      442: {
        /* n:"BrtEndPCDHGLGroup", */
        T: -1
      },
      /*::[*/
      443: {
        /* n:"BrtBeginPCDHGLGMembers", */
        T: 1
      },
      /*::[*/
      444: {
        /* n:"BrtEndPCDHGLGMembers", */
        T: -1
      },
      /*::[*/
      445: {
        /* n:"BrtBeginPCDHGLGMember", */
        T: 1
      },
      /*::[*/
      446: {
        /* n:"BrtEndPCDHGLGMember", */
        T: -1
      },
      /*::[*/
      447: {
        /* n:"BrtBeginQSI", */
        T: 1
      },
      /*::[*/
      448: {
        /* n:"BrtEndQSI", */
        T: -1
      },
      /*::[*/
      449: {
        /* n:"BrtBeginQSIR", */
        T: 1
      },
      /*::[*/
      450: {
        /* n:"BrtEndQSIR", */
        T: -1
      },
      /*::[*/
      451: {
        /* n:"BrtBeginDeletedNames", */
        T: 1
      },
      /*::[*/
      452: {
        /* n:"BrtEndDeletedNames", */
        T: -1
      },
      /*::[*/
      453: {
        /* n:"BrtBeginDeletedName", */
        T: 1
      },
      /*::[*/
      454: {
        /* n:"BrtEndDeletedName", */
        T: -1
      },
      /*::[*/
      455: {
        /* n:"BrtBeginQSIFs", */
        T: 1
      },
      /*::[*/
      456: {
        /* n:"BrtEndQSIFs", */
        T: -1
      },
      /*::[*/
      457: {
        /* n:"BrtBeginQSIF", */
        T: 1
      },
      /*::[*/
      458: {
        /* n:"BrtEndQSIF", */
        T: -1
      },
      /*::[*/
      459: {
        /* n:"BrtBeginAutoSortScope", */
        T: 1
      },
      /*::[*/
      460: {
        /* n:"BrtEndAutoSortScope", */
        T: -1
      },
      /*::[*/
      461: {
        /* n:"BrtBeginConditionalFormatting", */
        T: 1
      },
      /*::[*/
      462: {
        /* n:"BrtEndConditionalFormatting", */
        T: -1
      },
      /*::[*/
      463: {
        /* n:"BrtBeginCFRule", */
        T: 1
      },
      /*::[*/
      464: {
        /* n:"BrtEndCFRule", */
        T: -1
      },
      /*::[*/
      465: {
        /* n:"BrtBeginIconSet", */
        T: 1
      },
      /*::[*/
      466: {
        /* n:"BrtEndIconSet", */
        T: -1
      },
      /*::[*/
      467: {
        /* n:"BrtBeginDatabar", */
        T: 1
      },
      /*::[*/
      468: {
        /* n:"BrtEndDatabar", */
        T: -1
      },
      /*::[*/
      469: {
        /* n:"BrtBeginColorScale", */
        T: 1
      },
      /*::[*/
      470: {
        /* n:"BrtEndColorScale", */
        T: -1
      },
      /*::[*/
      471: {
        /* n:"BrtCFVO" */
      },
      /*::[*/
      472: {
        /* n:"BrtExternValueMeta" */
      },
      /*::[*/
      473: {
        /* n:"BrtBeginColorPalette", */
        T: 1
      },
      /*::[*/
      474: {
        /* n:"BrtEndColorPalette", */
        T: -1
      },
      /*::[*/
      475: {
        /* n:"BrtIndexedColor" */
      },
      /*::[*/
      476: {
        /* n:"BrtMargins", */
        f: parse_BrtMargins
      },
      /*::[*/
      477: {
        /* n:"BrtPrintOptions" */
      },
      /*::[*/
      478: {
        /* n:"BrtPageSetup" */
      },
      /*::[*/
      479: {
        /* n:"BrtBeginHeaderFooter", */
        T: 1
      },
      /*::[*/
      480: {
        /* n:"BrtEndHeaderFooter", */
        T: -1
      },
      /*::[*/
      481: {
        /* n:"BrtBeginSXCrtFormat", */
        T: 1
      },
      /*::[*/
      482: {
        /* n:"BrtEndSXCrtFormat", */
        T: -1
      },
      /*::[*/
      483: {
        /* n:"BrtBeginSXCrtFormats", */
        T: 1
      },
      /*::[*/
      484: {
        /* n:"BrtEndSXCrtFormats", */
        T: -1
      },
      /*::[*/
      485: {
        /* n:"BrtWsFmtInfo", */
        f: parse_BrtWsFmtInfo
      },
      /*::[*/
      486: {
        /* n:"BrtBeginMgs", */
        T: 1
      },
      /*::[*/
      487: {
        /* n:"BrtEndMGs", */
        T: -1
      },
      /*::[*/
      488: {
        /* n:"BrtBeginMGMaps", */
        T: 1
      },
      /*::[*/
      489: {
        /* n:"BrtEndMGMaps", */
        T: -1
      },
      /*::[*/
      490: {
        /* n:"BrtBeginMG", */
        T: 1
      },
      /*::[*/
      491: {
        /* n:"BrtEndMG", */
        T: -1
      },
      /*::[*/
      492: {
        /* n:"BrtBeginMap", */
        T: 1
      },
      /*::[*/
      493: {
        /* n:"BrtEndMap", */
        T: -1
      },
      /*::[*/
      494: {
        /* n:"BrtHLink", */
        f: parse_BrtHLink
      },
      /*::[*/
      495: {
        /* n:"BrtBeginDCon", */
        T: 1
      },
      /*::[*/
      496: {
        /* n:"BrtEndDCon", */
        T: -1
      },
      /*::[*/
      497: {
        /* n:"BrtBeginDRefs", */
        T: 1
      },
      /*::[*/
      498: {
        /* n:"BrtEndDRefs", */
        T: -1
      },
      /*::[*/
      499: {
        /* n:"BrtDRef" */
      },
      /*::[*/
      500: {
        /* n:"BrtBeginScenMan", */
        T: 1
      },
      /*::[*/
      501: {
        /* n:"BrtEndScenMan", */
        T: -1
      },
      /*::[*/
      502: {
        /* n:"BrtBeginSct", */
        T: 1
      },
      /*::[*/
      503: {
        /* n:"BrtEndSct", */
        T: -1
      },
      /*::[*/
      504: {
        /* n:"BrtSlc" */
      },
      /*::[*/
      505: {
        /* n:"BrtBeginDXFs", */
        T: 1
      },
      /*::[*/
      506: {
        /* n:"BrtEndDXFs", */
        T: -1
      },
      /*::[*/
      507: {
        /* n:"BrtDXF" */
      },
      /*::[*/
      508: {
        /* n:"BrtBeginTableStyles", */
        T: 1
      },
      /*::[*/
      509: {
        /* n:"BrtEndTableStyles", */
        T: -1
      },
      /*::[*/
      510: {
        /* n:"BrtBeginTableStyle", */
        T: 1
      },
      /*::[*/
      511: {
        /* n:"BrtEndTableStyle", */
        T: -1
      },
      /*::[*/
      512: {
        /* n:"BrtTableStyleElement" */
      },
      /*::[*/
      513: {
        /* n:"BrtTableStyleClient" */
      },
      /*::[*/
      514: {
        /* n:"BrtBeginVolDeps", */
        T: 1
      },
      /*::[*/
      515: {
        /* n:"BrtEndVolDeps", */
        T: -1
      },
      /*::[*/
      516: {
        /* n:"BrtBeginVolType", */
        T: 1
      },
      /*::[*/
      517: {
        /* n:"BrtEndVolType", */
        T: -1
      },
      /*::[*/
      518: {
        /* n:"BrtBeginVolMain", */
        T: 1
      },
      /*::[*/
      519: {
        /* n:"BrtEndVolMain", */
        T: -1
      },
      /*::[*/
      520: {
        /* n:"BrtBeginVolTopic", */
        T: 1
      },
      /*::[*/
      521: {
        /* n:"BrtEndVolTopic", */
        T: -1
      },
      /*::[*/
      522: {
        /* n:"BrtVolSubtopic" */
      },
      /*::[*/
      523: {
        /* n:"BrtVolRef" */
      },
      /*::[*/
      524: {
        /* n:"BrtVolNum" */
      },
      /*::[*/
      525: {
        /* n:"BrtVolErr" */
      },
      /*::[*/
      526: {
        /* n:"BrtVolStr" */
      },
      /*::[*/
      527: {
        /* n:"BrtVolBool" */
      },
      /*::[*/
      528: {
        /* n:"BrtBeginCalcChain$", */
        T: 1
      },
      /*::[*/
      529: {
        /* n:"BrtEndCalcChain$", */
        T: -1
      },
      /*::[*/
      530: {
        /* n:"BrtBeginSortState", */
        T: 1
      },
      /*::[*/
      531: {
        /* n:"BrtEndSortState", */
        T: -1
      },
      /*::[*/
      532: {
        /* n:"BrtBeginSortCond", */
        T: 1
      },
      /*::[*/
      533: {
        /* n:"BrtEndSortCond", */
        T: -1
      },
      /*::[*/
      534: {
        /* n:"BrtBookProtection" */
      },
      /*::[*/
      535: {
        /* n:"BrtSheetProtection" */
      },
      /*::[*/
      536: {
        /* n:"BrtRangeProtection" */
      },
      /*::[*/
      537: {
        /* n:"BrtPhoneticInfo" */
      },
      /*::[*/
      538: {
        /* n:"BrtBeginECTxtWiz", */
        T: 1
      },
      /*::[*/
      539: {
        /* n:"BrtEndECTxtWiz", */
        T: -1
      },
      /*::[*/
      540: {
        /* n:"BrtBeginECTWFldInfoLst", */
        T: 1
      },
      /*::[*/
      541: {
        /* n:"BrtEndECTWFldInfoLst", */
        T: -1
      },
      /*::[*/
      542: {
        /* n:"BrtBeginECTwFldInfo", */
        T: 1
      },
      /*::[*/
      548: {
        /* n:"BrtFileSharing" */
      },
      /*::[*/
      549: {
        /* n:"BrtOleSize" */
      },
      /*::[*/
      550: {
        /* n:"BrtDrawing", */
        f: parse_RelID
      },
      /*::[*/
      551: {
        /* n:"BrtLegacyDrawing" */
      },
      /*::[*/
      552: {
        /* n:"BrtLegacyDrawingHF" */
      },
      /*::[*/
      553: {
        /* n:"BrtWebOpt" */
      },
      /*::[*/
      554: {
        /* n:"BrtBeginWebPubItems", */
        T: 1
      },
      /*::[*/
      555: {
        /* n:"BrtEndWebPubItems", */
        T: -1
      },
      /*::[*/
      556: {
        /* n:"BrtBeginWebPubItem", */
        T: 1
      },
      /*::[*/
      557: {
        /* n:"BrtEndWebPubItem", */
        T: -1
      },
      /*::[*/
      558: {
        /* n:"BrtBeginSXCondFmt", */
        T: 1
      },
      /*::[*/
      559: {
        /* n:"BrtEndSXCondFmt", */
        T: -1
      },
      /*::[*/
      560: {
        /* n:"BrtBeginSXCondFmts", */
        T: 1
      },
      /*::[*/
      561: {
        /* n:"BrtEndSXCondFmts", */
        T: -1
      },
      /*::[*/
      562: {
        /* n:"BrtBkHim" */
      },
      /*::[*/
      564: {
        /* n:"BrtColor" */
      },
      /*::[*/
      565: {
        /* n:"BrtBeginIndexedColors", */
        T: 1
      },
      /*::[*/
      566: {
        /* n:"BrtEndIndexedColors", */
        T: -1
      },
      /*::[*/
      569: {
        /* n:"BrtBeginMRUColors", */
        T: 1
      },
      /*::[*/
      570: {
        /* n:"BrtEndMRUColors", */
        T: -1
      },
      /*::[*/
      572: {
        /* n:"BrtMRUColor" */
      },
      /*::[*/
      573: {
        /* n:"BrtBeginDVals", */
        T: 1
      },
      /*::[*/
      574: {
        /* n:"BrtEndDVals", */
        T: -1
      },
      /*::[*/
      577: {
        /* n:"BrtSupNameStart" */
      },
      /*::[*/
      578: {
        /* n:"BrtSupNameValueStart" */
      },
      /*::[*/
      579: {
        /* n:"BrtSupNameValueEnd" */
      },
      /*::[*/
      580: {
        /* n:"BrtSupNameNum" */
      },
      /*::[*/
      581: {
        /* n:"BrtSupNameErr" */
      },
      /*::[*/
      582: {
        /* n:"BrtSupNameSt" */
      },
      /*::[*/
      583: {
        /* n:"BrtSupNameNil" */
      },
      /*::[*/
      584: {
        /* n:"BrtSupNameBool" */
      },
      /*::[*/
      585: {
        /* n:"BrtSupNameFmla" */
      },
      /*::[*/
      586: {
        /* n:"BrtSupNameBits" */
      },
      /*::[*/
      587: {
        /* n:"BrtSupNameEnd" */
      },
      /*::[*/
      588: {
        /* n:"BrtEndSupBook", */
        T: -1
      },
      /*::[*/
      589: {
        /* n:"BrtCellSmartTagProperty" */
      },
      /*::[*/
      590: {
        /* n:"BrtBeginCellSmartTag", */
        T: 1
      },
      /*::[*/
      591: {
        /* n:"BrtEndCellSmartTag", */
        T: -1
      },
      /*::[*/
      592: {
        /* n:"BrtBeginCellSmartTags", */
        T: 1
      },
      /*::[*/
      593: {
        /* n:"BrtEndCellSmartTags", */
        T: -1
      },
      /*::[*/
      594: {
        /* n:"BrtBeginSmartTags", */
        T: 1
      },
      /*::[*/
      595: {
        /* n:"BrtEndSmartTags", */
        T: -1
      },
      /*::[*/
      596: {
        /* n:"BrtSmartTagType" */
      },
      /*::[*/
      597: {
        /* n:"BrtBeginSmartTagTypes", */
        T: 1
      },
      /*::[*/
      598: {
        /* n:"BrtEndSmartTagTypes", */
        T: -1
      },
      /*::[*/
      599: {
        /* n:"BrtBeginSXFilters", */
        T: 1
      },
      /*::[*/
      600: {
        /* n:"BrtEndSXFilters", */
        T: -1
      },
      /*::[*/
      601: {
        /* n:"BrtBeginSXFILTER", */
        T: 1
      },
      /*::[*/
      602: {
        /* n:"BrtEndSXFilter", */
        T: -1
      },
      /*::[*/
      603: {
        /* n:"BrtBeginFills", */
        T: 1
      },
      /*::[*/
      604: {
        /* n:"BrtEndFills", */
        T: -1
      },
      /*::[*/
      605: {
        /* n:"BrtBeginCellWatches", */
        T: 1
      },
      /*::[*/
      606: {
        /* n:"BrtEndCellWatches", */
        T: -1
      },
      /*::[*/
      607: {
        /* n:"BrtCellWatch" */
      },
      /*::[*/
      608: {
        /* n:"BrtBeginCRErrs", */
        T: 1
      },
      /*::[*/
      609: {
        /* n:"BrtEndCRErrs", */
        T: -1
      },
      /*::[*/
      610: {
        /* n:"BrtCrashRecErr" */
      },
      /*::[*/
      611: {
        /* n:"BrtBeginFonts", */
        T: 1
      },
      /*::[*/
      612: {
        /* n:"BrtEndFonts", */
        T: -1
      },
      /*::[*/
      613: {
        /* n:"BrtBeginBorders", */
        T: 1
      },
      /*::[*/
      614: {
        /* n:"BrtEndBorders", */
        T: -1
      },
      /*::[*/
      615: {
        /* n:"BrtBeginFmts", */
        T: 1
      },
      /*::[*/
      616: {
        /* n:"BrtEndFmts", */
        T: -1
      },
      /*::[*/
      617: {
        /* n:"BrtBeginCellXFs", */
        T: 1
      },
      /*::[*/
      618: {
        /* n:"BrtEndCellXFs", */
        T: -1
      },
      /*::[*/
      619: {
        /* n:"BrtBeginStyles", */
        T: 1
      },
      /*::[*/
      620: {
        /* n:"BrtEndStyles", */
        T: -1
      },
      /*::[*/
      625: {
        /* n:"BrtBigName" */
      },
      /*::[*/
      626: {
        /* n:"BrtBeginCellStyleXFs", */
        T: 1
      },
      /*::[*/
      627: {
        /* n:"BrtEndCellStyleXFs", */
        T: -1
      },
      /*::[*/
      628: {
        /* n:"BrtBeginComments", */
        T: 1
      },
      /*::[*/
      629: {
        /* n:"BrtEndComments", */
        T: -1
      },
      /*::[*/
      630: {
        /* n:"BrtBeginCommentAuthors", */
        T: 1
      },
      /*::[*/
      631: {
        /* n:"BrtEndCommentAuthors", */
        T: -1
      },
      /*::[*/
      632: {
        /* n:"BrtCommentAuthor", */
        f: parse_BrtCommentAuthor
      },
      /*::[*/
      633: {
        /* n:"BrtBeginCommentList", */
        T: 1
      },
      /*::[*/
      634: {
        /* n:"BrtEndCommentList", */
        T: -1
      },
      /*::[*/
      635: {
        /* n:"BrtBeginComment", */
        T: 1,
        f: parse_BrtBeginComment
      },
      /*::[*/
      636: {
        /* n:"BrtEndComment", */
        T: -1
      },
      /*::[*/
      637: {
        /* n:"BrtCommentText", */
        f: parse_BrtCommentText
      },
      /*::[*/
      638: {
        /* n:"BrtBeginOleObjects", */
        T: 1
      },
      /*::[*/
      639: {
        /* n:"BrtOleObject" */
      },
      /*::[*/
      640: {
        /* n:"BrtEndOleObjects", */
        T: -1
      },
      /*::[*/
      641: {
        /* n:"BrtBeginSxrules", */
        T: 1
      },
      /*::[*/
      642: {
        /* n:"BrtEndSxRules", */
        T: -1
      },
      /*::[*/
      643: {
        /* n:"BrtBeginActiveXControls", */
        T: 1
      },
      /*::[*/
      644: {
        /* n:"BrtActiveX" */
      },
      /*::[*/
      645: {
        /* n:"BrtEndActiveXControls", */
        T: -1
      },
      /*::[*/
      646: {
        /* n:"BrtBeginPCDSDTCEMembersSortBy", */
        T: 1
      },
      /*::[*/
      648: {
        /* n:"BrtBeginCellIgnoreECs", */
        T: 1
      },
      /*::[*/
      649: {
        /* n:"BrtCellIgnoreEC" */
      },
      /*::[*/
      650: {
        /* n:"BrtEndCellIgnoreECs", */
        T: -1
      },
      /*::[*/
      651: {
        /* n:"BrtCsProp", */
        f: parse_BrtCsProp
      },
      /*::[*/
      652: {
        /* n:"BrtCsPageSetup" */
      },
      /*::[*/
      653: {
        /* n:"BrtBeginUserCsViews", */
        T: 1
      },
      /*::[*/
      654: {
        /* n:"BrtEndUserCsViews", */
        T: -1
      },
      /*::[*/
      655: {
        /* n:"BrtBeginUserCsView", */
        T: 1
      },
      /*::[*/
      656: {
        /* n:"BrtEndUserCsView", */
        T: -1
      },
      /*::[*/
      657: {
        /* n:"BrtBeginPcdSFCIEntries", */
        T: 1
      },
      /*::[*/
      658: {
        /* n:"BrtEndPCDSFCIEntries", */
        T: -1
      },
      /*::[*/
      659: {
        /* n:"BrtPCDSFCIEntry" */
      },
      /*::[*/
      660: {
        /* n:"BrtBeginListParts", */
        T: 1
      },
      /*::[*/
      661: {
        /* n:"BrtListPart" */
      },
      /*::[*/
      662: {
        /* n:"BrtEndListParts", */
        T: -1
      },
      /*::[*/
      663: {
        /* n:"BrtSheetCalcProp" */
      },
      /*::[*/
      664: {
        /* n:"BrtBeginFnGroup", */
        T: 1
      },
      /*::[*/
      665: {
        /* n:"BrtFnGroup" */
      },
      /*::[*/
      666: {
        /* n:"BrtEndFnGroup", */
        T: -1
      },
      /*::[*/
      667: {
        /* n:"BrtSupAddin" */
      },
      /*::[*/
      668: {
        /* n:"BrtSXTDMPOrder" */
      },
      /*::[*/
      669: {
        /* n:"BrtCsProtection" */
      },
      /*::[*/
      671: {
        /* n:"BrtBeginWsSortMap", */
        T: 1
      },
      /*::[*/
      672: {
        /* n:"BrtEndWsSortMap", */
        T: -1
      },
      /*::[*/
      673: {
        /* n:"BrtBeginRRSort", */
        T: 1
      },
      /*::[*/
      674: {
        /* n:"BrtEndRRSort", */
        T: -1
      },
      /*::[*/
      675: {
        /* n:"BrtRRSortItem" */
      },
      /*::[*/
      676: {
        /* n:"BrtFileSharingIso" */
      },
      /*::[*/
      677: {
        /* n:"BrtBookProtectionIso" */
      },
      /*::[*/
      678: {
        /* n:"BrtSheetProtectionIso" */
      },
      /*::[*/
      679: {
        /* n:"BrtCsProtectionIso" */
      },
      /*::[*/
      680: {
        /* n:"BrtRangeProtectionIso" */
      },
      /*::[*/
      681: {
        /* n:"BrtDValList" */
      },
      /*::[*/
      1024: {
        /* n:"BrtRwDescent" */
      },
      /*::[*/
      1025: {
        /* n:"BrtKnownFonts" */
      },
      /*::[*/
      1026: {
        /* n:"BrtBeginSXTupleSet", */
        T: 1
      },
      /*::[*/
      1027: {
        /* n:"BrtEndSXTupleSet", */
        T: -1
      },
      /*::[*/
      1028: {
        /* n:"BrtBeginSXTupleSetHeader", */
        T: 1
      },
      /*::[*/
      1029: {
        /* n:"BrtEndSXTupleSetHeader", */
        T: -1
      },
      /*::[*/
      1030: {
        /* n:"BrtSXTupleSetHeaderItem" */
      },
      /*::[*/
      1031: {
        /* n:"BrtBeginSXTupleSetData", */
        T: 1
      },
      /*::[*/
      1032: {
        /* n:"BrtEndSXTupleSetData", */
        T: -1
      },
      /*::[*/
      1033: {
        /* n:"BrtBeginSXTupleSetRow", */
        T: 1
      },
      /*::[*/
      1034: {
        /* n:"BrtEndSXTupleSetRow", */
        T: -1
      },
      /*::[*/
      1035: {
        /* n:"BrtSXTupleSetRowItem" */
      },
      /*::[*/
      1036: {
        /* n:"BrtNameExt" */
      },
      /*::[*/
      1037: {
        /* n:"BrtPCDH14" */
      },
      /*::[*/
      1038: {
        /* n:"BrtBeginPCDCalcMem14", */
        T: 1
      },
      /*::[*/
      1039: {
        /* n:"BrtEndPCDCalcMem14", */
        T: -1
      },
      /*::[*/
      1040: {
        /* n:"BrtSXTH14" */
      },
      /*::[*/
      1041: {
        /* n:"BrtBeginSparklineGroup", */
        T: 1
      },
      /*::[*/
      1042: {
        /* n:"BrtEndSparklineGroup", */
        T: -1
      },
      /*::[*/
      1043: {
        /* n:"BrtSparkline" */
      },
      /*::[*/
      1044: {
        /* n:"BrtSXDI14" */
      },
      /*::[*/
      1045: {
        /* n:"BrtWsFmtInfoEx14" */
      },
      /*::[*/
      1046: {
        /* n:"BrtBeginConditionalFormatting14", */
        T: 1
      },
      /*::[*/
      1047: {
        /* n:"BrtEndConditionalFormatting14", */
        T: -1
      },
      /*::[*/
      1048: {
        /* n:"BrtBeginCFRule14", */
        T: 1
      },
      /*::[*/
      1049: {
        /* n:"BrtEndCFRule14", */
        T: -1
      },
      /*::[*/
      1050: {
        /* n:"BrtCFVO14" */
      },
      /*::[*/
      1051: {
        /* n:"BrtBeginDatabar14", */
        T: 1
      },
      /*::[*/
      1052: {
        /* n:"BrtBeginIconSet14", */
        T: 1
      },
      /*::[*/
      1053: {
        /* n:"BrtDVal14", */
        f: parse_BrtDVal14
      },
      /*::[*/
      1054: {
        /* n:"BrtBeginDVals14", */
        T: 1
      },
      /*::[*/
      1055: {
        /* n:"BrtColor14" */
      },
      /*::[*/
      1056: {
        /* n:"BrtBeginSparklines", */
        T: 1
      },
      /*::[*/
      1057: {
        /* n:"BrtEndSparklines", */
        T: -1
      },
      /*::[*/
      1058: {
        /* n:"BrtBeginSparklineGroups", */
        T: 1
      },
      /*::[*/
      1059: {
        /* n:"BrtEndSparklineGroups", */
        T: -1
      },
      /*::[*/
      1061: {
        /* n:"BrtSXVD14" */
      },
      /*::[*/
      1062: {
        /* n:"BrtBeginSXView14", */
        T: 1
      },
      /*::[*/
      1063: {
        /* n:"BrtEndSXView14", */
        T: -1
      },
      /*::[*/
      1064: {
        /* n:"BrtBeginSXView16", */
        T: 1
      },
      /*::[*/
      1065: {
        /* n:"BrtEndSXView16", */
        T: -1
      },
      /*::[*/
      1066: {
        /* n:"BrtBeginPCD14", */
        T: 1
      },
      /*::[*/
      1067: {
        /* n:"BrtEndPCD14", */
        T: -1
      },
      /*::[*/
      1068: {
        /* n:"BrtBeginExtConn14", */
        T: 1
      },
      /*::[*/
      1069: {
        /* n:"BrtEndExtConn14", */
        T: -1
      },
      /*::[*/
      1070: {
        /* n:"BrtBeginSlicerCacheIDs", */
        T: 1
      },
      /*::[*/
      1071: {
        /* n:"BrtEndSlicerCacheIDs", */
        T: -1
      },
      /*::[*/
      1072: {
        /* n:"BrtBeginSlicerCacheID", */
        T: 1
      },
      /*::[*/
      1073: {
        /* n:"BrtEndSlicerCacheID", */
        T: -1
      },
      /*::[*/
      1075: {
        /* n:"BrtBeginSlicerCache", */
        T: 1
      },
      /*::[*/
      1076: {
        /* n:"BrtEndSlicerCache", */
        T: -1
      },
      /*::[*/
      1077: {
        /* n:"BrtBeginSlicerCacheDef", */
        T: 1
      },
      /*::[*/
      1078: {
        /* n:"BrtEndSlicerCacheDef", */
        T: -1
      },
      /*::[*/
      1079: {
        /* n:"BrtBeginSlicersEx", */
        T: 1
      },
      /*::[*/
      1080: {
        /* n:"BrtEndSlicersEx", */
        T: -1
      },
      /*::[*/
      1081: {
        /* n:"BrtBeginSlicerEx", */
        T: 1
      },
      /*::[*/
      1082: {
        /* n:"BrtEndSlicerEx", */
        T: -1
      },
      /*::[*/
      1083: {
        /* n:"BrtBeginSlicer", */
        T: 1
      },
      /*::[*/
      1084: {
        /* n:"BrtEndSlicer", */
        T: -1
      },
      /*::[*/
      1085: {
        /* n:"BrtSlicerCachePivotTables" */
      },
      /*::[*/
      1086: {
        /* n:"BrtBeginSlicerCacheOlapImpl", */
        T: 1
      },
      /*::[*/
      1087: {
        /* n:"BrtEndSlicerCacheOlapImpl", */
        T: -1
      },
      /*::[*/
      1088: {
        /* n:"BrtBeginSlicerCacheLevelsData", */
        T: 1
      },
      /*::[*/
      1089: {
        /* n:"BrtEndSlicerCacheLevelsData", */
        T: -1
      },
      /*::[*/
      1090: {
        /* n:"BrtBeginSlicerCacheLevelData", */
        T: 1
      },
      /*::[*/
      1091: {
        /* n:"BrtEndSlicerCacheLevelData", */
        T: -1
      },
      /*::[*/
      1092: {
        /* n:"BrtBeginSlicerCacheSiRanges", */
        T: 1
      },
      /*::[*/
      1093: {
        /* n:"BrtEndSlicerCacheSiRanges", */
        T: -1
      },
      /*::[*/
      1094: {
        /* n:"BrtBeginSlicerCacheSiRange", */
        T: 1
      },
      /*::[*/
      1095: {
        /* n:"BrtEndSlicerCacheSiRange", */
        T: -1
      },
      /*::[*/
      1096: {
        /* n:"BrtSlicerCacheOlapItem" */
      },
      /*::[*/
      1097: {
        /* n:"BrtBeginSlicerCacheSelections", */
        T: 1
      },
      /*::[*/
      1098: {
        /* n:"BrtSlicerCacheSelection" */
      },
      /*::[*/
      1099: {
        /* n:"BrtEndSlicerCacheSelections", */
        T: -1
      },
      /*::[*/
      1100: {
        /* n:"BrtBeginSlicerCacheNative", */
        T: 1
      },
      /*::[*/
      1101: {
        /* n:"BrtEndSlicerCacheNative", */
        T: -1
      },
      /*::[*/
      1102: {
        /* n:"BrtSlicerCacheNativeItem" */
      },
      /*::[*/
      1103: {
        /* n:"BrtRangeProtection14" */
      },
      /*::[*/
      1104: {
        /* n:"BrtRangeProtectionIso14" */
      },
      /*::[*/
      1105: {
        /* n:"BrtCellIgnoreEC14" */
      },
      /*::[*/
      1111: {
        /* n:"BrtList14" */
      },
      /*::[*/
      1112: {
        /* n:"BrtCFIcon" */
      },
      /*::[*/
      1113: {
        /* n:"BrtBeginSlicerCachesPivotCacheIDs", */
        T: 1
      },
      /*::[*/
      1114: {
        /* n:"BrtEndSlicerCachesPivotCacheIDs", */
        T: -1
      },
      /*::[*/
      1115: {
        /* n:"BrtBeginSlicers", */
        T: 1
      },
      /*::[*/
      1116: {
        /* n:"BrtEndSlicers", */
        T: -1
      },
      /*::[*/
      1117: {
        /* n:"BrtWbProp14" */
      },
      /*::[*/
      1118: {
        /* n:"BrtBeginSXEdit", */
        T: 1
      },
      /*::[*/
      1119: {
        /* n:"BrtEndSXEdit", */
        T: -1
      },
      /*::[*/
      1120: {
        /* n:"BrtBeginSXEdits", */
        T: 1
      },
      /*::[*/
      1121: {
        /* n:"BrtEndSXEdits", */
        T: -1
      },
      /*::[*/
      1122: {
        /* n:"BrtBeginSXChange", */
        T: 1
      },
      /*::[*/
      1123: {
        /* n:"BrtEndSXChange", */
        T: -1
      },
      /*::[*/
      1124: {
        /* n:"BrtBeginSXChanges", */
        T: 1
      },
      /*::[*/
      1125: {
        /* n:"BrtEndSXChanges", */
        T: -1
      },
      /*::[*/
      1126: {
        /* n:"BrtSXTupleItems" */
      },
      /*::[*/
      1128: {
        /* n:"BrtBeginSlicerStyle", */
        T: 1
      },
      /*::[*/
      1129: {
        /* n:"BrtEndSlicerStyle", */
        T: -1
      },
      /*::[*/
      1130: {
        /* n:"BrtSlicerStyleElement" */
      },
      /*::[*/
      1131: {
        /* n:"BrtBeginStyleSheetExt14", */
        T: 1
      },
      /*::[*/
      1132: {
        /* n:"BrtEndStyleSheetExt14", */
        T: -1
      },
      /*::[*/
      1133: {
        /* n:"BrtBeginSlicerCachesPivotCacheID", */
        T: 1
      },
      /*::[*/
      1134: {
        /* n:"BrtEndSlicerCachesPivotCacheID", */
        T: -1
      },
      /*::[*/
      1135: {
        /* n:"BrtBeginConditionalFormattings", */
        T: 1
      },
      /*::[*/
      1136: {
        /* n:"BrtEndConditionalFormattings", */
        T: -1
      },
      /*::[*/
      1137: {
        /* n:"BrtBeginPCDCalcMemExt", */
        T: 1
      },
      /*::[*/
      1138: {
        /* n:"BrtEndPCDCalcMemExt", */
        T: -1
      },
      /*::[*/
      1139: {
        /* n:"BrtBeginPCDCalcMemsExt", */
        T: 1
      },
      /*::[*/
      1140: {
        /* n:"BrtEndPCDCalcMemsExt", */
        T: -1
      },
      /*::[*/
      1141: {
        /* n:"BrtPCDField14" */
      },
      /*::[*/
      1142: {
        /* n:"BrtBeginSlicerStyles", */
        T: 1
      },
      /*::[*/
      1143: {
        /* n:"BrtEndSlicerStyles", */
        T: -1
      },
      /*::[*/
      1144: {
        /* n:"BrtBeginSlicerStyleElements", */
        T: 1
      },
      /*::[*/
      1145: {
        /* n:"BrtEndSlicerStyleElements", */
        T: -1
      },
      /*::[*/
      1146: {
        /* n:"BrtCFRuleExt" */
      },
      /*::[*/
      1147: {
        /* n:"BrtBeginSXCondFmt14", */
        T: 1
      },
      /*::[*/
      1148: {
        /* n:"BrtEndSXCondFmt14", */
        T: -1
      },
      /*::[*/
      1149: {
        /* n:"BrtBeginSXCondFmts14", */
        T: 1
      },
      /*::[*/
      1150: {
        /* n:"BrtEndSXCondFmts14", */
        T: -1
      },
      /*::[*/
      1152: {
        /* n:"BrtBeginSortCond14", */
        T: 1
      },
      /*::[*/
      1153: {
        /* n:"BrtEndSortCond14", */
        T: -1
      },
      /*::[*/
      1154: {
        /* n:"BrtEndDVals14", */
        T: -1
      },
      /*::[*/
      1155: {
        /* n:"BrtEndIconSet14", */
        T: -1
      },
      /*::[*/
      1156: {
        /* n:"BrtEndDatabar14", */
        T: -1
      },
      /*::[*/
      1157: {
        /* n:"BrtBeginColorScale14", */
        T: 1
      },
      /*::[*/
      1158: {
        /* n:"BrtEndColorScale14", */
        T: -1
      },
      /*::[*/
      1159: {
        /* n:"BrtBeginSxrules14", */
        T: 1
      },
      /*::[*/
      1160: {
        /* n:"BrtEndSxrules14", */
        T: -1
      },
      /*::[*/
      1161: {
        /* n:"BrtBeginPRule14", */
        T: 1
      },
      /*::[*/
      1162: {
        /* n:"BrtEndPRule14", */
        T: -1
      },
      /*::[*/
      1163: {
        /* n:"BrtBeginPRFilters14", */
        T: 1
      },
      /*::[*/
      1164: {
        /* n:"BrtEndPRFilters14", */
        T: -1
      },
      /*::[*/
      1165: {
        /* n:"BrtBeginPRFilter14", */
        T: 1
      },
      /*::[*/
      1166: {
        /* n:"BrtEndPRFilter14", */
        T: -1
      },
      /*::[*/
      1167: {
        /* n:"BrtBeginPRFItem14", */
        T: 1
      },
      /*::[*/
      1168: {
        /* n:"BrtEndPRFItem14", */
        T: -1
      },
      /*::[*/
      1169: {
        /* n:"BrtBeginCellIgnoreECs14", */
        T: 1
      },
      /*::[*/
      1170: {
        /* n:"BrtEndCellIgnoreECs14", */
        T: -1
      },
      /*::[*/
      1171: {
        /* n:"BrtDxf14" */
      },
      /*::[*/
      1172: {
        /* n:"BrtBeginDxF14s", */
        T: 1
      },
      /*::[*/
      1173: {
        /* n:"BrtEndDxf14s", */
        T: -1
      },
      /*::[*/
      1177: {
        /* n:"BrtFilter14" */
      },
      /*::[*/
      1178: {
        /* n:"BrtBeginCustomFilters14", */
        T: 1
      },
      /*::[*/
      1180: {
        /* n:"BrtCustomFilter14" */
      },
      /*::[*/
      1181: {
        /* n:"BrtIconFilter14" */
      },
      /*::[*/
      1182: {
        /* n:"BrtPivotCacheConnectionName" */
      },
      /*::[*/
      2048: {
        /* n:"BrtBeginDecoupledPivotCacheIDs", */
        T: 1
      },
      /*::[*/
      2049: {
        /* n:"BrtEndDecoupledPivotCacheIDs", */
        T: -1
      },
      /*::[*/
      2050: {
        /* n:"BrtDecoupledPivotCacheID" */
      },
      /*::[*/
      2051: {
        /* n:"BrtBeginPivotTableRefs", */
        T: 1
      },
      /*::[*/
      2052: {
        /* n:"BrtEndPivotTableRefs", */
        T: -1
      },
      /*::[*/
      2053: {
        /* n:"BrtPivotTableRef" */
      },
      /*::[*/
      2054: {
        /* n:"BrtSlicerCacheBookPivotTables" */
      },
      /*::[*/
      2055: {
        /* n:"BrtBeginSxvcells", */
        T: 1
      },
      /*::[*/
      2056: {
        /* n:"BrtEndSxvcells", */
        T: -1
      },
      /*::[*/
      2057: {
        /* n:"BrtBeginSxRow", */
        T: 1
      },
      /*::[*/
      2058: {
        /* n:"BrtEndSxRow", */
        T: -1
      },
      /*::[*/
      2060: {
        /* n:"BrtPcdCalcMem15" */
      },
      /*::[*/
      2067: {
        /* n:"BrtQsi15" */
      },
      /*::[*/
      2068: {
        /* n:"BrtBeginWebExtensions", */
        T: 1
      },
      /*::[*/
      2069: {
        /* n:"BrtEndWebExtensions", */
        T: -1
      },
      /*::[*/
      2070: {
        /* n:"BrtWebExtension" */
      },
      /*::[*/
      2071: {
        /* n:"BrtAbsPath15" */
      },
      /*::[*/
      2072: {
        /* n:"BrtBeginPivotTableUISettings", */
        T: 1
      },
      /*::[*/
      2073: {
        /* n:"BrtEndPivotTableUISettings", */
        T: -1
      },
      /*::[*/
      2075: {
        /* n:"BrtTableSlicerCacheIDs" */
      },
      /*::[*/
      2076: {
        /* n:"BrtTableSlicerCacheID" */
      },
      /*::[*/
      2077: {
        /* n:"BrtBeginTableSlicerCache", */
        T: 1
      },
      /*::[*/
      2078: {
        /* n:"BrtEndTableSlicerCache", */
        T: -1
      },
      /*::[*/
      2079: {
        /* n:"BrtSxFilter15" */
      },
      /*::[*/
      2080: {
        /* n:"BrtBeginTimelineCachePivotCacheIDs", */
        T: 1
      },
      /*::[*/
      2081: {
        /* n:"BrtEndTimelineCachePivotCacheIDs", */
        T: -1
      },
      /*::[*/
      2082: {
        /* n:"BrtTimelineCachePivotCacheID" */
      },
      /*::[*/
      2083: {
        /* n:"BrtBeginTimelineCacheIDs", */
        T: 1
      },
      /*::[*/
      2084: {
        /* n:"BrtEndTimelineCacheIDs", */
        T: -1
      },
      /*::[*/
      2085: {
        /* n:"BrtBeginTimelineCacheID", */
        T: 1
      },
      /*::[*/
      2086: {
        /* n:"BrtEndTimelineCacheID", */
        T: -1
      },
      /*::[*/
      2087: {
        /* n:"BrtBeginTimelinesEx", */
        T: 1
      },
      /*::[*/
      2088: {
        /* n:"BrtEndTimelinesEx", */
        T: -1
      },
      /*::[*/
      2089: {
        /* n:"BrtBeginTimelineEx", */
        T: 1
      },
      /*::[*/
      2090: {
        /* n:"BrtEndTimelineEx", */
        T: -1
      },
      /*::[*/
      2091: {
        /* n:"BrtWorkBookPr15" */
      },
      /*::[*/
      2092: {
        /* n:"BrtPCDH15" */
      },
      /*::[*/
      2093: {
        /* n:"BrtBeginTimelineStyle", */
        T: 1
      },
      /*::[*/
      2094: {
        /* n:"BrtEndTimelineStyle", */
        T: -1
      },
      /*::[*/
      2095: {
        /* n:"BrtTimelineStyleElement" */
      },
      /*::[*/
      2096: {
        /* n:"BrtBeginTimelineStylesheetExt15", */
        T: 1
      },
      /*::[*/
      2097: {
        /* n:"BrtEndTimelineStylesheetExt15", */
        T: -1
      },
      /*::[*/
      2098: {
        /* n:"BrtBeginTimelineStyles", */
        T: 1
      },
      /*::[*/
      2099: {
        /* n:"BrtEndTimelineStyles", */
        T: -1
      },
      /*::[*/
      2100: {
        /* n:"BrtBeginTimelineStyleElements", */
        T: 1
      },
      /*::[*/
      2101: {
        /* n:"BrtEndTimelineStyleElements", */
        T: -1
      },
      /*::[*/
      2102: {
        /* n:"BrtDxf15" */
      },
      /*::[*/
      2103: {
        /* n:"BrtBeginDxfs15", */
        T: 1
      },
      /*::[*/
      2104: {
        /* n:"BrtEndDxfs15", */
        T: -1
      },
      /*::[*/
      2105: {
        /* n:"BrtSlicerCacheHideItemsWithNoData" */
      },
      /*::[*/
      2106: {
        /* n:"BrtBeginItemUniqueNames", */
        T: 1
      },
      /*::[*/
      2107: {
        /* n:"BrtEndItemUniqueNames", */
        T: -1
      },
      /*::[*/
      2108: {
        /* n:"BrtItemUniqueName" */
      },
      /*::[*/
      2109: {
        /* n:"BrtBeginExtConn15", */
        T: 1
      },
      /*::[*/
      2110: {
        /* n:"BrtEndExtConn15", */
        T: -1
      },
      /*::[*/
      2111: {
        /* n:"BrtBeginOledbPr15", */
        T: 1
      },
      /*::[*/
      2112: {
        /* n:"BrtEndOledbPr15", */
        T: -1
      },
      /*::[*/
      2113: {
        /* n:"BrtBeginDataFeedPr15", */
        T: 1
      },
      /*::[*/
      2114: {
        /* n:"BrtEndDataFeedPr15", */
        T: -1
      },
      /*::[*/
      2115: {
        /* n:"BrtTextPr15" */
      },
      /*::[*/
      2116: {
        /* n:"BrtRangePr15" */
      },
      /*::[*/
      2117: {
        /* n:"BrtDbCommand15" */
      },
      /*::[*/
      2118: {
        /* n:"BrtBeginDbTables15", */
        T: 1
      },
      /*::[*/
      2119: {
        /* n:"BrtEndDbTables15", */
        T: -1
      },
      /*::[*/
      2120: {
        /* n:"BrtDbTable15" */
      },
      /*::[*/
      2121: {
        /* n:"BrtBeginDataModel", */
        T: 1
      },
      /*::[*/
      2122: {
        /* n:"BrtEndDataModel", */
        T: -1
      },
      /*::[*/
      2123: {
        /* n:"BrtBeginModelTables", */
        T: 1
      },
      /*::[*/
      2124: {
        /* n:"BrtEndModelTables", */
        T: -1
      },
      /*::[*/
      2125: {
        /* n:"BrtModelTable" */
      },
      /*::[*/
      2126: {
        /* n:"BrtBeginModelRelationships", */
        T: 1
      },
      /*::[*/
      2127: {
        /* n:"BrtEndModelRelationships", */
        T: -1
      },
      /*::[*/
      2128: {
        /* n:"BrtModelRelationship" */
      },
      /*::[*/
      2129: {
        /* n:"BrtBeginECTxtWiz15", */
        T: 1
      },
      /*::[*/
      2130: {
        /* n:"BrtEndECTxtWiz15", */
        T: -1
      },
      /*::[*/
      2131: {
        /* n:"BrtBeginECTWFldInfoLst15", */
        T: 1
      },
      /*::[*/
      2132: {
        /* n:"BrtEndECTWFldInfoLst15", */
        T: -1
      },
      /*::[*/
      2133: {
        /* n:"BrtBeginECTWFldInfo15", */
        T: 1
      },
      /*::[*/
      2134: {
        /* n:"BrtFieldListActiveItem" */
      },
      /*::[*/
      2135: {
        /* n:"BrtPivotCacheIdVersion" */
      },
      /*::[*/
      2136: {
        /* n:"BrtSXDI15" */
      },
      /*::[*/
      2137: {
        /* n:"BrtBeginModelTimeGroupings", */
        T: 1
      },
      /*::[*/
      2138: {
        /* n:"BrtEndModelTimeGroupings", */
        T: -1
      },
      /*::[*/
      2139: {
        /* n:"BrtBeginModelTimeGrouping", */
        T: 1
      },
      /*::[*/
      2140: {
        /* n:"BrtEndModelTimeGrouping", */
        T: -1
      },
      /*::[*/
      2141: {
        /* n:"BrtModelTimeGroupingCalcCol" */
      },
      /*::[*/
      3072: {
        /* n:"BrtUid" */
      },
      /*::[*/
      3073: {
        /* n:"BrtRevisionPtr" */
      },
      /*::[*/
      4096: {
        /* n:"BrtBeginDynamicArrayPr", */
        T: 1
      },
      /*::[*/
      4097: {
        /* n:"BrtEndDynamicArrayPr", */
        T: -1
      },
      /*::[*/
      5002: {
        /* n:"BrtBeginRichValueBlock", */
        T: 1
      },
      /*::[*/
      5003: {
        /* n:"BrtEndRichValueBlock", */
        T: -1
      },
      /*::[*/
      5081: {
        /* n:"BrtBeginRichFilters", */
        T: 1
      },
      /*::[*/
      5082: {
        /* n:"BrtEndRichFilters", */
        T: -1
      },
      /*::[*/
      5083: {
        /* n:"BrtRichFilter" */
      },
      /*::[*/
      5084: {
        /* n:"BrtBeginRichFilterColumn", */
        T: 1
      },
      /*::[*/
      5085: {
        /* n:"BrtEndRichFilterColumn", */
        T: -1
      },
      /*::[*/
      5086: {
        /* n:"BrtBeginCustomRichFilters", */
        T: 1
      },
      /*::[*/
      5087: {
        /* n:"BrtEndCustomRichFilters", */
        T: -1
      },
      /*::[*/
      5088: {
        /* n:"BrtCustomRichFilter" */
      },
      /*::[*/
      5089: {
        /* n:"BrtTop10RichFilter" */
      },
      /*::[*/
      5090: {
        /* n:"BrtDynamicRichFilter" */
      },
      /*::[*/
      5092: {
        /* n:"BrtBeginRichSortCondition", */
        T: 1
      },
      /*::[*/
      5093: {
        /* n:"BrtEndRichSortCondition", */
        T: -1
      },
      /*::[*/
      5094: {
        /* n:"BrtRichFilterDateGroupItem" */
      },
      /*::[*/
      5095: {
        /* n:"BrtBeginCalcFeatures", */
        T: 1
      },
      /*::[*/
      5096: {
        /* n:"BrtEndCalcFeatures", */
        T: -1
      },
      /*::[*/
      5097: {
        /* n:"BrtCalcFeature" */
      },
      /*::[*/
      5099: {
        /* n:"BrtExternalLinksPr" */
      },
      /*::[*/
      65535: { n: "" }
    };
    function write_biff_rec(ba, type, payload, length) {
      var t = type;
      if (isNaN(t))
        return;
      var len = length || (payload || []).length || 0;
      var o = ba.next(4);
      o.write_shift(2, t);
      o.write_shift(2, len);
      if (
        /*:: len != null &&*/
        len > 0 && is_buf(payload)
      )
        ba.push(payload);
    }
    function write_biff_continue(ba, type, payload, length) {
      var len = (payload || []).length || 0;
      if (len <= 8224)
        return write_biff_rec(ba, type, payload, len);
      var t = type;
      if (isNaN(t))
        return;
      var parts = payload.parts || [], sidx = 0;
      var i = 0, w = 0;
      while (w + (parts[sidx] || 8224) <= 8224) {
        w += parts[sidx] || 8224;
        sidx++;
      }
      var o = ba.next(4);
      o.write_shift(2, t);
      o.write_shift(2, w);
      ba.push(payload.slice(i, i + w));
      i += w;
      while (i < len) {
        o = ba.next(4);
        o.write_shift(2, 60);
        w = 0;
        while (w + (parts[sidx] || 8224) <= 8224) {
          w += parts[sidx] || 8224;
          sidx++;
        }
        o.write_shift(2, w);
        ba.push(payload.slice(i, i + w));
        i += w;
      }
    }
    function write_BIFF2Cell(out, r, c) {
      if (!out)
        out = new_buf(7);
      out.write_shift(2, r);
      out.write_shift(2, c);
      out.write_shift(2, 0);
      out.write_shift(1, 0);
      return out;
    }
    function write_BIFF2BERR(r, c, val, t) {
      var out = new_buf(9);
      write_BIFF2Cell(out, r, c);
      write_Bes(val, t || "b", out);
      return out;
    }
    function write_BIFF2LABEL(r, c, val) {
      var out = new_buf(8 + 2 * val.length);
      write_BIFF2Cell(out, r, c);
      out.write_shift(1, val.length);
      out.write_shift(val.length, val, "sbcs");
      return out.l < out.length ? out.slice(0, out.l) : out;
    }
    function write_ws_biff2_cell(ba, cell, R, C) {
      if (cell.v != null)
        switch (cell.t) {
          case "d":
          case "n":
            var v = cell.t == "d" ? datenum(parseDate(cell.v)) : cell.v;
            if (v == (v | 0) && v >= 0 && v < 65536)
              write_biff_rec(ba, 2, write_BIFF2INT(R, C, v));
            else
              write_biff_rec(ba, 3, write_BIFF2NUM(R, C, v));
            return;
          case "b":
          case "e":
            write_biff_rec(ba, 5, write_BIFF2BERR(R, C, cell.v, cell.t));
            return;
          case "s":
          case "str":
            write_biff_rec(ba, 4, write_BIFF2LABEL(R, C, (cell.v || "").slice(0, 255)));
            return;
        }
      write_biff_rec(ba, 1, write_BIFF2Cell(null, R, C));
    }
    function write_ws_biff2(ba, ws, idx, opts) {
      var dense = Array.isArray(ws);
      var range = safe_decode_range(ws["!ref"] || "A1"), ref, rr = "", cols = [];
      if (range.e.c > 255 || range.e.r > 16383) {
        if (opts.WTF)
          throw new Error("Range " + (ws["!ref"] || "A1") + " exceeds format limit A1:IV16384");
        range.e.c = Math.min(range.e.c, 255);
        range.e.r = Math.min(range.e.c, 16383);
        ref = encode_range(range);
      }
      for (var R = range.s.r; R <= range.e.r; ++R) {
        rr = encode_row(R);
        for (var C = range.s.c; C <= range.e.c; ++C) {
          if (R === range.s.r)
            cols[C] = encode_col(C);
          ref = cols[C] + rr;
          var cell = dense ? (ws[R] || [])[C] : ws[ref];
          if (!cell)
            continue;
          write_ws_biff2_cell(ba, cell, R, C);
        }
      }
    }
    function write_biff2_buf(wb, opts) {
      var o = opts || {};
      var ba = buf_array();
      var idx = 0;
      for (var i = 0; i < wb.SheetNames.length; ++i)
        if (wb.SheetNames[i] == o.sheet)
          idx = i;
      if (idx == 0 && !!o.sheet && wb.SheetNames[0] != o.sheet)
        throw new Error("Sheet not found: " + o.sheet);
      write_biff_rec(ba, o.biff == 4 ? 1033 : o.biff == 3 ? 521 : 9, write_BOF(wb, 16, o));
      write_ws_biff2(ba, wb.Sheets[wb.SheetNames[idx]], idx, o);
      write_biff_rec(ba, 10);
      return ba.end();
    }
    function write_FONTS_biff8(ba, data, opts) {
      write_biff_rec(ba, 49, write_Font({
        sz: 12,
        name: "Arial"
      }, opts));
    }
    function write_FMTS_biff8(ba, NF, opts) {
      if (!NF)
        return;
      [[5, 8], [23, 26], [41, 44], [
        /*63*/
        50,
        /*66],[164,*/
        392
      ]].forEach(function(r) {
        for (var i = r[0]; i <= r[1]; ++i)
          if (NF[i] != null)
            write_biff_rec(ba, 1054, write_Format(i, NF[i], opts));
      });
    }
    function write_FEAT(ba, ws) {
      var o = new_buf(19);
      o.write_shift(4, 2151);
      o.write_shift(4, 0);
      o.write_shift(4, 0);
      o.write_shift(2, 3);
      o.write_shift(1, 1);
      o.write_shift(4, 0);
      write_biff_rec(ba, 2151, o);
      o = new_buf(39);
      o.write_shift(4, 2152);
      o.write_shift(4, 0);
      o.write_shift(4, 0);
      o.write_shift(2, 3);
      o.write_shift(1, 0);
      o.write_shift(4, 0);
      o.write_shift(2, 1);
      o.write_shift(4, 4);
      o.write_shift(2, 0);
      write_Ref8U(safe_decode_range(ws["!ref"] || "A1"), o);
      o.write_shift(4, 4);
      write_biff_rec(ba, 2152, o);
    }
    function write_CELLXFS_biff8(ba, opts) {
      for (var i = 0; i < 16; ++i)
        write_biff_rec(ba, 224, write_XF({ numFmtId: 0, style: true }, 0, opts));
      opts.cellXfs.forEach(function(c) {
        write_biff_rec(ba, 224, write_XF(c, 0, opts));
      });
    }
    function write_ws_biff8_hlinks(ba, ws) {
      for (var R = 0; R < ws["!links"].length; ++R) {
        var HL = ws["!links"][R];
        write_biff_rec(ba, 440, write_HLink(HL));
        if (HL[1].Tooltip)
          write_biff_rec(ba, 2048, write_HLinkTooltip(HL));
      }
      delete ws["!links"];
    }
    function write_ws_cols_biff8(ba, cols) {
      if (!cols)
        return;
      var cnt = 0;
      cols.forEach(function(col, idx) {
        if (++cnt <= 256 && col) {
          write_biff_rec(ba, 125, write_ColInfo(col_obj_w(idx, col), idx));
        }
      });
    }
    function write_ws_biff8_cell(ba, cell, R, C, opts) {
      var os = 16 + get_cell_style(opts.cellXfs, cell, opts);
      if (cell.v == null && !cell.bf) {
        write_biff_rec(ba, 513, write_XLSCell(R, C, os));
        return;
      }
      if (cell.bf)
        write_biff_rec(ba, 6, write_Formula(cell, R, C, opts, os));
      else
        switch (cell.t) {
          case "d":
          case "n":
            var v = cell.t == "d" ? datenum(parseDate(cell.v)) : cell.v;
            write_biff_rec(ba, 515, write_Number(R, C, v, os));
            break;
          case "b":
          case "e":
            write_biff_rec(ba, 517, write_BoolErr(R, C, cell.v, os, opts, cell.t));
            break;
          case "s":
          case "str":
            if (opts.bookSST) {
              var isst = get_sst_id(opts.Strings, cell.v, opts.revStrings);
              write_biff_rec(ba, 253, write_LabelSst(R, C, isst, os));
            } else
              write_biff_rec(ba, 516, write_Label(R, C, (cell.v || "").slice(0, 255), os, opts));
            break;
          default:
            write_biff_rec(ba, 513, write_XLSCell(R, C, os));
        }
    }
    function write_ws_biff8(idx, opts, wb) {
      var ba = buf_array();
      var s = wb.SheetNames[idx], ws = wb.Sheets[s] || {};
      var _WB = (wb || {}).Workbook || {};
      var _sheet = (_WB.Sheets || [])[idx] || {};
      var dense = Array.isArray(ws);
      var b8 = opts.biff == 8;
      var ref, rr = "", cols = [];
      var range = safe_decode_range(ws["!ref"] || "A1");
      var MAX_ROWS = b8 ? 65536 : 16384;
      if (range.e.c > 255 || range.e.r >= MAX_ROWS) {
        if (opts.WTF)
          throw new Error("Range " + (ws["!ref"] || "A1") + " exceeds format limit A1:IV16384");
        range.e.c = Math.min(range.e.c, 255);
        range.e.r = Math.min(range.e.c, MAX_ROWS - 1);
      }
      write_biff_rec(ba, 2057, write_BOF(wb, 16, opts));
      write_biff_rec(ba, 13, writeuint16(1));
      write_biff_rec(ba, 12, writeuint16(100));
      write_biff_rec(ba, 15, writebool(true));
      write_biff_rec(ba, 17, writebool(false));
      write_biff_rec(ba, 16, write_Xnum(1e-3));
      write_biff_rec(ba, 95, writebool(true));
      write_biff_rec(ba, 42, writebool(false));
      write_biff_rec(ba, 43, writebool(false));
      write_biff_rec(ba, 130, writeuint16(1));
      write_biff_rec(ba, 128, write_Guts());
      write_biff_rec(ba, 131, writebool(false));
      write_biff_rec(ba, 132, writebool(false));
      if (b8)
        write_ws_cols_biff8(ba, ws["!cols"]);
      write_biff_rec(ba, 512, write_Dimensions(range, opts));
      if (b8)
        ws["!links"] = [];
      for (var R = range.s.r; R <= range.e.r; ++R) {
        rr = encode_row(R);
        for (var C = range.s.c; C <= range.e.c; ++C) {
          if (R === range.s.r)
            cols[C] = encode_col(C);
          ref = cols[C] + rr;
          var cell = dense ? (ws[R] || [])[C] : ws[ref];
          if (!cell)
            continue;
          write_ws_biff8_cell(ba, cell, R, C, opts);
          if (b8 && cell.l)
            ws["!links"].push([ref, cell.l]);
        }
      }
      var cname = _sheet.CodeName || _sheet.name || s;
      if (b8)
        write_biff_rec(ba, 574, write_Window2((_WB.Views || [])[0]));
      if (b8 && (ws["!merges"] || []).length)
        write_biff_rec(ba, 229, write_MergeCells(ws["!merges"]));
      if (b8)
        write_ws_biff8_hlinks(ba, ws);
      write_biff_rec(ba, 442, write_XLUnicodeString(cname));
      if (b8)
        write_FEAT(ba, ws);
      write_biff_rec(
        ba,
        10
        /* EOF */
      );
      return ba.end();
    }
    function write_biff8_global(wb, bufs, opts) {
      var A = buf_array();
      var _WB = (wb || {}).Workbook || {};
      var _sheets = _WB.Sheets || [];
      var _wb = (
        /*::((*/
        _WB.WBProps || {
          /*::CodeName:"ThisWorkbook"*/
        }
      );
      var b8 = opts.biff == 8, b5 = opts.biff == 5;
      write_biff_rec(A, 2057, write_BOF(wb, 5, opts));
      if (opts.bookType == "xla")
        write_biff_rec(
          A,
          135
          /* Addin */
        );
      write_biff_rec(A, 225, b8 ? writeuint16(1200) : null);
      write_biff_rec(A, 193, writezeroes(2));
      if (b5)
        write_biff_rec(
          A,
          191
          /* ToolbarHdr */
        );
      if (b5)
        write_biff_rec(
          A,
          192
          /* ToolbarEnd */
        );
      write_biff_rec(
        A,
        226
        /* InterfaceEnd */
      );
      write_biff_rec(A, 92, write_WriteAccess("SheetJS", opts));
      write_biff_rec(A, 66, writeuint16(b8 ? 1200 : 1252));
      if (b8)
        write_biff_rec(A, 353, writeuint16(0));
      if (b8)
        write_biff_rec(
          A,
          448
          /* Excel9File */
        );
      write_biff_rec(A, 317, write_RRTabId(wb.SheetNames.length));
      if (b8 && wb.vbaraw)
        write_biff_rec(
          A,
          211
          /* ObProj */
        );
      if (b8 && wb.vbaraw) {
        var cname = _wb.CodeName || "ThisWorkbook";
        write_biff_rec(A, 442, write_XLUnicodeString(cname));
      }
      write_biff_rec(A, 156, writeuint16(17));
      write_biff_rec(A, 25, writebool(false));
      write_biff_rec(A, 18, writebool(false));
      write_biff_rec(A, 19, writeuint16(0));
      if (b8)
        write_biff_rec(A, 431, writebool(false));
      if (b8)
        write_biff_rec(A, 444, writeuint16(0));
      write_biff_rec(A, 61, write_Window1());
      write_biff_rec(A, 64, writebool(false));
      write_biff_rec(A, 141, writeuint16(0));
      write_biff_rec(A, 34, writebool(safe1904(wb) == "true"));
      write_biff_rec(A, 14, writebool(true));
      if (b8)
        write_biff_rec(A, 439, writebool(false));
      write_biff_rec(A, 218, writeuint16(0));
      write_FONTS_biff8(A, wb, opts);
      write_FMTS_biff8(A, wb.SSF, opts);
      write_CELLXFS_biff8(A, opts);
      if (b8)
        write_biff_rec(A, 352, writebool(false));
      var a = A.end();
      var C = buf_array();
      if (b8)
        write_biff_rec(C, 140, write_Country());
      if (b8 && opts.Strings)
        write_biff_continue(C, 252, write_SST(opts.Strings));
      write_biff_rec(
        C,
        10
        /* EOF */
      );
      var c = C.end();
      var B = buf_array();
      var blen = 0, j = 0;
      for (j = 0; j < wb.SheetNames.length; ++j)
        blen += (b8 ? 12 : 11) + (b8 ? 2 : 1) * wb.SheetNames[j].length;
      var start = a.length + blen + c.length;
      for (j = 0; j < wb.SheetNames.length; ++j) {
        var _sheet = _sheets[j] || {};
        write_biff_rec(B, 133, write_BoundSheet8({ pos: start, hs: _sheet.Hidden || 0, dt: 0, name: wb.SheetNames[j] }, opts));
        start += bufs[j].length;
      }
      var b = B.end();
      if (blen != b.length)
        throw new Error("BS8 " + blen + " != " + b.length);
      var out = [];
      if (a.length)
        out.push(a);
      if (b.length)
        out.push(b);
      if (c.length)
        out.push(c);
      return bconcat(out);
    }
    function write_biff8_buf(wb, opts) {
      var o = opts || {};
      var bufs = [];
      if (wb && !wb.SSF) {
        wb.SSF = dup(table_fmt);
      }
      if (wb && wb.SSF) {
        make_ssf();
        SSF_load_table(wb.SSF);
        o.revssf = evert_num(wb.SSF);
        o.revssf[wb.SSF[65535]] = 0;
        o.ssf = wb.SSF;
      }
      o.Strings = /*::((*/
      [];
      o.Strings.Count = 0;
      o.Strings.Unique = 0;
      fix_write_opts(o);
      o.cellXfs = [];
      get_cell_style(o.cellXfs, {}, { revssf: { "General": 0 } });
      if (!wb.Props)
        wb.Props = {};
      for (var i = 0; i < wb.SheetNames.length; ++i)
        bufs[bufs.length] = write_ws_biff8(i, o, wb);
      bufs.unshift(write_biff8_global(wb, bufs, o));
      return bconcat(bufs);
    }
    function write_biff_buf(wb, opts) {
      for (var i = 0; i <= wb.SheetNames.length; ++i) {
        var ws = wb.Sheets[wb.SheetNames[i]];
        if (!ws || !ws["!ref"])
          continue;
        var range = decode_range(ws["!ref"]);
        if (range.e.c > 255) {
          if (typeof console != "undefined" && console.error)
            console.error("Worksheet '" + wb.SheetNames[i] + "' extends beyond column IV (255).  Data may be lost.");
        }
      }
      var o = opts || {};
      switch (o.biff || 2) {
        case 8:
        case 5:
          return write_biff8_buf(wb, opts);
        case 4:
        case 3:
        case 2:
          return write_biff2_buf(wb, opts);
      }
      throw new Error("invalid type " + o.bookType + " for BIFF");
    }
    function make_html_row(ws, r, R, o) {
      var M = ws["!merges"] || [];
      var oo = [];
      for (var C = r.s.c; C <= r.e.c; ++C) {
        var RS = 0, CS = 0;
        for (var j = 0; j < M.length; ++j) {
          if (M[j].s.r > R || M[j].s.c > C)
            continue;
          if (M[j].e.r < R || M[j].e.c < C)
            continue;
          if (M[j].s.r < R || M[j].s.c < C) {
            RS = -1;
            break;
          }
          RS = M[j].e.r - M[j].s.r + 1;
          CS = M[j].e.c - M[j].s.c + 1;
          break;
        }
        if (RS < 0)
          continue;
        var coord = encode_cell({ r: R, c: C });
        var cell = o.dense ? (ws[R] || [])[C] : ws[coord];
        var w = cell && cell.v != null && (cell.h || escapehtml(cell.w || (format_cell(cell), cell.w) || "")) || "";
        var sp = {};
        if (RS > 1)
          sp.rowspan = RS;
        if (CS > 1)
          sp.colspan = CS;
        if (o.editable)
          w = '<span contenteditable="true">' + w + "</span>";
        else if (cell) {
          sp["data-t"] = cell && cell.t || "z";
          if (cell.v != null)
            sp["data-v"] = cell.v;
          if (cell.z != null)
            sp["data-z"] = cell.z;
          if (cell.l && (cell.l.Target || "#").charAt(0) != "#")
            w = '<a href="' + cell.l.Target + '">' + w + "</a>";
        }
        sp.id = (o.id || "sjs") + "-" + coord;
        oo.push(writextag("td", w, sp));
      }
      var preamble = "<tr>";
      return preamble + oo.join("") + "</tr>";
    }
    var HTML_BEGIN = '<html><head><meta charset="utf-8"/><title>SheetJS Table Export</title></head><body>';
    var HTML_END = "</body></html>";
    function make_html_preamble(ws, R, o) {
      var out = [];
      return out.join("") + "<table" + (o && o.id ? ' id="' + o.id + '"' : "") + ">";
    }
    function sheet_to_html(ws, opts) {
      var o = opts || {};
      var header = o.header != null ? o.header : HTML_BEGIN;
      var footer = o.footer != null ? o.footer : HTML_END;
      var out = [header];
      var r = decode_range(ws["!ref"]);
      o.dense = Array.isArray(ws);
      out.push(make_html_preamble(ws, r, o));
      for (var R = r.s.r; R <= r.e.r; ++R)
        out.push(make_html_row(ws, r, R, o));
      out.push("</table>" + footer);
      return out.join("");
    }
    function sheet_add_dom(ws, table, _opts) {
      var opts = _opts || {};
      var or_R = 0, or_C = 0;
      if (opts.origin != null) {
        if (typeof opts.origin == "number")
          or_R = opts.origin;
        else {
          var _origin = typeof opts.origin == "string" ? decode_cell(opts.origin) : opts.origin;
          or_R = _origin.r;
          or_C = _origin.c;
        }
      }
      var rows = table.getElementsByTagName("tr");
      var sheetRows = Math.min(opts.sheetRows || 1e7, rows.length);
      var range = { s: { r: 0, c: 0 }, e: { r: or_R, c: or_C } };
      if (ws["!ref"]) {
        var _range = decode_range(ws["!ref"]);
        range.s.r = Math.min(range.s.r, _range.s.r);
        range.s.c = Math.min(range.s.c, _range.s.c);
        range.e.r = Math.max(range.e.r, _range.e.r);
        range.e.c = Math.max(range.e.c, _range.e.c);
        if (or_R == -1)
          range.e.r = or_R = _range.e.r + 1;
      }
      var merges = [], midx = 0;
      var rowinfo = ws["!rows"] || (ws["!rows"] = []);
      var _R = 0, R = 0, _C = 0, C = 0, RS = 0, CS = 0;
      if (!ws["!cols"])
        ws["!cols"] = [];
      for (; _R < rows.length && R < sheetRows; ++_R) {
        var row = rows[_R];
        if (is_dom_element_hidden(row)) {
          if (opts.display)
            continue;
          rowinfo[R] = { hidden: true };
        }
        var elts = row.children;
        for (_C = C = 0; _C < elts.length; ++_C) {
          var elt = elts[_C];
          if (opts.display && is_dom_element_hidden(elt))
            continue;
          var v = elt.hasAttribute("data-v") ? elt.getAttribute("data-v") : elt.hasAttribute("v") ? elt.getAttribute("v") : htmldecode(elt.innerHTML);
          var z = elt.getAttribute("data-z") || elt.getAttribute("z");
          for (midx = 0; midx < merges.length; ++midx) {
            var m = merges[midx];
            if (m.s.c == C + or_C && m.s.r < R + or_R && R + or_R <= m.e.r) {
              C = m.e.c + 1 - or_C;
              midx = -1;
            }
          }
          CS = +elt.getAttribute("colspan") || 1;
          if ((RS = +elt.getAttribute("rowspan") || 1) > 1 || CS > 1)
            merges.push({ s: { r: R + or_R, c: C + or_C }, e: { r: R + or_R + (RS || 1) - 1, c: C + or_C + (CS || 1) - 1 } });
          var o = { t: "s", v };
          var _t = elt.getAttribute("data-t") || elt.getAttribute("t") || "";
          if (v != null) {
            if (v.length == 0)
              o.t = _t || "z";
            else if (opts.raw || v.trim().length == 0 || _t == "s")
              ;
            else if (v === "TRUE")
              o = { t: "b", v: true };
            else if (v === "FALSE")
              o = { t: "b", v: false };
            else if (!isNaN(fuzzynum(v)))
              o = { t: "n", v: fuzzynum(v) };
            else if (!isNaN(fuzzydate(v).getDate())) {
              o = { t: "d", v: parseDate(v) };
              if (!opts.cellDates)
                o = { t: "n", v: datenum(o.v) };
              o.z = opts.dateNF || table_fmt[14];
            }
          }
          if (o.z === void 0 && z != null)
            o.z = z;
          var l2 = "", Aelts = elt.getElementsByTagName("A");
          if (Aelts && Aelts.length) {
            for (var Aelti = 0; Aelti < Aelts.length; ++Aelti)
              if (Aelts[Aelti].hasAttribute("href")) {
                l2 = Aelts[Aelti].getAttribute("href");
                if (l2.charAt(0) != "#")
                  break;
              }
          }
          if (l2 && l2.charAt(0) != "#")
            o.l = { Target: l2 };
          if (opts.dense) {
            if (!ws[R + or_R])
              ws[R + or_R] = [];
            ws[R + or_R][C + or_C] = o;
          } else
            ws[encode_cell({ c: C + or_C, r: R + or_R })] = o;
          if (range.e.c < C + or_C)
            range.e.c = C + or_C;
          C += CS;
        }
        ++R;
      }
      if (merges.length)
        ws["!merges"] = (ws["!merges"] || []).concat(merges);
      range.e.r = Math.max(range.e.r, R - 1 + or_R);
      ws["!ref"] = encode_range(range);
      if (R >= sheetRows)
        ws["!fullref"] = encode_range((range.e.r = rows.length - _R + R - 1 + or_R, range));
      return ws;
    }
    function parse_dom_table(table, _opts) {
      var opts = _opts || {};
      var ws = opts.dense ? [] : {};
      return sheet_add_dom(ws, table, _opts);
    }
    function table_to_book(table, opts) {
      return sheet_to_workbook(parse_dom_table(table, opts), opts);
    }
    function is_dom_element_hidden(element) {
      var display = "";
      var get_computed_style = get_get_computed_style_function(element);
      if (get_computed_style)
        display = get_computed_style(element).getPropertyValue("display");
      if (!display)
        display = element.style && element.style.display;
      return display === "none";
    }
    function get_get_computed_style_function(element) {
      if (element.ownerDocument.defaultView && typeof element.ownerDocument.defaultView.getComputedStyle === "function")
        return element.ownerDocument.defaultView.getComputedStyle;
      if (typeof getComputedStyle === "function")
        return getComputedStyle;
      return null;
    }
    var write_styles_ods = /* @__PURE__ */ function() {
      var master_styles = [
        "<office:master-styles>",
        '<style:master-page style:name="mp1" style:page-layout-name="mp1">',
        "<style:header/>",
        '<style:header-left style:display="false"/>',
        "<style:footer/>",
        '<style:footer-left style:display="false"/>',
        "</style:master-page>",
        "</office:master-styles>"
      ].join("");
      var payload = "<office:document-styles " + wxt_helper({
        "xmlns:office": "urn:oasis:names:tc:opendocument:xmlns:office:1.0",
        "xmlns:table": "urn:oasis:names:tc:opendocument:xmlns:table:1.0",
        "xmlns:style": "urn:oasis:names:tc:opendocument:xmlns:style:1.0",
        "xmlns:text": "urn:oasis:names:tc:opendocument:xmlns:text:1.0",
        "xmlns:draw": "urn:oasis:names:tc:opendocument:xmlns:drawing:1.0",
        "xmlns:fo": "urn:oasis:names:tc:opendocument:xmlns:xsl-fo-compatible:1.0",
        "xmlns:xlink": "http://www.w3.org/1999/xlink",
        "xmlns:dc": "http://purl.org/dc/elements/1.1/",
        "xmlns:number": "urn:oasis:names:tc:opendocument:xmlns:datastyle:1.0",
        "xmlns:svg": "urn:oasis:names:tc:opendocument:xmlns:svg-compatible:1.0",
        "xmlns:of": "urn:oasis:names:tc:opendocument:xmlns:of:1.2",
        "office:version": "1.2"
      }) + ">" + master_styles + "</office:document-styles>";
      return function wso() {
        return XML_HEADER + payload;
      };
    }();
    var write_content_ods = /* @__PURE__ */ function() {
      var write_text_p = function(text) {
        return escapexml(text).replace(/  +/g, function($$) {
          return '<text:s text:c="' + $$.length + '"/>';
        }).replace(/\t/g, "<text:tab/>").replace(/\n/g, "</text:p><text:p>").replace(/^ /, "<text:s/>").replace(/ $/, "<text:s/>");
      };
      var null_cell_xml = "          <table:table-cell />\n";
      var covered_cell_xml = "          <table:covered-table-cell/>\n";
      var write_ws2 = function(ws, wb, i) {
        var o = [];
        o.push('      <table:table table:name="' + escapexml(wb.SheetNames[i]) + '" table:style-name="ta1">\n');
        var R = 0, C = 0, range = decode_range(ws["!ref"] || "A1");
        var marr = ws["!merges"] || [], mi = 0;
        var dense = Array.isArray(ws);
        if (ws["!cols"]) {
          for (C = 0; C <= range.e.c; ++C)
            o.push("        <table:table-column" + (ws["!cols"][C] ? ' table:style-name="co' + ws["!cols"][C].ods + '"' : "") + "></table:table-column>\n");
        }
        var H = "", ROWS = ws["!rows"] || [];
        for (R = 0; R < range.s.r; ++R) {
          H = ROWS[R] ? ' table:style-name="ro' + ROWS[R].ods + '"' : "";
          o.push("        <table:table-row" + H + "></table:table-row>\n");
        }
        for (; R <= range.e.r; ++R) {
          H = ROWS[R] ? ' table:style-name="ro' + ROWS[R].ods + '"' : "";
          o.push("        <table:table-row" + H + ">\n");
          for (C = 0; C < range.s.c; ++C)
            o.push(null_cell_xml);
          for (; C <= range.e.c; ++C) {
            var skip = false, ct = {}, textp = "";
            for (mi = 0; mi != marr.length; ++mi) {
              if (marr[mi].s.c > C)
                continue;
              if (marr[mi].s.r > R)
                continue;
              if (marr[mi].e.c < C)
                continue;
              if (marr[mi].e.r < R)
                continue;
              if (marr[mi].s.c != C || marr[mi].s.r != R)
                skip = true;
              ct["table:number-columns-spanned"] = marr[mi].e.c - marr[mi].s.c + 1;
              ct["table:number-rows-spanned"] = marr[mi].e.r - marr[mi].s.r + 1;
              break;
            }
            if (skip) {
              o.push(covered_cell_xml);
              continue;
            }
            var ref = encode_cell({ r: R, c: C }), cell = dense ? (ws[R] || [])[C] : ws[ref];
            if (cell && cell.f) {
              ct["table:formula"] = escapexml(csf_to_ods_formula(cell.f));
              if (cell.F) {
                if (cell.F.slice(0, ref.length) == ref) {
                  var _Fref = decode_range(cell.F);
                  ct["table:number-matrix-columns-spanned"] = _Fref.e.c - _Fref.s.c + 1;
                  ct["table:number-matrix-rows-spanned"] = _Fref.e.r - _Fref.s.r + 1;
                }
              }
            }
            if (!cell) {
              o.push(null_cell_xml);
              continue;
            }
            switch (cell.t) {
              case "b":
                textp = cell.v ? "TRUE" : "FALSE";
                ct["office:value-type"] = "boolean";
                ct["office:boolean-value"] = cell.v ? "true" : "false";
                break;
              case "n":
                textp = cell.w || String(cell.v || 0);
                ct["office:value-type"] = "float";
                ct["office:value"] = cell.v || 0;
                break;
              case "s":
              case "str":
                textp = cell.v == null ? "" : cell.v;
                ct["office:value-type"] = "string";
                break;
              case "d":
                textp = cell.w || parseDate(cell.v).toISOString();
                ct["office:value-type"] = "date";
                ct["office:date-value"] = parseDate(cell.v).toISOString();
                ct["table:style-name"] = "ce1";
                break;
              default:
                o.push(null_cell_xml);
                continue;
            }
            var text_p = write_text_p(textp);
            if (cell.l && cell.l.Target) {
              var _tgt = cell.l.Target;
              _tgt = _tgt.charAt(0) == "#" ? "#" + csf_to_ods_3D(_tgt.slice(1)) : _tgt;
              if (_tgt.charAt(0) != "#" && !_tgt.match(/^\w+:/))
                _tgt = "../" + _tgt;
              text_p = writextag("text:a", text_p, { "xlink:href": _tgt.replace(/&/g, "&amp;") });
            }
            o.push("          " + writextag("table:table-cell", writextag("text:p", text_p, {}), ct) + "\n");
          }
          o.push("        </table:table-row>\n");
        }
        o.push("      </table:table>\n");
        return o.join("");
      };
      var write_automatic_styles_ods = function(o, wb) {
        o.push(" <office:automatic-styles>\n");
        o.push('  <number:date-style style:name="N37" number:automatic-order="true">\n');
        o.push('   <number:month number:style="long"/>\n');
        o.push("   <number:text>/</number:text>\n");
        o.push('   <number:day number:style="long"/>\n');
        o.push("   <number:text>/</number:text>\n");
        o.push("   <number:year/>\n");
        o.push("  </number:date-style>\n");
        var cidx = 0;
        wb.SheetNames.map(function(n) {
          return wb.Sheets[n];
        }).forEach(function(ws) {
          if (!ws)
            return;
          if (ws["!cols"]) {
            for (var C = 0; C < ws["!cols"].length; ++C)
              if (ws["!cols"][C]) {
                var colobj = ws["!cols"][C];
                if (colobj.width == null && colobj.wpx == null && colobj.wch == null)
                  continue;
                process_col(colobj);
                colobj.ods = cidx;
                var w = ws["!cols"][C].wpx + "px";
                o.push('  <style:style style:name="co' + cidx + '" style:family="table-column">\n');
                o.push('   <style:table-column-properties fo:break-before="auto" style:column-width="' + w + '"/>\n');
                o.push("  </style:style>\n");
                ++cidx;
              }
          }
        });
        var ridx = 0;
        wb.SheetNames.map(function(n) {
          return wb.Sheets[n];
        }).forEach(function(ws) {
          if (!ws)
            return;
          if (ws["!rows"]) {
            for (var R = 0; R < ws["!rows"].length; ++R)
              if (ws["!rows"][R]) {
                ws["!rows"][R].ods = ridx;
                var h = ws["!rows"][R].hpx + "px";
                o.push('  <style:style style:name="ro' + ridx + '" style:family="table-row">\n');
                o.push('   <style:table-row-properties fo:break-before="auto" style:row-height="' + h + '"/>\n');
                o.push("  </style:style>\n");
                ++ridx;
              }
          }
        });
        o.push('  <style:style style:name="ta1" style:family="table" style:master-page-name="mp1">\n');
        o.push('   <style:table-properties table:display="true" style:writing-mode="lr-tb"/>\n');
        o.push("  </style:style>\n");
        o.push('  <style:style style:name="ce1" style:family="table-cell" style:parent-style-name="Default" style:data-style-name="N37"/>\n');
        o.push(" </office:automatic-styles>\n");
      };
      return function wcx(wb, opts) {
        var o = [XML_HEADER];
        var attr = wxt_helper({
          "xmlns:office": "urn:oasis:names:tc:opendocument:xmlns:office:1.0",
          "xmlns:table": "urn:oasis:names:tc:opendocument:xmlns:table:1.0",
          "xmlns:style": "urn:oasis:names:tc:opendocument:xmlns:style:1.0",
          "xmlns:text": "urn:oasis:names:tc:opendocument:xmlns:text:1.0",
          "xmlns:draw": "urn:oasis:names:tc:opendocument:xmlns:drawing:1.0",
          "xmlns:fo": "urn:oasis:names:tc:opendocument:xmlns:xsl-fo-compatible:1.0",
          "xmlns:xlink": "http://www.w3.org/1999/xlink",
          "xmlns:dc": "http://purl.org/dc/elements/1.1/",
          "xmlns:meta": "urn:oasis:names:tc:opendocument:xmlns:meta:1.0",
          "xmlns:number": "urn:oasis:names:tc:opendocument:xmlns:datastyle:1.0",
          "xmlns:presentation": "urn:oasis:names:tc:opendocument:xmlns:presentation:1.0",
          "xmlns:svg": "urn:oasis:names:tc:opendocument:xmlns:svg-compatible:1.0",
          "xmlns:chart": "urn:oasis:names:tc:opendocument:xmlns:chart:1.0",
          "xmlns:dr3d": "urn:oasis:names:tc:opendocument:xmlns:dr3d:1.0",
          "xmlns:math": "http://www.w3.org/1998/Math/MathML",
          "xmlns:form": "urn:oasis:names:tc:opendocument:xmlns:form:1.0",
          "xmlns:script": "urn:oasis:names:tc:opendocument:xmlns:script:1.0",
          "xmlns:ooo": "http://openoffice.org/2004/office",
          "xmlns:ooow": "http://openoffice.org/2004/writer",
          "xmlns:oooc": "http://openoffice.org/2004/calc",
          "xmlns:dom": "http://www.w3.org/2001/xml-events",
          "xmlns:xforms": "http://www.w3.org/2002/xforms",
          "xmlns:xsd": "http://www.w3.org/2001/XMLSchema",
          "xmlns:xsi": "http://www.w3.org/2001/XMLSchema-instance",
          "xmlns:sheet": "urn:oasis:names:tc:opendocument:sh33tjs:1.0",
          "xmlns:rpt": "http://openoffice.org/2005/report",
          "xmlns:of": "urn:oasis:names:tc:opendocument:xmlns:of:1.2",
          "xmlns:xhtml": "http://www.w3.org/1999/xhtml",
          "xmlns:grddl": "http://www.w3.org/2003/g/data-view#",
          "xmlns:tableooo": "http://openoffice.org/2009/table",
          "xmlns:drawooo": "http://openoffice.org/2010/draw",
          "xmlns:calcext": "urn:org:documentfoundation:names:experimental:calc:xmlns:calcext:1.0",
          "xmlns:loext": "urn:org:documentfoundation:names:experimental:office:xmlns:loext:1.0",
          "xmlns:field": "urn:openoffice:names:experimental:ooo-ms-interop:xmlns:field:1.0",
          "xmlns:formx": "urn:openoffice:names:experimental:ooxml-odf-interop:xmlns:form:1.0",
          "xmlns:css3t": "http://www.w3.org/TR/css3-text/",
          "office:version": "1.2"
        });
        var fods = wxt_helper({
          "xmlns:config": "urn:oasis:names:tc:opendocument:xmlns:config:1.0",
          "office:mimetype": "application/vnd.oasis.opendocument.spreadsheet"
        });
        if (opts.bookType == "fods") {
          o.push("<office:document" + attr + fods + ">\n");
          o.push(write_meta_ods().replace(/office:document-meta/g, "office:meta"));
        } else
          o.push("<office:document-content" + attr + ">\n");
        write_automatic_styles_ods(o, wb);
        o.push("  <office:body>\n");
        o.push("    <office:spreadsheet>\n");
        for (var i = 0; i != wb.SheetNames.length; ++i)
          o.push(write_ws2(wb.Sheets[wb.SheetNames[i]], wb, i));
        o.push("    </office:spreadsheet>\n");
        o.push("  </office:body>\n");
        if (opts.bookType == "fods")
          o.push("</office:document>");
        else
          o.push("</office:document-content>");
        return o.join("");
      };
    }();
    function write_ods(wb, opts) {
      if (opts.bookType == "fods")
        return write_content_ods(wb, opts);
      var zip = zip_new();
      var f = "";
      var manifest = [];
      var rdf = [];
      f = "mimetype";
      zip_add_file(zip, f, "application/vnd.oasis.opendocument.spreadsheet");
      f = "content.xml";
      zip_add_file(zip, f, write_content_ods(wb, opts));
      manifest.push([f, "text/xml"]);
      rdf.push([f, "ContentFile"]);
      f = "styles.xml";
      zip_add_file(zip, f, write_styles_ods(wb, opts));
      manifest.push([f, "text/xml"]);
      rdf.push([f, "StylesFile"]);
      f = "meta.xml";
      zip_add_file(zip, f, XML_HEADER + write_meta_ods(
        /*::wb, opts*/
      ));
      manifest.push([f, "text/xml"]);
      rdf.push([f, "MetadataFile"]);
      f = "manifest.rdf";
      zip_add_file(zip, f, write_rdf(
        rdf
        /*, opts*/
      ));
      manifest.push([f, "application/rdf+xml"]);
      f = "META-INF/manifest.xml";
      zip_add_file(zip, f, write_manifest(
        manifest
        /*, opts*/
      ));
      return zip;
    }
    function u8_to_dataview(array) {
      return new DataView(array.buffer, array.byteOffset, array.byteLength);
    }
    function stru8(str) {
      return typeof TextEncoder != "undefined" ? new TextEncoder().encode(str) : s2a(utf8write(str));
    }
    function u8contains(body, search) {
      outer:
        for (var L = 0; L <= body.length - search.length; ++L) {
          for (var j = 0; j < search.length; ++j)
            if (body[L + j] != search[j])
              continue outer;
          return true;
        }
      return false;
    }
    function u8concat(u8a) {
      var len = u8a.reduce(function(acc, x) {
        return acc + x.length;
      }, 0);
      var out = new Uint8Array(len);
      var off = 0;
      u8a.forEach(function(u8) {
        out.set(u8, off);
        off += u8.length;
      });
      return out;
    }
    function writeDecimal128LE(buf, offset, value) {
      var exp = Math.floor(value == 0 ? 0 : Math.LOG10E * Math.log(Math.abs(value))) + 6176 - 20;
      var mantissa = value / Math.pow(10, exp - 6176);
      buf[offset + 15] |= exp >> 7;
      buf[offset + 14] |= (exp & 127) << 1;
      for (var i = 0; mantissa >= 1; ++i, mantissa /= 256)
        buf[offset + i] = mantissa & 255;
      buf[offset + 15] |= value >= 0 ? 0 : 128;
    }
    function parse_varint49(buf, ptr) {
      var l2 = ptr ? ptr[0] : 0;
      var usz = buf[l2] & 127;
      varint:
        if (buf[l2++] >= 128) {
          usz |= (buf[l2] & 127) << 7;
          if (buf[l2++] < 128)
            break varint;
          usz |= (buf[l2] & 127) << 14;
          if (buf[l2++] < 128)
            break varint;
          usz |= (buf[l2] & 127) << 21;
          if (buf[l2++] < 128)
            break varint;
          usz += (buf[l2] & 127) * Math.pow(2, 28);
          ++l2;
          if (buf[l2++] < 128)
            break varint;
          usz += (buf[l2] & 127) * Math.pow(2, 35);
          ++l2;
          if (buf[l2++] < 128)
            break varint;
          usz += (buf[l2] & 127) * Math.pow(2, 42);
          ++l2;
          if (buf[l2++] < 128)
            break varint;
        }
      if (ptr)
        ptr[0] = l2;
      return usz;
    }
    function write_varint49(v) {
      var usz = new Uint8Array(7);
      usz[0] = v & 127;
      var L = 1;
      sz:
        if (v > 127) {
          usz[L - 1] |= 128;
          usz[L] = v >> 7 & 127;
          ++L;
          if (v <= 16383)
            break sz;
          usz[L - 1] |= 128;
          usz[L] = v >> 14 & 127;
          ++L;
          if (v <= 2097151)
            break sz;
          usz[L - 1] |= 128;
          usz[L] = v >> 21 & 127;
          ++L;
          if (v <= 268435455)
            break sz;
          usz[L - 1] |= 128;
          usz[L] = v / 256 >>> 21 & 127;
          ++L;
          if (v <= 34359738367)
            break sz;
          usz[L - 1] |= 128;
          usz[L] = v / 65536 >>> 21 & 127;
          ++L;
          if (v <= 4398046511103)
            break sz;
          usz[L - 1] |= 128;
          usz[L] = v / 16777216 >>> 21 & 127;
          ++L;
        }
      return usz.slice(0, L);
    }
    function varint_to_i32(buf) {
      var l2 = 0, i32 = buf[l2] & 127;
      varint:
        if (buf[l2++] >= 128) {
          i32 |= (buf[l2] & 127) << 7;
          if (buf[l2++] < 128)
            break varint;
          i32 |= (buf[l2] & 127) << 14;
          if (buf[l2++] < 128)
            break varint;
          i32 |= (buf[l2] & 127) << 21;
          if (buf[l2++] < 128)
            break varint;
          i32 |= (buf[l2] & 127) << 28;
        }
      return i32;
    }
    function parse_shallow(buf) {
      var out = [], ptr = [0];
      while (ptr[0] < buf.length) {
        var off = ptr[0];
        var num = parse_varint49(buf, ptr);
        var type = num & 7;
        num = Math.floor(num / 8);
        var len = 0;
        var res;
        if (num == 0)
          break;
        switch (type) {
          case 0:
            {
              var l2 = ptr[0];
              while (buf[ptr[0]++] >= 128)
                ;
              res = buf.slice(l2, ptr[0]);
            }
            break;
          case 5:
            len = 4;
            res = buf.slice(ptr[0], ptr[0] + len);
            ptr[0] += len;
            break;
          case 1:
            len = 8;
            res = buf.slice(ptr[0], ptr[0] + len);
            ptr[0] += len;
            break;
          case 2:
            len = parse_varint49(buf, ptr);
            res = buf.slice(ptr[0], ptr[0] + len);
            ptr[0] += len;
            break;
          case 3:
          case 4:
          default:
            throw new Error("PB Type ".concat(type, " for Field ").concat(num, " at offset ").concat(off));
        }
        var v = { data: res, type };
        if (out[num] == null)
          out[num] = [v];
        else
          out[num].push(v);
      }
      return out;
    }
    function write_shallow(proto) {
      var out = [];
      proto.forEach(function(field, idx) {
        field.forEach(function(item) {
          if (!item.data)
            return;
          out.push(write_varint49(idx * 8 + item.type));
          if (item.type == 2)
            out.push(write_varint49(item.data.length));
          out.push(item.data);
        });
      });
      return u8concat(out);
    }
    function parse_iwa_file(buf) {
      var _a;
      var out = [], ptr = [0];
      while (ptr[0] < buf.length) {
        var len = parse_varint49(buf, ptr);
        var ai = parse_shallow(buf.slice(ptr[0], ptr[0] + len));
        ptr[0] += len;
        var res = {
          id: varint_to_i32(ai[1][0].data),
          messages: []
        };
        ai[2].forEach(function(b) {
          var mi = parse_shallow(b.data);
          var fl = varint_to_i32(mi[3][0].data);
          res.messages.push({
            meta: mi,
            data: buf.slice(ptr[0], ptr[0] + fl)
          });
          ptr[0] += fl;
        });
        if ((_a = ai[3]) == null ? void 0 : _a[0])
          res.merge = varint_to_i32(ai[3][0].data) >>> 0 > 0;
        out.push(res);
      }
      return out;
    }
    function write_iwa_file(ias) {
      var bufs = [];
      ias.forEach(function(ia) {
        var ai = [];
        ai[1] = [{ data: write_varint49(ia.id), type: 0 }];
        ai[2] = [];
        if (ia.merge != null)
          ai[3] = [{ data: write_varint49(+!!ia.merge), type: 0 }];
        var midata = [];
        ia.messages.forEach(function(mi) {
          midata.push(mi.data);
          mi.meta[3] = [{ type: 0, data: write_varint49(mi.data.length) }];
          ai[2].push({ data: write_shallow(mi.meta), type: 2 });
        });
        var aipayload = write_shallow(ai);
        bufs.push(write_varint49(aipayload.length));
        bufs.push(aipayload);
        midata.forEach(function(mid) {
          return bufs.push(mid);
        });
      });
      return u8concat(bufs);
    }
    function parse_snappy_chunk(type, buf) {
      if (type != 0)
        throw new Error("Unexpected Snappy chunk type ".concat(type));
      var ptr = [0];
      var usz = parse_varint49(buf, ptr);
      var chunks = [];
      while (ptr[0] < buf.length) {
        var tag = buf[ptr[0]] & 3;
        if (tag == 0) {
          var len = buf[ptr[0]++] >> 2;
          if (len < 60)
            ++len;
          else {
            var c = len - 59;
            len = buf[ptr[0]];
            if (c > 1)
              len |= buf[ptr[0] + 1] << 8;
            if (c > 2)
              len |= buf[ptr[0] + 2] << 16;
            if (c > 3)
              len |= buf[ptr[0] + 3] << 24;
            len >>>= 0;
            len++;
            ptr[0] += c;
          }
          chunks.push(buf.slice(ptr[0], ptr[0] + len));
          ptr[0] += len;
          continue;
        } else {
          var offset = 0, length = 0;
          if (tag == 1) {
            length = (buf[ptr[0]] >> 2 & 7) + 4;
            offset = (buf[ptr[0]++] & 224) << 3;
            offset |= buf[ptr[0]++];
          } else {
            length = (buf[ptr[0]++] >> 2) + 1;
            if (tag == 2) {
              offset = buf[ptr[0]] | buf[ptr[0] + 1] << 8;
              ptr[0] += 2;
            } else {
              offset = (buf[ptr[0]] | buf[ptr[0] + 1] << 8 | buf[ptr[0] + 2] << 16 | buf[ptr[0] + 3] << 24) >>> 0;
              ptr[0] += 4;
            }
          }
          chunks = [u8concat(chunks)];
          if (offset == 0)
            throw new Error("Invalid offset 0");
          if (offset > chunks[0].length)
            throw new Error("Invalid offset beyond length");
          if (length >= offset) {
            chunks.push(chunks[0].slice(-offset));
            length -= offset;
            while (length >= chunks[chunks.length - 1].length) {
              chunks.push(chunks[chunks.length - 1]);
              length -= chunks[chunks.length - 1].length;
            }
          }
          chunks.push(chunks[0].slice(-offset, -offset + length));
        }
      }
      var o = u8concat(chunks);
      if (o.length != usz)
        throw new Error("Unexpected length: ".concat(o.length, " != ").concat(usz));
      return o;
    }
    function decompress_iwa_file(buf) {
      var out = [];
      var l2 = 0;
      while (l2 < buf.length) {
        var t = buf[l2++];
        var len = buf[l2] | buf[l2 + 1] << 8 | buf[l2 + 2] << 16;
        l2 += 3;
        out.push(parse_snappy_chunk(t, buf.slice(l2, l2 + len)));
        l2 += len;
      }
      if (l2 !== buf.length)
        throw new Error("data is not a valid framed stream!");
      return u8concat(out);
    }
    function compress_iwa_file(buf) {
      var out = [];
      var l2 = 0;
      while (l2 < buf.length) {
        var c = Math.min(buf.length - l2, 268435455);
        var frame = new Uint8Array(4);
        out.push(frame);
        var usz = write_varint49(c);
        var L = usz.length;
        out.push(usz);
        if (c <= 60) {
          L++;
          out.push(new Uint8Array([c - 1 << 2]));
        } else if (c <= 256) {
          L += 2;
          out.push(new Uint8Array([240, c - 1 & 255]));
        } else if (c <= 65536) {
          L += 3;
          out.push(new Uint8Array([244, c - 1 & 255, c - 1 >> 8 & 255]));
        } else if (c <= 16777216) {
          L += 4;
          out.push(new Uint8Array([248, c - 1 & 255, c - 1 >> 8 & 255, c - 1 >> 16 & 255]));
        } else if (c <= 4294967296) {
          L += 5;
          out.push(new Uint8Array([252, c - 1 & 255, c - 1 >> 8 & 255, c - 1 >> 16 & 255, c - 1 >>> 24 & 255]));
        }
        out.push(buf.slice(l2, l2 + c));
        L += c;
        frame[0] = 0;
        frame[1] = L & 255;
        frame[2] = L >> 8 & 255;
        frame[3] = L >> 16 & 255;
        l2 += c;
      }
      return u8concat(out);
    }
    function write_new_storage(cell, sst) {
      var out = new Uint8Array(32), dv = u8_to_dataview(out), l2 = 12, flags = 0;
      out[0] = 5;
      switch (cell.t) {
        case "n":
          out[1] = 2;
          writeDecimal128LE(out, l2, cell.v);
          flags |= 1;
          l2 += 16;
          break;
        case "b":
          out[1] = 6;
          dv.setFloat64(l2, cell.v ? 1 : 0, true);
          flags |= 2;
          l2 += 8;
          break;
        case "s":
          if (sst.indexOf(cell.v) == -1)
            throw new Error("Value ".concat(cell.v, " missing from SST!"));
          out[1] = 3;
          dv.setUint32(l2, sst.indexOf(cell.v), true);
          flags |= 8;
          l2 += 4;
          break;
        default:
          throw "unsupported cell type " + cell.t;
      }
      dv.setUint32(8, flags, true);
      return out.slice(0, l2);
    }
    function write_old_storage(cell, sst) {
      var out = new Uint8Array(32), dv = u8_to_dataview(out), l2 = 12, flags = 0;
      out[0] = 3;
      switch (cell.t) {
        case "n":
          out[2] = 2;
          dv.setFloat64(l2, cell.v, true);
          flags |= 32;
          l2 += 8;
          break;
        case "b":
          out[2] = 6;
          dv.setFloat64(l2, cell.v ? 1 : 0, true);
          flags |= 32;
          l2 += 8;
          break;
        case "s":
          if (sst.indexOf(cell.v) == -1)
            throw new Error("Value ".concat(cell.v, " missing from SST!"));
          out[2] = 3;
          dv.setUint32(l2, sst.indexOf(cell.v), true);
          flags |= 16;
          l2 += 4;
          break;
        default:
          throw "unsupported cell type " + cell.t;
      }
      dv.setUint32(4, flags, true);
      return out.slice(0, l2);
    }
    function parse_TSP_Reference(buf) {
      var pb = parse_shallow(buf);
      return parse_varint49(pb[1][0].data);
    }
    function write_tile_row(tri, data, SST) {
      var _a, _b, _c, _d;
      if (!((_a = tri[6]) == null ? void 0 : _a[0]) || !((_b = tri[7]) == null ? void 0 : _b[0]))
        throw "Mutation only works on post-BNC storages!";
      var wide_offsets = ((_d = (_c = tri[8]) == null ? void 0 : _c[0]) == null ? void 0 : _d.data) && varint_to_i32(tri[8][0].data) > 0 || false;
      if (wide_offsets)
        throw "Math only works with normal offsets";
      var cnt = 0;
      var dv = u8_to_dataview(tri[7][0].data), last_offset = 0, cell_storage = [];
      var _dv = u8_to_dataview(tri[4][0].data), _last_offset = 0, _cell_storage = [];
      for (var C = 0; C < data.length; ++C) {
        if (data[C] == null) {
          dv.setUint16(C * 2, 65535, true);
          _dv.setUint16(C * 2, 65535);
          continue;
        }
        dv.setUint16(C * 2, last_offset, true);
        _dv.setUint16(C * 2, _last_offset, true);
        var celload, _celload;
        switch (typeof data[C]) {
          case "string":
            celload = write_new_storage({ t: "s", v: data[C] }, SST);
            _celload = write_old_storage({ t: "s", v: data[C] }, SST);
            break;
          case "number":
            celload = write_new_storage({ t: "n", v: data[C] }, SST);
            _celload = write_old_storage({ t: "n", v: data[C] }, SST);
            break;
          case "boolean":
            celload = write_new_storage({ t: "b", v: data[C] }, SST);
            _celload = write_old_storage({ t: "b", v: data[C] }, SST);
            break;
          default:
            throw new Error("Unsupported value " + data[C]);
        }
        cell_storage.push(celload);
        last_offset += celload.length;
        _cell_storage.push(_celload);
        _last_offset += _celload.length;
        ++cnt;
      }
      tri[2][0].data = write_varint49(cnt);
      for (; C < tri[7][0].data.length / 2; ++C) {
        dv.setUint16(C * 2, 65535, true);
        _dv.setUint16(C * 2, 65535, true);
      }
      tri[6][0].data = u8concat(cell_storage);
      tri[3][0].data = u8concat(_cell_storage);
      return cnt;
    }
    function write_numbers_iwa(wb, opts) {
      if (!opts || !opts.numbers)
        throw new Error("Must pass a `numbers` option -- check the README");
      var ws = wb.Sheets[wb.SheetNames[0]];
      if (wb.SheetNames.length > 1)
        console.error("The Numbers writer currently writes only the first table");
      var range = decode_range(ws["!ref"]);
      range.s.r = range.s.c = 0;
      var trunc = false;
      if (range.e.c > 9) {
        trunc = true;
        range.e.c = 9;
      }
      if (range.e.r > 49) {
        trunc = true;
        range.e.r = 49;
      }
      if (trunc)
        console.error("The Numbers writer is currently limited to ".concat(encode_range(range)));
      var data = sheet_to_json(ws, { range, header: 1 });
      var SST = ["~Sh33tJ5~"];
      data.forEach(function(row) {
        return row.forEach(function(cell) {
          if (typeof cell == "string")
            SST.push(cell);
        });
      });
      var dependents = {};
      var indices = [];
      var cfb = CFB.read(opts.numbers, { type: "base64" });
      cfb.FileIndex.map(function(fi, idx) {
        return [fi, cfb.FullPaths[idx]];
      }).forEach(function(row) {
        var fi = row[0], fp = row[1];
        if (fi.type != 2)
          return;
        if (!fi.name.match(/\.iwa/))
          return;
        var old_content = fi.content;
        var raw1 = decompress_iwa_file(old_content);
        var x2 = parse_iwa_file(raw1);
        x2.forEach(function(packet2) {
          indices.push(packet2.id);
          dependents[packet2.id] = { deps: [], location: fp, type: varint_to_i32(packet2.messages[0].meta[1][0].data) };
        });
      });
      indices.sort(function(x2, y2) {
        return x2 - y2;
      });
      var indices_varint = indices.filter(function(x2) {
        return x2 > 1;
      }).map(function(x2) {
        return [x2, write_varint49(x2)];
      });
      cfb.FileIndex.map(function(fi, idx) {
        return [fi, cfb.FullPaths[idx]];
      }).forEach(function(row) {
        var fi = row[0];
        row[1];
        if (!fi.name.match(/\.iwa/))
          return;
        var x2 = parse_iwa_file(decompress_iwa_file(fi.content));
        x2.forEach(function(ia) {
          ia.messages.forEach(function(m) {
            indices_varint.forEach(function(ivi) {
              if (ia.messages.some(function(mess) {
                return varint_to_i32(mess.meta[1][0].data) != 11006 && u8contains(mess.data, ivi[1]);
              })) {
                dependents[ivi[0]].deps.push(ia.id);
              }
            });
          });
        });
      });
      var entry = CFB.find(cfb, dependents[1].location);
      var x = parse_iwa_file(decompress_iwa_file(entry.content));
      var docroot;
      for (var xi = 0; xi < x.length; ++xi) {
        var packet = x[xi];
        if (packet.id == 1)
          docroot = packet;
      }
      var sheetrootref = parse_TSP_Reference(parse_shallow(docroot.messages[0].data)[1][0].data);
      entry = CFB.find(cfb, dependents[sheetrootref].location);
      x = parse_iwa_file(decompress_iwa_file(entry.content));
      for (xi = 0; xi < x.length; ++xi) {
        packet = x[xi];
        if (packet.id == sheetrootref)
          docroot = packet;
      }
      sheetrootref = parse_TSP_Reference(parse_shallow(docroot.messages[0].data)[2][0].data);
      entry = CFB.find(cfb, dependents[sheetrootref].location);
      x = parse_iwa_file(decompress_iwa_file(entry.content));
      for (xi = 0; xi < x.length; ++xi) {
        packet = x[xi];
        if (packet.id == sheetrootref)
          docroot = packet;
      }
      sheetrootref = parse_TSP_Reference(parse_shallow(docroot.messages[0].data)[2][0].data);
      entry = CFB.find(cfb, dependents[sheetrootref].location);
      x = parse_iwa_file(decompress_iwa_file(entry.content));
      for (xi = 0; xi < x.length; ++xi) {
        packet = x[xi];
        if (packet.id == sheetrootref)
          docroot = packet;
      }
      var pb = parse_shallow(docroot.messages[0].data);
      {
        pb[6][0].data = write_varint49(range.e.r + 1);
        pb[7][0].data = write_varint49(range.e.c + 1);
        var cruidsref = parse_TSP_Reference(pb[46][0].data);
        var oldbucket = CFB.find(cfb, dependents[cruidsref].location);
        var _x = parse_iwa_file(decompress_iwa_file(oldbucket.content));
        {
          for (var j = 0; j < _x.length; ++j) {
            if (_x[j].id == cruidsref)
              break;
          }
          if (_x[j].id != cruidsref)
            throw "Bad ColumnRowUIDMapArchive";
          var cruids = parse_shallow(_x[j].messages[0].data);
          cruids[1] = [];
          cruids[2] = [], cruids[3] = [];
          for (var C = 0; C <= range.e.c; ++C) {
            var uuid = [];
            uuid[1] = uuid[2] = [{ type: 0, data: write_varint49(C + 420690) }];
            cruids[1].push({ type: 2, data: write_shallow(uuid) });
            cruids[2].push({ type: 0, data: write_varint49(C) });
            cruids[3].push({ type: 0, data: write_varint49(C) });
          }
          cruids[4] = [];
          cruids[5] = [], cruids[6] = [];
          for (var R = 0; R <= range.e.r; ++R) {
            uuid = [];
            uuid[1] = uuid[2] = [{ type: 0, data: write_varint49(R + 726270) }];
            cruids[4].push({ type: 2, data: write_shallow(uuid) });
            cruids[5].push({ type: 0, data: write_varint49(R) });
            cruids[6].push({ type: 0, data: write_varint49(R) });
          }
          _x[j].messages[0].data = write_shallow(cruids);
        }
        oldbucket.content = compress_iwa_file(write_iwa_file(_x));
        oldbucket.size = oldbucket.content.length;
        delete pb[46];
        var store = parse_shallow(pb[4][0].data);
        {
          store[7][0].data = write_varint49(range.e.r + 1);
          var row_headers = parse_shallow(store[1][0].data);
          var row_header_ref = parse_TSP_Reference(row_headers[2][0].data);
          oldbucket = CFB.find(cfb, dependents[row_header_ref].location);
          _x = parse_iwa_file(decompress_iwa_file(oldbucket.content));
          {
            if (_x[0].id != row_header_ref)
              throw "Bad HeaderStorageBucket";
            var base_bucket = parse_shallow(_x[0].messages[0].data);
            for (R = 0; R < data.length; ++R) {
              var _bucket = parse_shallow(base_bucket[2][0].data);
              _bucket[1][0].data = write_varint49(R);
              _bucket[4][0].data = write_varint49(data[R].length);
              base_bucket[2][R] = { type: base_bucket[2][0].type, data: write_shallow(_bucket) };
            }
            _x[0].messages[0].data = write_shallow(base_bucket);
          }
          oldbucket.content = compress_iwa_file(write_iwa_file(_x));
          oldbucket.size = oldbucket.content.length;
          var col_header_ref = parse_TSP_Reference(store[2][0].data);
          oldbucket = CFB.find(cfb, dependents[col_header_ref].location);
          _x = parse_iwa_file(decompress_iwa_file(oldbucket.content));
          {
            if (_x[0].id != col_header_ref)
              throw "Bad HeaderStorageBucket";
            base_bucket = parse_shallow(_x[0].messages[0].data);
            for (C = 0; C <= range.e.c; ++C) {
              _bucket = parse_shallow(base_bucket[2][0].data);
              _bucket[1][0].data = write_varint49(C);
              _bucket[4][0].data = write_varint49(range.e.r + 1);
              base_bucket[2][C] = { type: base_bucket[2][0].type, data: write_shallow(_bucket) };
            }
            _x[0].messages[0].data = write_shallow(base_bucket);
          }
          oldbucket.content = compress_iwa_file(write_iwa_file(_x));
          oldbucket.size = oldbucket.content.length;
          var sstref = parse_TSP_Reference(store[4][0].data);
          (function() {
            var sentry = CFB.find(cfb, dependents[sstref].location);
            var sx = parse_iwa_file(decompress_iwa_file(sentry.content));
            var sstroot;
            for (var sxi = 0; sxi < sx.length; ++sxi) {
              var packet2 = sx[sxi];
              if (packet2.id == sstref)
                sstroot = packet2;
            }
            var sstdata = parse_shallow(sstroot.messages[0].data);
            {
              sstdata[3] = [];
              var newsst = [];
              SST.forEach(function(str, i) {
                newsst[1] = [{ type: 0, data: write_varint49(i) }];
                newsst[2] = [{ type: 0, data: write_varint49(1) }];
                newsst[3] = [{ type: 2, data: stru8(str) }];
                sstdata[3].push({ type: 2, data: write_shallow(newsst) });
              });
            }
            sstroot.messages[0].data = write_shallow(sstdata);
            var sy = write_iwa_file(sx);
            var raw32 = compress_iwa_file(sy);
            sentry.content = raw32;
            sentry.size = sentry.content.length;
          })();
          var tile = parse_shallow(store[3][0].data);
          {
            var t = tile[1][0];
            delete tile[2];
            var tl = parse_shallow(t.data);
            {
              var tileref = parse_TSP_Reference(tl[2][0].data);
              (function() {
                var tentry = CFB.find(cfb, dependents[tileref].location);
                var tx = parse_iwa_file(decompress_iwa_file(tentry.content));
                var tileroot;
                for (var sxi = 0; sxi < tx.length; ++sxi) {
                  var packet2 = tx[sxi];
                  if (packet2.id == tileref)
                    tileroot = packet2;
                }
                var tiledata = parse_shallow(tileroot.messages[0].data);
                {
                  delete tiledata[6];
                  delete tile[7];
                  var rowload = new Uint8Array(tiledata[5][0].data);
                  tiledata[5] = [];
                  var cnt = 0;
                  for (var R2 = 0; R2 <= range.e.r; ++R2) {
                    var tilerow = parse_shallow(rowload);
                    cnt += write_tile_row(tilerow, data[R2], SST);
                    tilerow[1][0].data = write_varint49(R2);
                    tiledata[5].push({ data: write_shallow(tilerow), type: 2 });
                  }
                  tiledata[1] = [{ type: 0, data: write_varint49(range.e.c + 1) }];
                  tiledata[2] = [{ type: 0, data: write_varint49(range.e.r + 1) }];
                  tiledata[3] = [{ type: 0, data: write_varint49(cnt) }];
                  tiledata[4] = [{ type: 0, data: write_varint49(range.e.r + 1) }];
                }
                tileroot.messages[0].data = write_shallow(tiledata);
                var ty = write_iwa_file(tx);
                var raw32 = compress_iwa_file(ty);
                tentry.content = raw32;
                tentry.size = tentry.content.length;
              })();
            }
            t.data = write_shallow(tl);
          }
          store[3][0].data = write_shallow(tile);
        }
        pb[4][0].data = write_shallow(store);
      }
      docroot.messages[0].data = write_shallow(pb);
      var y = write_iwa_file(x);
      var raw3 = compress_iwa_file(y);
      entry.content = raw3;
      entry.size = entry.content.length;
      return cfb;
    }
    function fix_opts_func(defaults2) {
      return function fix_opts(opts) {
        for (var i = 0; i != defaults2.length; ++i) {
          var d = defaults2[i];
          if (opts[d[0]] === void 0)
            opts[d[0]] = d[1];
          if (d[2] === "n")
            opts[d[0]] = Number(opts[d[0]]);
        }
      };
    }
    function fix_write_opts(opts) {
      fix_opts_func([
        ["cellDates", false],
        /* write date cells with type `d` */
        ["bookSST", false],
        /* Generate Shared String Table */
        ["bookType", "xlsx"],
        /* Type of workbook (xlsx/m/b) */
        ["compression", false],
        /* Use file compression */
        ["WTF", false]
        /* WTF mode (throws errors) */
      ])(opts);
    }
    function write_zip(wb, opts) {
      if (opts.bookType == "ods")
        return write_ods(wb, opts);
      if (opts.bookType == "numbers")
        return write_numbers_iwa(wb, opts);
      if (opts.bookType == "xlsb")
        return write_zip_xlsxb(wb, opts);
      return write_zip_xlsx(wb, opts);
    }
    function write_zip_xlsxb(wb, opts) {
      _shapeid = 1024;
      if (wb && !wb.SSF) {
        wb.SSF = dup(table_fmt);
      }
      if (wb && wb.SSF) {
        make_ssf();
        SSF_load_table(wb.SSF);
        opts.revssf = evert_num(wb.SSF);
        opts.revssf[wb.SSF[65535]] = 0;
        opts.ssf = wb.SSF;
      }
      opts.rels = {};
      opts.wbrels = {};
      opts.Strings = /*::((*/
      [];
      opts.Strings.Count = 0;
      opts.Strings.Unique = 0;
      if (browser_has_Map)
        opts.revStrings = /* @__PURE__ */ new Map();
      else {
        opts.revStrings = {};
        opts.revStrings.foo = [];
        delete opts.revStrings.foo;
      }
      var wbext = opts.bookType == "xlsb" ? "bin" : "xml";
      var vbafmt = VBAFMTS.indexOf(opts.bookType) > -1;
      var ct = new_ct();
      fix_write_opts(opts = opts || {});
      var zip = zip_new();
      var f = "", rId = 0;
      opts.cellXfs = [];
      get_cell_style(opts.cellXfs, {}, { revssf: { "General": 0 } });
      if (!wb.Props)
        wb.Props = {};
      f = "docProps/core.xml";
      zip_add_file(zip, f, write_core_props(wb.Props, opts));
      ct.coreprops.push(f);
      add_rels(opts.rels, 2, f, RELS.CORE_PROPS);
      f = "docProps/app.xml";
      if (wb.Props && wb.Props.SheetNames)
        ;
      else if (!wb.Workbook || !wb.Workbook.Sheets)
        wb.Props.SheetNames = wb.SheetNames;
      else {
        var _sn = [];
        for (var _i = 0; _i < wb.SheetNames.length; ++_i)
          if ((wb.Workbook.Sheets[_i] || {}).Hidden != 2)
            _sn.push(wb.SheetNames[_i]);
        wb.Props.SheetNames = _sn;
      }
      wb.Props.Worksheets = wb.Props.SheetNames.length;
      zip_add_file(zip, f, write_ext_props(wb.Props));
      ct.extprops.push(f);
      add_rels(opts.rels, 3, f, RELS.EXT_PROPS);
      if (wb.Custprops !== wb.Props && keys(wb.Custprops || {}).length > 0) {
        f = "docProps/custom.xml";
        zip_add_file(zip, f, write_cust_props(wb.Custprops));
        ct.custprops.push(f);
        add_rels(opts.rels, 4, f, RELS.CUST_PROPS);
      }
      for (rId = 1; rId <= wb.SheetNames.length; ++rId) {
        var wsrels = { "!id": {} };
        var ws = wb.Sheets[wb.SheetNames[rId - 1]];
        var _type = (ws || {})["!type"] || "sheet";
        switch (_type) {
          case "chart":
          default:
            f = "xl/worksheets/sheet" + rId + "." + wbext;
            zip_add_file(zip, f, write_ws(rId - 1, f, opts, wb, wsrels));
            ct.sheets.push(f);
            add_rels(opts.wbrels, -1, "worksheets/sheet" + rId + "." + wbext, RELS.WS[0]);
        }
        if (ws) {
          var comments = ws["!comments"];
          var need_vml = false;
          var cf = "";
          if (comments && comments.length > 0) {
            cf = "xl/comments" + rId + "." + wbext;
            zip_add_file(zip, cf, write_cmnt(comments, cf));
            ct.comments.push(cf);
            add_rels(wsrels, -1, "../comments" + rId + "." + wbext, RELS.CMNT);
            need_vml = true;
          }
          if (ws["!legacy"]) {
            if (need_vml)
              zip_add_file(zip, "xl/drawings/vmlDrawing" + rId + ".vml", write_comments_vml(rId, ws["!comments"]));
          }
          delete ws["!comments"];
          delete ws["!legacy"];
        }
        if (wsrels["!id"].rId1)
          zip_add_file(zip, get_rels_path(f), write_rels(wsrels));
      }
      if (opts.Strings != null && opts.Strings.length > 0) {
        f = "xl/sharedStrings." + wbext;
        zip_add_file(zip, f, write_sst(opts.Strings, f, opts));
        ct.strs.push(f);
        add_rels(opts.wbrels, -1, "sharedStrings." + wbext, RELS.SST);
      }
      f = "xl/workbook." + wbext;
      zip_add_file(zip, f, write_wb(wb, f));
      ct.workbooks.push(f);
      add_rels(opts.rels, 1, f, RELS.WB);
      f = "xl/theme/theme1.xml";
      zip_add_file(zip, f, write_theme(wb.Themes, opts));
      ct.themes.push(f);
      add_rels(opts.wbrels, -1, "theme/theme1.xml", RELS.THEME);
      f = "xl/styles." + wbext;
      zip_add_file(zip, f, write_sty(wb, f, opts));
      ct.styles.push(f);
      add_rels(opts.wbrels, -1, "styles." + wbext, RELS.STY);
      if (wb.vbaraw && vbafmt) {
        f = "xl/vbaProject.bin";
        zip_add_file(zip, f, wb.vbaraw);
        ct.vba.push(f);
        add_rels(opts.wbrels, -1, "vbaProject.bin", RELS.VBA);
      }
      f = "xl/metadata." + wbext;
      zip_add_file(zip, f, write_xlmeta(f));
      ct.metadata.push(f);
      add_rels(opts.wbrels, -1, "metadata." + wbext, RELS.XLMETA);
      zip_add_file(zip, "[Content_Types].xml", write_ct(ct, opts));
      zip_add_file(zip, "_rels/.rels", write_rels(opts.rels));
      zip_add_file(zip, "xl/_rels/workbook." + wbext + ".rels", write_rels(opts.wbrels));
      delete opts.revssf;
      delete opts.ssf;
      return zip;
    }
    function write_zip_xlsx(wb, opts) {
      _shapeid = 1024;
      if (wb && !wb.SSF) {
        wb.SSF = dup(table_fmt);
      }
      if (wb && wb.SSF) {
        make_ssf();
        SSF_load_table(wb.SSF);
        opts.revssf = evert_num(wb.SSF);
        opts.revssf[wb.SSF[65535]] = 0;
        opts.ssf = wb.SSF;
      }
      opts.rels = {};
      opts.wbrels = {};
      opts.Strings = /*::((*/
      [];
      opts.Strings.Count = 0;
      opts.Strings.Unique = 0;
      if (browser_has_Map)
        opts.revStrings = /* @__PURE__ */ new Map();
      else {
        opts.revStrings = {};
        opts.revStrings.foo = [];
        delete opts.revStrings.foo;
      }
      var wbext = "xml";
      var vbafmt = VBAFMTS.indexOf(opts.bookType) > -1;
      var ct = new_ct();
      fix_write_opts(opts = opts || {});
      var zip = zip_new();
      var f = "", rId = 0;
      opts.cellXfs = [];
      get_cell_style(opts.cellXfs, {}, { revssf: { "General": 0 } });
      if (!wb.Props)
        wb.Props = {};
      f = "docProps/core.xml";
      zip_add_file(zip, f, write_core_props(wb.Props, opts));
      ct.coreprops.push(f);
      add_rels(opts.rels, 2, f, RELS.CORE_PROPS);
      f = "docProps/app.xml";
      if (wb.Props && wb.Props.SheetNames)
        ;
      else if (!wb.Workbook || !wb.Workbook.Sheets)
        wb.Props.SheetNames = wb.SheetNames;
      else {
        var _sn = [];
        for (var _i = 0; _i < wb.SheetNames.length; ++_i)
          if ((wb.Workbook.Sheets[_i] || {}).Hidden != 2)
            _sn.push(wb.SheetNames[_i]);
        wb.Props.SheetNames = _sn;
      }
      wb.Props.Worksheets = wb.Props.SheetNames.length;
      zip_add_file(zip, f, write_ext_props(wb.Props));
      ct.extprops.push(f);
      add_rels(opts.rels, 3, f, RELS.EXT_PROPS);
      if (wb.Custprops !== wb.Props && keys(wb.Custprops || {}).length > 0) {
        f = "docProps/custom.xml";
        zip_add_file(zip, f, write_cust_props(wb.Custprops));
        ct.custprops.push(f);
        add_rels(opts.rels, 4, f, RELS.CUST_PROPS);
      }
      var people = ["SheetJ5"];
      opts.tcid = 0;
      for (rId = 1; rId <= wb.SheetNames.length; ++rId) {
        var wsrels = { "!id": {} };
        var ws = wb.Sheets[wb.SheetNames[rId - 1]];
        var _type = (ws || {})["!type"] || "sheet";
        switch (_type) {
          case "chart":
          default:
            f = "xl/worksheets/sheet" + rId + "." + wbext;
            zip_add_file(zip, f, write_ws_xml(rId - 1, opts, wb, wsrels));
            ct.sheets.push(f);
            add_rels(opts.wbrels, -1, "worksheets/sheet" + rId + "." + wbext, RELS.WS[0]);
        }
        if (ws) {
          var comments = ws["!comments"];
          var need_vml = false;
          var cf = "";
          if (comments && comments.length > 0) {
            var needtc = false;
            comments.forEach(function(carr) {
              carr[1].forEach(function(c) {
                if (c.T == true)
                  needtc = true;
              });
            });
            if (needtc) {
              cf = "xl/threadedComments/threadedComment" + rId + "." + wbext;
              zip_add_file(zip, cf, write_tcmnt_xml(comments, people, opts));
              ct.threadedcomments.push(cf);
              add_rels(wsrels, -1, "../threadedComments/threadedComment" + rId + "." + wbext, RELS.TCMNT);
            }
            cf = "xl/comments" + rId + "." + wbext;
            zip_add_file(zip, cf, write_comments_xml(comments));
            ct.comments.push(cf);
            add_rels(wsrels, -1, "../comments" + rId + "." + wbext, RELS.CMNT);
            need_vml = true;
          }
          if (ws["!legacy"]) {
            if (need_vml)
              zip_add_file(zip, "xl/drawings/vmlDrawing" + rId + ".vml", write_comments_vml(rId, ws["!comments"]));
          }
          delete ws["!comments"];
          delete ws["!legacy"];
        }
        if (wsrels["!id"].rId1)
          zip_add_file(zip, get_rels_path(f), write_rels(wsrels));
      }
      if (opts.Strings != null && opts.Strings.length > 0) {
        f = "xl/sharedStrings." + wbext;
        zip_add_file(zip, f, write_sst_xml(opts.Strings, opts));
        ct.strs.push(f);
        add_rels(opts.wbrels, -1, "sharedStrings." + wbext, RELS.SST);
      }
      f = "xl/workbook." + wbext;
      zip_add_file(zip, f, write_wb_xml(wb));
      ct.workbooks.push(f);
      add_rels(opts.rels, 1, f, RELS.WB);
      f = "xl/theme/theme1.xml";
      zip_add_file(zip, f, write_theme(wb.Themes, opts));
      ct.themes.push(f);
      add_rels(opts.wbrels, -1, "theme/theme1.xml", RELS.THEME);
      f = "xl/styles." + wbext;
      zip_add_file(zip, f, write_sty_xml(wb, opts));
      ct.styles.push(f);
      add_rels(opts.wbrels, -1, "styles." + wbext, RELS.STY);
      if (wb.vbaraw && vbafmt) {
        f = "xl/vbaProject.bin";
        zip_add_file(zip, f, wb.vbaraw);
        ct.vba.push(f);
        add_rels(opts.wbrels, -1, "vbaProject.bin", RELS.VBA);
      }
      f = "xl/metadata." + wbext;
      zip_add_file(zip, f, write_xlmeta_xml());
      ct.metadata.push(f);
      add_rels(opts.wbrels, -1, "metadata." + wbext, RELS.XLMETA);
      if (people.length > 1) {
        f = "xl/persons/person.xml";
        zip_add_file(zip, f, write_people_xml(people));
        ct.people.push(f);
        add_rels(opts.wbrels, -1, "persons/person.xml", RELS.PEOPLE);
      }
      zip_add_file(zip, "[Content_Types].xml", write_ct(ct, opts));
      zip_add_file(zip, "_rels/.rels", write_rels(opts.rels));
      zip_add_file(zip, "xl/_rels/workbook." + wbext + ".rels", write_rels(opts.wbrels));
      delete opts.revssf;
      delete opts.ssf;
      return zip;
    }
    function firstbyte(f, o) {
      var x = "";
      switch ((o || {}).type || "base64") {
        case "buffer":
          return [f[0], f[1], f[2], f[3], f[4], f[5], f[6], f[7]];
        case "base64":
          x = Base64_decode(f.slice(0, 12));
          break;
        case "binary":
          x = f;
          break;
        case "array":
          return [f[0], f[1], f[2], f[3], f[4], f[5], f[6], f[7]];
        default:
          throw new Error("Unrecognized type " + (o && o.type || "undefined"));
      }
      return [x.charCodeAt(0), x.charCodeAt(1), x.charCodeAt(2), x.charCodeAt(3), x.charCodeAt(4), x.charCodeAt(5), x.charCodeAt(6), x.charCodeAt(7)];
    }
    function write_cfb_ctr(cfb, o) {
      switch (o.type) {
        case "base64":
        case "binary":
          break;
        case "buffer":
        case "array":
          o.type = "";
          break;
        case "file":
          return write_dl(o.file, CFB.write(cfb, { type: has_buf ? "buffer" : "" }));
        case "string":
          throw new Error("'string' output type invalid for '" + o.bookType + "' files");
        default:
          throw new Error("Unrecognized type " + o.type);
      }
      return CFB.write(cfb, o);
    }
    function write_zip_type(wb, opts) {
      var o = dup(opts || {});
      var z = write_zip(wb, o);
      return write_zip_denouement(z, o);
    }
    function write_zip_denouement(z, o) {
      var oopts = {};
      var ftype = has_buf ? "nodebuffer" : typeof Uint8Array !== "undefined" ? "array" : "string";
      if (o.compression)
        oopts.compression = "DEFLATE";
      if (o.password)
        oopts.type = ftype;
      else
        switch (o.type) {
          case "base64":
            oopts.type = "base64";
            break;
          case "binary":
            oopts.type = "string";
            break;
          case "string":
            throw new Error("'string' output type invalid for '" + o.bookType + "' files");
          case "buffer":
          case "file":
            oopts.type = ftype;
            break;
          default:
            throw new Error("Unrecognized type " + o.type);
        }
      var out = z.FullPaths ? CFB.write(z, { fileType: "zip", type: (
        /*::(*/
        { "nodebuffer": "buffer", "string": "binary" }[oopts.type] || oopts.type
      ), compression: !!o.compression }) : z.generate(oopts);
      if (typeof Deno !== "undefined") {
        if (typeof out == "string") {
          if (o.type == "binary" || o.type == "base64")
            return out;
          out = new Uint8Array(s2ab(out));
        }
      }
      if (o.password && typeof encrypt_agile !== "undefined")
        return write_cfb_ctr(encrypt_agile(out, o.password), o);
      if (o.type === "file")
        return write_dl(o.file, out);
      return o.type == "string" ? utf8read(
        /*::(*/
        out
        /*:: :any)*/
      ) : out;
    }
    function write_cfb_type(wb, opts) {
      var o = opts || {};
      var cfb = write_xlscfb(wb, o);
      return write_cfb_ctr(cfb, o);
    }
    function write_string_type(out, opts, bom) {
      if (!bom)
        bom = "";
      var o = bom + out;
      switch (opts.type) {
        case "base64":
          return Base64_encode(utf8write(o));
        case "binary":
          return utf8write(o);
        case "string":
          return out;
        case "file":
          return write_dl(opts.file, o, "utf8");
        case "buffer": {
          if (has_buf)
            return Buffer_from(o, "utf8");
          else if (typeof TextEncoder !== "undefined")
            return new TextEncoder().encode(o);
          else
            return write_string_type(o, { type: "binary" }).split("").map(function(c) {
              return c.charCodeAt(0);
            });
        }
      }
      throw new Error("Unrecognized type " + opts.type);
    }
    function write_stxt_type(out, opts) {
      switch (opts.type) {
        case "base64":
          return Base64_encode(out);
        case "binary":
          return out;
        case "string":
          return out;
        case "file":
          return write_dl(opts.file, out, "binary");
        case "buffer": {
          if (has_buf)
            return Buffer_from(out, "binary");
          else
            return out.split("").map(function(c) {
              return c.charCodeAt(0);
            });
        }
      }
      throw new Error("Unrecognized type " + opts.type);
    }
    function write_binary_type(out, opts) {
      switch (opts.type) {
        case "string":
        case "base64":
        case "binary":
          var bstr = "";
          for (var i = 0; i < out.length; ++i)
            bstr += String.fromCharCode(out[i]);
          return opts.type == "base64" ? Base64_encode(bstr) : opts.type == "string" ? utf8read(bstr) : bstr;
        case "file":
          return write_dl(opts.file, out);
        case "buffer":
          return out;
        default:
          throw new Error("Unrecognized type " + opts.type);
      }
    }
    function writeSync(wb, opts) {
      reset_cp();
      check_wb(wb);
      var o = dup(opts || {});
      if (o.cellStyles) {
        o.cellNF = true;
        o.sheetStubs = true;
      }
      if (o.type == "array") {
        o.type = "binary";
        var out = writeSync(wb, o);
        o.type = "array";
        return s2ab(out);
      }
      var idx = 0;
      if (o.sheet) {
        if (typeof o.sheet == "number")
          idx = o.sheet;
        else
          idx = wb.SheetNames.indexOf(o.sheet);
        if (!wb.SheetNames[idx])
          throw new Error("Sheet not found: " + o.sheet + " : " + typeof o.sheet);
      }
      switch (o.bookType || "xlsb") {
        case "xml":
        case "xlml":
          return write_string_type(write_xlml(wb, o), o);
        case "slk":
        case "sylk":
          return write_string_type(SYLK.from_sheet(wb.Sheets[wb.SheetNames[idx]], o), o);
        case "htm":
        case "html":
          return write_string_type(sheet_to_html(wb.Sheets[wb.SheetNames[idx]], o), o);
        case "txt":
          return write_stxt_type(sheet_to_txt(wb.Sheets[wb.SheetNames[idx]], o), o);
        case "csv":
          return write_string_type(sheet_to_csv(wb.Sheets[wb.SheetNames[idx]], o), o, "\uFEFF");
        case "dif":
          return write_string_type(DIF.from_sheet(wb.Sheets[wb.SheetNames[idx]], o), o);
        case "dbf":
          return write_binary_type(DBF.from_sheet(wb.Sheets[wb.SheetNames[idx]], o), o);
        case "prn":
          return write_string_type(PRN.from_sheet(wb.Sheets[wb.SheetNames[idx]], o), o);
        case "rtf":
          return write_string_type(RTF.from_sheet(wb.Sheets[wb.SheetNames[idx]], o), o);
        case "eth":
          return write_string_type(ETH.from_sheet(wb.Sheets[wb.SheetNames[idx]], o), o);
        case "fods":
          return write_string_type(write_ods(wb, o), o);
        case "wk1":
          return write_binary_type(WK_.sheet_to_wk1(wb.Sheets[wb.SheetNames[idx]], o), o);
        case "wk3":
          return write_binary_type(WK_.book_to_wk3(wb, o), o);
        case "biff2":
          if (!o.biff)
            o.biff = 2;
        case "biff3":
          if (!o.biff)
            o.biff = 3;
        case "biff4":
          if (!o.biff)
            o.biff = 4;
          return write_binary_type(write_biff_buf(wb, o), o);
        case "biff5":
          if (!o.biff)
            o.biff = 5;
        case "biff8":
        case "xla":
        case "xls":
          if (!o.biff)
            o.biff = 8;
          return write_cfb_type(wb, o);
        case "xlsx":
        case "xlsm":
        case "xlam":
        case "xlsb":
        case "numbers":
        case "ods":
          return write_zip_type(wb, o);
        default:
          throw new Error("Unrecognized bookType |" + o.bookType + "|");
      }
    }
    function make_json_row(sheet, r, R, cols, header, hdr, dense, o) {
      var rr = encode_row(R);
      var defval = o.defval, raw = o.raw || !Object.prototype.hasOwnProperty.call(o, "raw");
      var isempty = true;
      var row = header === 1 ? [] : {};
      if (header !== 1) {
        if (Object.defineProperty)
          try {
            Object.defineProperty(row, "__rowNum__", { value: R, enumerable: false });
          } catch (e) {
            row.__rowNum__ = R;
          }
        else
          row.__rowNum__ = R;
      }
      if (!dense || sheet[R])
        for (var C = r.s.c; C <= r.e.c; ++C) {
          var val = dense ? sheet[R][C] : sheet[cols[C] + rr];
          if (val === void 0 || val.t === void 0) {
            if (defval === void 0)
              continue;
            if (hdr[C] != null) {
              row[hdr[C]] = defval;
            }
            continue;
          }
          var v = val.v;
          switch (val.t) {
            case "z":
              if (v == null)
                break;
              continue;
            case "e":
              v = v == 0 ? null : void 0;
              break;
            case "s":
            case "d":
            case "b":
            case "n":
              break;
            default:
              throw new Error("unrecognized type " + val.t);
          }
          if (hdr[C] != null) {
            if (v == null) {
              if (val.t == "e" && v === null)
                row[hdr[C]] = null;
              else if (defval !== void 0)
                row[hdr[C]] = defval;
              else if (raw && v === null)
                row[hdr[C]] = null;
              else
                continue;
            } else {
              row[hdr[C]] = raw && (val.t !== "n" || val.t === "n" && o.rawNumbers !== false) ? v : format_cell(val, v, o);
            }
            if (v != null)
              isempty = false;
          }
        }
      return { row, isempty };
    }
    function sheet_to_json(sheet, opts) {
      if (sheet == null || sheet["!ref"] == null)
        return [];
      var val = { t: "n", v: 0 }, header = 0, offset = 1, hdr = [], v = 0, vv = "";
      var r = { s: { r: 0, c: 0 }, e: { r: 0, c: 0 } };
      var o = opts || {};
      var range = o.range != null ? o.range : sheet["!ref"];
      if (o.header === 1)
        header = 1;
      else if (o.header === "A")
        header = 2;
      else if (Array.isArray(o.header))
        header = 3;
      else if (o.header == null)
        header = 0;
      switch (typeof range) {
        case "string":
          r = safe_decode_range(range);
          break;
        case "number":
          r = safe_decode_range(sheet["!ref"]);
          r.s.r = range;
          break;
        default:
          r = range;
      }
      if (header > 0)
        offset = 0;
      var rr = encode_row(r.s.r);
      var cols = [];
      var out = [];
      var outi = 0, counter = 0;
      var dense = Array.isArray(sheet);
      var R = r.s.r, C = 0;
      var header_cnt = {};
      if (dense && !sheet[R])
        sheet[R] = [];
      var colinfo = o.skipHidden && sheet["!cols"] || [];
      var rowinfo = o.skipHidden && sheet["!rows"] || [];
      for (C = r.s.c; C <= r.e.c; ++C) {
        if ((colinfo[C] || {}).hidden)
          continue;
        cols[C] = encode_col(C);
        val = dense ? sheet[R][C] : sheet[cols[C] + rr];
        switch (header) {
          case 1:
            hdr[C] = C - r.s.c;
            break;
          case 2:
            hdr[C] = cols[C];
            break;
          case 3:
            hdr[C] = o.header[C - r.s.c];
            break;
          default:
            if (val == null)
              val = { w: "__EMPTY", t: "s" };
            vv = v = format_cell(val, null, o);
            counter = header_cnt[v] || 0;
            if (!counter)
              header_cnt[v] = 1;
            else {
              do {
                vv = v + "_" + counter++;
              } while (header_cnt[vv]);
              header_cnt[v] = counter;
              header_cnt[vv] = 1;
            }
            hdr[C] = vv;
        }
      }
      for (R = r.s.r + offset; R <= r.e.r; ++R) {
        if ((rowinfo[R] || {}).hidden)
          continue;
        var row = make_json_row(sheet, r, R, cols, header, hdr, dense, o);
        if (row.isempty === false || (header === 1 ? o.blankrows !== false : !!o.blankrows))
          out[outi++] = row.row;
      }
      out.length = outi;
      return out;
    }
    var qreg = /"/g;
    function make_csv_row(sheet, r, R, cols, fs, rs, FS, o) {
      var isempty = true;
      var row = [], txt = "", rr = encode_row(R);
      for (var C = r.s.c; C <= r.e.c; ++C) {
        if (!cols[C])
          continue;
        var val = o.dense ? (sheet[R] || [])[C] : sheet[cols[C] + rr];
        if (val == null)
          txt = "";
        else if (val.v != null) {
          isempty = false;
          txt = "" + (o.rawNumbers && val.t == "n" ? val.v : format_cell(val, null, o));
          for (var i = 0, cc = 0; i !== txt.length; ++i)
            if ((cc = txt.charCodeAt(i)) === fs || cc === rs || cc === 34 || o.forceQuotes) {
              txt = '"' + txt.replace(qreg, '""') + '"';
              break;
            }
          if (txt == "ID")
            txt = '"ID"';
        } else if (val.f != null && !val.F) {
          isempty = false;
          txt = "=" + val.f;
          if (txt.indexOf(",") >= 0)
            txt = '"' + txt.replace(qreg, '""') + '"';
        } else
          txt = "";
        row.push(txt);
      }
      if (o.blankrows === false && isempty)
        return null;
      return row.join(FS);
    }
    function sheet_to_csv(sheet, opts) {
      var out = [];
      var o = opts == null ? {} : opts;
      if (sheet == null || sheet["!ref"] == null)
        return "";
      var r = safe_decode_range(sheet["!ref"]);
      var FS = o.FS !== void 0 ? o.FS : ",", fs = FS.charCodeAt(0);
      var RS = o.RS !== void 0 ? o.RS : "\n", rs = RS.charCodeAt(0);
      var endregex = new RegExp((FS == "|" ? "\\|" : FS) + "+$");
      var row = "", cols = [];
      o.dense = Array.isArray(sheet);
      var colinfo = o.skipHidden && sheet["!cols"] || [];
      var rowinfo = o.skipHidden && sheet["!rows"] || [];
      for (var C = r.s.c; C <= r.e.c; ++C)
        if (!(colinfo[C] || {}).hidden)
          cols[C] = encode_col(C);
      var w = 0;
      for (var R = r.s.r; R <= r.e.r; ++R) {
        if ((rowinfo[R] || {}).hidden)
          continue;
        row = make_csv_row(sheet, r, R, cols, fs, rs, FS, o);
        if (row == null) {
          continue;
        }
        if (o.strip)
          row = row.replace(endregex, "");
        if (row || o.blankrows !== false)
          out.push((w++ ? RS : "") + row);
      }
      delete o.dense;
      return out.join("");
    }
    function sheet_to_txt(sheet, opts) {
      if (!opts)
        opts = {};
      opts.FS = "	";
      opts.RS = "\n";
      var s = sheet_to_csv(sheet, opts);
      return s;
    }
    function sheet_to_formulae(sheet) {
      var y = "", x, val = "";
      if (sheet == null || sheet["!ref"] == null)
        return [];
      var r = safe_decode_range(sheet["!ref"]), rr = "", cols = [], C;
      var cmds = [];
      var dense = Array.isArray(sheet);
      for (C = r.s.c; C <= r.e.c; ++C)
        cols[C] = encode_col(C);
      for (var R = r.s.r; R <= r.e.r; ++R) {
        rr = encode_row(R);
        for (C = r.s.c; C <= r.e.c; ++C) {
          y = cols[C] + rr;
          x = dense ? (sheet[R] || [])[C] : sheet[y];
          val = "";
          if (x === void 0)
            continue;
          else if (x.F != null) {
            y = x.F;
            if (!x.f)
              continue;
            val = x.f;
            if (y.indexOf(":") == -1)
              y = y + ":" + y;
          }
          if (x.f != null)
            val = x.f;
          else if (x.t == "z")
            continue;
          else if (x.t == "n" && x.v != null)
            val = "" + x.v;
          else if (x.t == "b")
            val = x.v ? "TRUE" : "FALSE";
          else if (x.w !== void 0)
            val = "'" + x.w;
          else if (x.v === void 0)
            continue;
          else if (x.t == "s")
            val = "'" + x.v;
          else
            val = "" + x.v;
          cmds[cmds.length] = y + "=" + val;
        }
      }
      return cmds;
    }
    function sheet_add_json(_ws, js, opts) {
      var o = opts || {};
      var offset = +!o.skipHeader;
      var ws = _ws || {};
      var _R = 0, _C = 0;
      if (ws && o.origin != null) {
        if (typeof o.origin == "number")
          _R = o.origin;
        else {
          var _origin = typeof o.origin == "string" ? decode_cell(o.origin) : o.origin;
          _R = _origin.r;
          _C = _origin.c;
        }
      }
      var cell;
      var range = { s: { c: 0, r: 0 }, e: { c: _C, r: _R + js.length - 1 + offset } };
      if (ws["!ref"]) {
        var _range = safe_decode_range(ws["!ref"]);
        range.e.c = Math.max(range.e.c, _range.e.c);
        range.e.r = Math.max(range.e.r, _range.e.r);
        if (_R == -1) {
          _R = _range.e.r + 1;
          range.e.r = _R + js.length - 1 + offset;
        }
      } else {
        if (_R == -1) {
          _R = 0;
          range.e.r = js.length - 1 + offset;
        }
      }
      var hdr = o.header || [], C = 0;
      js.forEach(function(JS, R) {
        keys(JS).forEach(function(k) {
          if ((C = hdr.indexOf(k)) == -1)
            hdr[C = hdr.length] = k;
          var v = JS[k];
          var t = "z";
          var z = "";
          var ref = encode_cell({ c: _C + C, r: _R + R + offset });
          cell = ws_get_cell_stub(ws, ref);
          if (v && typeof v === "object" && !(v instanceof Date)) {
            ws[ref] = v;
          } else {
            if (typeof v == "number")
              t = "n";
            else if (typeof v == "boolean")
              t = "b";
            else if (typeof v == "string")
              t = "s";
            else if (v instanceof Date) {
              t = "d";
              if (!o.cellDates) {
                t = "n";
                v = datenum(v);
              }
              z = o.dateNF || table_fmt[14];
            } else if (v === null && o.nullError) {
              t = "e";
              v = 0;
            }
            if (!cell)
              ws[ref] = cell = { t, v };
            else {
              cell.t = t;
              cell.v = v;
              delete cell.w;
              delete cell.R;
              if (z)
                cell.z = z;
            }
            if (z)
              cell.z = z;
          }
        });
      });
      range.e.c = Math.max(range.e.c, _C + hdr.length - 1);
      var __R = encode_row(_R);
      if (offset)
        for (C = 0; C < hdr.length; ++C)
          ws[encode_col(C + _C) + __R] = { t: "s", v: hdr[C] };
      ws["!ref"] = encode_range(range);
      return ws;
    }
    function json_to_sheet(js, opts) {
      return sheet_add_json(null, js, opts);
    }
    function ws_get_cell_stub(ws, R, C) {
      if (typeof R == "string") {
        if (Array.isArray(ws)) {
          var RC = decode_cell(R);
          if (!ws[RC.r])
            ws[RC.r] = [];
          return ws[RC.r][RC.c] || (ws[RC.r][RC.c] = { t: "z" });
        }
        return ws[R] || (ws[R] = { t: "z" });
      }
      if (typeof R != "number")
        return ws_get_cell_stub(ws, encode_cell(R));
      return ws_get_cell_stub(ws, encode_cell({ r: R, c: C || 0 }));
    }
    function wb_sheet_idx(wb, sh) {
      if (typeof sh == "number") {
        if (sh >= 0 && wb.SheetNames.length > sh)
          return sh;
        throw new Error("Cannot find sheet # " + sh);
      } else if (typeof sh == "string") {
        var idx = wb.SheetNames.indexOf(sh);
        if (idx > -1)
          return idx;
        throw new Error("Cannot find sheet name |" + sh + "|");
      } else
        throw new Error("Cannot find sheet |" + sh + "|");
    }
    function book_new() {
      return { SheetNames: [], Sheets: {} };
    }
    function book_append_sheet(wb, ws, name, roll) {
      var i = 1;
      if (!name) {
        for (; i <= 65535; ++i, name = void 0)
          if (wb.SheetNames.indexOf(name = "Sheet" + i) == -1)
            break;
      }
      if (!name || wb.SheetNames.length >= 65535)
        throw new Error("Too many worksheets");
      if (roll && wb.SheetNames.indexOf(name) >= 0) {
        var m = name.match(/(^.*?)(\d+)$/);
        i = m && +m[2] || 0;
        var root = m && m[1] || name;
        for (++i; i <= 65535; ++i)
          if (wb.SheetNames.indexOf(name = root + i) == -1)
            break;
      }
      check_ws_name(name);
      if (wb.SheetNames.indexOf(name) >= 0)
        throw new Error("Worksheet with name |" + name + "| already exists!");
      wb.SheetNames.push(name);
      wb.Sheets[name] = ws;
      return name;
    }
    function book_set_sheet_visibility(wb, sh, vis) {
      if (!wb.Workbook)
        wb.Workbook = {};
      if (!wb.Workbook.Sheets)
        wb.Workbook.Sheets = [];
      var idx = wb_sheet_idx(wb, sh);
      if (!wb.Workbook.Sheets[idx])
        wb.Workbook.Sheets[idx] = {};
      switch (vis) {
        case 0:
        case 1:
        case 2:
          break;
        default:
          throw new Error("Bad sheet visibility setting " + vis);
      }
      wb.Workbook.Sheets[idx].Hidden = vis;
    }
    function cell_set_number_format(cell, fmt) {
      cell.z = fmt;
      return cell;
    }
    function cell_set_hyperlink(cell, target, tooltip) {
      if (!target) {
        delete cell.l;
      } else {
        cell.l = { Target: target };
        if (tooltip)
          cell.l.Tooltip = tooltip;
      }
      return cell;
    }
    function cell_set_internal_link(cell, range, tooltip) {
      return cell_set_hyperlink(cell, "#" + range, tooltip);
    }
    function cell_add_comment(cell, text, author) {
      if (!cell.c)
        cell.c = [];
      cell.c.push({ t: text, a: author || "SheetJS" });
    }
    function sheet_set_array_formula(ws, range, formula, dynamic) {
      var rng2 = typeof range != "string" ? range : safe_decode_range(range);
      var rngstr = typeof range == "string" ? range : encode_range(range);
      for (var R = rng2.s.r; R <= rng2.e.r; ++R)
        for (var C = rng2.s.c; C <= rng2.e.c; ++C) {
          var cell = ws_get_cell_stub(ws, R, C);
          cell.t = "n";
          cell.F = rngstr;
          delete cell.v;
          if (R == rng2.s.r && C == rng2.s.c) {
            cell.f = formula;
            if (dynamic)
              cell.D = true;
          }
        }
      return ws;
    }
    var utils = {
      encode_col,
      encode_row,
      encode_cell,
      encode_range,
      decode_col,
      decode_row,
      split_cell,
      decode_cell,
      decode_range,
      format_cell,
      sheet_add_aoa,
      sheet_add_json,
      sheet_add_dom,
      aoa_to_sheet,
      json_to_sheet,
      table_to_sheet: parse_dom_table,
      table_to_book,
      sheet_to_csv,
      sheet_to_txt,
      sheet_to_json,
      sheet_to_html,
      sheet_to_formulae,
      sheet_to_row_object_array: sheet_to_json,
      sheet_get_cell: ws_get_cell_stub,
      book_new,
      book_append_sheet,
      book_set_sheet_visibility,
      cell_set_number_format,
      cell_set_hyperlink,
      cell_set_internal_link,
      cell_add_comment,
      sheet_set_array_formula,
      consts: {
        SHEET_VISIBLE: 0,
        SHEET_HIDDEN: 1,
        SHEET_VERY_HIDDEN: 2
      }
    };
    var HomePage = () => {
      const { formatMessage } = reactIntl.useIntl();
      const [fromDate, setFromDate] = react.useState(null);
      const [toDate, setToDate] = react.useState(null);
      const [leads, setLeads] = react.useState([]);
      const [page, setPage] = react.useState(1);
      const [pageCount, setPageCount] = react.useState(1);
      const [leadLoading, setLeadLoading] = react.useState(true);
      const [exportLoading, setExportLoading] = react.useState(false);
      const [toast, setToast] = react.useState(null);
      const pageSize = 10;
      let BACKEND_URL = process.env.BACKEND_URL;
      react.useEffect(() => {
        const fetchLeads = async () => {
          setLeadLoading(true);
          try {
            const response = await axios.get(`http://localhost:1337/api/leads?pagination[page]=${page}&pagination[pageSize]=${pageSize}`);
            console.log(response.data, BACKEND_URL);
            setLeads(response.data?.data);
            setPageCount(response.data?.meta?.pagination?.pageCount || 1);
          } catch (error) {
            console.log(error);
          } finally {
            setLeadLoading(false);
          }
        };
        fetchLeads();
      }, [page]);
      const handleExport = async () => {
        console.log("Exporting from:", fromDate, "to:", toDate);
        setExportLoading(true);
        try {
          const isoFromDate = fromDate ? new Date(fromDate).toISOString() : null;
          const isoToDate = toDate ? new Date(toDate).toISOString() : null;
          let url = `http://localhost:1337/api/leads?pagination[page]=${page}&pagination[pageSize]=${pageSize}`;
          if (isoFromDate || isoToDate) {
            url += `&filters[createdAt][$gte]=${isoFromDate}&filters[createdAt][$lte]=${isoToDate}`;
          }
          const response = await axios.get(url);
          const filteredLeads = response.data?.data || [];
          console.log(filteredLeads);
          setLeads(filteredLeads);
          if (filteredLeads.length === 0) {
            setToast({
              type: "error",
              message: "No data found for the selected date range!",
              icon: /* @__PURE__ */ jsxRuntime.jsx(icons.Cross, {})
            });
            return;
          }
          const worksheetData = filteredLeads.map((lead) => ({
            "Customer Name": lead.CustomerName,
            "Customer Email": lead.CustomerEmail,
            "Mobile Number": lead.MobileNumber,
            "Lead Type": lead.Lead_Type,
            "Notes": lead.Notes,
            "Date": lead.Date,
            "City": lead.City,
            "Created At": new Date(lead.createdAt).toLocaleDateString()
          }));
          const worksheet = utils.json_to_sheet(worksheetData);
          const workbook = utils.book_new();
          utils.book_append_sheet(workbook, worksheet, "Leads");
          const excelBuffer = writeSync(workbook, { bookType: "xlsx", type: "array" });
          const data = new Blob([excelBuffer], { type: "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet" });
          const urlLink = window.URL.createObjectURL(data);
          const link = document.createElement("a");
          link.href = urlLink;
          link.setAttribute("download", "leads.xlsx");
          document.body.appendChild(link);
          link.click();
          document.body.removeChild(link);
          setToast({
            type: "success",
            message: "Download successful!",
            icon: /* @__PURE__ */ jsxRuntime.jsx(icons.Check, {})
          });
        } catch (error) {
          console.log(error);
          setToast({
            type: "error",
            message: "Download failed! Please try again.",
            icon: /* @__PURE__ */ jsxRuntime.jsx(icons.Cross, {})
          });
        } finally {
          setExportLoading(false);
          setTimeout(() => setToast(null), 3e3);
        }
      };
      return /* @__PURE__ */ jsxRuntime.jsxs(designSystem.Main, { children: [
        toast && /* @__PURE__ */ jsxRuntime.jsx(designSystem.Box, { position: "fixed", bottom: 4, right: 4, zIndex: 1e3, children: /* @__PURE__ */ jsxRuntime.jsx(
          designSystem.Alert,
          {
            variant: toast.type === "success" ? "success" : "danger",
            title: toast.message,
            onClose: () => setToast(null),
            closeLabel: "Close"
          }
        ) }),
        /* @__PURE__ */ jsxRuntime.jsxs(designSystem.Main, { padding: 8, children: [
          /* @__PURE__ */ jsxRuntime.jsx(designSystem.Typography, { variant: "alpha", as: "h1", children: "Excel Export Leads" }),
          /* @__PURE__ */ jsxRuntime.jsx(designSystem.Typography, { variant: "epsilon", as: "p", style: { fontSize: "16px", color: "#6c757d" }, children: "Manage and export your leads data" })
        ] }),
        /* @__PURE__ */ jsxRuntime.jsx(designSystem.Main, { children: /* @__PURE__ */ jsxRuntime.jsxs(designSystem.Box, { padding: 8, background: "neutral100", children: [
          /* @__PURE__ */ jsxRuntime.jsxs(designSystem.Flex, { gap: 4, marginBottom: 6, children: [
            /* @__PURE__ */ jsxRuntime.jsxs(designSystem.Box, { children: [
              /* @__PURE__ */ jsxRuntime.jsx(designSystem.Typography, { variant: "pi", fontWeight: "bold", marginBottom: 2, children: "From Date" }),
              /* @__PURE__ */ jsxRuntime.jsx(
                designSystem.DatePicker,
                {
                  selectedDate: fromDate,
                  onChange: setFromDate,
                  clearLabel: "Clear",
                  onClear: () => setFromDate(null)
                }
              )
            ] }),
            /* @__PURE__ */ jsxRuntime.jsxs(designSystem.Box, { children: [
              /* @__PURE__ */ jsxRuntime.jsx(designSystem.Typography, { variant: "pi", fontWeight: "bold", marginBottom: 2, children: "To Date" }),
              /* @__PURE__ */ jsxRuntime.jsx(
                designSystem.DatePicker,
                {
                  selectedDate: toDate,
                  onChange: setToDate,
                  clearLabel: "Clear",
                  onClear: () => setToDate(null)
                }
              )
            ] }),
            /* @__PURE__ */ jsxRuntime.jsxs(designSystem.Box, { children: [
              /* @__PURE__ */ jsxRuntime.jsx(designSystem.Typography, { variant: "pi", fontWeight: "bold", marginBottom: 2 }),
              " ",
              /* @__PURE__ */ jsxRuntime.jsx("br", {}),
              /* @__PURE__ */ jsxRuntime.jsx(designSystem.Button, { onClick: handleExport, disabled: exportLoading, startIcon: /* @__PURE__ */ jsxRuntime.jsx(icons.Download, {}), children: exportLoading ? /* @__PURE__ */ jsxRuntime.jsx(designSystem.Loader, { small: true }) : "Export to Excel" })
            ] })
          ] }),
          leadLoading ? /* @__PURE__ */ jsxRuntime.jsx(designSystem.Flex, { justifyContent: "center", children: /* @__PURE__ */ jsxRuntime.jsx(designSystem.Loader, { children: "Loading leads..." }) }) : /* @__PURE__ */ jsxRuntime.jsxs(designSystem.Table, { colCount: 7, rowCount: leads?.length, children: [
            /* @__PURE__ */ jsxRuntime.jsx(designSystem.Thead, { children: /* @__PURE__ */ jsxRuntime.jsxs(designSystem.Tr, { children: [
              /* @__PURE__ */ jsxRuntime.jsx(designSystem.Th, { style: { fontSize: "18px", fontWeight: "bold" }, children: "Sl No" }),
              /* @__PURE__ */ jsxRuntime.jsx(designSystem.Th, { style: { fontSize: "18px", fontWeight: "bold" }, children: "Customer Name" }),
              /* @__PURE__ */ jsxRuntime.jsx(designSystem.Th, { style: { fontSize: "18px", fontWeight: "bold" }, children: "Customer Email" }),
              /* @__PURE__ */ jsxRuntime.jsx(designSystem.Th, { style: { fontSize: "18px", fontWeight: "bold" }, children: "Mobile Number" }),
              /* @__PURE__ */ jsxRuntime.jsx(designSystem.Th, { style: { fontSize: "18px", fontWeight: "bold" }, children: "Lead Type" }),
              /* @__PURE__ */ jsxRuntime.jsx(designSystem.Th, { style: { fontSize: "18px", fontWeight: "bold" }, children: "Date" }),
              /* @__PURE__ */ jsxRuntime.jsx(designSystem.Th, { style: { fontSize: "18px", fontWeight: "bold" }, children: "City" }),
              /* @__PURE__ */ jsxRuntime.jsx(designSystem.Th, { style: { fontSize: "18px", fontWeight: "bold" }, children: "Created At" })
            ] }) }),
            /* @__PURE__ */ jsxRuntime.jsx(designSystem.Tbody, { children: leads?.map((lead, index) => /* @__PURE__ */ jsxRuntime.jsxs(designSystem.Tr, { children: [
              /* @__PURE__ */ jsxRuntime.jsx(designSystem.Td, { style: { fontSize: "16px" }, children: index + 1 }),
              /* @__PURE__ */ jsxRuntime.jsx(designSystem.Td, { style: { fontSize: "16px" }, children: lead?.CustomerName }),
              /* @__PURE__ */ jsxRuntime.jsx(designSystem.Td, { style: { fontSize: "16px" }, children: lead?.CustomerEmail }),
              /* @__PURE__ */ jsxRuntime.jsx(designSystem.Td, { style: { fontSize: "16px" }, children: lead?.MobileNumber }),
              /* @__PURE__ */ jsxRuntime.jsx(designSystem.Td, { style: { fontSize: "16px" }, children: lead?.Lead_Type }),
              /* @__PURE__ */ jsxRuntime.jsx(designSystem.Td, { style: { fontSize: "16px" }, children: lead?.Date }),
              /* @__PURE__ */ jsxRuntime.jsx(designSystem.Td, { style: { fontSize: "16px" }, children: lead?.City }),
              /* @__PURE__ */ jsxRuntime.jsx(designSystem.Td, { style: { fontSize: "16px" }, children: new Date(lead?.createdAt).toLocaleDateString() })
            ] }, index)) })
          ] }),
          /* @__PURE__ */ jsxRuntime.jsx(designSystem.Box, { paddingTop: 4, children: /* @__PURE__ */ jsxRuntime.jsx(
            designSystem.Pagination,
            {
              activePage: page,
              pageCount,
              onPageChange: setPage
            }
          ) })
        ] }) })
      ] });
    };
    var App = () => {
      return /* @__PURE__ */ jsxRuntime.jsxs(reactRouterDom.Routes, { children: [
        /* @__PURE__ */ jsxRuntime.jsx(reactRouterDom.Route, { index: true, element: /* @__PURE__ */ jsxRuntime.jsx(HomePage, {}) }),
        /* @__PURE__ */ jsxRuntime.jsx(reactRouterDom.Route, { path: "*", element: /* @__PURE__ */ jsxRuntime.jsx(admin.Page.Error, {}) })
      ] });
    };
    exports2.App = App;
  }
});

// dist/_chunks/en-B4KWt_jN.js
var require_en_B4KWt_jN = __commonJS({
  "dist/_chunks/en-B4KWt_jN.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, Symbol.toStringTag, { value: "Module" });
    var en = {};
    exports2.default = en;
  }
});

// dist/admin/index.js
var require_admin = __commonJS({
  "dist/admin/index.js"(exports2, module2) {
    "use strict";
    var react = require("react");
    var jsxRuntime = require("react/jsx-runtime");
    var icons = require("@strapi/icons");
    var __variableDynamicImportRuntimeHelper = (glob, path, segs) => {
      const v = glob[path];
      if (v) {
        return typeof v === "function" ? v() : Promise.resolve(v);
      }
      return new Promise((_2, reject) => {
        (typeof queueMicrotask === "function" ? queueMicrotask : setTimeout)(
          reject.bind(
            null,
            new Error(
              "Unknown variable dynamic import: " + path + (path.split("/").length !== segs ? ". Note that variables only represent file names one level deep." : "")
            )
          )
        );
      });
    };
    var PLUGIN_ID = "excel-export";
    var Initializer = ({ setPlugin }) => {
      const ref = react.useRef(setPlugin);
      react.useEffect(() => {
        ref.current(PLUGIN_ID);
      }, []);
      return null;
    };
    var PluginIcon = () => /* @__PURE__ */ jsxRuntime.jsx(icons.PuzzlePiece, {});
    var index = {
      register(app) {
        app.addMenuLink({
          to: `plugins/${PluginIcon}`,
          icon: PluginIcon,
          intlLabel: {
            id: `${PLUGIN_ID}.plugin.name`,
            defaultMessage: PLUGIN_ID
          },
          Component: async () => {
            const { App } = await Promise.resolve().then(() => require_App_D58T0dWL());
            return App;
          }
        });
        app.registerPlugin({
          id: PLUGIN_ID,
          initializer: Initializer,
          isReady: false,
          name: PLUGIN_ID
        });
      },
      async registerTrads({ locales }) {
        return Promise.all(
          locales.map(async (locale) => {
            try {
              const { default: data } = await __variableDynamicImportRuntimeHelper(/* @__PURE__ */ Object.assign({ "./translations/en.json": () => Promise.resolve().then(() => require_en_B4KWt_jN()) }), `./translations/${locale}.json`, 3);
              return { data, locale };
            } catch {
              return { data: {}, locale };
            }
          })
        );
      }
    };
    module2.exports = index;
  }
});

// ../../../node_modules/exceljs/lib/utils/under-dash.js
var require_under_dash = __commonJS({
  "../../../node_modules/exceljs/lib/utils/under-dash.js"(exports2, module2) {
    var { toString } = Object.prototype;
    var escapeHtmlRegex = /["&<>]/;
    var _2 = {
      each: function each(obj2, cb) {
        if (obj2) {
          if (Array.isArray(obj2)) {
            obj2.forEach(cb);
          } else {
            Object.keys(obj2).forEach((key) => {
              cb(obj2[key], key);
            });
          }
        }
      },
      some: function some(obj2, cb) {
        if (obj2) {
          if (Array.isArray(obj2)) {
            return obj2.some(cb);
          }
          return Object.keys(obj2).some((key) => cb(obj2[key], key));
        }
        return false;
      },
      every: function every(obj2, cb) {
        if (obj2) {
          if (Array.isArray(obj2)) {
            return obj2.every(cb);
          }
          return Object.keys(obj2).every((key) => cb(obj2[key], key));
        }
        return true;
      },
      map: function map(obj2, cb) {
        if (obj2) {
          if (Array.isArray(obj2)) {
            return obj2.map(cb);
          }
          return Object.keys(obj2).map((key) => cb(obj2[key], key));
        }
        return [];
      },
      keyBy(a, p) {
        return a.reduce((o, v) => {
          o[v[p]] = v;
          return o;
        }, {});
      },
      isEqual: function isEqual(a, b) {
        const aType = typeof a;
        const bType = typeof b;
        const aArray = Array.isArray(a);
        const bArray = Array.isArray(b);
        let keys;
        if (aType !== bType) {
          return false;
        }
        switch (typeof a) {
          case "object":
            if (aArray || bArray) {
              if (aArray && bArray) {
                return a.length === b.length && a.every((aValue, index) => {
                  const bValue = b[index];
                  return _2.isEqual(aValue, bValue);
                });
              }
              return false;
            }
            if (a === null || b === null) {
              return a === b;
            }
            keys = Object.keys(a);
            if (Object.keys(b).length !== keys.length) {
              return false;
            }
            for (const key of keys) {
              if (!b.hasOwnProperty(key)) {
                return false;
              }
            }
            return _2.every(a, (aValue, key) => {
              const bValue = b[key];
              return _2.isEqual(aValue, bValue);
            });
          default:
            return a === b;
        }
      },
      escapeHtml(html) {
        const regexResult = escapeHtmlRegex.exec(html);
        if (!regexResult)
          return html;
        let result = "";
        let escape = "";
        let lastIndex = 0;
        let i = regexResult.index;
        for (; i < html.length; i++) {
          switch (html.charAt(i)) {
            case '"':
              escape = "&quot;";
              break;
            case "&":
              escape = "&amp;";
              break;
            case "'":
              escape = "&apos;";
              break;
            case "<":
              escape = "&lt;";
              break;
            case ">":
              escape = "&gt;";
              break;
            default:
              continue;
          }
          if (lastIndex !== i)
            result += html.substring(lastIndex, i);
          lastIndex = i + 1;
          result += escape;
        }
        if (lastIndex !== i)
          return result + html.substring(lastIndex, i);
        return result;
      },
      strcmp(a, b) {
        if (a < b)
          return -1;
        if (a > b)
          return 1;
        return 0;
      },
      isUndefined(val) {
        return toString.call(val) === "[object Undefined]";
      },
      isObject(val) {
        return toString.call(val) === "[object Object]";
      },
      deepMerge() {
        const target = arguments[0] || {};
        const { length } = arguments;
        let src, clone, copyIsArray;
        function assignValue(val, key) {
          src = target[key];
          copyIsArray = Array.isArray(val);
          if (_2.isObject(val) || copyIsArray) {
            if (copyIsArray) {
              copyIsArray = false;
              clone = src && Array.isArray(src) ? src : [];
            } else {
              clone = src && _2.isObject(src) ? src : {};
            }
            target[key] = _2.deepMerge(clone, val);
          } else if (!_2.isUndefined(val)) {
            target[key] = val;
          }
        }
        for (let i = 0; i < length; i++) {
          _2.each(arguments[i], assignValue);
        }
        return target;
      }
    };
    module2.exports = _2;
  }
});

// ../../../node_modules/exceljs/lib/utils/col-cache.js
var require_col_cache = __commonJS({
  "../../../node_modules/exceljs/lib/utils/col-cache.js"(exports2, module2) {
    var addressRegex = /^[A-Z]+\d+$/;
    var colCache = {
      _dictionary: [
        "A",
        "B",
        "C",
        "D",
        "E",
        "F",
        "G",
        "H",
        "I",
        "J",
        "K",
        "L",
        "M",
        "N",
        "O",
        "P",
        "Q",
        "R",
        "S",
        "T",
        "U",
        "V",
        "W",
        "X",
        "Y",
        "Z"
      ],
      _l2nFill: 0,
      _l2n: {},
      _n2l: [],
      _level(n) {
        if (n <= 26) {
          return 1;
        }
        if (n <= 26 * 26) {
          return 2;
        }
        return 3;
      },
      _fill(level) {
        let c;
        let v;
        let l1;
        let l2;
        let l3;
        let n = 1;
        if (level >= 4) {
          throw new Error("Out of bounds. Excel supports columns from 1 to 16384");
        }
        if (this._l2nFill < 1 && level >= 1) {
          while (n <= 26) {
            c = this._dictionary[n - 1];
            this._n2l[n] = c;
            this._l2n[c] = n;
            n++;
          }
          this._l2nFill = 1;
        }
        if (this._l2nFill < 2 && level >= 2) {
          n = 27;
          while (n <= 26 + 26 * 26) {
            v = n - (26 + 1);
            l1 = v % 26;
            l2 = Math.floor(v / 26);
            c = this._dictionary[l2] + this._dictionary[l1];
            this._n2l[n] = c;
            this._l2n[c] = n;
            n++;
          }
          this._l2nFill = 2;
        }
        if (this._l2nFill < 3 && level >= 3) {
          n = 26 + 26 * 26 + 1;
          while (n <= 16384) {
            v = n - (26 * 26 + 26 + 1);
            l1 = v % 26;
            l2 = Math.floor(v / 26) % 26;
            l3 = Math.floor(v / (26 * 26));
            c = this._dictionary[l3] + this._dictionary[l2] + this._dictionary[l1];
            this._n2l[n] = c;
            this._l2n[c] = n;
            n++;
          }
          this._l2nFill = 3;
        }
      },
      l2n(l2) {
        if (!this._l2n[l2]) {
          this._fill(l2.length);
        }
        if (!this._l2n[l2]) {
          throw new Error(`Out of bounds. Invalid column letter: ${l2}`);
        }
        return this._l2n[l2];
      },
      n2l(n) {
        if (n < 1 || n > 16384) {
          throw new Error(`${n} is out of bounds. Excel supports columns from 1 to 16384`);
        }
        if (!this._n2l[n]) {
          this._fill(this._level(n));
        }
        return this._n2l[n];
      },
      // =========================================================================
      // Address processing
      _hash: {},
      // check if value looks like an address
      validateAddress(value) {
        if (!addressRegex.test(value)) {
          throw new Error(`Invalid Address: ${value}`);
        }
        return true;
      },
      // convert address string into structure
      decodeAddress(value) {
        const addr = value.length < 5 && this._hash[value];
        if (addr) {
          return addr;
        }
        let hasCol = false;
        let col = "";
        let colNumber = 0;
        let hasRow = false;
        let row = "";
        let rowNumber = 0;
        for (let i = 0, char; i < value.length; i++) {
          char = value.charCodeAt(i);
          if (!hasRow && char >= 65 && char <= 90) {
            hasCol = true;
            col += value[i];
            colNumber = colNumber * 26 + char - 64;
          } else if (char >= 48 && char <= 57) {
            hasRow = true;
            row += value[i];
            rowNumber = rowNumber * 10 + char - 48;
          } else if (hasRow && hasCol && char !== 36) {
            break;
          }
        }
        if (!hasCol) {
          colNumber = void 0;
        } else if (colNumber > 16384) {
          throw new Error(`Out of bounds. Invalid column letter: ${col}`);
        }
        if (!hasRow) {
          rowNumber = void 0;
        }
        value = col + row;
        const address = {
          address: value,
          col: colNumber,
          row: rowNumber,
          $col$row: `$${col}$${row}`
        };
        if (colNumber <= 100 && rowNumber <= 100) {
          this._hash[value] = address;
          this._hash[address.$col$row] = address;
        }
        return address;
      },
      // convert r,c into structure (if only 1 arg, assume r is address string)
      getAddress(r, c) {
        if (c) {
          const address = this.n2l(c) + r;
          return this.decodeAddress(address);
        }
        return this.decodeAddress(r);
      },
      // convert [address], [tl:br] into address structures
      decode(value) {
        const parts = value.split(":");
        if (parts.length === 2) {
          const tl = this.decodeAddress(parts[0]);
          const br = this.decodeAddress(parts[1]);
          const result = {
            top: Math.min(tl.row, br.row),
            left: Math.min(tl.col, br.col),
            bottom: Math.max(tl.row, br.row),
            right: Math.max(tl.col, br.col)
          };
          result.tl = this.n2l(result.left) + result.top;
          result.br = this.n2l(result.right) + result.bottom;
          result.dimensions = `${result.tl}:${result.br}`;
          return result;
        }
        return this.decodeAddress(value);
      },
      // convert [sheetName!][$]col[$]row[[$]col[$]row] into address or range structures
      decodeEx(value) {
        const groups = value.match(/(?:(?:(?:'((?:[^']|'')*)')|([^'^ !]*))!)?(.*)/);
        const sheetName = groups[1] || groups[2];
        const reference = groups[3];
        const parts = reference.split(":");
        if (parts.length > 1) {
          let tl = this.decodeAddress(parts[0]);
          let br = this.decodeAddress(parts[1]);
          const top = Math.min(tl.row, br.row);
          const left = Math.min(tl.col, br.col);
          const bottom = Math.max(tl.row, br.row);
          const right = Math.max(tl.col, br.col);
          tl = this.n2l(left) + top;
          br = this.n2l(right) + bottom;
          return {
            top,
            left,
            bottom,
            right,
            sheetName,
            tl: { address: tl, col: left, row: top, $col$row: `$${this.n2l(left)}$${top}`, sheetName },
            br: {
              address: br,
              col: right,
              row: bottom,
              $col$row: `$${this.n2l(right)}$${bottom}`,
              sheetName
            },
            dimensions: `${tl}:${br}`
          };
        }
        if (reference.startsWith("#")) {
          return sheetName ? { sheetName, error: reference } : { error: reference };
        }
        const address = this.decodeAddress(reference);
        return sheetName ? { sheetName, ...address } : address;
      },
      // convert row,col into address string
      encodeAddress(row, col) {
        return colCache.n2l(col) + row;
      },
      // convert row,col into string address or t,l,b,r into range
      encode() {
        switch (arguments.length) {
          case 2:
            return colCache.encodeAddress(arguments[0], arguments[1]);
          case 4:
            return `${colCache.encodeAddress(arguments[0], arguments[1])}:${colCache.encodeAddress(
              arguments[2],
              arguments[3]
            )}`;
          default:
            throw new Error("Can only encode with 2 or 4 arguments");
        }
      },
      // return true if address is contained within range
      inRange(range, address) {
        const [left, top, , right, bottom] = range;
        const [col, row] = address;
        return col >= left && col <= right && row >= top && row <= bottom;
      }
    };
    module2.exports = colCache;
  }
});

// ../../../node_modules/exceljs/lib/doc/range.js
var require_range = __commonJS({
  "../../../node_modules/exceljs/lib/doc/range.js"(exports2, module2) {
    var colCache = require_col_cache();
    var Range = class _Range {
      constructor() {
        this.decode(arguments);
      }
      setTLBR(t, l2, b, r, s) {
        if (arguments.length < 4) {
          const tl = colCache.decodeAddress(t);
          const br = colCache.decodeAddress(l2);
          this.model = {
            top: Math.min(tl.row, br.row),
            left: Math.min(tl.col, br.col),
            bottom: Math.max(tl.row, br.row),
            right: Math.max(tl.col, br.col),
            sheetName: b
          };
          this.setTLBR(tl.row, tl.col, br.row, br.col, s);
        } else {
          this.model = {
            top: Math.min(t, b),
            left: Math.min(l2, r),
            bottom: Math.max(t, b),
            right: Math.max(l2, r),
            sheetName: s
          };
        }
      }
      decode(argv) {
        switch (argv.length) {
          case 5:
            this.setTLBR(argv[0], argv[1], argv[2], argv[3], argv[4]);
            break;
          case 4:
            this.setTLBR(argv[0], argv[1], argv[2], argv[3]);
            break;
          case 3:
            this.setTLBR(argv[0], argv[1], argv[2]);
            break;
          case 2:
            this.setTLBR(argv[0], argv[1]);
            break;
          case 1: {
            const value = argv[0];
            if (value instanceof _Range) {
              this.model = {
                top: value.model.top,
                left: value.model.left,
                bottom: value.model.bottom,
                right: value.model.right,
                sheetName: value.sheetName
              };
            } else if (value instanceof Array) {
              this.decode(value);
            } else if (value.top && value.left && value.bottom && value.right) {
              this.model = {
                top: value.top,
                left: value.left,
                bottom: value.bottom,
                right: value.right,
                sheetName: value.sheetName
              };
            } else {
              const tlbr = colCache.decodeEx(value);
              if (tlbr.top) {
                this.model = {
                  top: tlbr.top,
                  left: tlbr.left,
                  bottom: tlbr.bottom,
                  right: tlbr.right,
                  sheetName: tlbr.sheetName
                };
              } else {
                this.model = {
                  top: tlbr.row,
                  left: tlbr.col,
                  bottom: tlbr.row,
                  right: tlbr.col,
                  sheetName: tlbr.sheetName
                };
              }
            }
            break;
          }
          case 0:
            this.model = {
              top: 0,
              left: 0,
              bottom: 0,
              right: 0
            };
            break;
          default:
            throw new Error(`Invalid number of arguments to _getDimensions() - ${argv.length}`);
        }
      }
      get top() {
        return this.model.top || 1;
      }
      set top(value) {
        this.model.top = value;
      }
      get left() {
        return this.model.left || 1;
      }
      set left(value) {
        this.model.left = value;
      }
      get bottom() {
        return this.model.bottom || 1;
      }
      set bottom(value) {
        this.model.bottom = value;
      }
      get right() {
        return this.model.right || 1;
      }
      set right(value) {
        this.model.right = value;
      }
      get sheetName() {
        return this.model.sheetName;
      }
      set sheetName(value) {
        this.model.sheetName = value;
      }
      get _serialisedSheetName() {
        const { sheetName } = this.model;
        if (sheetName) {
          if (/^[a-zA-Z0-9]*$/.test(sheetName)) {
            return `${sheetName}!`;
          }
          return `'${sheetName}'!`;
        }
        return "";
      }
      expand(top, left, bottom, right) {
        if (!this.model.top || top < this.top)
          this.top = top;
        if (!this.model.left || left < this.left)
          this.left = left;
        if (!this.model.bottom || bottom > this.bottom)
          this.bottom = bottom;
        if (!this.model.right || right > this.right)
          this.right = right;
      }
      expandRow(row) {
        if (row) {
          const { dimensions, number } = row;
          if (dimensions) {
            this.expand(number, dimensions.min, number, dimensions.max);
          }
        }
      }
      expandToAddress(addressStr) {
        const address = colCache.decodeEx(addressStr);
        this.expand(address.row, address.col, address.row, address.col);
      }
      get tl() {
        return colCache.n2l(this.left) + this.top;
      }
      get $t$l() {
        return `$${colCache.n2l(this.left)}$${this.top}`;
      }
      get br() {
        return colCache.n2l(this.right) + this.bottom;
      }
      get $b$r() {
        return `$${colCache.n2l(this.right)}$${this.bottom}`;
      }
      get range() {
        return `${this._serialisedSheetName + this.tl}:${this.br}`;
      }
      get $range() {
        return `${this._serialisedSheetName + this.$t$l}:${this.$b$r}`;
      }
      get shortRange() {
        return this.count > 1 ? this.range : this._serialisedSheetName + this.tl;
      }
      get $shortRange() {
        return this.count > 1 ? this.$range : this._serialisedSheetName + this.$t$l;
      }
      get count() {
        return (1 + this.bottom - this.top) * (1 + this.right - this.left);
      }
      toString() {
        return this.range;
      }
      intersects(other) {
        if (other.sheetName && this.sheetName && other.sheetName !== this.sheetName)
          return false;
        if (other.bottom < this.top)
          return false;
        if (other.top > this.bottom)
          return false;
        if (other.right < this.left)
          return false;
        if (other.left > this.right)
          return false;
        return true;
      }
      contains(addressStr) {
        const address = colCache.decodeEx(addressStr);
        return this.containsEx(address);
      }
      containsEx(address) {
        if (address.sheetName && this.sheetName && address.sheetName !== this.sheetName)
          return false;
        return address.row >= this.top && address.row <= this.bottom && address.col >= this.left && address.col <= this.right;
      }
      forEachAddress(cb) {
        for (let col = this.left; col <= this.right; col++) {
          for (let row = this.top; row <= this.bottom; row++) {
            cb(colCache.encodeAddress(row, col), row, col);
          }
        }
      }
    };
    module2.exports = Range;
  }
});

// ../../../node_modules/exceljs/lib/doc/enums.js
var require_enums = __commonJS({
  "../../../node_modules/exceljs/lib/doc/enums.js"(exports2, module2) {
    "use strict";
    module2.exports = {
      ValueType: {
        Null: 0,
        Merge: 1,
        Number: 2,
        String: 3,
        Date: 4,
        Hyperlink: 5,
        Formula: 6,
        SharedString: 7,
        RichText: 8,
        Boolean: 9,
        Error: 10
      },
      FormulaType: {
        None: 0,
        Master: 1,
        Shared: 2
      },
      RelationshipType: {
        None: 0,
        OfficeDocument: 1,
        Worksheet: 2,
        CalcChain: 3,
        SharedStrings: 4,
        Styles: 5,
        Theme: 6,
        Hyperlink: 7
      },
      DocumentType: {
        Xlsx: 1
      },
      ReadingOrder: {
        LeftToRight: 1,
        RightToLeft: 2
      },
      ErrorValue: {
        NotApplicable: "#N/A",
        Ref: "#REF!",
        Name: "#NAME?",
        DivZero: "#DIV/0!",
        Null: "#NULL!",
        Value: "#VALUE!",
        Num: "#NUM!"
      }
    };
  }
});

// ../../../node_modules/exceljs/lib/utils/shared-formula.js
var require_shared_formula = __commonJS({
  "../../../node_modules/exceljs/lib/utils/shared-formula.js"(exports2, module2) {
    var colCache = require_col_cache();
    var replacementCandidateRx = /(([a-z_\-0-9]*)!)?([a-z0-9_$]{2,})([(])?/gi;
    var CRrx = /^([$])?([a-z]+)([$])?([1-9][0-9]*)$/i;
    function slideFormula(formula, fromCell, toCell) {
      const offset = colCache.decode(fromCell);
      const to = colCache.decode(toCell);
      return formula.replace(
        replacementCandidateRx,
        (refMatch, sheet, sheetMaybe, addrPart, trailingParen) => {
          if (trailingParen) {
            return refMatch;
          }
          const match = CRrx.exec(addrPart);
          if (match) {
            const colDollar = match[1];
            const colStr = match[2].toUpperCase();
            const rowDollar = match[3];
            const rowStr = match[4];
            if (colStr.length > 3 || colStr.length === 3 && colStr > "XFD") {
              return refMatch;
            }
            let col = colCache.l2n(colStr);
            let row = parseInt(rowStr, 10);
            if (!colDollar) {
              col += to.col - offset.col;
            }
            if (!rowDollar) {
              row += to.row - offset.row;
            }
            const res = (sheet || "") + (colDollar || "") + colCache.n2l(col) + (rowDollar || "") + row;
            return res;
          }
          return refMatch;
        }
      );
    }
    module2.exports = {
      slideFormula
    };
  }
});

// ../../../node_modules/exceljs/lib/doc/note.js
var require_note = __commonJS({
  "../../../node_modules/exceljs/lib/doc/note.js"(exports2, module2) {
    var _2 = require_under_dash();
    var Note = class _Note {
      constructor(note) {
        this.note = note;
      }
      get model() {
        let value = null;
        switch (typeof this.note) {
          case "string":
            value = {
              type: "note",
              note: {
                texts: [
                  {
                    text: this.note
                  }
                ]
              }
            };
            break;
          default:
            value = {
              type: "note",
              note: this.note
            };
            break;
        }
        return _2.deepMerge({}, _Note.DEFAULT_CONFIGS, value);
      }
      set model(value) {
        const { note } = value;
        const { texts } = note;
        if (texts.length === 1 && Object.keys(texts[0]).length === 1) {
          this.note = texts[0].text;
        } else {
          this.note = note;
        }
      }
      static fromModel(model) {
        const note = new _Note();
        note.model = model;
        return note;
      }
    };
    Note.DEFAULT_CONFIGS = {
      note: {
        margins: {
          insetmode: "auto",
          inset: [0.13, 0.13, 0.25, 0.25]
        },
        protection: {
          locked: "True",
          lockText: "True"
        },
        editAs: "absolute"
      }
    };
    module2.exports = Note;
  }
});

// ../../../node_modules/exceljs/lib/doc/cell.js
var require_cell = __commonJS({
  "../../../node_modules/exceljs/lib/doc/cell.js"(exports2, module2) {
    var colCache = require_col_cache();
    var _2 = require_under_dash();
    var Enums = require_enums();
    var { slideFormula } = require_shared_formula();
    var Note = require_note();
    var Cell = class _Cell {
      constructor(row, column, address) {
        if (!row || !column) {
          throw new Error("A Cell needs a Row");
        }
        this._row = row;
        this._column = column;
        colCache.validateAddress(address);
        this._address = address;
        this._value = Value.create(_Cell.Types.Null, this);
        this.style = this._mergeStyle(row.style, column.style, {});
        this._mergeCount = 0;
      }
      get worksheet() {
        return this._row.worksheet;
      }
      get workbook() {
        return this._row.worksheet.workbook;
      }
      // help GC by removing cyclic (and other) references
      destroy() {
        delete this.style;
        delete this._value;
        delete this._row;
        delete this._column;
        delete this._address;
      }
      // =========================================================================
      // Styles stuff
      get numFmt() {
        return this.style.numFmt;
      }
      set numFmt(value) {
        this.style.numFmt = value;
      }
      get font() {
        return this.style.font;
      }
      set font(value) {
        this.style.font = value;
      }
      get alignment() {
        return this.style.alignment;
      }
      set alignment(value) {
        this.style.alignment = value;
      }
      get border() {
        return this.style.border;
      }
      set border(value) {
        this.style.border = value;
      }
      get fill() {
        return this.style.fill;
      }
      set fill(value) {
        this.style.fill = value;
      }
      get protection() {
        return this.style.protection;
      }
      set protection(value) {
        this.style.protection = value;
      }
      _mergeStyle(rowStyle, colStyle, style) {
        const numFmt = rowStyle && rowStyle.numFmt || colStyle && colStyle.numFmt;
        if (numFmt)
          style.numFmt = numFmt;
        const font = rowStyle && rowStyle.font || colStyle && colStyle.font;
        if (font)
          style.font = font;
        const alignment = rowStyle && rowStyle.alignment || colStyle && colStyle.alignment;
        if (alignment)
          style.alignment = alignment;
        const border = rowStyle && rowStyle.border || colStyle && colStyle.border;
        if (border)
          style.border = border;
        const fill = rowStyle && rowStyle.fill || colStyle && colStyle.fill;
        if (fill)
          style.fill = fill;
        const protection = rowStyle && rowStyle.protection || colStyle && colStyle.protection;
        if (protection)
          style.protection = protection;
        return style;
      }
      // =========================================================================
      // return the address for this cell
      get address() {
        return this._address;
      }
      get row() {
        return this._row.number;
      }
      get col() {
        return this._column.number;
      }
      get $col$row() {
        return `$${this._column.letter}$${this.row}`;
      }
      // =========================================================================
      // Value stuff
      get type() {
        return this._value.type;
      }
      get effectiveType() {
        return this._value.effectiveType;
      }
      toCsvString() {
        return this._value.toCsvString();
      }
      // =========================================================================
      // Merge stuff
      addMergeRef() {
        this._mergeCount++;
      }
      releaseMergeRef() {
        this._mergeCount--;
      }
      get isMerged() {
        return this._mergeCount > 0 || this.type === _Cell.Types.Merge;
      }
      merge(master, ignoreStyle) {
        this._value.release();
        this._value = Value.create(_Cell.Types.Merge, this, master);
        if (!ignoreStyle) {
          this.style = master.style;
        }
      }
      unmerge() {
        if (this.type === _Cell.Types.Merge) {
          this._value.release();
          this._value = Value.create(_Cell.Types.Null, this);
          this.style = this._mergeStyle(this._row.style, this._column.style, {});
        }
      }
      isMergedTo(master) {
        if (this._value.type !== _Cell.Types.Merge)
          return false;
        return this._value.isMergedTo(master);
      }
      get master() {
        if (this.type === _Cell.Types.Merge) {
          return this._value.master;
        }
        return this;
      }
      get isHyperlink() {
        return this._value.type === _Cell.Types.Hyperlink;
      }
      get hyperlink() {
        return this._value.hyperlink;
      }
      // return the value
      get value() {
        return this._value.value;
      }
      // set the value - can be number, string or raw
      set value(v) {
        if (this.type === _Cell.Types.Merge) {
          this._value.master.value = v;
          return;
        }
        this._value.release();
        this._value = Value.create(Value.getType(v), this, v);
      }
      get note() {
        return this._comment && this._comment.note;
      }
      set note(note) {
        this._comment = new Note(note);
      }
      get text() {
        return this._value.toString();
      }
      get html() {
        return _2.escapeHtml(this.text);
      }
      toString() {
        return this.text;
      }
      _upgradeToHyperlink(hyperlink) {
        if (this.type === _Cell.Types.String) {
          this._value = Value.create(_Cell.Types.Hyperlink, this, {
            text: this._value.value,
            hyperlink
          });
        }
      }
      // =========================================================================
      // Formula stuff
      get formula() {
        return this._value.formula;
      }
      get result() {
        return this._value.result;
      }
      get formulaType() {
        return this._value.formulaType;
      }
      // =========================================================================
      // Name stuff
      get fullAddress() {
        const { worksheet } = this._row;
        return {
          sheetName: worksheet.name,
          address: this.address,
          row: this.row,
          col: this.col
        };
      }
      get name() {
        return this.names[0];
      }
      set name(value) {
        this.names = [value];
      }
      get names() {
        return this.workbook.definedNames.getNamesEx(this.fullAddress);
      }
      set names(value) {
        const { definedNames } = this.workbook;
        definedNames.removeAllNames(this.fullAddress);
        value.forEach((name) => {
          definedNames.addEx(this.fullAddress, name);
        });
      }
      addName(name) {
        this.workbook.definedNames.addEx(this.fullAddress, name);
      }
      removeName(name) {
        this.workbook.definedNames.removeEx(this.fullAddress, name);
      }
      removeAllNames() {
        this.workbook.definedNames.removeAllNames(this.fullAddress);
      }
      // =========================================================================
      // Data Validation stuff
      get _dataValidations() {
        return this.worksheet.dataValidations;
      }
      get dataValidation() {
        return this._dataValidations.find(this.address);
      }
      set dataValidation(value) {
        this._dataValidations.add(this.address, value);
      }
      // =========================================================================
      // Model stuff
      get model() {
        const { model } = this._value;
        model.style = this.style;
        if (this._comment) {
          model.comment = this._comment.model;
        }
        return model;
      }
      set model(value) {
        this._value.release();
        this._value = Value.create(value.type, this);
        this._value.model = value;
        if (value.comment) {
          switch (value.comment.type) {
            case "note":
              this._comment = Note.fromModel(value.comment);
              break;
          }
        }
        if (value.style) {
          this.style = value.style;
        } else {
          this.style = {};
        }
      }
    };
    Cell.Types = Enums.ValueType;
    var NullValue = class {
      constructor(cell) {
        this.model = {
          address: cell.address,
          type: Cell.Types.Null
        };
      }
      get value() {
        return null;
      }
      set value(value) {
      }
      get type() {
        return Cell.Types.Null;
      }
      get effectiveType() {
        return Cell.Types.Null;
      }
      get address() {
        return this.model.address;
      }
      set address(value) {
        this.model.address = value;
      }
      toCsvString() {
        return "";
      }
      release() {
      }
      toString() {
        return "";
      }
    };
    var NumberValue = class {
      constructor(cell, value) {
        this.model = {
          address: cell.address,
          type: Cell.Types.Number,
          value
        };
      }
      get value() {
        return this.model.value;
      }
      set value(value) {
        this.model.value = value;
      }
      get type() {
        return Cell.Types.Number;
      }
      get effectiveType() {
        return Cell.Types.Number;
      }
      get address() {
        return this.model.address;
      }
      set address(value) {
        this.model.address = value;
      }
      toCsvString() {
        return this.model.value.toString();
      }
      release() {
      }
      toString() {
        return this.model.value.toString();
      }
    };
    var StringValue = class {
      constructor(cell, value) {
        this.model = {
          address: cell.address,
          type: Cell.Types.String,
          value
        };
      }
      get value() {
        return this.model.value;
      }
      set value(value) {
        this.model.value = value;
      }
      get type() {
        return Cell.Types.String;
      }
      get effectiveType() {
        return Cell.Types.String;
      }
      get address() {
        return this.model.address;
      }
      set address(value) {
        this.model.address = value;
      }
      toCsvString() {
        return `"${this.model.value.replace(/"/g, '""')}"`;
      }
      release() {
      }
      toString() {
        return this.model.value;
      }
    };
    var RichTextValue = class {
      constructor(cell, value) {
        this.model = {
          address: cell.address,
          type: Cell.Types.String,
          value
        };
      }
      get value() {
        return this.model.value;
      }
      set value(value) {
        this.model.value = value;
      }
      toString() {
        return this.model.value.richText.map((t) => t.text).join("");
      }
      get type() {
        return Cell.Types.RichText;
      }
      get effectiveType() {
        return Cell.Types.RichText;
      }
      get address() {
        return this.model.address;
      }
      set address(value) {
        this.model.address = value;
      }
      toCsvString() {
        return `"${this.text.replace(/"/g, '""')}"`;
      }
      release() {
      }
    };
    var DateValue = class {
      constructor(cell, value) {
        this.model = {
          address: cell.address,
          type: Cell.Types.Date,
          value
        };
      }
      get value() {
        return this.model.value;
      }
      set value(value) {
        this.model.value = value;
      }
      get type() {
        return Cell.Types.Date;
      }
      get effectiveType() {
        return Cell.Types.Date;
      }
      get address() {
        return this.model.address;
      }
      set address(value) {
        this.model.address = value;
      }
      toCsvString() {
        return this.model.value.toISOString();
      }
      release() {
      }
      toString() {
        return this.model.value.toString();
      }
    };
    var HyperlinkValue = class {
      constructor(cell, value) {
        this.model = {
          address: cell.address,
          type: Cell.Types.Hyperlink,
          text: value ? value.text : void 0,
          hyperlink: value ? value.hyperlink : void 0
        };
        if (value && value.tooltip) {
          this.model.tooltip = value.tooltip;
        }
      }
      get value() {
        const v = {
          text: this.model.text,
          hyperlink: this.model.hyperlink
        };
        if (this.model.tooltip) {
          v.tooltip = this.model.tooltip;
        }
        return v;
      }
      set value(value) {
        this.model = {
          text: value.text,
          hyperlink: value.hyperlink
        };
        if (value.tooltip) {
          this.model.tooltip = value.tooltip;
        }
      }
      get text() {
        return this.model.text;
      }
      set text(value) {
        this.model.text = value;
      }
      /*
        get tooltip() {
          return this.model.tooltip;
        }
      
        set tooltip(value) {
          this.model.tooltip = value;
        } */
      get hyperlink() {
        return this.model.hyperlink;
      }
      set hyperlink(value) {
        this.model.hyperlink = value;
      }
      get type() {
        return Cell.Types.Hyperlink;
      }
      get effectiveType() {
        return Cell.Types.Hyperlink;
      }
      get address() {
        return this.model.address;
      }
      set address(value) {
        this.model.address = value;
      }
      toCsvString() {
        return this.model.hyperlink;
      }
      release() {
      }
      toString() {
        return this.model.text;
      }
    };
    var MergeValue = class {
      constructor(cell, master) {
        this.model = {
          address: cell.address,
          type: Cell.Types.Merge,
          master: master ? master.address : void 0
        };
        this._master = master;
        if (master) {
          master.addMergeRef();
        }
      }
      get value() {
        return this._master.value;
      }
      set value(value) {
        if (value instanceof Cell) {
          if (this._master) {
            this._master.releaseMergeRef();
          }
          value.addMergeRef();
          this._master = value;
        } else {
          this._master.value = value;
        }
      }
      isMergedTo(master) {
        return master === this._master;
      }
      get master() {
        return this._master;
      }
      get type() {
        return Cell.Types.Merge;
      }
      get effectiveType() {
        return this._master.effectiveType;
      }
      get address() {
        return this.model.address;
      }
      set address(value) {
        this.model.address = value;
      }
      toCsvString() {
        return "";
      }
      release() {
        this._master.releaseMergeRef();
      }
      toString() {
        return this.value.toString();
      }
    };
    var FormulaValue = class {
      constructor(cell, value) {
        this.cell = cell;
        this.model = {
          address: cell.address,
          type: Cell.Types.Formula,
          shareType: value ? value.shareType : void 0,
          ref: value ? value.ref : void 0,
          formula: value ? value.formula : void 0,
          sharedFormula: value ? value.sharedFormula : void 0,
          result: value ? value.result : void 0
        };
      }
      _copyModel(model) {
        const copy = {};
        const cp = (name) => {
          const value = model[name];
          if (value) {
            copy[name] = value;
          }
        };
        cp("formula");
        cp("result");
        cp("ref");
        cp("shareType");
        cp("sharedFormula");
        return copy;
      }
      get value() {
        return this._copyModel(this.model);
      }
      set value(value) {
        this.model = this._copyModel(value);
      }
      validate(value) {
        switch (Value.getType(value)) {
          case Cell.Types.Null:
          case Cell.Types.String:
          case Cell.Types.Number:
          case Cell.Types.Date:
            break;
          case Cell.Types.Hyperlink:
          case Cell.Types.Formula:
          default:
            throw new Error("Cannot process that type of result value");
        }
      }
      get dependencies() {
        const ranges = this.formula.match(/([a-zA-Z0-9]+!)?[A-Z]{1,3}\d{1,4}:[A-Z]{1,3}\d{1,4}/g);
        const cells = this.formula.replace(/([a-zA-Z0-9]+!)?[A-Z]{1,3}\d{1,4}:[A-Z]{1,3}\d{1,4}/g, "").match(/([a-zA-Z0-9]+!)?[A-Z]{1,3}\d{1,4}/g);
        return {
          ranges,
          cells
        };
      }
      get formula() {
        return this.model.formula || this._getTranslatedFormula();
      }
      set formula(value) {
        this.model.formula = value;
      }
      get formulaType() {
        if (this.model.formula) {
          return Enums.FormulaType.Master;
        }
        if (this.model.sharedFormula) {
          return Enums.FormulaType.Shared;
        }
        return Enums.FormulaType.None;
      }
      get result() {
        return this.model.result;
      }
      set result(value) {
        this.model.result = value;
      }
      get type() {
        return Cell.Types.Formula;
      }
      get effectiveType() {
        const v = this.model.result;
        if (v === null || v === void 0) {
          return Enums.ValueType.Null;
        }
        if (v instanceof String || typeof v === "string") {
          return Enums.ValueType.String;
        }
        if (typeof v === "number") {
          return Enums.ValueType.Number;
        }
        if (v instanceof Date) {
          return Enums.ValueType.Date;
        }
        if (v.text && v.hyperlink) {
          return Enums.ValueType.Hyperlink;
        }
        if (v.formula) {
          return Enums.ValueType.Formula;
        }
        return Enums.ValueType.Null;
      }
      get address() {
        return this.model.address;
      }
      set address(value) {
        this.model.address = value;
      }
      _getTranslatedFormula() {
        if (!this._translatedFormula && this.model.sharedFormula) {
          const { worksheet } = this.cell;
          const master = worksheet.findCell(this.model.sharedFormula);
          this._translatedFormula = master && slideFormula(master.formula, master.address, this.model.address);
        }
        return this._translatedFormula;
      }
      toCsvString() {
        return `${this.model.result || ""}`;
      }
      release() {
      }
      toString() {
        return this.model.result ? this.model.result.toString() : "";
      }
    };
    var SharedStringValue = class {
      constructor(cell, value) {
        this.model = {
          address: cell.address,
          type: Cell.Types.SharedString,
          value
        };
      }
      get value() {
        return this.model.value;
      }
      set value(value) {
        this.model.value = value;
      }
      get type() {
        return Cell.Types.SharedString;
      }
      get effectiveType() {
        return Cell.Types.SharedString;
      }
      get address() {
        return this.model.address;
      }
      set address(value) {
        this.model.address = value;
      }
      toCsvString() {
        return this.model.value.toString();
      }
      release() {
      }
      toString() {
        return this.model.value.toString();
      }
    };
    var BooleanValue = class {
      constructor(cell, value) {
        this.model = {
          address: cell.address,
          type: Cell.Types.Boolean,
          value
        };
      }
      get value() {
        return this.model.value;
      }
      set value(value) {
        this.model.value = value;
      }
      get type() {
        return Cell.Types.Boolean;
      }
      get effectiveType() {
        return Cell.Types.Boolean;
      }
      get address() {
        return this.model.address;
      }
      set address(value) {
        this.model.address = value;
      }
      toCsvString() {
        return this.model.value ? 1 : 0;
      }
      release() {
      }
      toString() {
        return this.model.value.toString();
      }
    };
    var ErrorValue = class {
      constructor(cell, value) {
        this.model = {
          address: cell.address,
          type: Cell.Types.Error,
          value
        };
      }
      get value() {
        return this.model.value;
      }
      set value(value) {
        this.model.value = value;
      }
      get type() {
        return Cell.Types.Error;
      }
      get effectiveType() {
        return Cell.Types.Error;
      }
      get address() {
        return this.model.address;
      }
      set address(value) {
        this.model.address = value;
      }
      toCsvString() {
        return this.toString();
      }
      release() {
      }
      toString() {
        return this.model.value.error.toString();
      }
    };
    var JSONValue = class {
      constructor(cell, value) {
        this.model = {
          address: cell.address,
          type: Cell.Types.String,
          value: JSON.stringify(value),
          rawValue: value
        };
      }
      get value() {
        return this.model.rawValue;
      }
      set value(value) {
        this.model.rawValue = value;
        this.model.value = JSON.stringify(value);
      }
      get type() {
        return Cell.Types.String;
      }
      get effectiveType() {
        return Cell.Types.String;
      }
      get address() {
        return this.model.address;
      }
      set address(value) {
        this.model.address = value;
      }
      toCsvString() {
        return this.model.value;
      }
      release() {
      }
      toString() {
        return this.model.value;
      }
    };
    var Value = {
      getType(value) {
        if (value === null || value === void 0) {
          return Cell.Types.Null;
        }
        if (value instanceof String || typeof value === "string") {
          return Cell.Types.String;
        }
        if (typeof value === "number") {
          return Cell.Types.Number;
        }
        if (typeof value === "boolean") {
          return Cell.Types.Boolean;
        }
        if (value instanceof Date) {
          return Cell.Types.Date;
        }
        if (value.text && value.hyperlink) {
          return Cell.Types.Hyperlink;
        }
        if (value.formula || value.sharedFormula) {
          return Cell.Types.Formula;
        }
        if (value.richText) {
          return Cell.Types.RichText;
        }
        if (value.sharedString) {
          return Cell.Types.SharedString;
        }
        if (value.error) {
          return Cell.Types.Error;
        }
        return Cell.Types.JSON;
      },
      // map valueType to constructor
      types: [
        { t: Cell.Types.Null, f: NullValue },
        { t: Cell.Types.Number, f: NumberValue },
        { t: Cell.Types.String, f: StringValue },
        { t: Cell.Types.Date, f: DateValue },
        { t: Cell.Types.Hyperlink, f: HyperlinkValue },
        { t: Cell.Types.Formula, f: FormulaValue },
        { t: Cell.Types.Merge, f: MergeValue },
        { t: Cell.Types.JSON, f: JSONValue },
        { t: Cell.Types.SharedString, f: SharedStringValue },
        { t: Cell.Types.RichText, f: RichTextValue },
        { t: Cell.Types.Boolean, f: BooleanValue },
        { t: Cell.Types.Error, f: ErrorValue }
      ].reduce((p, t) => {
        p[t.t] = t.f;
        return p;
      }, []),
      create(type, cell, value) {
        const T = this.types[type];
        if (!T) {
          throw new Error(`Could not create Value of type ${type}`);
        }
        return new T(cell, value);
      }
    };
    module2.exports = Cell;
  }
});

// ../../../node_modules/exceljs/lib/doc/row.js
var require_row = __commonJS({
  "../../../node_modules/exceljs/lib/doc/row.js"(exports2, module2) {
    "use strict";
    var _2 = require_under_dash();
    var Enums = require_enums();
    var colCache = require_col_cache();
    var Cell = require_cell();
    var Row = class {
      constructor(worksheet, number) {
        this._worksheet = worksheet;
        this._number = number;
        this._cells = [];
        this.style = {};
        this.outlineLevel = 0;
      }
      // return the row number
      get number() {
        return this._number;
      }
      get worksheet() {
        return this._worksheet;
      }
      // Inform Streaming Writer that this row (and all rows before it) are complete
      // and ready to write. Has no effect on Worksheet document
      commit() {
        this._worksheet._commitRow(this);
      }
      // helps GC by breaking cyclic references
      destroy() {
        delete this._worksheet;
        delete this._cells;
        delete this.style;
      }
      findCell(colNumber) {
        return this._cells[colNumber - 1];
      }
      // given {address, row, col}, find or create new cell
      getCellEx(address) {
        let cell = this._cells[address.col - 1];
        if (!cell) {
          const column = this._worksheet.getColumn(address.col);
          cell = new Cell(this, column, address.address);
          this._cells[address.col - 1] = cell;
        }
        return cell;
      }
      // get cell by key, letter or column number
      getCell(col) {
        if (typeof col === "string") {
          const column = this._worksheet.getColumnKey(col);
          if (column) {
            col = column.number;
          } else {
            col = colCache.l2n(col);
          }
        }
        return this._cells[col - 1] || this.getCellEx({
          address: colCache.encodeAddress(this._number, col),
          row: this._number,
          col
        });
      }
      // remove cell(s) and shift all higher cells down by count
      splice(start, count, ...inserts) {
        const nKeep = start + count;
        const nExpand = inserts.length - count;
        const nEnd = this._cells.length;
        let i;
        let cSrc;
        let cDst;
        if (nExpand < 0) {
          for (i = start + inserts.length; i <= nEnd; i++) {
            cDst = this._cells[i - 1];
            cSrc = this._cells[i - nExpand - 1];
            if (cSrc) {
              cDst = this.getCell(i);
              cDst.value = cSrc.value;
              cDst.style = cSrc.style;
              cDst._comment = cSrc._comment;
            } else if (cDst) {
              cDst.value = null;
              cDst.style = {};
              cDst._comment = void 0;
            }
          }
        } else if (nExpand > 0) {
          for (i = nEnd; i >= nKeep; i--) {
            cSrc = this._cells[i - 1];
            if (cSrc) {
              cDst = this.getCell(i + nExpand);
              cDst.value = cSrc.value;
              cDst.style = cSrc.style;
              cDst._comment = cSrc._comment;
            } else {
              this._cells[i + nExpand - 1] = void 0;
            }
          }
        }
        for (i = 0; i < inserts.length; i++) {
          cDst = this.getCell(start + i);
          cDst.value = inserts[i];
          cDst.style = {};
          cDst._comment = void 0;
        }
      }
      // Iterate over all non-null cells in this row
      eachCell(options, iteratee) {
        if (!iteratee) {
          iteratee = options;
          options = null;
        }
        if (options && options.includeEmpty) {
          const n = this._cells.length;
          for (let i = 1; i <= n; i++) {
            iteratee(this.getCell(i), i);
          }
        } else {
          this._cells.forEach((cell, index) => {
            if (cell && cell.type !== Enums.ValueType.Null) {
              iteratee(cell, index + 1);
            }
          });
        }
      }
      // ===========================================================================
      // Page Breaks
      addPageBreak(lft, rght) {
        const ws = this._worksheet;
        const left = Math.max(0, lft - 1) || 0;
        const right = Math.max(0, rght - 1) || 16838;
        const pb = {
          id: this._number,
          max: right,
          man: 1
        };
        if (left)
          pb.min = left;
        ws.rowBreaks.push(pb);
      }
      // return a sparse array of cell values
      get values() {
        const values = [];
        this._cells.forEach((cell) => {
          if (cell && cell.type !== Enums.ValueType.Null) {
            values[cell.col] = cell.value;
          }
        });
        return values;
      }
      // set the values by contiguous or sparse array, or by key'd object literal
      set values(value) {
        this._cells = [];
        if (!value) {
        } else if (value instanceof Array) {
          let offset = 0;
          if (value.hasOwnProperty("0")) {
            offset = 1;
          }
          value.forEach((item, index) => {
            if (item !== void 0) {
              this.getCellEx({
                address: colCache.encodeAddress(this._number, index + offset),
                row: this._number,
                col: index + offset
              }).value = item;
            }
          });
        } else {
          this._worksheet.eachColumnKey((column, key) => {
            if (value[key] !== void 0) {
              this.getCellEx({
                address: colCache.encodeAddress(this._number, column.number),
                row: this._number,
                col: column.number
              }).value = value[key];
            }
          });
        }
      }
      // returns true if the row includes at least one cell with a value
      get hasValues() {
        return _2.some(this._cells, (cell) => cell && cell.type !== Enums.ValueType.Null);
      }
      get cellCount() {
        return this._cells.length;
      }
      get actualCellCount() {
        let count = 0;
        this.eachCell(() => {
          count++;
        });
        return count;
      }
      // get the min and max column number for the non-null cells in this row or null
      get dimensions() {
        let min = 0;
        let max = 0;
        this._cells.forEach((cell) => {
          if (cell && cell.type !== Enums.ValueType.Null) {
            if (!min || min > cell.col) {
              min = cell.col;
            }
            if (max < cell.col) {
              max = cell.col;
            }
          }
        });
        return min > 0 ? {
          min,
          max
        } : null;
      }
      // =========================================================================
      // styles
      _applyStyle(name, value) {
        this.style[name] = value;
        this._cells.forEach((cell) => {
          if (cell) {
            cell[name] = value;
          }
        });
        return value;
      }
      get numFmt() {
        return this.style.numFmt;
      }
      set numFmt(value) {
        this._applyStyle("numFmt", value);
      }
      get font() {
        return this.style.font;
      }
      set font(value) {
        this._applyStyle("font", value);
      }
      get alignment() {
        return this.style.alignment;
      }
      set alignment(value) {
        this._applyStyle("alignment", value);
      }
      get protection() {
        return this.style.protection;
      }
      set protection(value) {
        this._applyStyle("protection", value);
      }
      get border() {
        return this.style.border;
      }
      set border(value) {
        this._applyStyle("border", value);
      }
      get fill() {
        return this.style.fill;
      }
      set fill(value) {
        this._applyStyle("fill", value);
      }
      get hidden() {
        return !!this._hidden;
      }
      set hidden(value) {
        this._hidden = value;
      }
      get outlineLevel() {
        return this._outlineLevel || 0;
      }
      set outlineLevel(value) {
        this._outlineLevel = value;
      }
      get collapsed() {
        return !!(this._outlineLevel && this._outlineLevel >= this._worksheet.properties.outlineLevelRow);
      }
      // =========================================================================
      get model() {
        const cells = [];
        let min = 0;
        let max = 0;
        this._cells.forEach((cell) => {
          if (cell) {
            const cellModel = cell.model;
            if (cellModel) {
              if (!min || min > cell.col) {
                min = cell.col;
              }
              if (max < cell.col) {
                max = cell.col;
              }
              cells.push(cellModel);
            }
          }
        });
        return this.height || cells.length ? {
          cells,
          number: this.number,
          min,
          max,
          height: this.height,
          style: this.style,
          hidden: this.hidden,
          outlineLevel: this.outlineLevel,
          collapsed: this.collapsed
        } : null;
      }
      set model(value) {
        if (value.number !== this._number) {
          throw new Error("Invalid row number in model");
        }
        this._cells = [];
        let previousAddress;
        value.cells.forEach((cellModel) => {
          switch (cellModel.type) {
            case Cell.Types.Merge:
              break;
            default: {
              let address;
              if (cellModel.address) {
                address = colCache.decodeAddress(cellModel.address);
              } else if (previousAddress) {
                const { row } = previousAddress;
                const col = previousAddress.col + 1;
                address = {
                  row,
                  col,
                  address: colCache.encodeAddress(row, col),
                  $col$row: `$${colCache.n2l(col)}$${row}`
                };
              }
              previousAddress = address;
              const cell = this.getCellEx(address);
              cell.model = cellModel;
              break;
            }
          }
        });
        if (value.height) {
          this.height = value.height;
        } else {
          delete this.height;
        }
        this.hidden = value.hidden;
        this.outlineLevel = value.outlineLevel || 0;
        this.style = value.style && JSON.parse(JSON.stringify(value.style)) || {};
      }
    };
    module2.exports = Row;
  }
});

// ../../../node_modules/exceljs/lib/doc/column.js
var require_column = __commonJS({
  "../../../node_modules/exceljs/lib/doc/column.js"(exports2, module2) {
    "use strict";
    var _2 = require_under_dash();
    var Enums = require_enums();
    var colCache = require_col_cache();
    var DEFAULT_COLUMN_WIDTH = 9;
    var Column = class _Column {
      constructor(worksheet, number, defn) {
        this._worksheet = worksheet;
        this._number = number;
        if (defn !== false) {
          this.defn = defn;
        }
      }
      get number() {
        return this._number;
      }
      get worksheet() {
        return this._worksheet;
      }
      get letter() {
        return colCache.n2l(this._number);
      }
      get isCustomWidth() {
        return this.width !== void 0 && this.width !== DEFAULT_COLUMN_WIDTH;
      }
      get defn() {
        return {
          header: this._header,
          key: this.key,
          width: this.width,
          style: this.style,
          hidden: this.hidden,
          outlineLevel: this.outlineLevel
        };
      }
      set defn(value) {
        if (value) {
          this.key = value.key;
          this.width = value.width !== void 0 ? value.width : DEFAULT_COLUMN_WIDTH;
          this.outlineLevel = value.outlineLevel;
          if (value.style) {
            this.style = value.style;
          } else {
            this.style = {};
          }
          this.header = value.header;
          this._hidden = !!value.hidden;
        } else {
          delete this._header;
          delete this._key;
          delete this.width;
          this.style = {};
          this.outlineLevel = 0;
        }
      }
      get headers() {
        return this._header && this._header instanceof Array ? this._header : [this._header];
      }
      get header() {
        return this._header;
      }
      set header(value) {
        if (value !== void 0) {
          this._header = value;
          this.headers.forEach((text, index) => {
            this._worksheet.getCell(index + 1, this.number).value = text;
          });
        } else {
          this._header = void 0;
        }
      }
      get key() {
        return this._key;
      }
      set key(value) {
        const column = this._key && this._worksheet.getColumnKey(this._key);
        if (column === this) {
          this._worksheet.deleteColumnKey(this._key);
        }
        this._key = value;
        if (value) {
          this._worksheet.setColumnKey(this._key, this);
        }
      }
      get hidden() {
        return !!this._hidden;
      }
      set hidden(value) {
        this._hidden = value;
      }
      get outlineLevel() {
        return this._outlineLevel || 0;
      }
      set outlineLevel(value) {
        this._outlineLevel = value;
      }
      get collapsed() {
        return !!(this._outlineLevel && this._outlineLevel >= this._worksheet.properties.outlineLevelCol);
      }
      toString() {
        return JSON.stringify({
          key: this.key,
          width: this.width,
          headers: this.headers.length ? this.headers : void 0
        });
      }
      equivalentTo(other) {
        return this.width === other.width && this.hidden === other.hidden && this.outlineLevel === other.outlineLevel && _2.isEqual(this.style, other.style);
      }
      get isDefault() {
        if (this.isCustomWidth) {
          return false;
        }
        if (this.hidden) {
          return false;
        }
        if (this.outlineLevel) {
          return false;
        }
        const s = this.style;
        if (s && (s.font || s.numFmt || s.alignment || s.border || s.fill || s.protection)) {
          return false;
        }
        return true;
      }
      get headerCount() {
        return this.headers.length;
      }
      eachCell(options, iteratee) {
        const colNumber = this.number;
        if (!iteratee) {
          iteratee = options;
          options = null;
        }
        this._worksheet.eachRow(options, (row, rowNumber) => {
          iteratee(row.getCell(colNumber), rowNumber);
        });
      }
      get values() {
        const v = [];
        this.eachCell((cell, rowNumber) => {
          if (cell && cell.type !== Enums.ValueType.Null) {
            v[rowNumber] = cell.value;
          }
        });
        return v;
      }
      set values(v) {
        if (!v) {
          return;
        }
        const colNumber = this.number;
        let offset = 0;
        if (v.hasOwnProperty("0")) {
          offset = 1;
        }
        v.forEach((value, index) => {
          this._worksheet.getCell(index + offset, colNumber).value = value;
        });
      }
      // =========================================================================
      // styles
      _applyStyle(name, value) {
        this.style[name] = value;
        this.eachCell((cell) => {
          cell[name] = value;
        });
        return value;
      }
      get numFmt() {
        return this.style.numFmt;
      }
      set numFmt(value) {
        this._applyStyle("numFmt", value);
      }
      get font() {
        return this.style.font;
      }
      set font(value) {
        this._applyStyle("font", value);
      }
      get alignment() {
        return this.style.alignment;
      }
      set alignment(value) {
        this._applyStyle("alignment", value);
      }
      get protection() {
        return this.style.protection;
      }
      set protection(value) {
        this._applyStyle("protection", value);
      }
      get border() {
        return this.style.border;
      }
      set border(value) {
        this._applyStyle("border", value);
      }
      get fill() {
        return this.style.fill;
      }
      set fill(value) {
        this._applyStyle("fill", value);
      }
      // =============================================================================
      // static functions
      static toModel(columns) {
        const cols = [];
        let col = null;
        if (columns) {
          columns.forEach((column, index) => {
            if (column.isDefault) {
              if (col) {
                col = null;
              }
            } else if (!col || !column.equivalentTo(col)) {
              col = {
                min: index + 1,
                max: index + 1,
                width: column.width !== void 0 ? column.width : DEFAULT_COLUMN_WIDTH,
                style: column.style,
                isCustomWidth: column.isCustomWidth,
                hidden: column.hidden,
                outlineLevel: column.outlineLevel,
                collapsed: column.collapsed
              };
              cols.push(col);
            } else {
              col.max = index + 1;
            }
          });
        }
        return cols.length ? cols : void 0;
      }
      static fromModel(worksheet, cols) {
        cols = cols || [];
        const columns = [];
        let count = 1;
        let index = 0;
        cols = cols.sort(function(pre, next) {
          return pre.min - next.min;
        });
        while (index < cols.length) {
          const col = cols[index++];
          while (count < col.min) {
            columns.push(new _Column(worksheet, count++));
          }
          while (count <= col.max) {
            columns.push(new _Column(worksheet, count++, col));
          }
        }
        return columns.length ? columns : null;
      }
    };
    module2.exports = Column;
  }
});

// ../../../node_modules/exceljs/lib/doc/anchor.js
var require_anchor = __commonJS({
  "../../../node_modules/exceljs/lib/doc/anchor.js"(exports2, module2) {
    "use strict";
    var colCache = require_col_cache();
    var Anchor = class _Anchor {
      constructor(worksheet, address, offset = 0) {
        this.worksheet = worksheet;
        if (!address) {
          this.nativeCol = 0;
          this.nativeColOff = 0;
          this.nativeRow = 0;
          this.nativeRowOff = 0;
        } else if (typeof address === "string") {
          const decoded = colCache.decodeAddress(address);
          this.nativeCol = decoded.col + offset;
          this.nativeColOff = 0;
          this.nativeRow = decoded.row + offset;
          this.nativeRowOff = 0;
        } else if (address.nativeCol !== void 0) {
          this.nativeCol = address.nativeCol || 0;
          this.nativeColOff = address.nativeColOff || 0;
          this.nativeRow = address.nativeRow || 0;
          this.nativeRowOff = address.nativeRowOff || 0;
        } else if (address.col !== void 0) {
          this.col = address.col + offset;
          this.row = address.row + offset;
        } else {
          this.nativeCol = 0;
          this.nativeColOff = 0;
          this.nativeRow = 0;
          this.nativeRowOff = 0;
        }
      }
      static asInstance(model) {
        return model instanceof _Anchor || model == null ? model : new _Anchor(model);
      }
      get col() {
        return this.nativeCol + Math.min(this.colWidth - 1, this.nativeColOff) / this.colWidth;
      }
      set col(v) {
        this.nativeCol = Math.floor(v);
        this.nativeColOff = Math.floor((v - this.nativeCol) * this.colWidth);
      }
      get row() {
        return this.nativeRow + Math.min(this.rowHeight - 1, this.nativeRowOff) / this.rowHeight;
      }
      set row(v) {
        this.nativeRow = Math.floor(v);
        this.nativeRowOff = Math.floor((v - this.nativeRow) * this.rowHeight);
      }
      get colWidth() {
        return this.worksheet && this.worksheet.getColumn(this.nativeCol + 1) && this.worksheet.getColumn(this.nativeCol + 1).isCustomWidth ? Math.floor(this.worksheet.getColumn(this.nativeCol + 1).width * 1e4) : 64e4;
      }
      get rowHeight() {
        return this.worksheet && this.worksheet.getRow(this.nativeRow + 1) && this.worksheet.getRow(this.nativeRow + 1).height ? Math.floor(this.worksheet.getRow(this.nativeRow + 1).height * 1e4) : 18e4;
      }
      get model() {
        return {
          nativeCol: this.nativeCol,
          nativeColOff: this.nativeColOff,
          nativeRow: this.nativeRow,
          nativeRowOff: this.nativeRowOff
        };
      }
      set model(value) {
        this.nativeCol = value.nativeCol;
        this.nativeColOff = value.nativeColOff;
        this.nativeRow = value.nativeRow;
        this.nativeRowOff = value.nativeRowOff;
      }
    };
    module2.exports = Anchor;
  }
});

// ../../../node_modules/exceljs/lib/doc/image.js
var require_image = __commonJS({
  "../../../node_modules/exceljs/lib/doc/image.js"(exports2, module2) {
    var colCache = require_col_cache();
    var Anchor = require_anchor();
    var Image = class {
      constructor(worksheet, model) {
        this.worksheet = worksheet;
        this.model = model;
      }
      get model() {
        switch (this.type) {
          case "background":
            return {
              type: this.type,
              imageId: this.imageId
            };
          case "image":
            return {
              type: this.type,
              imageId: this.imageId,
              hyperlinks: this.range.hyperlinks,
              range: {
                tl: this.range.tl.model,
                br: this.range.br && this.range.br.model,
                ext: this.range.ext,
                editAs: this.range.editAs
              }
            };
          default:
            throw new Error("Invalid Image Type");
        }
      }
      set model({ type, imageId, range, hyperlinks }) {
        this.type = type;
        this.imageId = imageId;
        if (type === "image") {
          if (typeof range === "string") {
            const decoded = colCache.decode(range);
            this.range = {
              tl: new Anchor(this.worksheet, { col: decoded.left, row: decoded.top }, -1),
              br: new Anchor(this.worksheet, { col: decoded.right, row: decoded.bottom }, 0),
              editAs: "oneCell"
            };
          } else {
            this.range = {
              tl: new Anchor(this.worksheet, range.tl, 0),
              br: range.br && new Anchor(this.worksheet, range.br, 0),
              ext: range.ext,
              editAs: range.editAs,
              hyperlinks: hyperlinks || range.hyperlinks
            };
          }
        }
      }
    };
    module2.exports = Image;
  }
});

// ../../../node_modules/exceljs/lib/doc/table.js
var require_table = __commonJS({
  "../../../node_modules/exceljs/lib/doc/table.js"(exports2, module2) {
    var colCache = require_col_cache();
    var Column = class {
      // wrapper around column model, allowing access and manipulation
      constructor(table, column, index) {
        this.table = table;
        this.column = column;
        this.index = index;
      }
      _set(name, value) {
        this.table.cacheState();
        this.column[name] = value;
      }
      /* eslint-disable lines-between-class-members */
      get name() {
        return this.column.name;
      }
      set name(value) {
        this._set("name", value);
      }
      get filterButton() {
        return this.column.filterButton;
      }
      set filterButton(value) {
        this.column.filterButton = value;
      }
      get style() {
        return this.column.style;
      }
      set style(value) {
        this.column.style = value;
      }
      get totalsRowLabel() {
        return this.column.totalsRowLabel;
      }
      set totalsRowLabel(value) {
        this._set("totalsRowLabel", value);
      }
      get totalsRowFunction() {
        return this.column.totalsRowFunction;
      }
      set totalsRowFunction(value) {
        this._set("totalsRowFunction", value);
      }
      get totalsRowResult() {
        return this.column.totalsRowResult;
      }
      set totalsRowResult(value) {
        this._set("totalsRowResult", value);
      }
      get totalsRowFormula() {
        return this.column.totalsRowFormula;
      }
      set totalsRowFormula(value) {
        this._set("totalsRowFormula", value);
      }
      /* eslint-enable lines-between-class-members */
    };
    var Table = class {
      constructor(worksheet, table) {
        this.worksheet = worksheet;
        if (table) {
          this.table = table;
          this.validate();
          this.store();
        }
      }
      getFormula(column) {
        switch (column.totalsRowFunction) {
          case "none":
            return null;
          case "average":
            return `SUBTOTAL(101,${this.table.name}[${column.name}])`;
          case "countNums":
            return `SUBTOTAL(102,${this.table.name}[${column.name}])`;
          case "count":
            return `SUBTOTAL(103,${this.table.name}[${column.name}])`;
          case "max":
            return `SUBTOTAL(104,${this.table.name}[${column.name}])`;
          case "min":
            return `SUBTOTAL(105,${this.table.name}[${column.name}])`;
          case "stdDev":
            return `SUBTOTAL(106,${this.table.name}[${column.name}])`;
          case "var":
            return `SUBTOTAL(107,${this.table.name}[${column.name}])`;
          case "sum":
            return `SUBTOTAL(109,${this.table.name}[${column.name}])`;
          case "custom":
            return column.totalsRowFormula;
          default:
            throw new Error(`Invalid Totals Row Function: ${column.totalsRowFunction}`);
        }
      }
      get width() {
        return this.table.columns.length;
      }
      get height() {
        return this.table.rows.length;
      }
      get filterHeight() {
        return this.height + (this.table.headerRow ? 1 : 0);
      }
      get tableHeight() {
        return this.filterHeight + (this.table.totalsRow ? 1 : 0);
      }
      validate() {
        const { table } = this;
        const assign = (o, name, dflt) => {
          if (o[name] === void 0) {
            o[name] = dflt;
          }
        };
        assign(table, "headerRow", true);
        assign(table, "totalsRow", false);
        assign(table, "style", {});
        assign(table.style, "theme", "TableStyleMedium2");
        assign(table.style, "showFirstColumn", false);
        assign(table.style, "showLastColumn", false);
        assign(table.style, "showRowStripes", false);
        assign(table.style, "showColumnStripes", false);
        const assert = (test, message) => {
          if (!test) {
            throw new Error(message);
          }
        };
        assert(table.ref, "Table must have ref");
        assert(table.columns, "Table must have column definitions");
        assert(table.rows, "Table must have row definitions");
        table.tl = colCache.decodeAddress(table.ref);
        const { row, col } = table.tl;
        assert(row > 0, "Table must be on valid row");
        assert(col > 0, "Table must be on valid col");
        const { width, filterHeight, tableHeight } = this;
        table.autoFilterRef = colCache.encode(row, col, row + filterHeight - 1, col + width - 1);
        table.tableRef = colCache.encode(row, col, row + tableHeight - 1, col + width - 1);
        table.columns.forEach((column, i) => {
          assert(column.name, `Column ${i} must have a name`);
          if (i === 0) {
            assign(column, "totalsRowLabel", "Total");
          } else {
            assign(column, "totalsRowFunction", "none");
            column.totalsRowFormula = this.getFormula(column);
          }
        });
      }
      store() {
        const assignStyle = (cell, style) => {
          if (style) {
            Object.keys(style).forEach((key) => {
              cell[key] = style[key];
            });
          }
        };
        const { worksheet, table } = this;
        const { row, col } = table.tl;
        let count = 0;
        if (table.headerRow) {
          const r = worksheet.getRow(row + count++);
          table.columns.forEach((column, j) => {
            const { style, name } = column;
            const cell = r.getCell(col + j);
            cell.value = name;
            assignStyle(cell, style);
          });
        }
        table.rows.forEach((data) => {
          const r = worksheet.getRow(row + count++);
          data.forEach((value, j) => {
            const cell = r.getCell(col + j);
            cell.value = value;
            assignStyle(cell, table.columns[j].style);
          });
        });
        if (table.totalsRow) {
          const r = worksheet.getRow(row + count++);
          table.columns.forEach((column, j) => {
            const cell = r.getCell(col + j);
            if (j === 0) {
              cell.value = column.totalsRowLabel;
            } else {
              const formula = this.getFormula(column);
              if (formula) {
                cell.value = {
                  formula: column.totalsRowFormula,
                  result: column.totalsRowResult
                };
              } else {
                cell.value = null;
              }
            }
            assignStyle(cell, column.style);
          });
        }
      }
      load(worksheet) {
        const { table } = this;
        const { row, col } = table.tl;
        let count = 0;
        if (table.headerRow) {
          const r = worksheet.getRow(row + count++);
          table.columns.forEach((column, j) => {
            const cell = r.getCell(col + j);
            cell.value = column.name;
          });
        }
        table.rows.forEach((data) => {
          const r = worksheet.getRow(row + count++);
          data.forEach((value, j) => {
            const cell = r.getCell(col + j);
            cell.value = value;
          });
        });
        if (table.totalsRow) {
          const r = worksheet.getRow(row + count++);
          table.columns.forEach((column, j) => {
            const cell = r.getCell(col + j);
            if (j === 0) {
              cell.value = column.totalsRowLabel;
            } else {
              const formula = this.getFormula(column);
              if (formula) {
                cell.value = {
                  formula: column.totalsRowFormula,
                  result: column.totalsRowResult
                };
              }
            }
          });
        }
      }
      get model() {
        return this.table;
      }
      set model(value) {
        this.table = value;
      }
      // ================================================================
      // TODO: Mutating methods
      cacheState() {
        if (!this._cache) {
          this._cache = {
            ref: this.ref,
            width: this.width,
            tableHeight: this.tableHeight
          };
        }
      }
      commit() {
        if (!this._cache) {
          return;
        }
        this.validate();
        const ref = colCache.decodeAddress(this._cache.ref);
        if (this.ref !== this._cache.ref) {
          for (let i = 0; i < this._cache.tableHeight; i++) {
            const row = this.worksheet.getRow(ref.row + i);
            for (let j = 0; j < this._cache.width; j++) {
              const cell = row.getCell(ref.col + j);
              cell.value = null;
            }
          }
        } else {
          for (let i = this.tableHeight; i < this._cache.tableHeight; i++) {
            const row = this.worksheet.getRow(ref.row + i);
            for (let j = 0; j < this._cache.width; j++) {
              const cell = row.getCell(ref.col + j);
              cell.value = null;
            }
          }
          for (let i = 0; i < this.tableHeight; i++) {
            const row = this.worksheet.getRow(ref.row + i);
            for (let j = this.width; j < this._cache.width; j++) {
              const cell = row.getCell(ref.col + j);
              cell.value = null;
            }
          }
        }
        this.store();
      }
      addRow(values, rowNumber) {
        this.cacheState();
        if (rowNumber === void 0) {
          this.table.rows.push(values);
        } else {
          this.table.rows.splice(rowNumber, 0, values);
        }
      }
      removeRows(rowIndex, count = 1) {
        this.cacheState();
        this.table.rows.splice(rowIndex, count);
      }
      getColumn(colIndex) {
        const column = this.table.columns[colIndex];
        return new Column(this, column, colIndex);
      }
      addColumn(column, values, colIndex) {
        this.cacheState();
        if (colIndex === void 0) {
          this.table.columns.push(column);
          this.table.rows.forEach((row, i) => {
            row.push(values[i]);
          });
        } else {
          this.table.columns.splice(colIndex, 0, column);
          this.table.rows.forEach((row, i) => {
            row.splice(colIndex, 0, values[i]);
          });
        }
      }
      removeColumns(colIndex, count = 1) {
        this.cacheState();
        this.table.columns.splice(colIndex, count);
        this.table.rows.forEach((row) => {
          row.splice(colIndex, count);
        });
      }
      _assign(target, prop, value) {
        this.cacheState();
        target[prop] = value;
      }
      /* eslint-disable lines-between-class-members */
      get ref() {
        return this.table.ref;
      }
      set ref(value) {
        this._assign(this.table, "ref", value);
      }
      get name() {
        return this.table.name;
      }
      set name(value) {
        this.table.name = value;
      }
      get displayName() {
        return this.table.displyName || this.table.name;
      }
      set displayNamename(value) {
        this.table.displayName = value;
      }
      get headerRow() {
        return this.table.headerRow;
      }
      set headerRow(value) {
        this._assign(this.table, "headerRow", value);
      }
      get totalsRow() {
        return this.table.totalsRow;
      }
      set totalsRow(value) {
        this._assign(this.table, "totalsRow", value);
      }
      get theme() {
        return this.table.style.name;
      }
      set theme(value) {
        this.table.style.name = value;
      }
      get showFirstColumn() {
        return this.table.style.showFirstColumn;
      }
      set showFirstColumn(value) {
        this.table.style.showFirstColumn = value;
      }
      get showLastColumn() {
        return this.table.style.showLastColumn;
      }
      set showLastColumn(value) {
        this.table.style.showLastColumn = value;
      }
      get showRowStripes() {
        return this.table.style.showRowStripes;
      }
      set showRowStripes(value) {
        this.table.style.showRowStripes = value;
      }
      get showColumnStripes() {
        return this.table.style.showColumnStripes;
      }
      set showColumnStripes(value) {
        this.table.style.showColumnStripes = value;
      }
      /* eslint-enable lines-between-class-members */
    };
    module2.exports = Table;
  }
});

// ../../../node_modules/exceljs/lib/doc/data-validations.js
var require_data_validations = __commonJS({
  "../../../node_modules/exceljs/lib/doc/data-validations.js"(exports2, module2) {
    var DataValidations = class {
      constructor(model) {
        this.model = model || {};
      }
      add(address, validation) {
        return this.model[address] = validation;
      }
      find(address) {
        return this.model[address];
      }
      remove(address) {
        this.model[address] = void 0;
      }
    };
    module2.exports = DataValidations;
  }
});

// ../../../node_modules/exceljs/lib/utils/encryptor.js
var require_encryptor = __commonJS({
  "../../../node_modules/exceljs/lib/utils/encryptor.js"(exports2, module2) {
    "use strict";
    var crypto4 = require("crypto");
    var Encryptor = {
      /**
       * Calculate a hash of the concatenated buffers with the given algorithm.
       * @param {string} algorithm - The hash algorithm.
       * @returns {Buffer} The hash
       */
      hash(algorithm, ...buffers) {
        const hash = crypto4.createHash(algorithm);
        hash.update(Buffer.concat(buffers));
        return hash.digest();
      },
      /**
       * Convert a password into an encryption key
       * @param {string} password - The password
       * @param {string} hashAlgorithm - The hash algoritm
       * @param {string} saltValue - The salt value
       * @param {number} spinCount - The spin count
       * @param {number} keyBits - The length of the key in bits
       * @param {Buffer} blockKey - The block key
       * @returns {Buffer} The encryption key
       */
      convertPasswordToHash(password, hashAlgorithm, saltValue, spinCount) {
        hashAlgorithm = hashAlgorithm.toLowerCase();
        const hashes = crypto4.getHashes();
        if (hashes.indexOf(hashAlgorithm) < 0) {
          throw new Error(`Hash algorithm '${hashAlgorithm}' not supported!`);
        }
        const passwordBuffer = Buffer.from(password, "utf16le");
        let key = this.hash(hashAlgorithm, Buffer.from(saltValue, "base64"), passwordBuffer);
        for (let i = 0; i < spinCount; i++) {
          const iterator = Buffer.alloc(4);
          iterator.writeUInt32LE(i, 0);
          key = this.hash(hashAlgorithm, key, iterator);
        }
        return key.toString("base64");
      },
      /**
       * Generates cryptographically strong pseudo-random data.
       * @param size The size argument is a number indicating the number of bytes to generate.
       */
      randomBytes(size) {
        return crypto4.randomBytes(size);
      }
    };
    module2.exports = Encryptor;
  }
});

// ../../../node_modules/exceljs/lib/utils/copy-style.js
var require_copy_style = __commonJS({
  "../../../node_modules/exceljs/lib/utils/copy-style.js"(exports2) {
    var oneDepthCopy = (obj2, nestKeys) => ({
      ...obj2,
      ...nestKeys.reduce((memo, key) => {
        if (obj2[key])
          memo[key] = { ...obj2[key] };
        return memo;
      }, {})
    });
    var setIfExists = (src, dst, key, nestKeys = []) => {
      if (src[key])
        dst[key] = oneDepthCopy(src[key], nestKeys);
    };
    var isEmptyObj = (obj2) => Object.keys(obj2).length === 0;
    var copyStyle = (style) => {
      if (!style)
        return style;
      if (isEmptyObj(style))
        return {};
      const copied = { ...style };
      setIfExists(style, copied, "font", ["color"]);
      setIfExists(style, copied, "alignment");
      setIfExists(style, copied, "protection");
      if (style.border) {
        setIfExists(style, copied, "border");
        setIfExists(style.border, copied.border, "top", ["color"]);
        setIfExists(style.border, copied.border, "left", ["color"]);
        setIfExists(style.border, copied.border, "bottom", ["color"]);
        setIfExists(style.border, copied.border, "right", ["color"]);
        setIfExists(style.border, copied.border, "diagonal", ["color"]);
      }
      if (style.fill) {
        setIfExists(style, copied, "fill", ["fgColor", "bgColor", "center"]);
        if (style.fill.stops) {
          copied.fill.stops = style.fill.stops.map((s) => oneDepthCopy(s, ["color"]));
        }
      }
      return copied;
    };
    exports2.copyStyle = copyStyle;
  }
});

// ../../../node_modules/exceljs/lib/doc/worksheet.js
var require_worksheet = __commonJS({
  "../../../node_modules/exceljs/lib/doc/worksheet.js"(exports2, module2) {
    var _2 = require_under_dash();
    var colCache = require_col_cache();
    var Range = require_range();
    var Row = require_row();
    var Column = require_column();
    var Enums = require_enums();
    var Image = require_image();
    var Table = require_table();
    var DataValidations = require_data_validations();
    var Encryptor = require_encryptor();
    var { copyStyle } = require_copy_style();
    var Worksheet = class {
      constructor(options) {
        options = options || {};
        this._workbook = options.workbook;
        this.id = options.id;
        this.orderNo = options.orderNo;
        this.name = options.name;
        this.state = options.state || "visible";
        this._rows = [];
        this._columns = null;
        this._keys = {};
        this._merges = {};
        this.rowBreaks = [];
        this.properties = Object.assign(
          {},
          {
            defaultRowHeight: 15,
            dyDescent: 55,
            outlineLevelCol: 0,
            outlineLevelRow: 0
          },
          options.properties
        );
        this.pageSetup = Object.assign(
          {},
          {
            margins: { left: 0.7, right: 0.7, top: 0.75, bottom: 0.75, header: 0.3, footer: 0.3 },
            orientation: "portrait",
            horizontalDpi: 4294967295,
            verticalDpi: 4294967295,
            fitToPage: !!(options.pageSetup && (options.pageSetup.fitToWidth || options.pageSetup.fitToHeight) && !options.pageSetup.scale),
            pageOrder: "downThenOver",
            blackAndWhite: false,
            draft: false,
            cellComments: "None",
            errors: "displayed",
            scale: 100,
            fitToWidth: 1,
            fitToHeight: 1,
            paperSize: void 0,
            showRowColHeaders: false,
            showGridLines: false,
            firstPageNumber: void 0,
            horizontalCentered: false,
            verticalCentered: false,
            rowBreaks: null,
            colBreaks: null
          },
          options.pageSetup
        );
        this.headerFooter = Object.assign(
          {},
          {
            differentFirst: false,
            differentOddEven: false,
            oddHeader: null,
            oddFooter: null,
            evenHeader: null,
            evenFooter: null,
            firstHeader: null,
            firstFooter: null
          },
          options.headerFooter
        );
        this.dataValidations = new DataValidations();
        this.views = options.views || [];
        this.autoFilter = options.autoFilter || null;
        this._media = [];
        this.sheetProtection = null;
        this.tables = {};
        this.conditionalFormattings = [];
      }
      get name() {
        return this._name;
      }
      set name(name) {
        if (name === void 0) {
          name = `sheet${this.id}`;
        }
        if (this._name === name)
          return;
        if (typeof name !== "string") {
          throw new Error("The name has to be a string.");
        }
        if (name === "") {
          throw new Error("The name can't be empty.");
        }
        if (name === "History") {
          throw new Error('The name "History" is protected. Please use a different name.');
        }
        if (/[*?:/\\[\]]/.test(name)) {
          throw new Error(`Worksheet name ${name} cannot include any of the following characters: * ? : \\ / [ ]`);
        }
        if (/(^')|('$)/.test(name)) {
          throw new Error(`The first or last character of worksheet name cannot be a single quotation mark: ${name}`);
        }
        if (name && name.length > 31) {
          console.warn(`Worksheet name ${name} exceeds 31 chars. This will be truncated`);
          name = name.substring(0, 31);
        }
        if (this._workbook._worksheets.find((ws) => ws && ws.name.toLowerCase() === name.toLowerCase())) {
          throw new Error(`Worksheet name already exists: ${name}`);
        }
        this._name = name;
      }
      get workbook() {
        return this._workbook;
      }
      // when you're done with this worksheet, call this to remove from workbook
      destroy() {
        this._workbook.removeWorksheetEx(this);
      }
      // Get the bounding range of the cells in this worksheet
      get dimensions() {
        const dimensions = new Range();
        this._rows.forEach((row) => {
          if (row) {
            const rowDims = row.dimensions;
            if (rowDims) {
              dimensions.expand(row.number, rowDims.min, row.number, rowDims.max);
            }
          }
        });
        return dimensions;
      }
      // =========================================================================
      // Columns
      // get the current columns array.
      get columns() {
        return this._columns;
      }
      // set the columns from an array of column definitions.
      // Note: any headers defined will overwrite existing values.
      set columns(value) {
        this._headerRowCount = value.reduce((pv, cv) => {
          const headerCount = cv.header && 1 || cv.headers && cv.headers.length || 0;
          return Math.max(pv, headerCount);
        }, 0);
        let count = 1;
        const columns = this._columns = [];
        value.forEach((defn) => {
          const column = new Column(this, count++, false);
          columns.push(column);
          column.defn = defn;
        });
      }
      getColumnKey(key) {
        return this._keys[key];
      }
      setColumnKey(key, value) {
        this._keys[key] = value;
      }
      deleteColumnKey(key) {
        delete this._keys[key];
      }
      eachColumnKey(f) {
        _2.each(this._keys, f);
      }
      // get a single column by col number. If it doesn't exist, create it and any gaps before it
      getColumn(c) {
        if (typeof c === "string") {
          const col = this._keys[c];
          if (col)
            return col;
          c = colCache.l2n(c);
        }
        if (!this._columns) {
          this._columns = [];
        }
        if (c > this._columns.length) {
          let n = this._columns.length + 1;
          while (n <= c) {
            this._columns.push(new Column(this, n++));
          }
        }
        return this._columns[c - 1];
      }
      spliceColumns(start, count, ...inserts) {
        const rows = this._rows;
        const nRows = rows.length;
        if (inserts.length > 0) {
          for (let i = 0; i < nRows; i++) {
            const rowArguments = [start, count];
            inserts.forEach((insert) => {
              rowArguments.push(insert[i] || null);
            });
            const row = this.getRow(i + 1);
            row.splice.apply(row, rowArguments);
          }
        } else {
          this._rows.forEach((r) => {
            if (r) {
              r.splice(start, count);
            }
          });
        }
        const nExpand = inserts.length - count;
        const nKeep = start + count;
        const nEnd = this._columns.length;
        if (nExpand < 0) {
          for (let i = start + inserts.length; i <= nEnd; i++) {
            this.getColumn(i).defn = this.getColumn(i - nExpand).defn;
          }
        } else if (nExpand > 0) {
          for (let i = nEnd; i >= nKeep; i--) {
            this.getColumn(i + nExpand).defn = this.getColumn(i).defn;
          }
        }
        for (let i = start; i < start + inserts.length; i++) {
          this.getColumn(i).defn = null;
        }
        this.workbook.definedNames.spliceColumns(this.name, start, count, inserts.length);
      }
      get lastColumn() {
        return this.getColumn(this.columnCount);
      }
      get columnCount() {
        let maxCount = 0;
        this.eachRow((row) => {
          maxCount = Math.max(maxCount, row.cellCount);
        });
        return maxCount;
      }
      get actualColumnCount() {
        const counts = [];
        let count = 0;
        this.eachRow((row) => {
          row.eachCell(({ col }) => {
            if (!counts[col]) {
              counts[col] = true;
              count++;
            }
          });
        });
        return count;
      }
      // =========================================================================
      // Rows
      _commitRow() {
      }
      get _lastRowNumber() {
        const rows = this._rows;
        let n = rows.length;
        while (n > 0 && rows[n - 1] === void 0) {
          n--;
        }
        return n;
      }
      get _nextRow() {
        return this._lastRowNumber + 1;
      }
      get lastRow() {
        if (this._rows.length) {
          return this._rows[this._rows.length - 1];
        }
        return void 0;
      }
      // find a row (if exists) by row number
      findRow(r) {
        return this._rows[r - 1];
      }
      // find multiple rows (if exists) by row number
      findRows(start, length) {
        return this._rows.slice(start - 1, start - 1 + length);
      }
      get rowCount() {
        return this._lastRowNumber;
      }
      get actualRowCount() {
        let count = 0;
        this.eachRow(() => {
          count++;
        });
        return count;
      }
      // get a row by row number.
      getRow(r) {
        let row = this._rows[r - 1];
        if (!row) {
          row = this._rows[r - 1] = new Row(this, r);
        }
        return row;
      }
      // get multiple rows by row number.
      getRows(start, length) {
        if (length < 1)
          return void 0;
        const rows = [];
        for (let i = start; i < start + length; i++) {
          rows.push(this.getRow(i));
        }
        return rows;
      }
      addRow(value, style = "n") {
        const rowNo = this._nextRow;
        const row = this.getRow(rowNo);
        row.values = value;
        this._setStyleOption(rowNo, style[0] === "i" ? style : "n");
        return row;
      }
      addRows(value, style = "n") {
        const rows = [];
        value.forEach((row) => {
          rows.push(this.addRow(row, style));
        });
        return rows;
      }
      insertRow(pos, value, style = "n") {
        this.spliceRows(pos, 0, value);
        this._setStyleOption(pos, style);
        return this.getRow(pos);
      }
      insertRows(pos, values, style = "n") {
        this.spliceRows(pos, 0, ...values);
        if (style !== "n") {
          for (let i = 0; i < values.length; i++) {
            if (style[0] === "o" && this.findRow(values.length + pos + i) !== void 0) {
              this._copyStyle(values.length + pos + i, pos + i, style[1] === "+");
            } else if (style[0] === "i" && this.findRow(pos - 1) !== void 0) {
              this._copyStyle(pos - 1, pos + i, style[1] === "+");
            }
          }
        }
        return this.getRows(pos, values.length);
      }
      // set row at position to same style as of either pervious row (option 'i') or next row (option 'o')
      _setStyleOption(pos, style = "n") {
        if (style[0] === "o" && this.findRow(pos + 1) !== void 0) {
          this._copyStyle(pos + 1, pos, style[1] === "+");
        } else if (style[0] === "i" && this.findRow(pos - 1) !== void 0) {
          this._copyStyle(pos - 1, pos, style[1] === "+");
        }
      }
      _copyStyle(src, dest, styleEmpty = false) {
        const rSrc = this.getRow(src);
        const rDst = this.getRow(dest);
        rDst.style = copyStyle(rSrc.style);
        rSrc.eachCell({ includeEmpty: styleEmpty }, (cell, colNumber) => {
          rDst.getCell(colNumber).style = copyStyle(cell.style);
        });
        rDst.height = rSrc.height;
      }
      duplicateRow(rowNum, count, insert = false) {
        const rSrc = this._rows[rowNum - 1];
        const inserts = new Array(count).fill(rSrc.values);
        this.spliceRows(rowNum + 1, insert ? 0 : count, ...inserts);
        for (let i = 0; i < count; i++) {
          const rDst = this._rows[rowNum + i];
          rDst.style = rSrc.style;
          rDst.height = rSrc.height;
          rSrc.eachCell({ includeEmpty: true }, (cell, colNumber) => {
            rDst.getCell(colNumber).style = cell.style;
          });
        }
      }
      spliceRows(start, count, ...inserts) {
        const nKeep = start + count;
        const nInserts = inserts.length;
        const nExpand = nInserts - count;
        const nEnd = this._rows.length;
        let i;
        let rSrc;
        if (nExpand < 0) {
          if (start === nEnd) {
            this._rows[nEnd - 1] = void 0;
          }
          for (i = nKeep; i <= nEnd; i++) {
            rSrc = this._rows[i - 1];
            if (rSrc) {
              const rDst = this.getRow(i + nExpand);
              rDst.values = rSrc.values;
              rDst.style = rSrc.style;
              rDst.height = rSrc.height;
              rSrc.eachCell({ includeEmpty: true }, (cell, colNumber) => {
                rDst.getCell(colNumber).style = cell.style;
              });
              this._rows[i - 1] = void 0;
            } else {
              this._rows[i + nExpand - 1] = void 0;
            }
          }
        } else if (nExpand > 0) {
          for (i = nEnd; i >= nKeep; i--) {
            rSrc = this._rows[i - 1];
            if (rSrc) {
              const rDst = this.getRow(i + nExpand);
              rDst.values = rSrc.values;
              rDst.style = rSrc.style;
              rDst.height = rSrc.height;
              rSrc.eachCell({ includeEmpty: true }, (cell, colNumber) => {
                rDst.getCell(colNumber).style = cell.style;
                if (cell._value.constructor.name === "MergeValue") {
                  const cellToBeMerged = this.getRow(cell._row._number + nInserts).getCell(colNumber);
                  const prevMaster = cell._value._master;
                  const newMaster = this.getRow(prevMaster._row._number + nInserts).getCell(prevMaster._column._number);
                  cellToBeMerged.merge(newMaster);
                }
              });
            } else {
              this._rows[i + nExpand - 1] = void 0;
            }
          }
        }
        for (i = 0; i < nInserts; i++) {
          const rDst = this.getRow(start + i);
          rDst.style = {};
          rDst.values = inserts[i];
        }
        this.workbook.definedNames.spliceRows(this.name, start, count, nInserts);
      }
      // iterate over every row in the worksheet, including maybe empty rows
      eachRow(options, iteratee) {
        if (!iteratee) {
          iteratee = options;
          options = void 0;
        }
        if (options && options.includeEmpty) {
          const n = this._rows.length;
          for (let i = 1; i <= n; i++) {
            iteratee(this.getRow(i), i);
          }
        } else {
          this._rows.forEach((row) => {
            if (row && row.hasValues) {
              iteratee(row, row.number);
            }
          });
        }
      }
      // return all rows as sparse array
      getSheetValues() {
        const rows = [];
        this._rows.forEach((row) => {
          if (row) {
            rows[row.number] = row.values;
          }
        });
        return rows;
      }
      // =========================================================================
      // Cells
      // returns the cell at [r,c] or address given by r. If not found, return undefined
      findCell(r, c) {
        const address = colCache.getAddress(r, c);
        const row = this._rows[address.row - 1];
        return row ? row.findCell(address.col) : void 0;
      }
      // return the cell at [r,c] or address given by r. If not found, create a new one.
      getCell(r, c) {
        const address = colCache.getAddress(r, c);
        const row = this.getRow(address.row);
        return row.getCellEx(address);
      }
      // =========================================================================
      // Merge
      // convert the range defined by ['tl:br'], [tl,br] or [t,l,b,r] into a single 'merged' cell
      mergeCells(...cells) {
        const dimensions = new Range(cells);
        this._mergeCellsInternal(dimensions);
      }
      mergeCellsWithoutStyle(...cells) {
        const dimensions = new Range(cells);
        this._mergeCellsInternal(dimensions, true);
      }
      _mergeCellsInternal(dimensions, ignoreStyle) {
        _2.each(this._merges, (merge) => {
          if (merge.intersects(dimensions)) {
            throw new Error("Cannot merge already merged cells");
          }
        });
        const master = this.getCell(dimensions.top, dimensions.left);
        for (let i = dimensions.top; i <= dimensions.bottom; i++) {
          for (let j = dimensions.left; j <= dimensions.right; j++) {
            if (i > dimensions.top || j > dimensions.left) {
              this.getCell(i, j).merge(master, ignoreStyle);
            }
          }
        }
        this._merges[master.address] = dimensions;
      }
      _unMergeMaster(master) {
        const merge = this._merges[master.address];
        if (merge) {
          for (let i = merge.top; i <= merge.bottom; i++) {
            for (let j = merge.left; j <= merge.right; j++) {
              this.getCell(i, j).unmerge();
            }
          }
          delete this._merges[master.address];
        }
      }
      get hasMerges() {
        return _2.some(this._merges, Boolean);
      }
      // scan the range defined by ['tl:br'], [tl,br] or [t,l,b,r] and if any cell is part of a merge,
      // un-merge the group. Note this function can affect multiple merges and merge-blocks are
      // atomic - either they're all merged or all un-merged.
      unMergeCells(...cells) {
        const dimensions = new Range(cells);
        for (let i = dimensions.top; i <= dimensions.bottom; i++) {
          for (let j = dimensions.left; j <= dimensions.right; j++) {
            const cell = this.findCell(i, j);
            if (cell) {
              if (cell.type === Enums.ValueType.Merge) {
                this._unMergeMaster(cell.master);
              } else if (this._merges[cell.address]) {
                this._unMergeMaster(cell);
              }
            }
          }
        }
      }
      // ===========================================================================
      // Shared/Array Formula
      fillFormula(range, formula, results, shareType = "shared") {
        const decoded = colCache.decode(range);
        const { top, left, bottom, right } = decoded;
        const width = right - left + 1;
        const masterAddress = colCache.encodeAddress(top, left);
        const isShared = shareType === "shared";
        let getResult;
        if (typeof results === "function") {
          getResult = results;
        } else if (Array.isArray(results)) {
          if (Array.isArray(results[0])) {
            getResult = (row, col) => results[row - top][col - left];
          } else {
            getResult = (row, col) => results[(row - top) * width + (col - left)];
          }
        } else {
          getResult = () => void 0;
        }
        let first = true;
        for (let r = top; r <= bottom; r++) {
          for (let c = left; c <= right; c++) {
            if (first) {
              this.getCell(r, c).value = {
                shareType,
                formula,
                ref: range,
                result: getResult(r, c)
              };
              first = false;
            } else {
              this.getCell(r, c).value = isShared ? {
                sharedFormula: masterAddress,
                result: getResult(r, c)
              } : getResult(r, c);
            }
          }
        }
      }
      // =========================================================================
      // Images
      addImage(imageId, range) {
        const model = {
          type: "image",
          imageId,
          range
        };
        this._media.push(new Image(this, model));
      }
      getImages() {
        return this._media.filter((m) => m.type === "image");
      }
      addBackgroundImage(imageId) {
        const model = {
          type: "background",
          imageId
        };
        this._media.push(new Image(this, model));
      }
      getBackgroundImageId() {
        const image = this._media.find((m) => m.type === "background");
        return image && image.imageId;
      }
      // =========================================================================
      // Worksheet Protection
      protect(password, options) {
        return new Promise((resolve) => {
          this.sheetProtection = {
            sheet: true
          };
          if (options && "spinCount" in options) {
            options.spinCount = Number.isFinite(options.spinCount) ? Math.round(Math.max(0, options.spinCount)) : 1e5;
          }
          if (password) {
            this.sheetProtection.algorithmName = "SHA-512";
            this.sheetProtection.saltValue = Encryptor.randomBytes(16).toString("base64");
            this.sheetProtection.spinCount = options && "spinCount" in options ? options.spinCount : 1e5;
            this.sheetProtection.hashValue = Encryptor.convertPasswordToHash(
              password,
              "SHA512",
              this.sheetProtection.saltValue,
              this.sheetProtection.spinCount
            );
          }
          if (options) {
            this.sheetProtection = Object.assign(this.sheetProtection, options);
            if (!password && "spinCount" in options) {
              delete this.sheetProtection.spinCount;
            }
          }
          resolve();
        });
      }
      unprotect() {
        this.sheetProtection = null;
      }
      // =========================================================================
      // Tables
      addTable(model) {
        const table = new Table(this, model);
        this.tables[model.name] = table;
        return table;
      }
      getTable(name) {
        return this.tables[name];
      }
      removeTable(name) {
        delete this.tables[name];
      }
      getTables() {
        return Object.values(this.tables);
      }
      // ===========================================================================
      // Conditional Formatting
      addConditionalFormatting(cf) {
        this.conditionalFormattings.push(cf);
      }
      removeConditionalFormatting(filter) {
        if (typeof filter === "number") {
          this.conditionalFormattings.splice(filter, 1);
        } else if (filter instanceof Function) {
          this.conditionalFormattings = this.conditionalFormattings.filter(filter);
        } else {
          this.conditionalFormattings = [];
        }
      }
      // ===========================================================================
      // Deprecated
      get tabColor() {
        console.trace("worksheet.tabColor property is now deprecated. Please use worksheet.properties.tabColor");
        return this.properties.tabColor;
      }
      set tabColor(value) {
        console.trace("worksheet.tabColor property is now deprecated. Please use worksheet.properties.tabColor");
        this.properties.tabColor = value;
      }
      // ===========================================================================
      // Model
      get model() {
        const model = {
          id: this.id,
          name: this.name,
          dataValidations: this.dataValidations.model,
          properties: this.properties,
          state: this.state,
          pageSetup: this.pageSetup,
          headerFooter: this.headerFooter,
          rowBreaks: this.rowBreaks,
          views: this.views,
          autoFilter: this.autoFilter,
          media: this._media.map((medium) => medium.model),
          sheetProtection: this.sheetProtection,
          tables: Object.values(this.tables).map((table) => table.model),
          conditionalFormattings: this.conditionalFormattings
        };
        model.cols = Column.toModel(this.columns);
        const rows = model.rows = [];
        const dimensions = model.dimensions = new Range();
        this._rows.forEach((row) => {
          const rowModel = row && row.model;
          if (rowModel) {
            dimensions.expand(rowModel.number, rowModel.min, rowModel.number, rowModel.max);
            rows.push(rowModel);
          }
        });
        model.merges = [];
        _2.each(this._merges, (merge) => {
          model.merges.push(merge.range);
        });
        return model;
      }
      _parseRows(model) {
        this._rows = [];
        model.rows.forEach((rowModel) => {
          const row = new Row(this, rowModel.number);
          this._rows[row.number - 1] = row;
          row.model = rowModel;
        });
      }
      _parseMergeCells(model) {
        _2.each(model.mergeCells, (merge) => {
          this.mergeCellsWithoutStyle(merge);
        });
      }
      set model(value) {
        this.name = value.name;
        this._columns = Column.fromModel(this, value.cols);
        this._parseRows(value);
        this._parseMergeCells(value);
        this.dataValidations = new DataValidations(value.dataValidations);
        this.properties = value.properties;
        this.pageSetup = value.pageSetup;
        this.headerFooter = value.headerFooter;
        this.views = value.views;
        this.autoFilter = value.autoFilter;
        this._media = value.media.map((medium) => new Image(this, medium));
        this.sheetProtection = value.sheetProtection;
        this.tables = value.tables.reduce((tables, table) => {
          const t = new Table();
          t.model = table;
          tables[table.name] = t;
          return tables;
        }, {});
        this.conditionalFormattings = value.conditionalFormattings;
      }
    };
    module2.exports = Worksheet;
  }
});

// ../../../node_modules/exceljs/lib/utils/cell-matrix.js
var require_cell_matrix = __commonJS({
  "../../../node_modules/exceljs/lib/utils/cell-matrix.js"(exports2, module2) {
    var _2 = require_under_dash();
    var colCache = require_col_cache();
    var CellMatrix = class {
      constructor(template) {
        this.template = template;
        this.sheets = {};
      }
      addCell(addressStr) {
        this.addCellEx(colCache.decodeEx(addressStr));
      }
      getCell(addressStr) {
        return this.findCellEx(colCache.decodeEx(addressStr), true);
      }
      findCell(addressStr) {
        return this.findCellEx(colCache.decodeEx(addressStr), false);
      }
      findCellAt(sheetName, rowNumber, colNumber) {
        const sheet = this.sheets[sheetName];
        const row = sheet && sheet[rowNumber];
        return row && row[colNumber];
      }
      addCellEx(address) {
        if (address.top) {
          for (let row = address.top; row <= address.bottom; row++) {
            for (let col = address.left; col <= address.right; col++) {
              this.getCellAt(address.sheetName, row, col);
            }
          }
        } else {
          this.findCellEx(address, true);
        }
      }
      getCellEx(address) {
        return this.findCellEx(address, true);
      }
      findCellEx(address, create) {
        const sheet = this.findSheet(address, create);
        const row = this.findSheetRow(sheet, address, create);
        return this.findRowCell(row, address, create);
      }
      getCellAt(sheetName, rowNumber, colNumber) {
        const sheet = this.sheets[sheetName] || (this.sheets[sheetName] = []);
        const row = sheet[rowNumber] || (sheet[rowNumber] = []);
        const cell = row[colNumber] || (row[colNumber] = {
          sheetName,
          address: colCache.n2l(colNumber) + rowNumber,
          row: rowNumber,
          col: colNumber
        });
        return cell;
      }
      removeCellEx(address) {
        const sheet = this.findSheet(address);
        if (!sheet) {
          return;
        }
        const row = this.findSheetRow(sheet, address);
        if (!row) {
          return;
        }
        delete row[address.col];
      }
      forEachInSheet(sheetName, callback) {
        const sheet = this.sheets[sheetName];
        if (sheet) {
          sheet.forEach((row, rowNumber) => {
            if (row) {
              row.forEach((cell, colNumber) => {
                if (cell) {
                  callback(cell, rowNumber, colNumber);
                }
              });
            }
          });
        }
      }
      forEach(callback) {
        _2.each(this.sheets, (sheet, sheetName) => {
          this.forEachInSheet(sheetName, callback);
        });
      }
      map(callback) {
        const results = [];
        this.forEach((cell) => {
          results.push(callback(cell));
        });
        return results;
      }
      findSheet(address, create) {
        const name = address.sheetName;
        if (this.sheets[name]) {
          return this.sheets[name];
        }
        if (create) {
          return this.sheets[name] = [];
        }
        return void 0;
      }
      findSheetRow(sheet, address, create) {
        const { row } = address;
        if (sheet && sheet[row]) {
          return sheet[row];
        }
        if (create) {
          return sheet[row] = [];
        }
        return void 0;
      }
      findRowCell(row, address, create) {
        const { col } = address;
        if (row && row[col]) {
          return row[col];
        }
        if (create) {
          return row[col] = this.template ? Object.assign(address, JSON.parse(JSON.stringify(this.template))) : address;
        }
        return void 0;
      }
      spliceRows(sheetName, start, numDelete, numInsert) {
        const sheet = this.sheets[sheetName];
        if (sheet) {
          const inserts = [];
          for (let i = 0; i < numInsert; i++) {
            inserts.push([]);
          }
          sheet.splice(start, numDelete, ...inserts);
        }
      }
      spliceColumns(sheetName, start, numDelete, numInsert) {
        const sheet = this.sheets[sheetName];
        if (sheet) {
          const inserts = [];
          for (let i = 0; i < numInsert; i++) {
            inserts.push(null);
          }
          _2.each(sheet, (row) => {
            row.splice(start, numDelete, ...inserts);
          });
        }
      }
    };
    module2.exports = CellMatrix;
  }
});

// ../../../node_modules/exceljs/lib/doc/defined-names.js
var require_defined_names = __commonJS({
  "../../../node_modules/exceljs/lib/doc/defined-names.js"(exports2, module2) {
    "use strict";
    var _2 = require_under_dash();
    var colCache = require_col_cache();
    var CellMatrix = require_cell_matrix();
    var Range = require_range();
    var rangeRegexp = /[$](\w+)[$](\d+)(:[$](\w+)[$](\d+))?/;
    var DefinedNames = class {
      constructor() {
        this.matrixMap = {};
      }
      getMatrix(name) {
        const matrix = this.matrixMap[name] || (this.matrixMap[name] = new CellMatrix());
        return matrix;
      }
      // add a name to a cell. locStr in the form SheetName!$col$row or SheetName!$c1$r1:$c2:$r2
      add(locStr, name) {
        const location = colCache.decodeEx(locStr);
        this.addEx(location, name);
      }
      addEx(location, name) {
        const matrix = this.getMatrix(name);
        if (location.top) {
          for (let col = location.left; col <= location.right; col++) {
            for (let row = location.top; row <= location.bottom; row++) {
              const address = {
                sheetName: location.sheetName,
                address: colCache.n2l(col) + row,
                row,
                col
              };
              matrix.addCellEx(address);
            }
          }
        } else {
          matrix.addCellEx(location);
        }
      }
      remove(locStr, name) {
        const location = colCache.decodeEx(locStr);
        this.removeEx(location, name);
      }
      removeEx(location, name) {
        const matrix = this.getMatrix(name);
        matrix.removeCellEx(location);
      }
      removeAllNames(location) {
        _2.each(this.matrixMap, (matrix) => {
          matrix.removeCellEx(location);
        });
      }
      forEach(callback) {
        _2.each(this.matrixMap, (matrix, name) => {
          matrix.forEach((cell) => {
            callback(name, cell);
          });
        });
      }
      // get all the names of a cell
      getNames(addressStr) {
        return this.getNamesEx(colCache.decodeEx(addressStr));
      }
      getNamesEx(address) {
        return _2.map(this.matrixMap, (matrix, name) => matrix.findCellEx(address) && name).filter(
          Boolean
        );
      }
      _explore(matrix, cell) {
        cell.mark = false;
        const { sheetName } = cell;
        const range = new Range(cell.row, cell.col, cell.row, cell.col, sheetName);
        let x;
        let y;
        function vGrow(yy, edge) {
          const c = matrix.findCellAt(sheetName, yy, cell.col);
          if (!c || !c.mark) {
            return false;
          }
          range[edge] = yy;
          c.mark = false;
          return true;
        }
        for (y = cell.row - 1; vGrow(y, "top"); y--)
          ;
        for (y = cell.row + 1; vGrow(y, "bottom"); y++)
          ;
        function hGrow(xx, edge) {
          const cells = [];
          for (y = range.top; y <= range.bottom; y++) {
            const c = matrix.findCellAt(sheetName, y, xx);
            if (c && c.mark) {
              cells.push(c);
            } else {
              return false;
            }
          }
          range[edge] = xx;
          for (let i = 0; i < cells.length; i++) {
            cells[i].mark = false;
          }
          return true;
        }
        for (x = cell.col - 1; hGrow(x, "left"); x--)
          ;
        for (x = cell.col + 1; hGrow(x, "right"); x++)
          ;
        return range;
      }
      getRanges(name, matrix) {
        matrix = matrix || this.matrixMap[name];
        if (!matrix) {
          return { name, ranges: [] };
        }
        matrix.forEach((cell) => {
          cell.mark = true;
        });
        const ranges = matrix.map((cell) => cell.mark && this._explore(matrix, cell)).filter(Boolean).map((range) => range.$shortRange);
        return {
          name,
          ranges
        };
      }
      normaliseMatrix(matrix, sheetName) {
        matrix.forEachInSheet(sheetName, (cell, row, col) => {
          if (cell) {
            if (cell.row !== row || cell.col !== col) {
              cell.row = row;
              cell.col = col;
              cell.address = colCache.n2l(col) + row;
            }
          }
        });
      }
      spliceRows(sheetName, start, numDelete, numInsert) {
        _2.each(this.matrixMap, (matrix) => {
          matrix.spliceRows(sheetName, start, numDelete, numInsert);
          this.normaliseMatrix(matrix, sheetName);
        });
      }
      spliceColumns(sheetName, start, numDelete, numInsert) {
        _2.each(this.matrixMap, (matrix) => {
          matrix.spliceColumns(sheetName, start, numDelete, numInsert);
          this.normaliseMatrix(matrix, sheetName);
        });
      }
      get model() {
        return _2.map(this.matrixMap, (matrix, name) => this.getRanges(name, matrix)).filter(
          (definedName) => definedName.ranges.length
        );
      }
      set model(value) {
        const matrixMap = this.matrixMap = {};
        value.forEach((definedName) => {
          const matrix = matrixMap[definedName.name] = new CellMatrix();
          definedName.ranges.forEach((rangeStr) => {
            if (rangeRegexp.test(rangeStr.split("!").pop() || "")) {
              matrix.addCell(rangeStr);
            }
          });
        });
      }
    };
    module2.exports = DefinedNames;
  }
});

// ../../../node_modules/process-nextick-args/index.js
var require_process_nextick_args = __commonJS({
  "../../../node_modules/process-nextick-args/index.js"(exports2, module2) {
    "use strict";
    if (typeof process === "undefined" || !process.version || process.version.indexOf("v0.") === 0 || process.version.indexOf("v1.") === 0 && process.version.indexOf("v1.8.") !== 0) {
      module2.exports = { nextTick };
    } else {
      module2.exports = process;
    }
    function nextTick(fn, arg1, arg2, arg3) {
      if (typeof fn !== "function") {
        throw new TypeError('"callback" argument must be a function');
      }
      var len = arguments.length;
      var args, i;
      switch (len) {
        case 0:
        case 1:
          return process.nextTick(fn);
        case 2:
          return process.nextTick(function afterTickOne() {
            fn.call(null, arg1);
          });
        case 3:
          return process.nextTick(function afterTickTwo() {
            fn.call(null, arg1, arg2);
          });
        case 4:
          return process.nextTick(function afterTickThree() {
            fn.call(null, arg1, arg2, arg3);
          });
        default:
          args = new Array(len - 1);
          i = 0;
          while (i < args.length) {
            args[i++] = arguments[i];
          }
          return process.nextTick(function afterTick() {
            fn.apply(null, args);
          });
      }
    }
  }
});

// ../../../node_modules/jszip/node_modules/isarray/index.js
var require_isarray = __commonJS({
  "../../../node_modules/jszip/node_modules/isarray/index.js"(exports2, module2) {
    var toString = {}.toString;
    module2.exports = Array.isArray || function(arr) {
      return toString.call(arr) == "[object Array]";
    };
  }
});

// ../../../node_modules/jszip/node_modules/readable-stream/lib/internal/streams/stream.js
var require_stream = __commonJS({
  "../../../node_modules/jszip/node_modules/readable-stream/lib/internal/streams/stream.js"(exports2, module2) {
    module2.exports = require("stream");
  }
});

// ../../../node_modules/jszip/node_modules/safe-buffer/index.js
var require_safe_buffer = __commonJS({
  "../../../node_modules/jszip/node_modules/safe-buffer/index.js"(exports2, module2) {
    var buffer = require("buffer");
    var Buffer2 = buffer.Buffer;
    function copyProps(src, dst) {
      for (var key in src) {
        dst[key] = src[key];
      }
    }
    if (Buffer2.from && Buffer2.alloc && Buffer2.allocUnsafe && Buffer2.allocUnsafeSlow) {
      module2.exports = buffer;
    } else {
      copyProps(buffer, exports2);
      exports2.Buffer = SafeBuffer;
    }
    function SafeBuffer(arg, encodingOrOffset, length) {
      return Buffer2(arg, encodingOrOffset, length);
    }
    copyProps(Buffer2, SafeBuffer);
    SafeBuffer.from = function(arg, encodingOrOffset, length) {
      if (typeof arg === "number") {
        throw new TypeError("Argument must not be a number");
      }
      return Buffer2(arg, encodingOrOffset, length);
    };
    SafeBuffer.alloc = function(size, fill, encoding) {
      if (typeof size !== "number") {
        throw new TypeError("Argument must be a number");
      }
      var buf = Buffer2(size);
      if (fill !== void 0) {
        if (typeof encoding === "string") {
          buf.fill(fill, encoding);
        } else {
          buf.fill(fill);
        }
      } else {
        buf.fill(0);
      }
      return buf;
    };
    SafeBuffer.allocUnsafe = function(size) {
      if (typeof size !== "number") {
        throw new TypeError("Argument must be a number");
      }
      return Buffer2(size);
    };
    SafeBuffer.allocUnsafeSlow = function(size) {
      if (typeof size !== "number") {
        throw new TypeError("Argument must be a number");
      }
      return buffer.SlowBuffer(size);
    };
  }
});

// ../../../node_modules/core-util-is/lib/util.js
var require_util = __commonJS({
  "../../../node_modules/core-util-is/lib/util.js"(exports2) {
    function isArray(arg) {
      if (Array.isArray) {
        return Array.isArray(arg);
      }
      return objectToString(arg) === "[object Array]";
    }
    exports2.isArray = isArray;
    function isBoolean(arg) {
      return typeof arg === "boolean";
    }
    exports2.isBoolean = isBoolean;
    function isNull(arg) {
      return arg === null;
    }
    exports2.isNull = isNull;
    function isNullOrUndefined(arg) {
      return arg == null;
    }
    exports2.isNullOrUndefined = isNullOrUndefined;
    function isNumber(arg) {
      return typeof arg === "number";
    }
    exports2.isNumber = isNumber;
    function isString(arg) {
      return typeof arg === "string";
    }
    exports2.isString = isString;
    function isSymbol(arg) {
      return typeof arg === "symbol";
    }
    exports2.isSymbol = isSymbol;
    function isUndefined(arg) {
      return arg === void 0;
    }
    exports2.isUndefined = isUndefined;
    function isRegExp(re) {
      return objectToString(re) === "[object RegExp]";
    }
    exports2.isRegExp = isRegExp;
    function isObject2(arg) {
      return typeof arg === "object" && arg !== null;
    }
    exports2.isObject = isObject2;
    function isDate(d) {
      return objectToString(d) === "[object Date]";
    }
    exports2.isDate = isDate;
    function isError2(e) {
      return objectToString(e) === "[object Error]" || e instanceof Error;
    }
    exports2.isError = isError2;
    function isFunction(arg) {
      return typeof arg === "function";
    }
    exports2.isFunction = isFunction;
    function isPrimitive2(arg) {
      return arg === null || typeof arg === "boolean" || typeof arg === "number" || typeof arg === "string" || typeof arg === "symbol" || // ES6 symbol
      typeof arg === "undefined";
    }
    exports2.isPrimitive = isPrimitive2;
    exports2.isBuffer = require("buffer").Buffer.isBuffer;
    function objectToString(o) {
      return Object.prototype.toString.call(o);
    }
  }
});

// ../../../node_modules/inherits/inherits_browser.js
var require_inherits_browser = __commonJS({
  "../../../node_modules/inherits/inherits_browser.js"(exports2, module2) {
    if (typeof Object.create === "function") {
      module2.exports = function inherits2(ctor, superCtor) {
        if (superCtor) {
          ctor.super_ = superCtor;
          ctor.prototype = Object.create(superCtor.prototype, {
            constructor: {
              value: ctor,
              enumerable: false,
              writable: true,
              configurable: true
            }
          });
        }
      };
    } else {
      module2.exports = function inherits2(ctor, superCtor) {
        if (superCtor) {
          ctor.super_ = superCtor;
          var TempCtor = function() {
          };
          TempCtor.prototype = superCtor.prototype;
          ctor.prototype = new TempCtor();
          ctor.prototype.constructor = ctor;
        }
      };
    }
  }
});

// ../../../node_modules/inherits/inherits.js
var require_inherits = __commonJS({
  "../../../node_modules/inherits/inherits.js"(exports2, module2) {
    try {
      util = require("util");
      if (typeof util.inherits !== "function")
        throw "";
      module2.exports = util.inherits;
    } catch (e) {
      module2.exports = require_inherits_browser();
    }
    var util;
  }
});

// ../../../node_modules/jszip/node_modules/readable-stream/lib/internal/streams/BufferList.js
var require_BufferList = __commonJS({
  "../../../node_modules/jszip/node_modules/readable-stream/lib/internal/streams/BufferList.js"(exports2, module2) {
    "use strict";
    function _classCallCheck(instance, Constructor) {
      if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
      }
    }
    var Buffer2 = require_safe_buffer().Buffer;
    var util = require("util");
    function copyBuffer(src, target, offset) {
      src.copy(target, offset);
    }
    module2.exports = function() {
      function BufferList() {
        _classCallCheck(this, BufferList);
        this.head = null;
        this.tail = null;
        this.length = 0;
      }
      BufferList.prototype.push = function push(v) {
        var entry = { data: v, next: null };
        if (this.length > 0)
          this.tail.next = entry;
        else
          this.head = entry;
        this.tail = entry;
        ++this.length;
      };
      BufferList.prototype.unshift = function unshift(v) {
        var entry = { data: v, next: this.head };
        if (this.length === 0)
          this.tail = entry;
        this.head = entry;
        ++this.length;
      };
      BufferList.prototype.shift = function shift() {
        if (this.length === 0)
          return;
        var ret2 = this.head.data;
        if (this.length === 1)
          this.head = this.tail = null;
        else
          this.head = this.head.next;
        --this.length;
        return ret2;
      };
      BufferList.prototype.clear = function clear() {
        this.head = this.tail = null;
        this.length = 0;
      };
      BufferList.prototype.join = function join(s) {
        if (this.length === 0)
          return "";
        var p = this.head;
        var ret2 = "" + p.data;
        while (p = p.next) {
          ret2 += s + p.data;
        }
        return ret2;
      };
      BufferList.prototype.concat = function concat(n) {
        if (this.length === 0)
          return Buffer2.alloc(0);
        var ret2 = Buffer2.allocUnsafe(n >>> 0);
        var p = this.head;
        var i = 0;
        while (p) {
          copyBuffer(p.data, ret2, i);
          i += p.data.length;
          p = p.next;
        }
        return ret2;
      };
      return BufferList;
    }();
    if (util && util.inspect && util.inspect.custom) {
      module2.exports.prototype[util.inspect.custom] = function() {
        var obj2 = util.inspect({ length: this.length });
        return this.constructor.name + " " + obj2;
      };
    }
  }
});

// ../../../node_modules/jszip/node_modules/readable-stream/lib/internal/streams/destroy.js
var require_destroy = __commonJS({
  "../../../node_modules/jszip/node_modules/readable-stream/lib/internal/streams/destroy.js"(exports2, module2) {
    "use strict";
    var pna = require_process_nextick_args();
    function destroy(err, cb) {
      var _this = this;
      var readableDestroyed = this._readableState && this._readableState.destroyed;
      var writableDestroyed = this._writableState && this._writableState.destroyed;
      if (readableDestroyed || writableDestroyed) {
        if (cb) {
          cb(err);
        } else if (err) {
          if (!this._writableState) {
            pna.nextTick(emitErrorNT, this, err);
          } else if (!this._writableState.errorEmitted) {
            this._writableState.errorEmitted = true;
            pna.nextTick(emitErrorNT, this, err);
          }
        }
        return this;
      }
      if (this._readableState) {
        this._readableState.destroyed = true;
      }
      if (this._writableState) {
        this._writableState.destroyed = true;
      }
      this._destroy(err || null, function(err2) {
        if (!cb && err2) {
          if (!_this._writableState) {
            pna.nextTick(emitErrorNT, _this, err2);
          } else if (!_this._writableState.errorEmitted) {
            _this._writableState.errorEmitted = true;
            pna.nextTick(emitErrorNT, _this, err2);
          }
        } else if (cb) {
          cb(err2);
        }
      });
      return this;
    }
    function undestroy() {
      if (this._readableState) {
        this._readableState.destroyed = false;
        this._readableState.reading = false;
        this._readableState.ended = false;
        this._readableState.endEmitted = false;
      }
      if (this._writableState) {
        this._writableState.destroyed = false;
        this._writableState.ended = false;
        this._writableState.ending = false;
        this._writableState.finalCalled = false;
        this._writableState.prefinished = false;
        this._writableState.finished = false;
        this._writableState.errorEmitted = false;
      }
    }
    function emitErrorNT(self2, err) {
      self2.emit("error", err);
    }
    module2.exports = {
      destroy,
      undestroy
    };
  }
});

// ../../../node_modules/util-deprecate/node.js
var require_node = __commonJS({
  "../../../node_modules/util-deprecate/node.js"(exports2, module2) {
    module2.exports = require("util").deprecate;
  }
});

// ../../../node_modules/jszip/node_modules/readable-stream/lib/_stream_writable.js
var require_stream_writable = __commonJS({
  "../../../node_modules/jszip/node_modules/readable-stream/lib/_stream_writable.js"(exports2, module2) {
    "use strict";
    var pna = require_process_nextick_args();
    module2.exports = Writable;
    function CorkedRequest(state) {
      var _this = this;
      this.next = null;
      this.entry = null;
      this.finish = function() {
        onCorkedFinish(_this, state);
      };
    }
    var asyncWrite = !process.browser && ["v0.10", "v0.9."].indexOf(process.version.slice(0, 5)) > -1 ? setImmediate : pna.nextTick;
    var Duplex;
    Writable.WritableState = WritableState;
    var util = Object.create(require_util());
    util.inherits = require_inherits();
    var internalUtil = {
      deprecate: require_node()
    };
    var Stream = require_stream();
    var Buffer2 = require_safe_buffer().Buffer;
    var OurUint8Array = (typeof global !== "undefined" ? global : typeof window !== "undefined" ? window : typeof self !== "undefined" ? self : {}).Uint8Array || function() {
    };
    function _uint8ArrayToBuffer(chunk) {
      return Buffer2.from(chunk);
    }
    function _isUint8Array(obj2) {
      return Buffer2.isBuffer(obj2) || obj2 instanceof OurUint8Array;
    }
    var destroyImpl = require_destroy();
    util.inherits(Writable, Stream);
    function nop() {
    }
    function WritableState(options, stream) {
      Duplex = Duplex || require_stream_duplex();
      options = options || {};
      var isDuplex = stream instanceof Duplex;
      this.objectMode = !!options.objectMode;
      if (isDuplex)
        this.objectMode = this.objectMode || !!options.writableObjectMode;
      var hwm = options.highWaterMark;
      var writableHwm = options.writableHighWaterMark;
      var defaultHwm = this.objectMode ? 16 : 16 * 1024;
      if (hwm || hwm === 0)
        this.highWaterMark = hwm;
      else if (isDuplex && (writableHwm || writableHwm === 0))
        this.highWaterMark = writableHwm;
      else
        this.highWaterMark = defaultHwm;
      this.highWaterMark = Math.floor(this.highWaterMark);
      this.finalCalled = false;
      this.needDrain = false;
      this.ending = false;
      this.ended = false;
      this.finished = false;
      this.destroyed = false;
      var noDecode = options.decodeStrings === false;
      this.decodeStrings = !noDecode;
      this.defaultEncoding = options.defaultEncoding || "utf8";
      this.length = 0;
      this.writing = false;
      this.corked = 0;
      this.sync = true;
      this.bufferProcessing = false;
      this.onwrite = function(er) {
        onwrite(stream, er);
      };
      this.writecb = null;
      this.writelen = 0;
      this.bufferedRequest = null;
      this.lastBufferedRequest = null;
      this.pendingcb = 0;
      this.prefinished = false;
      this.errorEmitted = false;
      this.bufferedRequestCount = 0;
      this.corkedRequestsFree = new CorkedRequest(this);
    }
    WritableState.prototype.getBuffer = function getBuffer() {
      var current = this.bufferedRequest;
      var out = [];
      while (current) {
        out.push(current);
        current = current.next;
      }
      return out;
    };
    (function() {
      try {
        Object.defineProperty(WritableState.prototype, "buffer", {
          get: internalUtil.deprecate(function() {
            return this.getBuffer();
          }, "_writableState.buffer is deprecated. Use _writableState.getBuffer instead.", "DEP0003")
        });
      } catch (_2) {
      }
    })();
    var realHasInstance;
    if (typeof Symbol === "function" && Symbol.hasInstance && typeof Function.prototype[Symbol.hasInstance] === "function") {
      realHasInstance = Function.prototype[Symbol.hasInstance];
      Object.defineProperty(Writable, Symbol.hasInstance, {
        value: function(object) {
          if (realHasInstance.call(this, object))
            return true;
          if (this !== Writable)
            return false;
          return object && object._writableState instanceof WritableState;
        }
      });
    } else {
      realHasInstance = function(object) {
        return object instanceof this;
      };
    }
    function Writable(options) {
      Duplex = Duplex || require_stream_duplex();
      if (!realHasInstance.call(Writable, this) && !(this instanceof Duplex)) {
        return new Writable(options);
      }
      this._writableState = new WritableState(options, this);
      this.writable = true;
      if (options) {
        if (typeof options.write === "function")
          this._write = options.write;
        if (typeof options.writev === "function")
          this._writev = options.writev;
        if (typeof options.destroy === "function")
          this._destroy = options.destroy;
        if (typeof options.final === "function")
          this._final = options.final;
      }
      Stream.call(this);
    }
    Writable.prototype.pipe = function() {
      this.emit("error", new Error("Cannot pipe, not readable"));
    };
    function writeAfterEnd(stream, cb) {
      var er = new Error("write after end");
      stream.emit("error", er);
      pna.nextTick(cb, er);
    }
    function validChunk(stream, state, chunk, cb) {
      var valid = true;
      var er = false;
      if (chunk === null) {
        er = new TypeError("May not write null values to stream");
      } else if (typeof chunk !== "string" && chunk !== void 0 && !state.objectMode) {
        er = new TypeError("Invalid non-string/buffer chunk");
      }
      if (er) {
        stream.emit("error", er);
        pna.nextTick(cb, er);
        valid = false;
      }
      return valid;
    }
    Writable.prototype.write = function(chunk, encoding, cb) {
      var state = this._writableState;
      var ret2 = false;
      var isBuf = !state.objectMode && _isUint8Array(chunk);
      if (isBuf && !Buffer2.isBuffer(chunk)) {
        chunk = _uint8ArrayToBuffer(chunk);
      }
      if (typeof encoding === "function") {
        cb = encoding;
        encoding = null;
      }
      if (isBuf)
        encoding = "buffer";
      else if (!encoding)
        encoding = state.defaultEncoding;
      if (typeof cb !== "function")
        cb = nop;
      if (state.ended)
        writeAfterEnd(this, cb);
      else if (isBuf || validChunk(this, state, chunk, cb)) {
        state.pendingcb++;
        ret2 = writeOrBuffer(this, state, isBuf, chunk, encoding, cb);
      }
      return ret2;
    };
    Writable.prototype.cork = function() {
      var state = this._writableState;
      state.corked++;
    };
    Writable.prototype.uncork = function() {
      var state = this._writableState;
      if (state.corked) {
        state.corked--;
        if (!state.writing && !state.corked && !state.bufferProcessing && state.bufferedRequest)
          clearBuffer(this, state);
      }
    };
    Writable.prototype.setDefaultEncoding = function setDefaultEncoding(encoding) {
      if (typeof encoding === "string")
        encoding = encoding.toLowerCase();
      if (!(["hex", "utf8", "utf-8", "ascii", "binary", "base64", "ucs2", "ucs-2", "utf16le", "utf-16le", "raw"].indexOf((encoding + "").toLowerCase()) > -1))
        throw new TypeError("Unknown encoding: " + encoding);
      this._writableState.defaultEncoding = encoding;
      return this;
    };
    function decodeChunk(state, chunk, encoding) {
      if (!state.objectMode && state.decodeStrings !== false && typeof chunk === "string") {
        chunk = Buffer2.from(chunk, encoding);
      }
      return chunk;
    }
    Object.defineProperty(Writable.prototype, "writableHighWaterMark", {
      // making it explicit this property is not enumerable
      // because otherwise some prototype manipulation in
      // userland will fail
      enumerable: false,
      get: function() {
        return this._writableState.highWaterMark;
      }
    });
    function writeOrBuffer(stream, state, isBuf, chunk, encoding, cb) {
      if (!isBuf) {
        var newChunk = decodeChunk(state, chunk, encoding);
        if (chunk !== newChunk) {
          isBuf = true;
          encoding = "buffer";
          chunk = newChunk;
        }
      }
      var len = state.objectMode ? 1 : chunk.length;
      state.length += len;
      var ret2 = state.length < state.highWaterMark;
      if (!ret2)
        state.needDrain = true;
      if (state.writing || state.corked) {
        var last = state.lastBufferedRequest;
        state.lastBufferedRequest = {
          chunk,
          encoding,
          isBuf,
          callback: cb,
          next: null
        };
        if (last) {
          last.next = state.lastBufferedRequest;
        } else {
          state.bufferedRequest = state.lastBufferedRequest;
        }
        state.bufferedRequestCount += 1;
      } else {
        doWrite(stream, state, false, len, chunk, encoding, cb);
      }
      return ret2;
    }
    function doWrite(stream, state, writev, len, chunk, encoding, cb) {
      state.writelen = len;
      state.writecb = cb;
      state.writing = true;
      state.sync = true;
      if (writev)
        stream._writev(chunk, state.onwrite);
      else
        stream._write(chunk, encoding, state.onwrite);
      state.sync = false;
    }
    function onwriteError(stream, state, sync, er, cb) {
      --state.pendingcb;
      if (sync) {
        pna.nextTick(cb, er);
        pna.nextTick(finishMaybe, stream, state);
        stream._writableState.errorEmitted = true;
        stream.emit("error", er);
      } else {
        cb(er);
        stream._writableState.errorEmitted = true;
        stream.emit("error", er);
        finishMaybe(stream, state);
      }
    }
    function onwriteStateUpdate(state) {
      state.writing = false;
      state.writecb = null;
      state.length -= state.writelen;
      state.writelen = 0;
    }
    function onwrite(stream, er) {
      var state = stream._writableState;
      var sync = state.sync;
      var cb = state.writecb;
      onwriteStateUpdate(state);
      if (er)
        onwriteError(stream, state, sync, er, cb);
      else {
        var finished = needFinish(state);
        if (!finished && !state.corked && !state.bufferProcessing && state.bufferedRequest) {
          clearBuffer(stream, state);
        }
        if (sync) {
          asyncWrite(afterWrite, stream, state, finished, cb);
        } else {
          afterWrite(stream, state, finished, cb);
        }
      }
    }
    function afterWrite(stream, state, finished, cb) {
      if (!finished)
        onwriteDrain(stream, state);
      state.pendingcb--;
      cb();
      finishMaybe(stream, state);
    }
    function onwriteDrain(stream, state) {
      if (state.length === 0 && state.needDrain) {
        state.needDrain = false;
        stream.emit("drain");
      }
    }
    function clearBuffer(stream, state) {
      state.bufferProcessing = true;
      var entry = state.bufferedRequest;
      if (stream._writev && entry && entry.next) {
        var l2 = state.bufferedRequestCount;
        var buffer = new Array(l2);
        var holder = state.corkedRequestsFree;
        holder.entry = entry;
        var count = 0;
        var allBuffers = true;
        while (entry) {
          buffer[count] = entry;
          if (!entry.isBuf)
            allBuffers = false;
          entry = entry.next;
          count += 1;
        }
        buffer.allBuffers = allBuffers;
        doWrite(stream, state, true, state.length, buffer, "", holder.finish);
        state.pendingcb++;
        state.lastBufferedRequest = null;
        if (holder.next) {
          state.corkedRequestsFree = holder.next;
          holder.next = null;
        } else {
          state.corkedRequestsFree = new CorkedRequest(state);
        }
        state.bufferedRequestCount = 0;
      } else {
        while (entry) {
          var chunk = entry.chunk;
          var encoding = entry.encoding;
          var cb = entry.callback;
          var len = state.objectMode ? 1 : chunk.length;
          doWrite(stream, state, false, len, chunk, encoding, cb);
          entry = entry.next;
          state.bufferedRequestCount--;
          if (state.writing) {
            break;
          }
        }
        if (entry === null)
          state.lastBufferedRequest = null;
      }
      state.bufferedRequest = entry;
      state.bufferProcessing = false;
    }
    Writable.prototype._write = function(chunk, encoding, cb) {
      cb(new Error("_write() is not implemented"));
    };
    Writable.prototype._writev = null;
    Writable.prototype.end = function(chunk, encoding, cb) {
      var state = this._writableState;
      if (typeof chunk === "function") {
        cb = chunk;
        chunk = null;
        encoding = null;
      } else if (typeof encoding === "function") {
        cb = encoding;
        encoding = null;
      }
      if (chunk !== null && chunk !== void 0)
        this.write(chunk, encoding);
      if (state.corked) {
        state.corked = 1;
        this.uncork();
      }
      if (!state.ending)
        endWritable(this, state, cb);
    };
    function needFinish(state) {
      return state.ending && state.length === 0 && state.bufferedRequest === null && !state.finished && !state.writing;
    }
    function callFinal(stream, state) {
      stream._final(function(err) {
        state.pendingcb--;
        if (err) {
          stream.emit("error", err);
        }
        state.prefinished = true;
        stream.emit("prefinish");
        finishMaybe(stream, state);
      });
    }
    function prefinish(stream, state) {
      if (!state.prefinished && !state.finalCalled) {
        if (typeof stream._final === "function") {
          state.pendingcb++;
          state.finalCalled = true;
          pna.nextTick(callFinal, stream, state);
        } else {
          state.prefinished = true;
          stream.emit("prefinish");
        }
      }
    }
    function finishMaybe(stream, state) {
      var need = needFinish(state);
      if (need) {
        prefinish(stream, state);
        if (state.pendingcb === 0) {
          state.finished = true;
          stream.emit("finish");
        }
      }
      return need;
    }
    function endWritable(stream, state, cb) {
      state.ending = true;
      finishMaybe(stream, state);
      if (cb) {
        if (state.finished)
          pna.nextTick(cb);
        else
          stream.once("finish", cb);
      }
      state.ended = true;
      stream.writable = false;
    }
    function onCorkedFinish(corkReq, state, err) {
      var entry = corkReq.entry;
      corkReq.entry = null;
      while (entry) {
        var cb = entry.callback;
        state.pendingcb--;
        cb(err);
        entry = entry.next;
      }
      state.corkedRequestsFree.next = corkReq;
    }
    Object.defineProperty(Writable.prototype, "destroyed", {
      get: function() {
        if (this._writableState === void 0) {
          return false;
        }
        return this._writableState.destroyed;
      },
      set: function(value) {
        if (!this._writableState) {
          return;
        }
        this._writableState.destroyed = value;
      }
    });
    Writable.prototype.destroy = destroyImpl.destroy;
    Writable.prototype._undestroy = destroyImpl.undestroy;
    Writable.prototype._destroy = function(err, cb) {
      this.end();
      cb(err);
    };
  }
});

// ../../../node_modules/jszip/node_modules/readable-stream/lib/_stream_duplex.js
var require_stream_duplex = __commonJS({
  "../../../node_modules/jszip/node_modules/readable-stream/lib/_stream_duplex.js"(exports2, module2) {
    "use strict";
    var pna = require_process_nextick_args();
    var objectKeys = Object.keys || function(obj2) {
      var keys2 = [];
      for (var key in obj2) {
        keys2.push(key);
      }
      return keys2;
    };
    module2.exports = Duplex;
    var util = Object.create(require_util());
    util.inherits = require_inherits();
    var Readable = require_stream_readable();
    var Writable = require_stream_writable();
    util.inherits(Duplex, Readable);
    {
      keys = objectKeys(Writable.prototype);
      for (v = 0; v < keys.length; v++) {
        method = keys[v];
        if (!Duplex.prototype[method])
          Duplex.prototype[method] = Writable.prototype[method];
      }
    }
    var keys;
    var method;
    var v;
    function Duplex(options) {
      if (!(this instanceof Duplex))
        return new Duplex(options);
      Readable.call(this, options);
      Writable.call(this, options);
      if (options && options.readable === false)
        this.readable = false;
      if (options && options.writable === false)
        this.writable = false;
      this.allowHalfOpen = true;
      if (options && options.allowHalfOpen === false)
        this.allowHalfOpen = false;
      this.once("end", onend);
    }
    Object.defineProperty(Duplex.prototype, "writableHighWaterMark", {
      // making it explicit this property is not enumerable
      // because otherwise some prototype manipulation in
      // userland will fail
      enumerable: false,
      get: function() {
        return this._writableState.highWaterMark;
      }
    });
    function onend() {
      if (this.allowHalfOpen || this._writableState.ended)
        return;
      pna.nextTick(onEndNT, this);
    }
    function onEndNT(self2) {
      self2.end();
    }
    Object.defineProperty(Duplex.prototype, "destroyed", {
      get: function() {
        if (this._readableState === void 0 || this._writableState === void 0) {
          return false;
        }
        return this._readableState.destroyed && this._writableState.destroyed;
      },
      set: function(value) {
        if (this._readableState === void 0 || this._writableState === void 0) {
          return;
        }
        this._readableState.destroyed = value;
        this._writableState.destroyed = value;
      }
    });
    Duplex.prototype._destroy = function(err, cb) {
      this.push(null);
      this.end();
      pna.nextTick(cb, err);
    };
  }
});

// ../../../node_modules/jszip/node_modules/string_decoder/lib/string_decoder.js
var require_string_decoder = __commonJS({
  "../../../node_modules/jszip/node_modules/string_decoder/lib/string_decoder.js"(exports2) {
    "use strict";
    var Buffer2 = require_safe_buffer().Buffer;
    var isEncoding = Buffer2.isEncoding || function(encoding) {
      encoding = "" + encoding;
      switch (encoding && encoding.toLowerCase()) {
        case "hex":
        case "utf8":
        case "utf-8":
        case "ascii":
        case "binary":
        case "base64":
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
        case "raw":
          return true;
        default:
          return false;
      }
    };
    function _normalizeEncoding(enc) {
      if (!enc)
        return "utf8";
      var retried;
      while (true) {
        switch (enc) {
          case "utf8":
          case "utf-8":
            return "utf8";
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
            return "utf16le";
          case "latin1":
          case "binary":
            return "latin1";
          case "base64":
          case "ascii":
          case "hex":
            return enc;
          default:
            if (retried)
              return;
            enc = ("" + enc).toLowerCase();
            retried = true;
        }
      }
    }
    function normalizeEncoding(enc) {
      var nenc = _normalizeEncoding(enc);
      if (typeof nenc !== "string" && (Buffer2.isEncoding === isEncoding || !isEncoding(enc)))
        throw new Error("Unknown encoding: " + enc);
      return nenc || enc;
    }
    exports2.StringDecoder = StringDecoder;
    function StringDecoder(encoding) {
      this.encoding = normalizeEncoding(encoding);
      var nb;
      switch (this.encoding) {
        case "utf16le":
          this.text = utf16Text;
          this.end = utf16End;
          nb = 4;
          break;
        case "utf8":
          this.fillLast = utf8FillLast;
          nb = 4;
          break;
        case "base64":
          this.text = base64Text;
          this.end = base64End;
          nb = 3;
          break;
        default:
          this.write = simpleWrite;
          this.end = simpleEnd;
          return;
      }
      this.lastNeed = 0;
      this.lastTotal = 0;
      this.lastChar = Buffer2.allocUnsafe(nb);
    }
    StringDecoder.prototype.write = function(buf) {
      if (buf.length === 0)
        return "";
      var r;
      var i;
      if (this.lastNeed) {
        r = this.fillLast(buf);
        if (r === void 0)
          return "";
        i = this.lastNeed;
        this.lastNeed = 0;
      } else {
        i = 0;
      }
      if (i < buf.length)
        return r ? r + this.text(buf, i) : this.text(buf, i);
      return r || "";
    };
    StringDecoder.prototype.end = utf8End;
    StringDecoder.prototype.text = utf8Text;
    StringDecoder.prototype.fillLast = function(buf) {
      if (this.lastNeed <= buf.length) {
        buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, this.lastNeed);
        return this.lastChar.toString(this.encoding, 0, this.lastTotal);
      }
      buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, buf.length);
      this.lastNeed -= buf.length;
    };
    function utf8CheckByte(byte) {
      if (byte <= 127)
        return 0;
      else if (byte >> 5 === 6)
        return 2;
      else if (byte >> 4 === 14)
        return 3;
      else if (byte >> 3 === 30)
        return 4;
      return byte >> 6 === 2 ? -1 : -2;
    }
    function utf8CheckIncomplete(self2, buf, i) {
      var j = buf.length - 1;
      if (j < i)
        return 0;
      var nb = utf8CheckByte(buf[j]);
      if (nb >= 0) {
        if (nb > 0)
          self2.lastNeed = nb - 1;
        return nb;
      }
      if (--j < i || nb === -2)
        return 0;
      nb = utf8CheckByte(buf[j]);
      if (nb >= 0) {
        if (nb > 0)
          self2.lastNeed = nb - 2;
        return nb;
      }
      if (--j < i || nb === -2)
        return 0;
      nb = utf8CheckByte(buf[j]);
      if (nb >= 0) {
        if (nb > 0) {
          if (nb === 2)
            nb = 0;
          else
            self2.lastNeed = nb - 3;
        }
        return nb;
      }
      return 0;
    }
    function utf8CheckExtraBytes(self2, buf, p) {
      if ((buf[0] & 192) !== 128) {
        self2.lastNeed = 0;
        return "\uFFFD";
      }
      if (self2.lastNeed > 1 && buf.length > 1) {
        if ((buf[1] & 192) !== 128) {
          self2.lastNeed = 1;
          return "\uFFFD";
        }
        if (self2.lastNeed > 2 && buf.length > 2) {
          if ((buf[2] & 192) !== 128) {
            self2.lastNeed = 2;
            return "\uFFFD";
          }
        }
      }
    }
    function utf8FillLast(buf) {
      var p = this.lastTotal - this.lastNeed;
      var r = utf8CheckExtraBytes(this, buf, p);
      if (r !== void 0)
        return r;
      if (this.lastNeed <= buf.length) {
        buf.copy(this.lastChar, p, 0, this.lastNeed);
        return this.lastChar.toString(this.encoding, 0, this.lastTotal);
      }
      buf.copy(this.lastChar, p, 0, buf.length);
      this.lastNeed -= buf.length;
    }
    function utf8Text(buf, i) {
      var total = utf8CheckIncomplete(this, buf, i);
      if (!this.lastNeed)
        return buf.toString("utf8", i);
      this.lastTotal = total;
      var end = buf.length - (total - this.lastNeed);
      buf.copy(this.lastChar, 0, end);
      return buf.toString("utf8", i, end);
    }
    function utf8End(buf) {
      var r = buf && buf.length ? this.write(buf) : "";
      if (this.lastNeed)
        return r + "\uFFFD";
      return r;
    }
    function utf16Text(buf, i) {
      if ((buf.length - i) % 2 === 0) {
        var r = buf.toString("utf16le", i);
        if (r) {
          var c = r.charCodeAt(r.length - 1);
          if (c >= 55296 && c <= 56319) {
            this.lastNeed = 2;
            this.lastTotal = 4;
            this.lastChar[0] = buf[buf.length - 2];
            this.lastChar[1] = buf[buf.length - 1];
            return r.slice(0, -1);
          }
        }
        return r;
      }
      this.lastNeed = 1;
      this.lastTotal = 2;
      this.lastChar[0] = buf[buf.length - 1];
      return buf.toString("utf16le", i, buf.length - 1);
    }
    function utf16End(buf) {
      var r = buf && buf.length ? this.write(buf) : "";
      if (this.lastNeed) {
        var end = this.lastTotal - this.lastNeed;
        return r + this.lastChar.toString("utf16le", 0, end);
      }
      return r;
    }
    function base64Text(buf, i) {
      var n = (buf.length - i) % 3;
      if (n === 0)
        return buf.toString("base64", i);
      this.lastNeed = 3 - n;
      this.lastTotal = 3;
      if (n === 1) {
        this.lastChar[0] = buf[buf.length - 1];
      } else {
        this.lastChar[0] = buf[buf.length - 2];
        this.lastChar[1] = buf[buf.length - 1];
      }
      return buf.toString("base64", i, buf.length - n);
    }
    function base64End(buf) {
      var r = buf && buf.length ? this.write(buf) : "";
      if (this.lastNeed)
        return r + this.lastChar.toString("base64", 0, 3 - this.lastNeed);
      return r;
    }
    function simpleWrite(buf) {
      return buf.toString(this.encoding);
    }
    function simpleEnd(buf) {
      return buf && buf.length ? this.write(buf) : "";
    }
  }
});

// ../../../node_modules/jszip/node_modules/readable-stream/lib/_stream_readable.js
var require_stream_readable = __commonJS({
  "../../../node_modules/jszip/node_modules/readable-stream/lib/_stream_readable.js"(exports2, module2) {
    "use strict";
    var pna = require_process_nextick_args();
    module2.exports = Readable;
    var isArray = require_isarray();
    var Duplex;
    Readable.ReadableState = ReadableState;
    var EE = require("events").EventEmitter;
    var EElistenerCount = function(emitter, type) {
      return emitter.listeners(type).length;
    };
    var Stream = require_stream();
    var Buffer2 = require_safe_buffer().Buffer;
    var OurUint8Array = (typeof global !== "undefined" ? global : typeof window !== "undefined" ? window : typeof self !== "undefined" ? self : {}).Uint8Array || function() {
    };
    function _uint8ArrayToBuffer(chunk) {
      return Buffer2.from(chunk);
    }
    function _isUint8Array(obj2) {
      return Buffer2.isBuffer(obj2) || obj2 instanceof OurUint8Array;
    }
    var util = Object.create(require_util());
    util.inherits = require_inherits();
    var debugUtil = require("util");
    var debug = void 0;
    if (debugUtil && debugUtil.debuglog) {
      debug = debugUtil.debuglog("stream");
    } else {
      debug = function() {
      };
    }
    var BufferList = require_BufferList();
    var destroyImpl = require_destroy();
    var StringDecoder;
    util.inherits(Readable, Stream);
    var kProxyEvents = ["error", "close", "destroy", "pause", "resume"];
    function prependListener(emitter, event, fn) {
      if (typeof emitter.prependListener === "function")
        return emitter.prependListener(event, fn);
      if (!emitter._events || !emitter._events[event])
        emitter.on(event, fn);
      else if (isArray(emitter._events[event]))
        emitter._events[event].unshift(fn);
      else
        emitter._events[event] = [fn, emitter._events[event]];
    }
    function ReadableState(options, stream) {
      Duplex = Duplex || require_stream_duplex();
      options = options || {};
      var isDuplex = stream instanceof Duplex;
      this.objectMode = !!options.objectMode;
      if (isDuplex)
        this.objectMode = this.objectMode || !!options.readableObjectMode;
      var hwm = options.highWaterMark;
      var readableHwm = options.readableHighWaterMark;
      var defaultHwm = this.objectMode ? 16 : 16 * 1024;
      if (hwm || hwm === 0)
        this.highWaterMark = hwm;
      else if (isDuplex && (readableHwm || readableHwm === 0))
        this.highWaterMark = readableHwm;
      else
        this.highWaterMark = defaultHwm;
      this.highWaterMark = Math.floor(this.highWaterMark);
      this.buffer = new BufferList();
      this.length = 0;
      this.pipes = null;
      this.pipesCount = 0;
      this.flowing = null;
      this.ended = false;
      this.endEmitted = false;
      this.reading = false;
      this.sync = true;
      this.needReadable = false;
      this.emittedReadable = false;
      this.readableListening = false;
      this.resumeScheduled = false;
      this.destroyed = false;
      this.defaultEncoding = options.defaultEncoding || "utf8";
      this.awaitDrain = 0;
      this.readingMore = false;
      this.decoder = null;
      this.encoding = null;
      if (options.encoding) {
        if (!StringDecoder)
          StringDecoder = require_string_decoder().StringDecoder;
        this.decoder = new StringDecoder(options.encoding);
        this.encoding = options.encoding;
      }
    }
    function Readable(options) {
      Duplex = Duplex || require_stream_duplex();
      if (!(this instanceof Readable))
        return new Readable(options);
      this._readableState = new ReadableState(options, this);
      this.readable = true;
      if (options) {
        if (typeof options.read === "function")
          this._read = options.read;
        if (typeof options.destroy === "function")
          this._destroy = options.destroy;
      }
      Stream.call(this);
    }
    Object.defineProperty(Readable.prototype, "destroyed", {
      get: function() {
        if (this._readableState === void 0) {
          return false;
        }
        return this._readableState.destroyed;
      },
      set: function(value) {
        if (!this._readableState) {
          return;
        }
        this._readableState.destroyed = value;
      }
    });
    Readable.prototype.destroy = destroyImpl.destroy;
    Readable.prototype._undestroy = destroyImpl.undestroy;
    Readable.prototype._destroy = function(err, cb) {
      this.push(null);
      cb(err);
    };
    Readable.prototype.push = function(chunk, encoding) {
      var state = this._readableState;
      var skipChunkCheck;
      if (!state.objectMode) {
        if (typeof chunk === "string") {
          encoding = encoding || state.defaultEncoding;
          if (encoding !== state.encoding) {
            chunk = Buffer2.from(chunk, encoding);
            encoding = "";
          }
          skipChunkCheck = true;
        }
      } else {
        skipChunkCheck = true;
      }
      return readableAddChunk(this, chunk, encoding, false, skipChunkCheck);
    };
    Readable.prototype.unshift = function(chunk) {
      return readableAddChunk(this, chunk, null, true, false);
    };
    function readableAddChunk(stream, chunk, encoding, addToFront, skipChunkCheck) {
      var state = stream._readableState;
      if (chunk === null) {
        state.reading = false;
        onEofChunk(stream, state);
      } else {
        var er;
        if (!skipChunkCheck)
          er = chunkInvalid(state, chunk);
        if (er) {
          stream.emit("error", er);
        } else if (state.objectMode || chunk && chunk.length > 0) {
          if (typeof chunk !== "string" && !state.objectMode && Object.getPrototypeOf(chunk) !== Buffer2.prototype) {
            chunk = _uint8ArrayToBuffer(chunk);
          }
          if (addToFront) {
            if (state.endEmitted)
              stream.emit("error", new Error("stream.unshift() after end event"));
            else
              addChunk(stream, state, chunk, true);
          } else if (state.ended) {
            stream.emit("error", new Error("stream.push() after EOF"));
          } else {
            state.reading = false;
            if (state.decoder && !encoding) {
              chunk = state.decoder.write(chunk);
              if (state.objectMode || chunk.length !== 0)
                addChunk(stream, state, chunk, false);
              else
                maybeReadMore(stream, state);
            } else {
              addChunk(stream, state, chunk, false);
            }
          }
        } else if (!addToFront) {
          state.reading = false;
        }
      }
      return needMoreData(state);
    }
    function addChunk(stream, state, chunk, addToFront) {
      if (state.flowing && state.length === 0 && !state.sync) {
        stream.emit("data", chunk);
        stream.read(0);
      } else {
        state.length += state.objectMode ? 1 : chunk.length;
        if (addToFront)
          state.buffer.unshift(chunk);
        else
          state.buffer.push(chunk);
        if (state.needReadable)
          emitReadable(stream);
      }
      maybeReadMore(stream, state);
    }
    function chunkInvalid(state, chunk) {
      var er;
      if (!_isUint8Array(chunk) && typeof chunk !== "string" && chunk !== void 0 && !state.objectMode) {
        er = new TypeError("Invalid non-string/buffer chunk");
      }
      return er;
    }
    function needMoreData(state) {
      return !state.ended && (state.needReadable || state.length < state.highWaterMark || state.length === 0);
    }
    Readable.prototype.isPaused = function() {
      return this._readableState.flowing === false;
    };
    Readable.prototype.setEncoding = function(enc) {
      if (!StringDecoder)
        StringDecoder = require_string_decoder().StringDecoder;
      this._readableState.decoder = new StringDecoder(enc);
      this._readableState.encoding = enc;
      return this;
    };
    var MAX_HWM = 8388608;
    function computeNewHighWaterMark(n) {
      if (n >= MAX_HWM) {
        n = MAX_HWM;
      } else {
        n--;
        n |= n >>> 1;
        n |= n >>> 2;
        n |= n >>> 4;
        n |= n >>> 8;
        n |= n >>> 16;
        n++;
      }
      return n;
    }
    function howMuchToRead(n, state) {
      if (n <= 0 || state.length === 0 && state.ended)
        return 0;
      if (state.objectMode)
        return 1;
      if (n !== n) {
        if (state.flowing && state.length)
          return state.buffer.head.data.length;
        else
          return state.length;
      }
      if (n > state.highWaterMark)
        state.highWaterMark = computeNewHighWaterMark(n);
      if (n <= state.length)
        return n;
      if (!state.ended) {
        state.needReadable = true;
        return 0;
      }
      return state.length;
    }
    Readable.prototype.read = function(n) {
      debug("read", n);
      n = parseInt(n, 10);
      var state = this._readableState;
      var nOrig = n;
      if (n !== 0)
        state.emittedReadable = false;
      if (n === 0 && state.needReadable && (state.length >= state.highWaterMark || state.ended)) {
        debug("read: emitReadable", state.length, state.ended);
        if (state.length === 0 && state.ended)
          endReadable(this);
        else
          emitReadable(this);
        return null;
      }
      n = howMuchToRead(n, state);
      if (n === 0 && state.ended) {
        if (state.length === 0)
          endReadable(this);
        return null;
      }
      var doRead = state.needReadable;
      debug("need readable", doRead);
      if (state.length === 0 || state.length - n < state.highWaterMark) {
        doRead = true;
        debug("length less than watermark", doRead);
      }
      if (state.ended || state.reading) {
        doRead = false;
        debug("reading or ended", doRead);
      } else if (doRead) {
        debug("do read");
        state.reading = true;
        state.sync = true;
        if (state.length === 0)
          state.needReadable = true;
        this._read(state.highWaterMark);
        state.sync = false;
        if (!state.reading)
          n = howMuchToRead(nOrig, state);
      }
      var ret2;
      if (n > 0)
        ret2 = fromList(n, state);
      else
        ret2 = null;
      if (ret2 === null) {
        state.needReadable = true;
        n = 0;
      } else {
        state.length -= n;
      }
      if (state.length === 0) {
        if (!state.ended)
          state.needReadable = true;
        if (nOrig !== n && state.ended)
          endReadable(this);
      }
      if (ret2 !== null)
        this.emit("data", ret2);
      return ret2;
    };
    function onEofChunk(stream, state) {
      if (state.ended)
        return;
      if (state.decoder) {
        var chunk = state.decoder.end();
        if (chunk && chunk.length) {
          state.buffer.push(chunk);
          state.length += state.objectMode ? 1 : chunk.length;
        }
      }
      state.ended = true;
      emitReadable(stream);
    }
    function emitReadable(stream) {
      var state = stream._readableState;
      state.needReadable = false;
      if (!state.emittedReadable) {
        debug("emitReadable", state.flowing);
        state.emittedReadable = true;
        if (state.sync)
          pna.nextTick(emitReadable_, stream);
        else
          emitReadable_(stream);
      }
    }
    function emitReadable_(stream) {
      debug("emit readable");
      stream.emit("readable");
      flow(stream);
    }
    function maybeReadMore(stream, state) {
      if (!state.readingMore) {
        state.readingMore = true;
        pna.nextTick(maybeReadMore_, stream, state);
      }
    }
    function maybeReadMore_(stream, state) {
      var len = state.length;
      while (!state.reading && !state.flowing && !state.ended && state.length < state.highWaterMark) {
        debug("maybeReadMore read 0");
        stream.read(0);
        if (len === state.length)
          break;
        else
          len = state.length;
      }
      state.readingMore = false;
    }
    Readable.prototype._read = function(n) {
      this.emit("error", new Error("_read() is not implemented"));
    };
    Readable.prototype.pipe = function(dest, pipeOpts) {
      var src = this;
      var state = this._readableState;
      switch (state.pipesCount) {
        case 0:
          state.pipes = dest;
          break;
        case 1:
          state.pipes = [state.pipes, dest];
          break;
        default:
          state.pipes.push(dest);
          break;
      }
      state.pipesCount += 1;
      debug("pipe count=%d opts=%j", state.pipesCount, pipeOpts);
      var doEnd = (!pipeOpts || pipeOpts.end !== false) && dest !== process.stdout && dest !== process.stderr;
      var endFn = doEnd ? onend : unpipe;
      if (state.endEmitted)
        pna.nextTick(endFn);
      else
        src.once("end", endFn);
      dest.on("unpipe", onunpipe);
      function onunpipe(readable, unpipeInfo) {
        debug("onunpipe");
        if (readable === src) {
          if (unpipeInfo && unpipeInfo.hasUnpiped === false) {
            unpipeInfo.hasUnpiped = true;
            cleanup();
          }
        }
      }
      function onend() {
        debug("onend");
        dest.end();
      }
      var ondrain = pipeOnDrain(src);
      dest.on("drain", ondrain);
      var cleanedUp = false;
      function cleanup() {
        debug("cleanup");
        dest.removeListener("close", onclose);
        dest.removeListener("finish", onfinish);
        dest.removeListener("drain", ondrain);
        dest.removeListener("error", onerror);
        dest.removeListener("unpipe", onunpipe);
        src.removeListener("end", onend);
        src.removeListener("end", unpipe);
        src.removeListener("data", ondata);
        cleanedUp = true;
        if (state.awaitDrain && (!dest._writableState || dest._writableState.needDrain))
          ondrain();
      }
      var increasedAwaitDrain = false;
      src.on("data", ondata);
      function ondata(chunk) {
        debug("ondata");
        increasedAwaitDrain = false;
        var ret2 = dest.write(chunk);
        if (false === ret2 && !increasedAwaitDrain) {
          if ((state.pipesCount === 1 && state.pipes === dest || state.pipesCount > 1 && indexOf(state.pipes, dest) !== -1) && !cleanedUp) {
            debug("false write response, pause", state.awaitDrain);
            state.awaitDrain++;
            increasedAwaitDrain = true;
          }
          src.pause();
        }
      }
      function onerror(er) {
        debug("onerror", er);
        unpipe();
        dest.removeListener("error", onerror);
        if (EElistenerCount(dest, "error") === 0)
          dest.emit("error", er);
      }
      prependListener(dest, "error", onerror);
      function onclose() {
        dest.removeListener("finish", onfinish);
        unpipe();
      }
      dest.once("close", onclose);
      function onfinish() {
        debug("onfinish");
        dest.removeListener("close", onclose);
        unpipe();
      }
      dest.once("finish", onfinish);
      function unpipe() {
        debug("unpipe");
        src.unpipe(dest);
      }
      dest.emit("pipe", src);
      if (!state.flowing) {
        debug("pipe resume");
        src.resume();
      }
      return dest;
    };
    function pipeOnDrain(src) {
      return function() {
        var state = src._readableState;
        debug("pipeOnDrain", state.awaitDrain);
        if (state.awaitDrain)
          state.awaitDrain--;
        if (state.awaitDrain === 0 && EElistenerCount(src, "data")) {
          state.flowing = true;
          flow(src);
        }
      };
    }
    Readable.prototype.unpipe = function(dest) {
      var state = this._readableState;
      var unpipeInfo = { hasUnpiped: false };
      if (state.pipesCount === 0)
        return this;
      if (state.pipesCount === 1) {
        if (dest && dest !== state.pipes)
          return this;
        if (!dest)
          dest = state.pipes;
        state.pipes = null;
        state.pipesCount = 0;
        state.flowing = false;
        if (dest)
          dest.emit("unpipe", this, unpipeInfo);
        return this;
      }
      if (!dest) {
        var dests = state.pipes;
        var len = state.pipesCount;
        state.pipes = null;
        state.pipesCount = 0;
        state.flowing = false;
        for (var i = 0; i < len; i++) {
          dests[i].emit("unpipe", this, { hasUnpiped: false });
        }
        return this;
      }
      var index = indexOf(state.pipes, dest);
      if (index === -1)
        return this;
      state.pipes.splice(index, 1);
      state.pipesCount -= 1;
      if (state.pipesCount === 1)
        state.pipes = state.pipes[0];
      dest.emit("unpipe", this, unpipeInfo);
      return this;
    };
    Readable.prototype.on = function(ev, fn) {
      var res = Stream.prototype.on.call(this, ev, fn);
      if (ev === "data") {
        if (this._readableState.flowing !== false)
          this.resume();
      } else if (ev === "readable") {
        var state = this._readableState;
        if (!state.endEmitted && !state.readableListening) {
          state.readableListening = state.needReadable = true;
          state.emittedReadable = false;
          if (!state.reading) {
            pna.nextTick(nReadingNextTick, this);
          } else if (state.length) {
            emitReadable(this);
          }
        }
      }
      return res;
    };
    Readable.prototype.addListener = Readable.prototype.on;
    function nReadingNextTick(self2) {
      debug("readable nexttick read 0");
      self2.read(0);
    }
    Readable.prototype.resume = function() {
      var state = this._readableState;
      if (!state.flowing) {
        debug("resume");
        state.flowing = true;
        resume(this, state);
      }
      return this;
    };
    function resume(stream, state) {
      if (!state.resumeScheduled) {
        state.resumeScheduled = true;
        pna.nextTick(resume_, stream, state);
      }
    }
    function resume_(stream, state) {
      if (!state.reading) {
        debug("resume read 0");
        stream.read(0);
      }
      state.resumeScheduled = false;
      state.awaitDrain = 0;
      stream.emit("resume");
      flow(stream);
      if (state.flowing && !state.reading)
        stream.read(0);
    }
    Readable.prototype.pause = function() {
      debug("call pause flowing=%j", this._readableState.flowing);
      if (false !== this._readableState.flowing) {
        debug("pause");
        this._readableState.flowing = false;
        this.emit("pause");
      }
      return this;
    };
    function flow(stream) {
      var state = stream._readableState;
      debug("flow", state.flowing);
      while (state.flowing && stream.read() !== null) {
      }
    }
    Readable.prototype.wrap = function(stream) {
      var _this = this;
      var state = this._readableState;
      var paused = false;
      stream.on("end", function() {
        debug("wrapped end");
        if (state.decoder && !state.ended) {
          var chunk = state.decoder.end();
          if (chunk && chunk.length)
            _this.push(chunk);
        }
        _this.push(null);
      });
      stream.on("data", function(chunk) {
        debug("wrapped data");
        if (state.decoder)
          chunk = state.decoder.write(chunk);
        if (state.objectMode && (chunk === null || chunk === void 0))
          return;
        else if (!state.objectMode && (!chunk || !chunk.length))
          return;
        var ret2 = _this.push(chunk);
        if (!ret2) {
          paused = true;
          stream.pause();
        }
      });
      for (var i in stream) {
        if (this[i] === void 0 && typeof stream[i] === "function") {
          this[i] = /* @__PURE__ */ function(method) {
            return function() {
              return stream[method].apply(stream, arguments);
            };
          }(i);
        }
      }
      for (var n = 0; n < kProxyEvents.length; n++) {
        stream.on(kProxyEvents[n], this.emit.bind(this, kProxyEvents[n]));
      }
      this._read = function(n2) {
        debug("wrapped _read", n2);
        if (paused) {
          paused = false;
          stream.resume();
        }
      };
      return this;
    };
    Object.defineProperty(Readable.prototype, "readableHighWaterMark", {
      // making it explicit this property is not enumerable
      // because otherwise some prototype manipulation in
      // userland will fail
      enumerable: false,
      get: function() {
        return this._readableState.highWaterMark;
      }
    });
    Readable._fromList = fromList;
    function fromList(n, state) {
      if (state.length === 0)
        return null;
      var ret2;
      if (state.objectMode)
        ret2 = state.buffer.shift();
      else if (!n || n >= state.length) {
        if (state.decoder)
          ret2 = state.buffer.join("");
        else if (state.buffer.length === 1)
          ret2 = state.buffer.head.data;
        else
          ret2 = state.buffer.concat(state.length);
        state.buffer.clear();
      } else {
        ret2 = fromListPartial(n, state.buffer, state.decoder);
      }
      return ret2;
    }
    function fromListPartial(n, list, hasStrings) {
      var ret2;
      if (n < list.head.data.length) {
        ret2 = list.head.data.slice(0, n);
        list.head.data = list.head.data.slice(n);
      } else if (n === list.head.data.length) {
        ret2 = list.shift();
      } else {
        ret2 = hasStrings ? copyFromBufferString(n, list) : copyFromBuffer(n, list);
      }
      return ret2;
    }
    function copyFromBufferString(n, list) {
      var p = list.head;
      var c = 1;
      var ret2 = p.data;
      n -= ret2.length;
      while (p = p.next) {
        var str = p.data;
        var nb = n > str.length ? str.length : n;
        if (nb === str.length)
          ret2 += str;
        else
          ret2 += str.slice(0, n);
        n -= nb;
        if (n === 0) {
          if (nb === str.length) {
            ++c;
            if (p.next)
              list.head = p.next;
            else
              list.head = list.tail = null;
          } else {
            list.head = p;
            p.data = str.slice(nb);
          }
          break;
        }
        ++c;
      }
      list.length -= c;
      return ret2;
    }
    function copyFromBuffer(n, list) {
      var ret2 = Buffer2.allocUnsafe(n);
      var p = list.head;
      var c = 1;
      p.data.copy(ret2);
      n -= p.data.length;
      while (p = p.next) {
        var buf = p.data;
        var nb = n > buf.length ? buf.length : n;
        buf.copy(ret2, ret2.length - n, 0, nb);
        n -= nb;
        if (n === 0) {
          if (nb === buf.length) {
            ++c;
            if (p.next)
              list.head = p.next;
            else
              list.head = list.tail = null;
          } else {
            list.head = p;
            p.data = buf.slice(nb);
          }
          break;
        }
        ++c;
      }
      list.length -= c;
      return ret2;
    }
    function endReadable(stream) {
      var state = stream._readableState;
      if (state.length > 0)
        throw new Error('"endReadable()" called on non-empty stream');
      if (!state.endEmitted) {
        state.ended = true;
        pna.nextTick(endReadableNT, state, stream);
      }
    }
    function endReadableNT(state, stream) {
      if (!state.endEmitted && state.length === 0) {
        state.endEmitted = true;
        stream.readable = false;
        stream.emit("end");
      }
    }
    function indexOf(xs, x) {
      for (var i = 0, l2 = xs.length; i < l2; i++) {
        if (xs[i] === x)
          return i;
      }
      return -1;
    }
  }
});

// ../../../node_modules/jszip/node_modules/readable-stream/lib/_stream_transform.js
var require_stream_transform = __commonJS({
  "../../../node_modules/jszip/node_modules/readable-stream/lib/_stream_transform.js"(exports2, module2) {
    "use strict";
    module2.exports = Transform;
    var Duplex = require_stream_duplex();
    var util = Object.create(require_util());
    util.inherits = require_inherits();
    util.inherits(Transform, Duplex);
    function afterTransform(er, data) {
      var ts = this._transformState;
      ts.transforming = false;
      var cb = ts.writecb;
      if (!cb) {
        return this.emit("error", new Error("write callback called multiple times"));
      }
      ts.writechunk = null;
      ts.writecb = null;
      if (data != null)
        this.push(data);
      cb(er);
      var rs = this._readableState;
      rs.reading = false;
      if (rs.needReadable || rs.length < rs.highWaterMark) {
        this._read(rs.highWaterMark);
      }
    }
    function Transform(options) {
      if (!(this instanceof Transform))
        return new Transform(options);
      Duplex.call(this, options);
      this._transformState = {
        afterTransform: afterTransform.bind(this),
        needTransform: false,
        transforming: false,
        writecb: null,
        writechunk: null,
        writeencoding: null
      };
      this._readableState.needReadable = true;
      this._readableState.sync = false;
      if (options) {
        if (typeof options.transform === "function")
          this._transform = options.transform;
        if (typeof options.flush === "function")
          this._flush = options.flush;
      }
      this.on("prefinish", prefinish);
    }
    function prefinish() {
      var _this = this;
      if (typeof this._flush === "function") {
        this._flush(function(er, data) {
          done(_this, er, data);
        });
      } else {
        done(this, null, null);
      }
    }
    Transform.prototype.push = function(chunk, encoding) {
      this._transformState.needTransform = false;
      return Duplex.prototype.push.call(this, chunk, encoding);
    };
    Transform.prototype._transform = function(chunk, encoding, cb) {
      throw new Error("_transform() is not implemented");
    };
    Transform.prototype._write = function(chunk, encoding, cb) {
      var ts = this._transformState;
      ts.writecb = cb;
      ts.writechunk = chunk;
      ts.writeencoding = encoding;
      if (!ts.transforming) {
        var rs = this._readableState;
        if (ts.needTransform || rs.needReadable || rs.length < rs.highWaterMark)
          this._read(rs.highWaterMark);
      }
    };
    Transform.prototype._read = function(n) {
      var ts = this._transformState;
      if (ts.writechunk !== null && ts.writecb && !ts.transforming) {
        ts.transforming = true;
        this._transform(ts.writechunk, ts.writeencoding, ts.afterTransform);
      } else {
        ts.needTransform = true;
      }
    };
    Transform.prototype._destroy = function(err, cb) {
      var _this2 = this;
      Duplex.prototype._destroy.call(this, err, function(err2) {
        cb(err2);
        _this2.emit("close");
      });
    };
    function done(stream, er, data) {
      if (er)
        return stream.emit("error", er);
      if (data != null)
        stream.push(data);
      if (stream._writableState.length)
        throw new Error("Calling transform done when ws.length != 0");
      if (stream._transformState.transforming)
        throw new Error("Calling transform done when still transforming");
      return stream.push(null);
    }
  }
});

// ../../../node_modules/jszip/node_modules/readable-stream/lib/_stream_passthrough.js
var require_stream_passthrough = __commonJS({
  "../../../node_modules/jszip/node_modules/readable-stream/lib/_stream_passthrough.js"(exports2, module2) {
    "use strict";
    module2.exports = PassThrough;
    var Transform = require_stream_transform();
    var util = Object.create(require_util());
    util.inherits = require_inherits();
    util.inherits(PassThrough, Transform);
    function PassThrough(options) {
      if (!(this instanceof PassThrough))
        return new PassThrough(options);
      Transform.call(this, options);
    }
    PassThrough.prototype._transform = function(chunk, encoding, cb) {
      cb(null, chunk);
    };
  }
});

// ../../../node_modules/jszip/node_modules/readable-stream/readable.js
var require_readable = __commonJS({
  "../../../node_modules/jszip/node_modules/readable-stream/readable.js"(exports2, module2) {
    var Stream = require("stream");
    if (process.env.READABLE_STREAM === "disable" && Stream) {
      module2.exports = Stream;
      exports2 = module2.exports = Stream.Readable;
      exports2.Readable = Stream.Readable;
      exports2.Writable = Stream.Writable;
      exports2.Duplex = Stream.Duplex;
      exports2.Transform = Stream.Transform;
      exports2.PassThrough = Stream.PassThrough;
      exports2.Stream = Stream;
    } else {
      exports2 = module2.exports = require_stream_readable();
      exports2.Stream = Stream || exports2;
      exports2.Readable = exports2;
      exports2.Writable = require_stream_writable();
      exports2.Duplex = require_stream_duplex();
      exports2.Transform = require_stream_transform();
      exports2.PassThrough = require_stream_passthrough();
    }
  }
});

// ../../../node_modules/jszip/lib/support.js
var require_support = __commonJS({
  "../../../node_modules/jszip/lib/support.js"(exports2) {
    "use strict";
    exports2.base64 = true;
    exports2.array = true;
    exports2.string = true;
    exports2.arraybuffer = typeof ArrayBuffer !== "undefined" && typeof Uint8Array !== "undefined";
    exports2.nodebuffer = typeof Buffer !== "undefined";
    exports2.uint8array = typeof Uint8Array !== "undefined";
    if (typeof ArrayBuffer === "undefined") {
      exports2.blob = false;
    } else {
      buffer = new ArrayBuffer(0);
      try {
        exports2.blob = new Blob([buffer], {
          type: "application/zip"
        }).size === 0;
      } catch (e) {
        try {
          Builder = self.BlobBuilder || self.WebKitBlobBuilder || self.MozBlobBuilder || self.MSBlobBuilder;
          builder = new Builder();
          builder.append(buffer);
          exports2.blob = builder.getBlob("application/zip").size === 0;
        } catch (e2) {
          exports2.blob = false;
        }
      }
    }
    var buffer;
    var Builder;
    var builder;
    try {
      exports2.nodestream = !!require_readable().Readable;
    } catch (e) {
      exports2.nodestream = false;
    }
  }
});

// ../../../node_modules/jszip/lib/base64.js
var require_base64 = __commonJS({
  "../../../node_modules/jszip/lib/base64.js"(exports2) {
    "use strict";
    var utils = require_utils();
    var support = require_support();
    var _keyStr = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";
    exports2.encode = function(input) {
      var output = [];
      var chr1, chr2, chr3, enc1, enc2, enc3, enc4;
      var i = 0, len = input.length, remainingBytes = len;
      var isArray = utils.getTypeOf(input) !== "string";
      while (i < input.length) {
        remainingBytes = len - i;
        if (!isArray) {
          chr1 = input.charCodeAt(i++);
          chr2 = i < len ? input.charCodeAt(i++) : 0;
          chr3 = i < len ? input.charCodeAt(i++) : 0;
        } else {
          chr1 = input[i++];
          chr2 = i < len ? input[i++] : 0;
          chr3 = i < len ? input[i++] : 0;
        }
        enc1 = chr1 >> 2;
        enc2 = (chr1 & 3) << 4 | chr2 >> 4;
        enc3 = remainingBytes > 1 ? (chr2 & 15) << 2 | chr3 >> 6 : 64;
        enc4 = remainingBytes > 2 ? chr3 & 63 : 64;
        output.push(_keyStr.charAt(enc1) + _keyStr.charAt(enc2) + _keyStr.charAt(enc3) + _keyStr.charAt(enc4));
      }
      return output.join("");
    };
    exports2.decode = function(input) {
      var chr1, chr2, chr3;
      var enc1, enc2, enc3, enc4;
      var i = 0, resultIndex = 0;
      var dataUrlPrefix = "data:";
      if (input.substr(0, dataUrlPrefix.length) === dataUrlPrefix) {
        throw new Error("Invalid base64 input, it looks like a data url.");
      }
      input = input.replace(/[^A-Za-z0-9+/=]/g, "");
      var totalLength = input.length * 3 / 4;
      if (input.charAt(input.length - 1) === _keyStr.charAt(64)) {
        totalLength--;
      }
      if (input.charAt(input.length - 2) === _keyStr.charAt(64)) {
        totalLength--;
      }
      if (totalLength % 1 !== 0) {
        throw new Error("Invalid base64 input, bad content length.");
      }
      var output;
      if (support.uint8array) {
        output = new Uint8Array(totalLength | 0);
      } else {
        output = new Array(totalLength | 0);
      }
      while (i < input.length) {
        enc1 = _keyStr.indexOf(input.charAt(i++));
        enc2 = _keyStr.indexOf(input.charAt(i++));
        enc3 = _keyStr.indexOf(input.charAt(i++));
        enc4 = _keyStr.indexOf(input.charAt(i++));
        chr1 = enc1 << 2 | enc2 >> 4;
        chr2 = (enc2 & 15) << 4 | enc3 >> 2;
        chr3 = (enc3 & 3) << 6 | enc4;
        output[resultIndex++] = chr1;
        if (enc3 !== 64) {
          output[resultIndex++] = chr2;
        }
        if (enc4 !== 64) {
          output[resultIndex++] = chr3;
        }
      }
      return output;
    };
  }
});

// ../../../node_modules/jszip/lib/nodejsUtils.js
var require_nodejsUtils = __commonJS({
  "../../../node_modules/jszip/lib/nodejsUtils.js"(exports2, module2) {
    "use strict";
    module2.exports = {
      /**
       * True if this is running in Nodejs, will be undefined in a browser.
       * In a browser, browserify won't include this file and the whole module
       * will be resolved an empty object.
       */
      isNode: typeof Buffer !== "undefined",
      /**
       * Create a new nodejs Buffer from an existing content.
       * @param {Object} data the data to pass to the constructor.
       * @param {String} encoding the encoding to use.
       * @return {Buffer} a new Buffer.
       */
      newBufferFrom: function(data, encoding) {
        if (Buffer.from && Buffer.from !== Uint8Array.from) {
          return Buffer.from(data, encoding);
        } else {
          if (typeof data === "number") {
            throw new Error('The "data" argument must not be a number');
          }
          return new Buffer(data, encoding);
        }
      },
      /**
       * Create a new nodejs Buffer with the specified size.
       * @param {Integer} size the size of the buffer.
       * @return {Buffer} a new Buffer.
       */
      allocBuffer: function(size) {
        if (Buffer.alloc) {
          return Buffer.alloc(size);
        } else {
          var buf = new Buffer(size);
          buf.fill(0);
          return buf;
        }
      },
      /**
       * Find out if an object is a Buffer.
       * @param {Object} b the object to test.
       * @return {Boolean} true if the object is a Buffer, false otherwise.
       */
      isBuffer: function(b) {
        return Buffer.isBuffer(b);
      },
      isStream: function(obj2) {
        return obj2 && typeof obj2.on === "function" && typeof obj2.pause === "function" && typeof obj2.resume === "function";
      }
    };
  }
});

// ../../../node_modules/immediate/lib/index.js
var require_lib = __commonJS({
  "../../../node_modules/immediate/lib/index.js"(exports2, module2) {
    "use strict";
    var Mutation = global.MutationObserver || global.WebKitMutationObserver;
    var scheduleDrain;
    if (process.browser) {
      if (Mutation) {
        called = 0;
        observer = new Mutation(nextTick);
        element = global.document.createTextNode("");
        observer.observe(element, {
          characterData: true
        });
        scheduleDrain = function() {
          element.data = called = ++called % 2;
        };
      } else if (!global.setImmediate && typeof global.MessageChannel !== "undefined") {
        channel = new global.MessageChannel();
        channel.port1.onmessage = nextTick;
        scheduleDrain = function() {
          channel.port2.postMessage(0);
        };
      } else if ("document" in global && "onreadystatechange" in global.document.createElement("script")) {
        scheduleDrain = function() {
          var scriptEl = global.document.createElement("script");
          scriptEl.onreadystatechange = function() {
            nextTick();
            scriptEl.onreadystatechange = null;
            scriptEl.parentNode.removeChild(scriptEl);
            scriptEl = null;
          };
          global.document.documentElement.appendChild(scriptEl);
        };
      } else {
        scheduleDrain = function() {
          setTimeout(nextTick, 0);
        };
      }
    } else {
      scheduleDrain = function() {
        process.nextTick(nextTick);
      };
    }
    var called;
    var observer;
    var element;
    var channel;
    var draining;
    var queue = [];
    function nextTick() {
      draining = true;
      var i, oldQueue;
      var len = queue.length;
      while (len) {
        oldQueue = queue;
        queue = [];
        i = -1;
        while (++i < len) {
          oldQueue[i]();
        }
        len = queue.length;
      }
      draining = false;
    }
    module2.exports = immediate;
    function immediate(task) {
      if (queue.push(task) === 1 && !draining) {
        scheduleDrain();
      }
    }
  }
});

// ../../../node_modules/lie/lib/index.js
var require_lib2 = __commonJS({
  "../../../node_modules/lie/lib/index.js"(exports2, module2) {
    "use strict";
    var immediate = require_lib();
    function INTERNAL() {
    }
    var handlers = {};
    var REJECTED = ["REJECTED"];
    var FULFILLED = ["FULFILLED"];
    var PENDING = ["PENDING"];
    if (!process.browser) {
      UNHANDLED = ["UNHANDLED"];
    }
    var UNHANDLED;
    module2.exports = Promise2;
    function Promise2(resolver) {
      if (typeof resolver !== "function") {
        throw new TypeError("resolver must be a function");
      }
      this.state = PENDING;
      this.queue = [];
      this.outcome = void 0;
      if (!process.browser) {
        this.handled = UNHANDLED;
      }
      if (resolver !== INTERNAL) {
        safelyResolveThenable(this, resolver);
      }
    }
    Promise2.prototype.finally = function(callback) {
      if (typeof callback !== "function") {
        return this;
      }
      var p = this.constructor;
      return this.then(resolve2, reject2);
      function resolve2(value) {
        function yes() {
          return value;
        }
        return p.resolve(callback()).then(yes);
      }
      function reject2(reason) {
        function no() {
          throw reason;
        }
        return p.resolve(callback()).then(no);
      }
    };
    Promise2.prototype.catch = function(onRejected) {
      return this.then(null, onRejected);
    };
    Promise2.prototype.then = function(onFulfilled, onRejected) {
      if (typeof onFulfilled !== "function" && this.state === FULFILLED || typeof onRejected !== "function" && this.state === REJECTED) {
        return this;
      }
      var promise = new this.constructor(INTERNAL);
      if (!process.browser) {
        if (this.handled === UNHANDLED) {
          this.handled = null;
        }
      }
      if (this.state !== PENDING) {
        var resolver = this.state === FULFILLED ? onFulfilled : onRejected;
        unwrap(promise, resolver, this.outcome);
      } else {
        this.queue.push(new QueueItem(promise, onFulfilled, onRejected));
      }
      return promise;
    };
    function QueueItem(promise, onFulfilled, onRejected) {
      this.promise = promise;
      if (typeof onFulfilled === "function") {
        this.onFulfilled = onFulfilled;
        this.callFulfilled = this.otherCallFulfilled;
      }
      if (typeof onRejected === "function") {
        this.onRejected = onRejected;
        this.callRejected = this.otherCallRejected;
      }
    }
    QueueItem.prototype.callFulfilled = function(value) {
      handlers.resolve(this.promise, value);
    };
    QueueItem.prototype.otherCallFulfilled = function(value) {
      unwrap(this.promise, this.onFulfilled, value);
    };
    QueueItem.prototype.callRejected = function(value) {
      handlers.reject(this.promise, value);
    };
    QueueItem.prototype.otherCallRejected = function(value) {
      unwrap(this.promise, this.onRejected, value);
    };
    function unwrap(promise, func, value) {
      immediate(function() {
        var returnValue;
        try {
          returnValue = func(value);
        } catch (e) {
          return handlers.reject(promise, e);
        }
        if (returnValue === promise) {
          handlers.reject(promise, new TypeError("Cannot resolve promise with itself"));
        } else {
          handlers.resolve(promise, returnValue);
        }
      });
    }
    handlers.resolve = function(self2, value) {
      var result = tryCatch2(getThen, value);
      if (result.status === "error") {
        return handlers.reject(self2, result.value);
      }
      var thenable = result.value;
      if (thenable) {
        safelyResolveThenable(self2, thenable);
      } else {
        self2.state = FULFILLED;
        self2.outcome = value;
        var i = -1;
        var len = self2.queue.length;
        while (++i < len) {
          self2.queue[i].callFulfilled(value);
        }
      }
      return self2;
    };
    handlers.reject = function(self2, error) {
      self2.state = REJECTED;
      self2.outcome = error;
      if (!process.browser) {
        if (self2.handled === UNHANDLED) {
          immediate(function() {
            if (self2.handled === UNHANDLED) {
              process.emit("unhandledRejection", error, self2);
            }
          });
        }
      }
      var i = -1;
      var len = self2.queue.length;
      while (++i < len) {
        self2.queue[i].callRejected(error);
      }
      return self2;
    };
    function getThen(obj2) {
      var then = obj2 && obj2.then;
      if (obj2 && (typeof obj2 === "object" || typeof obj2 === "function") && typeof then === "function") {
        return function appyThen() {
          then.apply(obj2, arguments);
        };
      }
    }
    function safelyResolveThenable(self2, thenable) {
      var called = false;
      function onError(value) {
        if (called) {
          return;
        }
        called = true;
        handlers.reject(self2, value);
      }
      function onSuccess(value) {
        if (called) {
          return;
        }
        called = true;
        handlers.resolve(self2, value);
      }
      function tryToUnwrap() {
        thenable(onSuccess, onError);
      }
      var result = tryCatch2(tryToUnwrap);
      if (result.status === "error") {
        onError(result.value);
      }
    }
    function tryCatch2(func, value) {
      var out = {};
      try {
        out.value = func(value);
        out.status = "success";
      } catch (e) {
        out.status = "error";
        out.value = e;
      }
      return out;
    }
    Promise2.resolve = resolve;
    function resolve(value) {
      if (value instanceof this) {
        return value;
      }
      return handlers.resolve(new this(INTERNAL), value);
    }
    Promise2.reject = reject;
    function reject(reason) {
      var promise = new this(INTERNAL);
      return handlers.reject(promise, reason);
    }
    Promise2.all = all;
    function all(iterable) {
      var self2 = this;
      if (Object.prototype.toString.call(iterable) !== "[object Array]") {
        return this.reject(new TypeError("must be an array"));
      }
      var len = iterable.length;
      var called = false;
      if (!len) {
        return this.resolve([]);
      }
      var values = new Array(len);
      var resolved = 0;
      var i = -1;
      var promise = new this(INTERNAL);
      while (++i < len) {
        allResolver(iterable[i], i);
      }
      return promise;
      function allResolver(value, i2) {
        self2.resolve(value).then(resolveFromAll, function(error) {
          if (!called) {
            called = true;
            handlers.reject(promise, error);
          }
        });
        function resolveFromAll(outValue) {
          values[i2] = outValue;
          if (++resolved === len && !called) {
            called = true;
            handlers.resolve(promise, values);
          }
        }
      }
    }
    Promise2.race = race;
    function race(iterable) {
      var self2 = this;
      if (Object.prototype.toString.call(iterable) !== "[object Array]") {
        return this.reject(new TypeError("must be an array"));
      }
      var len = iterable.length;
      var called = false;
      if (!len) {
        return this.resolve([]);
      }
      var i = -1;
      var promise = new this(INTERNAL);
      while (++i < len) {
        resolver(iterable[i]);
      }
      return promise;
      function resolver(value) {
        self2.resolve(value).then(function(response) {
          if (!called) {
            called = true;
            handlers.resolve(promise, response);
          }
        }, function(error) {
          if (!called) {
            called = true;
            handlers.reject(promise, error);
          }
        });
      }
    }
  }
});

// ../../../node_modules/jszip/lib/external.js
var require_external = __commonJS({
  "../../../node_modules/jszip/lib/external.js"(exports2, module2) {
    "use strict";
    var ES6Promise = null;
    if (typeof Promise !== "undefined") {
      ES6Promise = Promise;
    } else {
      ES6Promise = require_lib2();
    }
    module2.exports = {
      Promise: ES6Promise
    };
  }
});

// ../../../node_modules/setimmediate/setImmediate.js
var require_setImmediate = __commonJS({
  "../../../node_modules/setimmediate/setImmediate.js"(exports2) {
    (function(global2, undefined2) {
      "use strict";
      if (global2.setImmediate) {
        return;
      }
      var nextHandle = 1;
      var tasksByHandle = {};
      var currentlyRunningATask = false;
      var doc = global2.document;
      var registerImmediate;
      function setImmediate2(callback) {
        if (typeof callback !== "function") {
          callback = new Function("" + callback);
        }
        var args = new Array(arguments.length - 1);
        for (var i = 0; i < args.length; i++) {
          args[i] = arguments[i + 1];
        }
        var task = { callback, args };
        tasksByHandle[nextHandle] = task;
        registerImmediate(nextHandle);
        return nextHandle++;
      }
      function clearImmediate(handle) {
        delete tasksByHandle[handle];
      }
      function run(task) {
        var callback = task.callback;
        var args = task.args;
        switch (args.length) {
          case 0:
            callback();
            break;
          case 1:
            callback(args[0]);
            break;
          case 2:
            callback(args[0], args[1]);
            break;
          case 3:
            callback(args[0], args[1], args[2]);
            break;
          default:
            callback.apply(undefined2, args);
            break;
        }
      }
      function runIfPresent(handle) {
        if (currentlyRunningATask) {
          setTimeout(runIfPresent, 0, handle);
        } else {
          var task = tasksByHandle[handle];
          if (task) {
            currentlyRunningATask = true;
            try {
              run(task);
            } finally {
              clearImmediate(handle);
              currentlyRunningATask = false;
            }
          }
        }
      }
      function installNextTickImplementation() {
        registerImmediate = function(handle) {
          process.nextTick(function() {
            runIfPresent(handle);
          });
        };
      }
      function canUsePostMessage() {
        if (global2.postMessage && !global2.importScripts) {
          var postMessageIsAsynchronous = true;
          var oldOnMessage = global2.onmessage;
          global2.onmessage = function() {
            postMessageIsAsynchronous = false;
          };
          global2.postMessage("", "*");
          global2.onmessage = oldOnMessage;
          return postMessageIsAsynchronous;
        }
      }
      function installPostMessageImplementation() {
        var messagePrefix = "setImmediate$" + Math.random() + "$";
        var onGlobalMessage = function(event) {
          if (event.source === global2 && typeof event.data === "string" && event.data.indexOf(messagePrefix) === 0) {
            runIfPresent(+event.data.slice(messagePrefix.length));
          }
        };
        if (global2.addEventListener) {
          global2.addEventListener("message", onGlobalMessage, false);
        } else {
          global2.attachEvent("onmessage", onGlobalMessage);
        }
        registerImmediate = function(handle) {
          global2.postMessage(messagePrefix + handle, "*");
        };
      }
      function installMessageChannelImplementation() {
        var channel = new MessageChannel();
        channel.port1.onmessage = function(event) {
          var handle = event.data;
          runIfPresent(handle);
        };
        registerImmediate = function(handle) {
          channel.port2.postMessage(handle);
        };
      }
      function installReadyStateChangeImplementation() {
        var html = doc.documentElement;
        registerImmediate = function(handle) {
          var script = doc.createElement("script");
          script.onreadystatechange = function() {
            runIfPresent(handle);
            script.onreadystatechange = null;
            html.removeChild(script);
            script = null;
          };
          html.appendChild(script);
        };
      }
      function installSetTimeoutImplementation() {
        registerImmediate = function(handle) {
          setTimeout(runIfPresent, 0, handle);
        };
      }
      var attachTo = Object.getPrototypeOf && Object.getPrototypeOf(global2);
      attachTo = attachTo && attachTo.setTimeout ? attachTo : global2;
      if ({}.toString.call(global2.process) === "[object process]") {
        installNextTickImplementation();
      } else if (canUsePostMessage()) {
        installPostMessageImplementation();
      } else if (global2.MessageChannel) {
        installMessageChannelImplementation();
      } else if (doc && "onreadystatechange" in doc.createElement("script")) {
        installReadyStateChangeImplementation();
      } else {
        installSetTimeoutImplementation();
      }
      attachTo.setImmediate = setImmediate2;
      attachTo.clearImmediate = clearImmediate;
    })(typeof self === "undefined" ? typeof global === "undefined" ? exports2 : global : self);
  }
});

// ../../../node_modules/jszip/lib/utils.js
var require_utils = __commonJS({
  "../../../node_modules/jszip/lib/utils.js"(exports2) {
    "use strict";
    var support = require_support();
    var base64 = require_base64();
    var nodejsUtils = require_nodejsUtils();
    var external = require_external();
    require_setImmediate();
    function string2binary(str) {
      var result = null;
      if (support.uint8array) {
        result = new Uint8Array(str.length);
      } else {
        result = new Array(str.length);
      }
      return stringToArrayLike(str, result);
    }
    exports2.newBlob = function(part, type) {
      exports2.checkSupport("blob");
      try {
        return new Blob([part], {
          type
        });
      } catch (e) {
        try {
          var Builder = self.BlobBuilder || self.WebKitBlobBuilder || self.MozBlobBuilder || self.MSBlobBuilder;
          var builder = new Builder();
          builder.append(part);
          return builder.getBlob(type);
        } catch (e2) {
          throw new Error("Bug : can't construct the Blob.");
        }
      }
    };
    function identity(input) {
      return input;
    }
    function stringToArrayLike(str, array) {
      for (var i = 0; i < str.length; ++i) {
        array[i] = str.charCodeAt(i) & 255;
      }
      return array;
    }
    var arrayToStringHelper = {
      /**
       * Transform an array of int into a string, chunk by chunk.
       * See the performances notes on arrayLikeToString.
       * @param {Array|ArrayBuffer|Uint8Array|Buffer} array the array to transform.
       * @param {String} type the type of the array.
       * @param {Integer} chunk the chunk size.
       * @return {String} the resulting string.
       * @throws Error if the chunk is too big for the stack.
       */
      stringifyByChunk: function(array, type, chunk) {
        var result = [], k = 0, len = array.length;
        if (len <= chunk) {
          return String.fromCharCode.apply(null, array);
        }
        while (k < len) {
          if (type === "array" || type === "nodebuffer") {
            result.push(String.fromCharCode.apply(null, array.slice(k, Math.min(k + chunk, len))));
          } else {
            result.push(String.fromCharCode.apply(null, array.subarray(k, Math.min(k + chunk, len))));
          }
          k += chunk;
        }
        return result.join("");
      },
      /**
       * Call String.fromCharCode on every item in the array.
       * This is the naive implementation, which generate A LOT of intermediate string.
       * This should be used when everything else fail.
       * @param {Array|ArrayBuffer|Uint8Array|Buffer} array the array to transform.
       * @return {String} the result.
       */
      stringifyByChar: function(array) {
        var resultStr = "";
        for (var i = 0; i < array.length; i++) {
          resultStr += String.fromCharCode(array[i]);
        }
        return resultStr;
      },
      applyCanBeUsed: {
        /**
         * true if the browser accepts to use String.fromCharCode on Uint8Array
         */
        uint8array: function() {
          try {
            return support.uint8array && String.fromCharCode.apply(null, new Uint8Array(1)).length === 1;
          } catch (e) {
            return false;
          }
        }(),
        /**
         * true if the browser accepts to use String.fromCharCode on nodejs Buffer.
         */
        nodebuffer: function() {
          try {
            return support.nodebuffer && String.fromCharCode.apply(null, nodejsUtils.allocBuffer(1)).length === 1;
          } catch (e) {
            return false;
          }
        }()
      }
    };
    function arrayLikeToString(array) {
      var chunk = 65536, type = exports2.getTypeOf(array), canUseApply = true;
      if (type === "uint8array") {
        canUseApply = arrayToStringHelper.applyCanBeUsed.uint8array;
      } else if (type === "nodebuffer") {
        canUseApply = arrayToStringHelper.applyCanBeUsed.nodebuffer;
      }
      if (canUseApply) {
        while (chunk > 1) {
          try {
            return arrayToStringHelper.stringifyByChunk(array, type, chunk);
          } catch (e) {
            chunk = Math.floor(chunk / 2);
          }
        }
      }
      return arrayToStringHelper.stringifyByChar(array);
    }
    exports2.applyFromCharCode = arrayLikeToString;
    function arrayLikeToArrayLike(arrayFrom, arrayTo) {
      for (var i = 0; i < arrayFrom.length; i++) {
        arrayTo[i] = arrayFrom[i];
      }
      return arrayTo;
    }
    var transform = {};
    transform["string"] = {
      "string": identity,
      "array": function(input) {
        return stringToArrayLike(input, new Array(input.length));
      },
      "arraybuffer": function(input) {
        return transform["string"]["uint8array"](input).buffer;
      },
      "uint8array": function(input) {
        return stringToArrayLike(input, new Uint8Array(input.length));
      },
      "nodebuffer": function(input) {
        return stringToArrayLike(input, nodejsUtils.allocBuffer(input.length));
      }
    };
    transform["array"] = {
      "string": arrayLikeToString,
      "array": identity,
      "arraybuffer": function(input) {
        return new Uint8Array(input).buffer;
      },
      "uint8array": function(input) {
        return new Uint8Array(input);
      },
      "nodebuffer": function(input) {
        return nodejsUtils.newBufferFrom(input);
      }
    };
    transform["arraybuffer"] = {
      "string": function(input) {
        return arrayLikeToString(new Uint8Array(input));
      },
      "array": function(input) {
        return arrayLikeToArrayLike(new Uint8Array(input), new Array(input.byteLength));
      },
      "arraybuffer": identity,
      "uint8array": function(input) {
        return new Uint8Array(input);
      },
      "nodebuffer": function(input) {
        return nodejsUtils.newBufferFrom(new Uint8Array(input));
      }
    };
    transform["uint8array"] = {
      "string": arrayLikeToString,
      "array": function(input) {
        return arrayLikeToArrayLike(input, new Array(input.length));
      },
      "arraybuffer": function(input) {
        return input.buffer;
      },
      "uint8array": identity,
      "nodebuffer": function(input) {
        return nodejsUtils.newBufferFrom(input);
      }
    };
    transform["nodebuffer"] = {
      "string": arrayLikeToString,
      "array": function(input) {
        return arrayLikeToArrayLike(input, new Array(input.length));
      },
      "arraybuffer": function(input) {
        return transform["nodebuffer"]["uint8array"](input).buffer;
      },
      "uint8array": function(input) {
        return arrayLikeToArrayLike(input, new Uint8Array(input.length));
      },
      "nodebuffer": identity
    };
    exports2.transformTo = function(outputType, input) {
      if (!input) {
        input = "";
      }
      if (!outputType) {
        return input;
      }
      exports2.checkSupport(outputType);
      var inputType = exports2.getTypeOf(input);
      var result = transform[inputType][outputType](input);
      return result;
    };
    exports2.resolve = function(path) {
      var parts = path.split("/");
      var result = [];
      for (var index = 0; index < parts.length; index++) {
        var part = parts[index];
        if (part === "." || part === "" && index !== 0 && index !== parts.length - 1) {
          continue;
        } else if (part === "..") {
          result.pop();
        } else {
          result.push(part);
        }
      }
      return result.join("/");
    };
    exports2.getTypeOf = function(input) {
      if (typeof input === "string") {
        return "string";
      }
      if (Object.prototype.toString.call(input) === "[object Array]") {
        return "array";
      }
      if (support.nodebuffer && nodejsUtils.isBuffer(input)) {
        return "nodebuffer";
      }
      if (support.uint8array && input instanceof Uint8Array) {
        return "uint8array";
      }
      if (support.arraybuffer && input instanceof ArrayBuffer) {
        return "arraybuffer";
      }
    };
    exports2.checkSupport = function(type) {
      var supported = support[type.toLowerCase()];
      if (!supported) {
        throw new Error(type + " is not supported by this platform");
      }
    };
    exports2.MAX_VALUE_16BITS = 65535;
    exports2.MAX_VALUE_32BITS = -1;
    exports2.pretty = function(str) {
      var res = "", code, i;
      for (i = 0; i < (str || "").length; i++) {
        code = str.charCodeAt(i);
        res += "\\x" + (code < 16 ? "0" : "") + code.toString(16).toUpperCase();
      }
      return res;
    };
    exports2.delay = function(callback, args, self2) {
      setImmediate(function() {
        callback.apply(self2 || null, args || []);
      });
    };
    exports2.inherits = function(ctor, superCtor) {
      var Obj = function() {
      };
      Obj.prototype = superCtor.prototype;
      ctor.prototype = new Obj();
    };
    exports2.extend = function() {
      var result = {}, i, attr;
      for (i = 0; i < arguments.length; i++) {
        for (attr in arguments[i]) {
          if (Object.prototype.hasOwnProperty.call(arguments[i], attr) && typeof result[attr] === "undefined") {
            result[attr] = arguments[i][attr];
          }
        }
      }
      return result;
    };
    exports2.prepareContent = function(name, inputData, isBinary, isOptimizedBinaryString, isBase64) {
      var promise = external.Promise.resolve(inputData).then(function(data) {
        var isBlob = support.blob && (data instanceof Blob || ["[object File]", "[object Blob]"].indexOf(Object.prototype.toString.call(data)) !== -1);
        if (isBlob && typeof FileReader !== "undefined") {
          return new external.Promise(function(resolve, reject) {
            var reader = new FileReader();
            reader.onload = function(e) {
              resolve(e.target.result);
            };
            reader.onerror = function(e) {
              reject(e.target.error);
            };
            reader.readAsArrayBuffer(data);
          });
        } else {
          return data;
        }
      });
      return promise.then(function(data) {
        var dataType = exports2.getTypeOf(data);
        if (!dataType) {
          return external.Promise.reject(
            new Error("Can't read the data of '" + name + "'. Is it in a supported JavaScript type (String, Blob, ArrayBuffer, etc) ?")
          );
        }
        if (dataType === "arraybuffer") {
          data = exports2.transformTo("uint8array", data);
        } else if (dataType === "string") {
          if (isBase64) {
            data = base64.decode(data);
          } else if (isBinary) {
            if (isOptimizedBinaryString !== true) {
              data = string2binary(data);
            }
          }
        }
        return data;
      });
    };
  }
});

// ../../../node_modules/jszip/lib/stream/GenericWorker.js
var require_GenericWorker = __commonJS({
  "../../../node_modules/jszip/lib/stream/GenericWorker.js"(exports2, module2) {
    "use strict";
    function GenericWorker(name) {
      this.name = name || "default";
      this.streamInfo = {};
      this.generatedError = null;
      this.extraStreamInfo = {};
      this.isPaused = true;
      this.isFinished = false;
      this.isLocked = false;
      this._listeners = {
        "data": [],
        "end": [],
        "error": []
      };
      this.previous = null;
    }
    GenericWorker.prototype = {
      /**
       * Push a chunk to the next workers.
       * @param {Object} chunk the chunk to push
       */
      push: function(chunk) {
        this.emit("data", chunk);
      },
      /**
       * End the stream.
       * @return {Boolean} true if this call ended the worker, false otherwise.
       */
      end: function() {
        if (this.isFinished) {
          return false;
        }
        this.flush();
        try {
          this.emit("end");
          this.cleanUp();
          this.isFinished = true;
        } catch (e) {
          this.emit("error", e);
        }
        return true;
      },
      /**
       * End the stream with an error.
       * @param {Error} e the error which caused the premature end.
       * @return {Boolean} true if this call ended the worker with an error, false otherwise.
       */
      error: function(e) {
        if (this.isFinished) {
          return false;
        }
        if (this.isPaused) {
          this.generatedError = e;
        } else {
          this.isFinished = true;
          this.emit("error", e);
          if (this.previous) {
            this.previous.error(e);
          }
          this.cleanUp();
        }
        return true;
      },
      /**
       * Add a callback on an event.
       * @param {String} name the name of the event (data, end, error)
       * @param {Function} listener the function to call when the event is triggered
       * @return {GenericWorker} the current object for chainability
       */
      on: function(name, listener) {
        this._listeners[name].push(listener);
        return this;
      },
      /**
       * Clean any references when a worker is ending.
       */
      cleanUp: function() {
        this.streamInfo = this.generatedError = this.extraStreamInfo = null;
        this._listeners = [];
      },
      /**
       * Trigger an event. This will call registered callback with the provided arg.
       * @param {String} name the name of the event (data, end, error)
       * @param {Object} arg the argument to call the callback with.
       */
      emit: function(name, arg) {
        if (this._listeners[name]) {
          for (var i = 0; i < this._listeners[name].length; i++) {
            this._listeners[name][i].call(this, arg);
          }
        }
      },
      /**
       * Chain a worker with an other.
       * @param {Worker} next the worker receiving events from the current one.
       * @return {worker} the next worker for chainability
       */
      pipe: function(next) {
        return next.registerPrevious(this);
      },
      /**
       * Same as `pipe` in the other direction.
       * Using an API with `pipe(next)` is very easy.
       * Implementing the API with the point of view of the next one registering
       * a source is easier, see the ZipFileWorker.
       * @param {Worker} previous the previous worker, sending events to this one
       * @return {Worker} the current worker for chainability
       */
      registerPrevious: function(previous) {
        if (this.isLocked) {
          throw new Error("The stream '" + this + "' has already been used.");
        }
        this.streamInfo = previous.streamInfo;
        this.mergeStreamInfo();
        this.previous = previous;
        var self2 = this;
        previous.on("data", function(chunk) {
          self2.processChunk(chunk);
        });
        previous.on("end", function() {
          self2.end();
        });
        previous.on("error", function(e) {
          self2.error(e);
        });
        return this;
      },
      /**
       * Pause the stream so it doesn't send events anymore.
       * @return {Boolean} true if this call paused the worker, false otherwise.
       */
      pause: function() {
        if (this.isPaused || this.isFinished) {
          return false;
        }
        this.isPaused = true;
        if (this.previous) {
          this.previous.pause();
        }
        return true;
      },
      /**
       * Resume a paused stream.
       * @return {Boolean} true if this call resumed the worker, false otherwise.
       */
      resume: function() {
        if (!this.isPaused || this.isFinished) {
          return false;
        }
        this.isPaused = false;
        var withError = false;
        if (this.generatedError) {
          this.error(this.generatedError);
          withError = true;
        }
        if (this.previous) {
          this.previous.resume();
        }
        return !withError;
      },
      /**
       * Flush any remaining bytes as the stream is ending.
       */
      flush: function() {
      },
      /**
       * Process a chunk. This is usually the method overridden.
       * @param {Object} chunk the chunk to process.
       */
      processChunk: function(chunk) {
        this.push(chunk);
      },
      /**
       * Add a key/value to be added in the workers chain streamInfo once activated.
       * @param {String} key the key to use
       * @param {Object} value the associated value
       * @return {Worker} the current worker for chainability
       */
      withStreamInfo: function(key, value) {
        this.extraStreamInfo[key] = value;
        this.mergeStreamInfo();
        return this;
      },
      /**
       * Merge this worker's streamInfo into the chain's streamInfo.
       */
      mergeStreamInfo: function() {
        for (var key in this.extraStreamInfo) {
          if (!Object.prototype.hasOwnProperty.call(this.extraStreamInfo, key)) {
            continue;
          }
          this.streamInfo[key] = this.extraStreamInfo[key];
        }
      },
      /**
       * Lock the stream to prevent further updates on the workers chain.
       * After calling this method, all calls to pipe will fail.
       */
      lock: function() {
        if (this.isLocked) {
          throw new Error("The stream '" + this + "' has already been used.");
        }
        this.isLocked = true;
        if (this.previous) {
          this.previous.lock();
        }
      },
      /**
       *
       * Pretty print the workers chain.
       */
      toString: function() {
        var me = "Worker " + this.name;
        if (this.previous) {
          return this.previous + " -> " + me;
        } else {
          return me;
        }
      }
    };
    module2.exports = GenericWorker;
  }
});

// ../../../node_modules/jszip/lib/utf8.js
var require_utf8 = __commonJS({
  "../../../node_modules/jszip/lib/utf8.js"(exports2) {
    "use strict";
    var utils = require_utils();
    var support = require_support();
    var nodejsUtils = require_nodejsUtils();
    var GenericWorker = require_GenericWorker();
    var _utf8len = new Array(256);
    for (i = 0; i < 256; i++) {
      _utf8len[i] = i >= 252 ? 6 : i >= 248 ? 5 : i >= 240 ? 4 : i >= 224 ? 3 : i >= 192 ? 2 : 1;
    }
    var i;
    _utf8len[254] = _utf8len[254] = 1;
    var string2buf = function(str) {
      var buf, c, c2, m_pos, i2, str_len = str.length, buf_len = 0;
      for (m_pos = 0; m_pos < str_len; m_pos++) {
        c = str.charCodeAt(m_pos);
        if ((c & 64512) === 55296 && m_pos + 1 < str_len) {
          c2 = str.charCodeAt(m_pos + 1);
          if ((c2 & 64512) === 56320) {
            c = 65536 + (c - 55296 << 10) + (c2 - 56320);
            m_pos++;
          }
        }
        buf_len += c < 128 ? 1 : c < 2048 ? 2 : c < 65536 ? 3 : 4;
      }
      if (support.uint8array) {
        buf = new Uint8Array(buf_len);
      } else {
        buf = new Array(buf_len);
      }
      for (i2 = 0, m_pos = 0; i2 < buf_len; m_pos++) {
        c = str.charCodeAt(m_pos);
        if ((c & 64512) === 55296 && m_pos + 1 < str_len) {
          c2 = str.charCodeAt(m_pos + 1);
          if ((c2 & 64512) === 56320) {
            c = 65536 + (c - 55296 << 10) + (c2 - 56320);
            m_pos++;
          }
        }
        if (c < 128) {
          buf[i2++] = c;
        } else if (c < 2048) {
          buf[i2++] = 192 | c >>> 6;
          buf[i2++] = 128 | c & 63;
        } else if (c < 65536) {
          buf[i2++] = 224 | c >>> 12;
          buf[i2++] = 128 | c >>> 6 & 63;
          buf[i2++] = 128 | c & 63;
        } else {
          buf[i2++] = 240 | c >>> 18;
          buf[i2++] = 128 | c >>> 12 & 63;
          buf[i2++] = 128 | c >>> 6 & 63;
          buf[i2++] = 128 | c & 63;
        }
      }
      return buf;
    };
    var utf8border = function(buf, max) {
      var pos;
      max = max || buf.length;
      if (max > buf.length) {
        max = buf.length;
      }
      pos = max - 1;
      while (pos >= 0 && (buf[pos] & 192) === 128) {
        pos--;
      }
      if (pos < 0) {
        return max;
      }
      if (pos === 0) {
        return max;
      }
      return pos + _utf8len[buf[pos]] > max ? pos : max;
    };
    var buf2string = function(buf) {
      var i2, out, c, c_len;
      var len = buf.length;
      var utf16buf = new Array(len * 2);
      for (out = 0, i2 = 0; i2 < len; ) {
        c = buf[i2++];
        if (c < 128) {
          utf16buf[out++] = c;
          continue;
        }
        c_len = _utf8len[c];
        if (c_len > 4) {
          utf16buf[out++] = 65533;
          i2 += c_len - 1;
          continue;
        }
        c &= c_len === 2 ? 31 : c_len === 3 ? 15 : 7;
        while (c_len > 1 && i2 < len) {
          c = c << 6 | buf[i2++] & 63;
          c_len--;
        }
        if (c_len > 1) {
          utf16buf[out++] = 65533;
          continue;
        }
        if (c < 65536) {
          utf16buf[out++] = c;
        } else {
          c -= 65536;
          utf16buf[out++] = 55296 | c >> 10 & 1023;
          utf16buf[out++] = 56320 | c & 1023;
        }
      }
      if (utf16buf.length !== out) {
        if (utf16buf.subarray) {
          utf16buf = utf16buf.subarray(0, out);
        } else {
          utf16buf.length = out;
        }
      }
      return utils.applyFromCharCode(utf16buf);
    };
    exports2.utf8encode = function utf8encode(str) {
      if (support.nodebuffer) {
        return nodejsUtils.newBufferFrom(str, "utf-8");
      }
      return string2buf(str);
    };
    exports2.utf8decode = function utf8decode(buf) {
      if (support.nodebuffer) {
        return utils.transformTo("nodebuffer", buf).toString("utf-8");
      }
      buf = utils.transformTo(support.uint8array ? "uint8array" : "array", buf);
      return buf2string(buf);
    };
    function Utf8DecodeWorker() {
      GenericWorker.call(this, "utf-8 decode");
      this.leftOver = null;
    }
    utils.inherits(Utf8DecodeWorker, GenericWorker);
    Utf8DecodeWorker.prototype.processChunk = function(chunk) {
      var data = utils.transformTo(support.uint8array ? "uint8array" : "array", chunk.data);
      if (this.leftOver && this.leftOver.length) {
        if (support.uint8array) {
          var previousData = data;
          data = new Uint8Array(previousData.length + this.leftOver.length);
          data.set(this.leftOver, 0);
          data.set(previousData, this.leftOver.length);
        } else {
          data = this.leftOver.concat(data);
        }
        this.leftOver = null;
      }
      var nextBoundary = utf8border(data);
      var usableData = data;
      if (nextBoundary !== data.length) {
        if (support.uint8array) {
          usableData = data.subarray(0, nextBoundary);
          this.leftOver = data.subarray(nextBoundary, data.length);
        } else {
          usableData = data.slice(0, nextBoundary);
          this.leftOver = data.slice(nextBoundary, data.length);
        }
      }
      this.push({
        data: exports2.utf8decode(usableData),
        meta: chunk.meta
      });
    };
    Utf8DecodeWorker.prototype.flush = function() {
      if (this.leftOver && this.leftOver.length) {
        this.push({
          data: exports2.utf8decode(this.leftOver),
          meta: {}
        });
        this.leftOver = null;
      }
    };
    exports2.Utf8DecodeWorker = Utf8DecodeWorker;
    function Utf8EncodeWorker() {
      GenericWorker.call(this, "utf-8 encode");
    }
    utils.inherits(Utf8EncodeWorker, GenericWorker);
    Utf8EncodeWorker.prototype.processChunk = function(chunk) {
      this.push({
        data: exports2.utf8encode(chunk.data),
        meta: chunk.meta
      });
    };
    exports2.Utf8EncodeWorker = Utf8EncodeWorker;
  }
});

// ../../../node_modules/jszip/lib/stream/ConvertWorker.js
var require_ConvertWorker = __commonJS({
  "../../../node_modules/jszip/lib/stream/ConvertWorker.js"(exports2, module2) {
    "use strict";
    var GenericWorker = require_GenericWorker();
    var utils = require_utils();
    function ConvertWorker(destType) {
      GenericWorker.call(this, "ConvertWorker to " + destType);
      this.destType = destType;
    }
    utils.inherits(ConvertWorker, GenericWorker);
    ConvertWorker.prototype.processChunk = function(chunk) {
      this.push({
        data: utils.transformTo(this.destType, chunk.data),
        meta: chunk.meta
      });
    };
    module2.exports = ConvertWorker;
  }
});

// ../../../node_modules/jszip/lib/nodejs/NodejsStreamOutputAdapter.js
var require_NodejsStreamOutputAdapter = __commonJS({
  "../../../node_modules/jszip/lib/nodejs/NodejsStreamOutputAdapter.js"(exports2, module2) {
    "use strict";
    var Readable = require_readable().Readable;
    var utils = require_utils();
    utils.inherits(NodejsStreamOutputAdapter, Readable);
    function NodejsStreamOutputAdapter(helper, options, updateCb) {
      Readable.call(this, options);
      this._helper = helper;
      var self2 = this;
      helper.on("data", function(data, meta) {
        if (!self2.push(data)) {
          self2._helper.pause();
        }
        if (updateCb) {
          updateCb(meta);
        }
      }).on("error", function(e) {
        self2.emit("error", e);
      }).on("end", function() {
        self2.push(null);
      });
    }
    NodejsStreamOutputAdapter.prototype._read = function() {
      this._helper.resume();
    };
    module2.exports = NodejsStreamOutputAdapter;
  }
});

// ../../../node_modules/jszip/lib/stream/StreamHelper.js
var require_StreamHelper = __commonJS({
  "../../../node_modules/jszip/lib/stream/StreamHelper.js"(exports2, module2) {
    "use strict";
    var utils = require_utils();
    var ConvertWorker = require_ConvertWorker();
    var GenericWorker = require_GenericWorker();
    var base64 = require_base64();
    var support = require_support();
    var external = require_external();
    var NodejsStreamOutputAdapter = null;
    if (support.nodestream) {
      try {
        NodejsStreamOutputAdapter = require_NodejsStreamOutputAdapter();
      } catch (e) {
      }
    }
    function transformZipOutput(type, content, mimeType) {
      switch (type) {
        case "blob":
          return utils.newBlob(utils.transformTo("arraybuffer", content), mimeType);
        case "base64":
          return base64.encode(content);
        default:
          return utils.transformTo(type, content);
      }
    }
    function concat(type, dataArray) {
      var i, index = 0, res = null, totalLength = 0;
      for (i = 0; i < dataArray.length; i++) {
        totalLength += dataArray[i].length;
      }
      switch (type) {
        case "string":
          return dataArray.join("");
        case "array":
          return Array.prototype.concat.apply([], dataArray);
        case "uint8array":
          res = new Uint8Array(totalLength);
          for (i = 0; i < dataArray.length; i++) {
            res.set(dataArray[i], index);
            index += dataArray[i].length;
          }
          return res;
        case "nodebuffer":
          return Buffer.concat(dataArray);
        default:
          throw new Error("concat : unsupported type '" + type + "'");
      }
    }
    function accumulate(helper, updateCallback) {
      return new external.Promise(function(resolve, reject) {
        var dataArray = [];
        var chunkType = helper._internalType, resultType = helper._outputType, mimeType = helper._mimeType;
        helper.on("data", function(data, meta) {
          dataArray.push(data);
          if (updateCallback) {
            updateCallback(meta);
          }
        }).on("error", function(err) {
          dataArray = [];
          reject(err);
        }).on("end", function() {
          try {
            var result = transformZipOutput(resultType, concat(chunkType, dataArray), mimeType);
            resolve(result);
          } catch (e) {
            reject(e);
          }
          dataArray = [];
        }).resume();
      });
    }
    function StreamHelper(worker, outputType, mimeType) {
      var internalType = outputType;
      switch (outputType) {
        case "blob":
        case "arraybuffer":
          internalType = "uint8array";
          break;
        case "base64":
          internalType = "string";
          break;
      }
      try {
        this._internalType = internalType;
        this._outputType = outputType;
        this._mimeType = mimeType;
        utils.checkSupport(internalType);
        this._worker = worker.pipe(new ConvertWorker(internalType));
        worker.lock();
      } catch (e) {
        this._worker = new GenericWorker("error");
        this._worker.error(e);
      }
    }
    StreamHelper.prototype = {
      /**
       * Listen a StreamHelper, accumulate its content and concatenate it into a
       * complete block.
       * @param {Function} updateCb the update callback.
       * @return Promise the promise for the accumulation.
       */
      accumulate: function(updateCb) {
        return accumulate(this, updateCb);
      },
      /**
       * Add a listener on an event triggered on a stream.
       * @param {String} evt the name of the event
       * @param {Function} fn the listener
       * @return {StreamHelper} the current helper.
       */
      on: function(evt, fn) {
        var self2 = this;
        if (evt === "data") {
          this._worker.on(evt, function(chunk) {
            fn.call(self2, chunk.data, chunk.meta);
          });
        } else {
          this._worker.on(evt, function() {
            utils.delay(fn, arguments, self2);
          });
        }
        return this;
      },
      /**
       * Resume the flow of chunks.
       * @return {StreamHelper} the current helper.
       */
      resume: function() {
        utils.delay(this._worker.resume, [], this._worker);
        return this;
      },
      /**
       * Pause the flow of chunks.
       * @return {StreamHelper} the current helper.
       */
      pause: function() {
        this._worker.pause();
        return this;
      },
      /**
       * Return a nodejs stream for this helper.
       * @param {Function} updateCb the update callback.
       * @return {NodejsStreamOutputAdapter} the nodejs stream.
       */
      toNodejsStream: function(updateCb) {
        utils.checkSupport("nodestream");
        if (this._outputType !== "nodebuffer") {
          throw new Error(this._outputType + " is not supported by this method");
        }
        return new NodejsStreamOutputAdapter(this, {
          objectMode: this._outputType !== "nodebuffer"
        }, updateCb);
      }
    };
    module2.exports = StreamHelper;
  }
});

// ../../../node_modules/jszip/lib/defaults.js
var require_defaults = __commonJS({
  "../../../node_modules/jszip/lib/defaults.js"(exports2) {
    "use strict";
    exports2.base64 = false;
    exports2.binary = false;
    exports2.dir = false;
    exports2.createFolders = true;
    exports2.date = null;
    exports2.compression = null;
    exports2.compressionOptions = null;
    exports2.comment = null;
    exports2.unixPermissions = null;
    exports2.dosPermissions = null;
  }
});

// ../../../node_modules/jszip/lib/stream/DataWorker.js
var require_DataWorker = __commonJS({
  "../../../node_modules/jszip/lib/stream/DataWorker.js"(exports2, module2) {
    "use strict";
    var utils = require_utils();
    var GenericWorker = require_GenericWorker();
    var DEFAULT_BLOCK_SIZE = 16 * 1024;
    function DataWorker(dataP) {
      GenericWorker.call(this, "DataWorker");
      var self2 = this;
      this.dataIsReady = false;
      this.index = 0;
      this.max = 0;
      this.data = null;
      this.type = "";
      this._tickScheduled = false;
      dataP.then(function(data) {
        self2.dataIsReady = true;
        self2.data = data;
        self2.max = data && data.length || 0;
        self2.type = utils.getTypeOf(data);
        if (!self2.isPaused) {
          self2._tickAndRepeat();
        }
      }, function(e) {
        self2.error(e);
      });
    }
    utils.inherits(DataWorker, GenericWorker);
    DataWorker.prototype.cleanUp = function() {
      GenericWorker.prototype.cleanUp.call(this);
      this.data = null;
    };
    DataWorker.prototype.resume = function() {
      if (!GenericWorker.prototype.resume.call(this)) {
        return false;
      }
      if (!this._tickScheduled && this.dataIsReady) {
        this._tickScheduled = true;
        utils.delay(this._tickAndRepeat, [], this);
      }
      return true;
    };
    DataWorker.prototype._tickAndRepeat = function() {
      this._tickScheduled = false;
      if (this.isPaused || this.isFinished) {
        return;
      }
      this._tick();
      if (!this.isFinished) {
        utils.delay(this._tickAndRepeat, [], this);
        this._tickScheduled = true;
      }
    };
    DataWorker.prototype._tick = function() {
      if (this.isPaused || this.isFinished) {
        return false;
      }
      var size = DEFAULT_BLOCK_SIZE;
      var data = null, nextIndex = Math.min(this.max, this.index + size);
      if (this.index >= this.max) {
        return this.end();
      } else {
        switch (this.type) {
          case "string":
            data = this.data.substring(this.index, nextIndex);
            break;
          case "uint8array":
            data = this.data.subarray(this.index, nextIndex);
            break;
          case "array":
          case "nodebuffer":
            data = this.data.slice(this.index, nextIndex);
            break;
        }
        this.index = nextIndex;
        return this.push({
          data,
          meta: {
            percent: this.max ? this.index / this.max * 100 : 0
          }
        });
      }
    };
    module2.exports = DataWorker;
  }
});

// ../../../node_modules/jszip/lib/crc32.js
var require_crc32 = __commonJS({
  "../../../node_modules/jszip/lib/crc32.js"(exports2, module2) {
    "use strict";
    var utils = require_utils();
    function makeTable() {
      var c, table = [];
      for (var n = 0; n < 256; n++) {
        c = n;
        for (var k = 0; k < 8; k++) {
          c = c & 1 ? 3988292384 ^ c >>> 1 : c >>> 1;
        }
        table[n] = c;
      }
      return table;
    }
    var crcTable = makeTable();
    function crc32(crc, buf, len, pos) {
      var t = crcTable, end = pos + len;
      crc = crc ^ -1;
      for (var i = pos; i < end; i++) {
        crc = crc >>> 8 ^ t[(crc ^ buf[i]) & 255];
      }
      return crc ^ -1;
    }
    function crc32str(crc, str, len, pos) {
      var t = crcTable, end = pos + len;
      crc = crc ^ -1;
      for (var i = pos; i < end; i++) {
        crc = crc >>> 8 ^ t[(crc ^ str.charCodeAt(i)) & 255];
      }
      return crc ^ -1;
    }
    module2.exports = function crc32wrapper(input, crc) {
      if (typeof input === "undefined" || !input.length) {
        return 0;
      }
      var isArray = utils.getTypeOf(input) !== "string";
      if (isArray) {
        return crc32(crc | 0, input, input.length, 0);
      } else {
        return crc32str(crc | 0, input, input.length, 0);
      }
    };
  }
});

// ../../../node_modules/jszip/lib/stream/Crc32Probe.js
var require_Crc32Probe = __commonJS({
  "../../../node_modules/jszip/lib/stream/Crc32Probe.js"(exports2, module2) {
    "use strict";
    var GenericWorker = require_GenericWorker();
    var crc32 = require_crc32();
    var utils = require_utils();
    function Crc32Probe() {
      GenericWorker.call(this, "Crc32Probe");
      this.withStreamInfo("crc32", 0);
    }
    utils.inherits(Crc32Probe, GenericWorker);
    Crc32Probe.prototype.processChunk = function(chunk) {
      this.streamInfo.crc32 = crc32(chunk.data, this.streamInfo.crc32 || 0);
      this.push(chunk);
    };
    module2.exports = Crc32Probe;
  }
});

// ../../../node_modules/jszip/lib/stream/DataLengthProbe.js
var require_DataLengthProbe = __commonJS({
  "../../../node_modules/jszip/lib/stream/DataLengthProbe.js"(exports2, module2) {
    "use strict";
    var utils = require_utils();
    var GenericWorker = require_GenericWorker();
    function DataLengthProbe(propName) {
      GenericWorker.call(this, "DataLengthProbe for " + propName);
      this.propName = propName;
      this.withStreamInfo(propName, 0);
    }
    utils.inherits(DataLengthProbe, GenericWorker);
    DataLengthProbe.prototype.processChunk = function(chunk) {
      if (chunk) {
        var length = this.streamInfo[this.propName] || 0;
        this.streamInfo[this.propName] = length + chunk.data.length;
      }
      GenericWorker.prototype.processChunk.call(this, chunk);
    };
    module2.exports = DataLengthProbe;
  }
});

// ../../../node_modules/jszip/lib/compressedObject.js
var require_compressedObject = __commonJS({
  "../../../node_modules/jszip/lib/compressedObject.js"(exports2, module2) {
    "use strict";
    var external = require_external();
    var DataWorker = require_DataWorker();
    var Crc32Probe = require_Crc32Probe();
    var DataLengthProbe = require_DataLengthProbe();
    function CompressedObject(compressedSize, uncompressedSize, crc32, compression, data) {
      this.compressedSize = compressedSize;
      this.uncompressedSize = uncompressedSize;
      this.crc32 = crc32;
      this.compression = compression;
      this.compressedContent = data;
    }
    CompressedObject.prototype = {
      /**
       * Create a worker to get the uncompressed content.
       * @return {GenericWorker} the worker.
       */
      getContentWorker: function() {
        var worker = new DataWorker(external.Promise.resolve(this.compressedContent)).pipe(this.compression.uncompressWorker()).pipe(new DataLengthProbe("data_length"));
        var that = this;
        worker.on("end", function() {
          if (this.streamInfo["data_length"] !== that.uncompressedSize) {
            throw new Error("Bug : uncompressed data size mismatch");
          }
        });
        return worker;
      },
      /**
       * Create a worker to get the compressed content.
       * @return {GenericWorker} the worker.
       */
      getCompressedWorker: function() {
        return new DataWorker(external.Promise.resolve(this.compressedContent)).withStreamInfo("compressedSize", this.compressedSize).withStreamInfo("uncompressedSize", this.uncompressedSize).withStreamInfo("crc32", this.crc32).withStreamInfo("compression", this.compression);
      }
    };
    CompressedObject.createWorkerFrom = function(uncompressedWorker, compression, compressionOptions) {
      return uncompressedWorker.pipe(new Crc32Probe()).pipe(new DataLengthProbe("uncompressedSize")).pipe(compression.compressWorker(compressionOptions)).pipe(new DataLengthProbe("compressedSize")).withStreamInfo("compression", compression);
    };
    module2.exports = CompressedObject;
  }
});

// ../../../node_modules/jszip/lib/zipObject.js
var require_zipObject = __commonJS({
  "../../../node_modules/jszip/lib/zipObject.js"(exports2, module2) {
    "use strict";
    var StreamHelper = require_StreamHelper();
    var DataWorker = require_DataWorker();
    var utf8 = require_utf8();
    var CompressedObject = require_compressedObject();
    var GenericWorker = require_GenericWorker();
    var ZipObject = function(name, data, options) {
      this.name = name;
      this.dir = options.dir;
      this.date = options.date;
      this.comment = options.comment;
      this.unixPermissions = options.unixPermissions;
      this.dosPermissions = options.dosPermissions;
      this._data = data;
      this._dataBinary = options.binary;
      this.options = {
        compression: options.compression,
        compressionOptions: options.compressionOptions
      };
    };
    ZipObject.prototype = {
      /**
       * Create an internal stream for the content of this object.
       * @param {String} type the type of each chunk.
       * @return StreamHelper the stream.
       */
      internalStream: function(type) {
        var result = null, outputType = "string";
        try {
          if (!type) {
            throw new Error("No output type specified.");
          }
          outputType = type.toLowerCase();
          var askUnicodeString = outputType === "string" || outputType === "text";
          if (outputType === "binarystring" || outputType === "text") {
            outputType = "string";
          }
          result = this._decompressWorker();
          var isUnicodeString = !this._dataBinary;
          if (isUnicodeString && !askUnicodeString) {
            result = result.pipe(new utf8.Utf8EncodeWorker());
          }
          if (!isUnicodeString && askUnicodeString) {
            result = result.pipe(new utf8.Utf8DecodeWorker());
          }
        } catch (e) {
          result = new GenericWorker("error");
          result.error(e);
        }
        return new StreamHelper(result, outputType, "");
      },
      /**
       * Prepare the content in the asked type.
       * @param {String} type the type of the result.
       * @param {Function} onUpdate a function to call on each internal update.
       * @return Promise the promise of the result.
       */
      async: function(type, onUpdate) {
        return this.internalStream(type).accumulate(onUpdate);
      },
      /**
       * Prepare the content as a nodejs stream.
       * @param {String} type the type of each chunk.
       * @param {Function} onUpdate a function to call on each internal update.
       * @return Stream the stream.
       */
      nodeStream: function(type, onUpdate) {
        return this.internalStream(type || "nodebuffer").toNodejsStream(onUpdate);
      },
      /**
       * Return a worker for the compressed content.
       * @private
       * @param {Object} compression the compression object to use.
       * @param {Object} compressionOptions the options to use when compressing.
       * @return Worker the worker.
       */
      _compressWorker: function(compression, compressionOptions) {
        if (this._data instanceof CompressedObject && this._data.compression.magic === compression.magic) {
          return this._data.getCompressedWorker();
        } else {
          var result = this._decompressWorker();
          if (!this._dataBinary) {
            result = result.pipe(new utf8.Utf8EncodeWorker());
          }
          return CompressedObject.createWorkerFrom(result, compression, compressionOptions);
        }
      },
      /**
       * Return a worker for the decompressed content.
       * @private
       * @return Worker the worker.
       */
      _decompressWorker: function() {
        if (this._data instanceof CompressedObject) {
          return this._data.getContentWorker();
        } else if (this._data instanceof GenericWorker) {
          return this._data;
        } else {
          return new DataWorker(this._data);
        }
      }
    };
    var removedMethods = ["asText", "asBinary", "asNodeBuffer", "asUint8Array", "asArrayBuffer"];
    var removedFn = function() {
      throw new Error("This method has been removed in JSZip 3.0, please check the upgrade guide.");
    };
    for (i = 0; i < removedMethods.length; i++) {
      ZipObject.prototype[removedMethods[i]] = removedFn;
    }
    var i;
    module2.exports = ZipObject;
  }
});

// ../../../node_modules/pako/lib/utils/common.js
var require_common = __commonJS({
  "../../../node_modules/pako/lib/utils/common.js"(exports2) {
    "use strict";
    var TYPED_OK = typeof Uint8Array !== "undefined" && typeof Uint16Array !== "undefined" && typeof Int32Array !== "undefined";
    function _has(obj2, key) {
      return Object.prototype.hasOwnProperty.call(obj2, key);
    }
    exports2.assign = function(obj2) {
      var sources = Array.prototype.slice.call(arguments, 1);
      while (sources.length) {
        var source = sources.shift();
        if (!source) {
          continue;
        }
        if (typeof source !== "object") {
          throw new TypeError(source + "must be non-object");
        }
        for (var p in source) {
          if (_has(source, p)) {
            obj2[p] = source[p];
          }
        }
      }
      return obj2;
    };
    exports2.shrinkBuf = function(buf, size) {
      if (buf.length === size) {
        return buf;
      }
      if (buf.subarray) {
        return buf.subarray(0, size);
      }
      buf.length = size;
      return buf;
    };
    var fnTyped = {
      arraySet: function(dest, src, src_offs, len, dest_offs) {
        if (src.subarray && dest.subarray) {
          dest.set(src.subarray(src_offs, src_offs + len), dest_offs);
          return;
        }
        for (var i = 0; i < len; i++) {
          dest[dest_offs + i] = src[src_offs + i];
        }
      },
      // Join array of chunks to single array.
      flattenChunks: function(chunks) {
        var i, l2, len, pos, chunk, result;
        len = 0;
        for (i = 0, l2 = chunks.length; i < l2; i++) {
          len += chunks[i].length;
        }
        result = new Uint8Array(len);
        pos = 0;
        for (i = 0, l2 = chunks.length; i < l2; i++) {
          chunk = chunks[i];
          result.set(chunk, pos);
          pos += chunk.length;
        }
        return result;
      }
    };
    var fnUntyped = {
      arraySet: function(dest, src, src_offs, len, dest_offs) {
        for (var i = 0; i < len; i++) {
          dest[dest_offs + i] = src[src_offs + i];
        }
      },
      // Join array of chunks to single array.
      flattenChunks: function(chunks) {
        return [].concat.apply([], chunks);
      }
    };
    exports2.setTyped = function(on) {
      if (on) {
        exports2.Buf8 = Uint8Array;
        exports2.Buf16 = Uint16Array;
        exports2.Buf32 = Int32Array;
        exports2.assign(exports2, fnTyped);
      } else {
        exports2.Buf8 = Array;
        exports2.Buf16 = Array;
        exports2.Buf32 = Array;
        exports2.assign(exports2, fnUntyped);
      }
    };
    exports2.setTyped(TYPED_OK);
  }
});

// ../../../node_modules/pako/lib/zlib/trees.js
var require_trees = __commonJS({
  "../../../node_modules/pako/lib/zlib/trees.js"(exports2) {
    "use strict";
    var utils = require_common();
    var Z_FIXED = 4;
    var Z_BINARY = 0;
    var Z_TEXT = 1;
    var Z_UNKNOWN = 2;
    function zero(buf) {
      var len = buf.length;
      while (--len >= 0) {
        buf[len] = 0;
      }
    }
    var STORED_BLOCK = 0;
    var STATIC_TREES = 1;
    var DYN_TREES = 2;
    var MIN_MATCH = 3;
    var MAX_MATCH = 258;
    var LENGTH_CODES = 29;
    var LITERALS = 256;
    var L_CODES = LITERALS + 1 + LENGTH_CODES;
    var D_CODES = 30;
    var BL_CODES = 19;
    var HEAP_SIZE = 2 * L_CODES + 1;
    var MAX_BITS = 15;
    var Buf_size = 16;
    var MAX_BL_BITS = 7;
    var END_BLOCK = 256;
    var REP_3_6 = 16;
    var REPZ_3_10 = 17;
    var REPZ_11_138 = 18;
    var extra_lbits = (
      /* extra bits for each length code */
      [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0]
    );
    var extra_dbits = (
      /* extra bits for each distance code */
      [0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13]
    );
    var extra_blbits = (
      /* extra bits for each bit length code */
      [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 3, 7]
    );
    var bl_order = [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15];
    var DIST_CODE_LEN = 512;
    var static_ltree = new Array((L_CODES + 2) * 2);
    zero(static_ltree);
    var static_dtree = new Array(D_CODES * 2);
    zero(static_dtree);
    var _dist_code = new Array(DIST_CODE_LEN);
    zero(_dist_code);
    var _length_code = new Array(MAX_MATCH - MIN_MATCH + 1);
    zero(_length_code);
    var base_length = new Array(LENGTH_CODES);
    zero(base_length);
    var base_dist = new Array(D_CODES);
    zero(base_dist);
    function StaticTreeDesc(static_tree, extra_bits, extra_base, elems, max_length) {
      this.static_tree = static_tree;
      this.extra_bits = extra_bits;
      this.extra_base = extra_base;
      this.elems = elems;
      this.max_length = max_length;
      this.has_stree = static_tree && static_tree.length;
    }
    var static_l_desc;
    var static_d_desc;
    var static_bl_desc;
    function TreeDesc(dyn_tree, stat_desc) {
      this.dyn_tree = dyn_tree;
      this.max_code = 0;
      this.stat_desc = stat_desc;
    }
    function d_code(dist) {
      return dist < 256 ? _dist_code[dist] : _dist_code[256 + (dist >>> 7)];
    }
    function put_short(s, w) {
      s.pending_buf[s.pending++] = w & 255;
      s.pending_buf[s.pending++] = w >>> 8 & 255;
    }
    function send_bits(s, value, length) {
      if (s.bi_valid > Buf_size - length) {
        s.bi_buf |= value << s.bi_valid & 65535;
        put_short(s, s.bi_buf);
        s.bi_buf = value >> Buf_size - s.bi_valid;
        s.bi_valid += length - Buf_size;
      } else {
        s.bi_buf |= value << s.bi_valid & 65535;
        s.bi_valid += length;
      }
    }
    function send_code(s, c, tree) {
      send_bits(
        s,
        tree[c * 2],
        tree[c * 2 + 1]
        /*.Len*/
      );
    }
    function bi_reverse(code, len) {
      var res = 0;
      do {
        res |= code & 1;
        code >>>= 1;
        res <<= 1;
      } while (--len > 0);
      return res >>> 1;
    }
    function bi_flush(s) {
      if (s.bi_valid === 16) {
        put_short(s, s.bi_buf);
        s.bi_buf = 0;
        s.bi_valid = 0;
      } else if (s.bi_valid >= 8) {
        s.pending_buf[s.pending++] = s.bi_buf & 255;
        s.bi_buf >>= 8;
        s.bi_valid -= 8;
      }
    }
    function gen_bitlen(s, desc) {
      var tree = desc.dyn_tree;
      var max_code = desc.max_code;
      var stree = desc.stat_desc.static_tree;
      var has_stree = desc.stat_desc.has_stree;
      var extra = desc.stat_desc.extra_bits;
      var base = desc.stat_desc.extra_base;
      var max_length = desc.stat_desc.max_length;
      var h;
      var n, m;
      var bits;
      var xbits;
      var f;
      var overflow = 0;
      for (bits = 0; bits <= MAX_BITS; bits++) {
        s.bl_count[bits] = 0;
      }
      tree[s.heap[s.heap_max] * 2 + 1] = 0;
      for (h = s.heap_max + 1; h < HEAP_SIZE; h++) {
        n = s.heap[h];
        bits = tree[tree[n * 2 + 1] * 2 + 1] + 1;
        if (bits > max_length) {
          bits = max_length;
          overflow++;
        }
        tree[n * 2 + 1] = bits;
        if (n > max_code) {
          continue;
        }
        s.bl_count[bits]++;
        xbits = 0;
        if (n >= base) {
          xbits = extra[n - base];
        }
        f = tree[n * 2];
        s.opt_len += f * (bits + xbits);
        if (has_stree) {
          s.static_len += f * (stree[n * 2 + 1] + xbits);
        }
      }
      if (overflow === 0) {
        return;
      }
      do {
        bits = max_length - 1;
        while (s.bl_count[bits] === 0) {
          bits--;
        }
        s.bl_count[bits]--;
        s.bl_count[bits + 1] += 2;
        s.bl_count[max_length]--;
        overflow -= 2;
      } while (overflow > 0);
      for (bits = max_length; bits !== 0; bits--) {
        n = s.bl_count[bits];
        while (n !== 0) {
          m = s.heap[--h];
          if (m > max_code) {
            continue;
          }
          if (tree[m * 2 + 1] !== bits) {
            s.opt_len += (bits - tree[m * 2 + 1]) * tree[m * 2];
            tree[m * 2 + 1] = bits;
          }
          n--;
        }
      }
    }
    function gen_codes(tree, max_code, bl_count) {
      var next_code = new Array(MAX_BITS + 1);
      var code = 0;
      var bits;
      var n;
      for (bits = 1; bits <= MAX_BITS; bits++) {
        next_code[bits] = code = code + bl_count[bits - 1] << 1;
      }
      for (n = 0; n <= max_code; n++) {
        var len = tree[n * 2 + 1];
        if (len === 0) {
          continue;
        }
        tree[n * 2] = bi_reverse(next_code[len]++, len);
      }
    }
    function tr_static_init() {
      var n;
      var bits;
      var length;
      var code;
      var dist;
      var bl_count = new Array(MAX_BITS + 1);
      length = 0;
      for (code = 0; code < LENGTH_CODES - 1; code++) {
        base_length[code] = length;
        for (n = 0; n < 1 << extra_lbits[code]; n++) {
          _length_code[length++] = code;
        }
      }
      _length_code[length - 1] = code;
      dist = 0;
      for (code = 0; code < 16; code++) {
        base_dist[code] = dist;
        for (n = 0; n < 1 << extra_dbits[code]; n++) {
          _dist_code[dist++] = code;
        }
      }
      dist >>= 7;
      for (; code < D_CODES; code++) {
        base_dist[code] = dist << 7;
        for (n = 0; n < 1 << extra_dbits[code] - 7; n++) {
          _dist_code[256 + dist++] = code;
        }
      }
      for (bits = 0; bits <= MAX_BITS; bits++) {
        bl_count[bits] = 0;
      }
      n = 0;
      while (n <= 143) {
        static_ltree[n * 2 + 1] = 8;
        n++;
        bl_count[8]++;
      }
      while (n <= 255) {
        static_ltree[n * 2 + 1] = 9;
        n++;
        bl_count[9]++;
      }
      while (n <= 279) {
        static_ltree[n * 2 + 1] = 7;
        n++;
        bl_count[7]++;
      }
      while (n <= 287) {
        static_ltree[n * 2 + 1] = 8;
        n++;
        bl_count[8]++;
      }
      gen_codes(static_ltree, L_CODES + 1, bl_count);
      for (n = 0; n < D_CODES; n++) {
        static_dtree[n * 2 + 1] = 5;
        static_dtree[n * 2] = bi_reverse(n, 5);
      }
      static_l_desc = new StaticTreeDesc(static_ltree, extra_lbits, LITERALS + 1, L_CODES, MAX_BITS);
      static_d_desc = new StaticTreeDesc(static_dtree, extra_dbits, 0, D_CODES, MAX_BITS);
      static_bl_desc = new StaticTreeDesc(new Array(0), extra_blbits, 0, BL_CODES, MAX_BL_BITS);
    }
    function init_block(s) {
      var n;
      for (n = 0; n < L_CODES; n++) {
        s.dyn_ltree[n * 2] = 0;
      }
      for (n = 0; n < D_CODES; n++) {
        s.dyn_dtree[n * 2] = 0;
      }
      for (n = 0; n < BL_CODES; n++) {
        s.bl_tree[n * 2] = 0;
      }
      s.dyn_ltree[END_BLOCK * 2] = 1;
      s.opt_len = s.static_len = 0;
      s.last_lit = s.matches = 0;
    }
    function bi_windup(s) {
      if (s.bi_valid > 8) {
        put_short(s, s.bi_buf);
      } else if (s.bi_valid > 0) {
        s.pending_buf[s.pending++] = s.bi_buf;
      }
      s.bi_buf = 0;
      s.bi_valid = 0;
    }
    function copy_block(s, buf, len, header) {
      bi_windup(s);
      if (header) {
        put_short(s, len);
        put_short(s, ~len);
      }
      utils.arraySet(s.pending_buf, s.window, buf, len, s.pending);
      s.pending += len;
    }
    function smaller(tree, n, m, depth) {
      var _n2 = n * 2;
      var _m2 = m * 2;
      return tree[_n2] < tree[_m2] || tree[_n2] === tree[_m2] && depth[n] <= depth[m];
    }
    function pqdownheap(s, tree, k) {
      var v = s.heap[k];
      var j = k << 1;
      while (j <= s.heap_len) {
        if (j < s.heap_len && smaller(tree, s.heap[j + 1], s.heap[j], s.depth)) {
          j++;
        }
        if (smaller(tree, v, s.heap[j], s.depth)) {
          break;
        }
        s.heap[k] = s.heap[j];
        k = j;
        j <<= 1;
      }
      s.heap[k] = v;
    }
    function compress_block(s, ltree, dtree) {
      var dist;
      var lc;
      var lx = 0;
      var code;
      var extra;
      if (s.last_lit !== 0) {
        do {
          dist = s.pending_buf[s.d_buf + lx * 2] << 8 | s.pending_buf[s.d_buf + lx * 2 + 1];
          lc = s.pending_buf[s.l_buf + lx];
          lx++;
          if (dist === 0) {
            send_code(s, lc, ltree);
          } else {
            code = _length_code[lc];
            send_code(s, code + LITERALS + 1, ltree);
            extra = extra_lbits[code];
            if (extra !== 0) {
              lc -= base_length[code];
              send_bits(s, lc, extra);
            }
            dist--;
            code = d_code(dist);
            send_code(s, code, dtree);
            extra = extra_dbits[code];
            if (extra !== 0) {
              dist -= base_dist[code];
              send_bits(s, dist, extra);
            }
          }
        } while (lx < s.last_lit);
      }
      send_code(s, END_BLOCK, ltree);
    }
    function build_tree(s, desc) {
      var tree = desc.dyn_tree;
      var stree = desc.stat_desc.static_tree;
      var has_stree = desc.stat_desc.has_stree;
      var elems = desc.stat_desc.elems;
      var n, m;
      var max_code = -1;
      var node;
      s.heap_len = 0;
      s.heap_max = HEAP_SIZE;
      for (n = 0; n < elems; n++) {
        if (tree[n * 2] !== 0) {
          s.heap[++s.heap_len] = max_code = n;
          s.depth[n] = 0;
        } else {
          tree[n * 2 + 1] = 0;
        }
      }
      while (s.heap_len < 2) {
        node = s.heap[++s.heap_len] = max_code < 2 ? ++max_code : 0;
        tree[node * 2] = 1;
        s.depth[node] = 0;
        s.opt_len--;
        if (has_stree) {
          s.static_len -= stree[node * 2 + 1];
        }
      }
      desc.max_code = max_code;
      for (n = s.heap_len >> 1; n >= 1; n--) {
        pqdownheap(s, tree, n);
      }
      node = elems;
      do {
        n = s.heap[
          1
          /*SMALLEST*/
        ];
        s.heap[
          1
          /*SMALLEST*/
        ] = s.heap[s.heap_len--];
        pqdownheap(
          s,
          tree,
          1
          /*SMALLEST*/
        );
        m = s.heap[
          1
          /*SMALLEST*/
        ];
        s.heap[--s.heap_max] = n;
        s.heap[--s.heap_max] = m;
        tree[node * 2] = tree[n * 2] + tree[m * 2];
        s.depth[node] = (s.depth[n] >= s.depth[m] ? s.depth[n] : s.depth[m]) + 1;
        tree[n * 2 + 1] = tree[m * 2 + 1] = node;
        s.heap[
          1
          /*SMALLEST*/
        ] = node++;
        pqdownheap(
          s,
          tree,
          1
          /*SMALLEST*/
        );
      } while (s.heap_len >= 2);
      s.heap[--s.heap_max] = s.heap[
        1
        /*SMALLEST*/
      ];
      gen_bitlen(s, desc);
      gen_codes(tree, max_code, s.bl_count);
    }
    function scan_tree(s, tree, max_code) {
      var n;
      var prevlen = -1;
      var curlen;
      var nextlen = tree[0 * 2 + 1];
      var count = 0;
      var max_count = 7;
      var min_count = 4;
      if (nextlen === 0) {
        max_count = 138;
        min_count = 3;
      }
      tree[(max_code + 1) * 2 + 1] = 65535;
      for (n = 0; n <= max_code; n++) {
        curlen = nextlen;
        nextlen = tree[(n + 1) * 2 + 1];
        if (++count < max_count && curlen === nextlen) {
          continue;
        } else if (count < min_count) {
          s.bl_tree[curlen * 2] += count;
        } else if (curlen !== 0) {
          if (curlen !== prevlen) {
            s.bl_tree[curlen * 2]++;
          }
          s.bl_tree[REP_3_6 * 2]++;
        } else if (count <= 10) {
          s.bl_tree[REPZ_3_10 * 2]++;
        } else {
          s.bl_tree[REPZ_11_138 * 2]++;
        }
        count = 0;
        prevlen = curlen;
        if (nextlen === 0) {
          max_count = 138;
          min_count = 3;
        } else if (curlen === nextlen) {
          max_count = 6;
          min_count = 3;
        } else {
          max_count = 7;
          min_count = 4;
        }
      }
    }
    function send_tree(s, tree, max_code) {
      var n;
      var prevlen = -1;
      var curlen;
      var nextlen = tree[0 * 2 + 1];
      var count = 0;
      var max_count = 7;
      var min_count = 4;
      if (nextlen === 0) {
        max_count = 138;
        min_count = 3;
      }
      for (n = 0; n <= max_code; n++) {
        curlen = nextlen;
        nextlen = tree[(n + 1) * 2 + 1];
        if (++count < max_count && curlen === nextlen) {
          continue;
        } else if (count < min_count) {
          do {
            send_code(s, curlen, s.bl_tree);
          } while (--count !== 0);
        } else if (curlen !== 0) {
          if (curlen !== prevlen) {
            send_code(s, curlen, s.bl_tree);
            count--;
          }
          send_code(s, REP_3_6, s.bl_tree);
          send_bits(s, count - 3, 2);
        } else if (count <= 10) {
          send_code(s, REPZ_3_10, s.bl_tree);
          send_bits(s, count - 3, 3);
        } else {
          send_code(s, REPZ_11_138, s.bl_tree);
          send_bits(s, count - 11, 7);
        }
        count = 0;
        prevlen = curlen;
        if (nextlen === 0) {
          max_count = 138;
          min_count = 3;
        } else if (curlen === nextlen) {
          max_count = 6;
          min_count = 3;
        } else {
          max_count = 7;
          min_count = 4;
        }
      }
    }
    function build_bl_tree(s) {
      var max_blindex;
      scan_tree(s, s.dyn_ltree, s.l_desc.max_code);
      scan_tree(s, s.dyn_dtree, s.d_desc.max_code);
      build_tree(s, s.bl_desc);
      for (max_blindex = BL_CODES - 1; max_blindex >= 3; max_blindex--) {
        if (s.bl_tree[bl_order[max_blindex] * 2 + 1] !== 0) {
          break;
        }
      }
      s.opt_len += 3 * (max_blindex + 1) + 5 + 5 + 4;
      return max_blindex;
    }
    function send_all_trees(s, lcodes, dcodes, blcodes) {
      var rank;
      send_bits(s, lcodes - 257, 5);
      send_bits(s, dcodes - 1, 5);
      send_bits(s, blcodes - 4, 4);
      for (rank = 0; rank < blcodes; rank++) {
        send_bits(s, s.bl_tree[bl_order[rank] * 2 + 1], 3);
      }
      send_tree(s, s.dyn_ltree, lcodes - 1);
      send_tree(s, s.dyn_dtree, dcodes - 1);
    }
    function detect_data_type(s) {
      var black_mask = 4093624447;
      var n;
      for (n = 0; n <= 31; n++, black_mask >>>= 1) {
        if (black_mask & 1 && s.dyn_ltree[n * 2] !== 0) {
          return Z_BINARY;
        }
      }
      if (s.dyn_ltree[9 * 2] !== 0 || s.dyn_ltree[10 * 2] !== 0 || s.dyn_ltree[13 * 2] !== 0) {
        return Z_TEXT;
      }
      for (n = 32; n < LITERALS; n++) {
        if (s.dyn_ltree[n * 2] !== 0) {
          return Z_TEXT;
        }
      }
      return Z_BINARY;
    }
    var static_init_done = false;
    function _tr_init(s) {
      if (!static_init_done) {
        tr_static_init();
        static_init_done = true;
      }
      s.l_desc = new TreeDesc(s.dyn_ltree, static_l_desc);
      s.d_desc = new TreeDesc(s.dyn_dtree, static_d_desc);
      s.bl_desc = new TreeDesc(s.bl_tree, static_bl_desc);
      s.bi_buf = 0;
      s.bi_valid = 0;
      init_block(s);
    }
    function _tr_stored_block(s, buf, stored_len, last) {
      send_bits(s, (STORED_BLOCK << 1) + (last ? 1 : 0), 3);
      copy_block(s, buf, stored_len, true);
    }
    function _tr_align(s) {
      send_bits(s, STATIC_TREES << 1, 3);
      send_code(s, END_BLOCK, static_ltree);
      bi_flush(s);
    }
    function _tr_flush_block(s, buf, stored_len, last) {
      var opt_lenb, static_lenb;
      var max_blindex = 0;
      if (s.level > 0) {
        if (s.strm.data_type === Z_UNKNOWN) {
          s.strm.data_type = detect_data_type(s);
        }
        build_tree(s, s.l_desc);
        build_tree(s, s.d_desc);
        max_blindex = build_bl_tree(s);
        opt_lenb = s.opt_len + 3 + 7 >>> 3;
        static_lenb = s.static_len + 3 + 7 >>> 3;
        if (static_lenb <= opt_lenb) {
          opt_lenb = static_lenb;
        }
      } else {
        opt_lenb = static_lenb = stored_len + 5;
      }
      if (stored_len + 4 <= opt_lenb && buf !== -1) {
        _tr_stored_block(s, buf, stored_len, last);
      } else if (s.strategy === Z_FIXED || static_lenb === opt_lenb) {
        send_bits(s, (STATIC_TREES << 1) + (last ? 1 : 0), 3);
        compress_block(s, static_ltree, static_dtree);
      } else {
        send_bits(s, (DYN_TREES << 1) + (last ? 1 : 0), 3);
        send_all_trees(s, s.l_desc.max_code + 1, s.d_desc.max_code + 1, max_blindex + 1);
        compress_block(s, s.dyn_ltree, s.dyn_dtree);
      }
      init_block(s);
      if (last) {
        bi_windup(s);
      }
    }
    function _tr_tally(s, dist, lc) {
      s.pending_buf[s.d_buf + s.last_lit * 2] = dist >>> 8 & 255;
      s.pending_buf[s.d_buf + s.last_lit * 2 + 1] = dist & 255;
      s.pending_buf[s.l_buf + s.last_lit] = lc & 255;
      s.last_lit++;
      if (dist === 0) {
        s.dyn_ltree[lc * 2]++;
      } else {
        s.matches++;
        dist--;
        s.dyn_ltree[(_length_code[lc] + LITERALS + 1) * 2]++;
        s.dyn_dtree[d_code(dist) * 2]++;
      }
      return s.last_lit === s.lit_bufsize - 1;
    }
    exports2._tr_init = _tr_init;
    exports2._tr_stored_block = _tr_stored_block;
    exports2._tr_flush_block = _tr_flush_block;
    exports2._tr_tally = _tr_tally;
    exports2._tr_align = _tr_align;
  }
});

// ../../../node_modules/pako/lib/zlib/adler32.js
var require_adler32 = __commonJS({
  "../../../node_modules/pako/lib/zlib/adler32.js"(exports2, module2) {
    "use strict";
    function adler32(adler, buf, len, pos) {
      var s1 = adler & 65535 | 0, s2 = adler >>> 16 & 65535 | 0, n = 0;
      while (len !== 0) {
        n = len > 2e3 ? 2e3 : len;
        len -= n;
        do {
          s1 = s1 + buf[pos++] | 0;
          s2 = s2 + s1 | 0;
        } while (--n);
        s1 %= 65521;
        s2 %= 65521;
      }
      return s1 | s2 << 16 | 0;
    }
    module2.exports = adler32;
  }
});

// ../../../node_modules/pako/lib/zlib/crc32.js
var require_crc322 = __commonJS({
  "../../../node_modules/pako/lib/zlib/crc32.js"(exports2, module2) {
    "use strict";
    function makeTable() {
      var c, table = [];
      for (var n = 0; n < 256; n++) {
        c = n;
        for (var k = 0; k < 8; k++) {
          c = c & 1 ? 3988292384 ^ c >>> 1 : c >>> 1;
        }
        table[n] = c;
      }
      return table;
    }
    var crcTable = makeTable();
    function crc32(crc, buf, len, pos) {
      var t = crcTable, end = pos + len;
      crc ^= -1;
      for (var i = pos; i < end; i++) {
        crc = crc >>> 8 ^ t[(crc ^ buf[i]) & 255];
      }
      return crc ^ -1;
    }
    module2.exports = crc32;
  }
});

// ../../../node_modules/pako/lib/zlib/messages.js
var require_messages = __commonJS({
  "../../../node_modules/pako/lib/zlib/messages.js"(exports2, module2) {
    "use strict";
    module2.exports = {
      2: "need dictionary",
      /* Z_NEED_DICT       2  */
      1: "stream end",
      /* Z_STREAM_END      1  */
      0: "",
      /* Z_OK              0  */
      "-1": "file error",
      /* Z_ERRNO         (-1) */
      "-2": "stream error",
      /* Z_STREAM_ERROR  (-2) */
      "-3": "data error",
      /* Z_DATA_ERROR    (-3) */
      "-4": "insufficient memory",
      /* Z_MEM_ERROR     (-4) */
      "-5": "buffer error",
      /* Z_BUF_ERROR     (-5) */
      "-6": "incompatible version"
      /* Z_VERSION_ERROR (-6) */
    };
  }
});

// ../../../node_modules/pako/lib/zlib/deflate.js
var require_deflate = __commonJS({
  "../../../node_modules/pako/lib/zlib/deflate.js"(exports2) {
    "use strict";
    var utils = require_common();
    var trees = require_trees();
    var adler32 = require_adler32();
    var crc32 = require_crc322();
    var msg = require_messages();
    var Z_NO_FLUSH = 0;
    var Z_PARTIAL_FLUSH = 1;
    var Z_FULL_FLUSH = 3;
    var Z_FINISH = 4;
    var Z_BLOCK = 5;
    var Z_OK = 0;
    var Z_STREAM_END = 1;
    var Z_STREAM_ERROR = -2;
    var Z_DATA_ERROR = -3;
    var Z_BUF_ERROR = -5;
    var Z_DEFAULT_COMPRESSION = -1;
    var Z_FILTERED = 1;
    var Z_HUFFMAN_ONLY = 2;
    var Z_RLE = 3;
    var Z_FIXED = 4;
    var Z_DEFAULT_STRATEGY = 0;
    var Z_UNKNOWN = 2;
    var Z_DEFLATED = 8;
    var MAX_MEM_LEVEL = 9;
    var MAX_WBITS = 15;
    var DEF_MEM_LEVEL = 8;
    var LENGTH_CODES = 29;
    var LITERALS = 256;
    var L_CODES = LITERALS + 1 + LENGTH_CODES;
    var D_CODES = 30;
    var BL_CODES = 19;
    var HEAP_SIZE = 2 * L_CODES + 1;
    var MAX_BITS = 15;
    var MIN_MATCH = 3;
    var MAX_MATCH = 258;
    var MIN_LOOKAHEAD = MAX_MATCH + MIN_MATCH + 1;
    var PRESET_DICT = 32;
    var INIT_STATE = 42;
    var EXTRA_STATE = 69;
    var NAME_STATE = 73;
    var COMMENT_STATE = 91;
    var HCRC_STATE = 103;
    var BUSY_STATE = 113;
    var FINISH_STATE = 666;
    var BS_NEED_MORE = 1;
    var BS_BLOCK_DONE = 2;
    var BS_FINISH_STARTED = 3;
    var BS_FINISH_DONE = 4;
    var OS_CODE = 3;
    function err(strm, errorCode) {
      strm.msg = msg[errorCode];
      return errorCode;
    }
    function rank(f) {
      return (f << 1) - (f > 4 ? 9 : 0);
    }
    function zero(buf) {
      var len = buf.length;
      while (--len >= 0) {
        buf[len] = 0;
      }
    }
    function flush_pending(strm) {
      var s = strm.state;
      var len = s.pending;
      if (len > strm.avail_out) {
        len = strm.avail_out;
      }
      if (len === 0) {
        return;
      }
      utils.arraySet(strm.output, s.pending_buf, s.pending_out, len, strm.next_out);
      strm.next_out += len;
      s.pending_out += len;
      strm.total_out += len;
      strm.avail_out -= len;
      s.pending -= len;
      if (s.pending === 0) {
        s.pending_out = 0;
      }
    }
    function flush_block_only(s, last) {
      trees._tr_flush_block(s, s.block_start >= 0 ? s.block_start : -1, s.strstart - s.block_start, last);
      s.block_start = s.strstart;
      flush_pending(s.strm);
    }
    function put_byte(s, b) {
      s.pending_buf[s.pending++] = b;
    }
    function putShortMSB(s, b) {
      s.pending_buf[s.pending++] = b >>> 8 & 255;
      s.pending_buf[s.pending++] = b & 255;
    }
    function read_buf(strm, buf, start, size) {
      var len = strm.avail_in;
      if (len > size) {
        len = size;
      }
      if (len === 0) {
        return 0;
      }
      strm.avail_in -= len;
      utils.arraySet(buf, strm.input, strm.next_in, len, start);
      if (strm.state.wrap === 1) {
        strm.adler = adler32(strm.adler, buf, len, start);
      } else if (strm.state.wrap === 2) {
        strm.adler = crc32(strm.adler, buf, len, start);
      }
      strm.next_in += len;
      strm.total_in += len;
      return len;
    }
    function longest_match(s, cur_match) {
      var chain_length = s.max_chain_length;
      var scan = s.strstart;
      var match;
      var len;
      var best_len = s.prev_length;
      var nice_match = s.nice_match;
      var limit = s.strstart > s.w_size - MIN_LOOKAHEAD ? s.strstart - (s.w_size - MIN_LOOKAHEAD) : 0;
      var _win = s.window;
      var wmask = s.w_mask;
      var prev = s.prev;
      var strend = s.strstart + MAX_MATCH;
      var scan_end1 = _win[scan + best_len - 1];
      var scan_end = _win[scan + best_len];
      if (s.prev_length >= s.good_match) {
        chain_length >>= 2;
      }
      if (nice_match > s.lookahead) {
        nice_match = s.lookahead;
      }
      do {
        match = cur_match;
        if (_win[match + best_len] !== scan_end || _win[match + best_len - 1] !== scan_end1 || _win[match] !== _win[scan] || _win[++match] !== _win[scan + 1]) {
          continue;
        }
        scan += 2;
        match++;
        do {
        } while (_win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && scan < strend);
        len = MAX_MATCH - (strend - scan);
        scan = strend - MAX_MATCH;
        if (len > best_len) {
          s.match_start = cur_match;
          best_len = len;
          if (len >= nice_match) {
            break;
          }
          scan_end1 = _win[scan + best_len - 1];
          scan_end = _win[scan + best_len];
        }
      } while ((cur_match = prev[cur_match & wmask]) > limit && --chain_length !== 0);
      if (best_len <= s.lookahead) {
        return best_len;
      }
      return s.lookahead;
    }
    function fill_window(s) {
      var _w_size = s.w_size;
      var p, n, m, more, str;
      do {
        more = s.window_size - s.lookahead - s.strstart;
        if (s.strstart >= _w_size + (_w_size - MIN_LOOKAHEAD)) {
          utils.arraySet(s.window, s.window, _w_size, _w_size, 0);
          s.match_start -= _w_size;
          s.strstart -= _w_size;
          s.block_start -= _w_size;
          n = s.hash_size;
          p = n;
          do {
            m = s.head[--p];
            s.head[p] = m >= _w_size ? m - _w_size : 0;
          } while (--n);
          n = _w_size;
          p = n;
          do {
            m = s.prev[--p];
            s.prev[p] = m >= _w_size ? m - _w_size : 0;
          } while (--n);
          more += _w_size;
        }
        if (s.strm.avail_in === 0) {
          break;
        }
        n = read_buf(s.strm, s.window, s.strstart + s.lookahead, more);
        s.lookahead += n;
        if (s.lookahead + s.insert >= MIN_MATCH) {
          str = s.strstart - s.insert;
          s.ins_h = s.window[str];
          s.ins_h = (s.ins_h << s.hash_shift ^ s.window[str + 1]) & s.hash_mask;
          while (s.insert) {
            s.ins_h = (s.ins_h << s.hash_shift ^ s.window[str + MIN_MATCH - 1]) & s.hash_mask;
            s.prev[str & s.w_mask] = s.head[s.ins_h];
            s.head[s.ins_h] = str;
            str++;
            s.insert--;
            if (s.lookahead + s.insert < MIN_MATCH) {
              break;
            }
          }
        }
      } while (s.lookahead < MIN_LOOKAHEAD && s.strm.avail_in !== 0);
    }
    function deflate_stored(s, flush) {
      var max_block_size = 65535;
      if (max_block_size > s.pending_buf_size - 5) {
        max_block_size = s.pending_buf_size - 5;
      }
      for (; ; ) {
        if (s.lookahead <= 1) {
          fill_window(s);
          if (s.lookahead === 0 && flush === Z_NO_FLUSH) {
            return BS_NEED_MORE;
          }
          if (s.lookahead === 0) {
            break;
          }
        }
        s.strstart += s.lookahead;
        s.lookahead = 0;
        var max_start = s.block_start + max_block_size;
        if (s.strstart === 0 || s.strstart >= max_start) {
          s.lookahead = s.strstart - max_start;
          s.strstart = max_start;
          flush_block_only(s, false);
          if (s.strm.avail_out === 0) {
            return BS_NEED_MORE;
          }
        }
        if (s.strstart - s.block_start >= s.w_size - MIN_LOOKAHEAD) {
          flush_block_only(s, false);
          if (s.strm.avail_out === 0) {
            return BS_NEED_MORE;
          }
        }
      }
      s.insert = 0;
      if (flush === Z_FINISH) {
        flush_block_only(s, true);
        if (s.strm.avail_out === 0) {
          return BS_FINISH_STARTED;
        }
        return BS_FINISH_DONE;
      }
      if (s.strstart > s.block_start) {
        flush_block_only(s, false);
        if (s.strm.avail_out === 0) {
          return BS_NEED_MORE;
        }
      }
      return BS_NEED_MORE;
    }
    function deflate_fast(s, flush) {
      var hash_head;
      var bflush;
      for (; ; ) {
        if (s.lookahead < MIN_LOOKAHEAD) {
          fill_window(s);
          if (s.lookahead < MIN_LOOKAHEAD && flush === Z_NO_FLUSH) {
            return BS_NEED_MORE;
          }
          if (s.lookahead === 0) {
            break;
          }
        }
        hash_head = 0;
        if (s.lookahead >= MIN_MATCH) {
          s.ins_h = (s.ins_h << s.hash_shift ^ s.window[s.strstart + MIN_MATCH - 1]) & s.hash_mask;
          hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
          s.head[s.ins_h] = s.strstart;
        }
        if (hash_head !== 0 && s.strstart - hash_head <= s.w_size - MIN_LOOKAHEAD) {
          s.match_length = longest_match(s, hash_head);
        }
        if (s.match_length >= MIN_MATCH) {
          bflush = trees._tr_tally(s, s.strstart - s.match_start, s.match_length - MIN_MATCH);
          s.lookahead -= s.match_length;
          if (s.match_length <= s.max_lazy_match && s.lookahead >= MIN_MATCH) {
            s.match_length--;
            do {
              s.strstart++;
              s.ins_h = (s.ins_h << s.hash_shift ^ s.window[s.strstart + MIN_MATCH - 1]) & s.hash_mask;
              hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
              s.head[s.ins_h] = s.strstart;
            } while (--s.match_length !== 0);
            s.strstart++;
          } else {
            s.strstart += s.match_length;
            s.match_length = 0;
            s.ins_h = s.window[s.strstart];
            s.ins_h = (s.ins_h << s.hash_shift ^ s.window[s.strstart + 1]) & s.hash_mask;
          }
        } else {
          bflush = trees._tr_tally(s, 0, s.window[s.strstart]);
          s.lookahead--;
          s.strstart++;
        }
        if (bflush) {
          flush_block_only(s, false);
          if (s.strm.avail_out === 0) {
            return BS_NEED_MORE;
          }
        }
      }
      s.insert = s.strstart < MIN_MATCH - 1 ? s.strstart : MIN_MATCH - 1;
      if (flush === Z_FINISH) {
        flush_block_only(s, true);
        if (s.strm.avail_out === 0) {
          return BS_FINISH_STARTED;
        }
        return BS_FINISH_DONE;
      }
      if (s.last_lit) {
        flush_block_only(s, false);
        if (s.strm.avail_out === 0) {
          return BS_NEED_MORE;
        }
      }
      return BS_BLOCK_DONE;
    }
    function deflate_slow(s, flush) {
      var hash_head;
      var bflush;
      var max_insert;
      for (; ; ) {
        if (s.lookahead < MIN_LOOKAHEAD) {
          fill_window(s);
          if (s.lookahead < MIN_LOOKAHEAD && flush === Z_NO_FLUSH) {
            return BS_NEED_MORE;
          }
          if (s.lookahead === 0) {
            break;
          }
        }
        hash_head = 0;
        if (s.lookahead >= MIN_MATCH) {
          s.ins_h = (s.ins_h << s.hash_shift ^ s.window[s.strstart + MIN_MATCH - 1]) & s.hash_mask;
          hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
          s.head[s.ins_h] = s.strstart;
        }
        s.prev_length = s.match_length;
        s.prev_match = s.match_start;
        s.match_length = MIN_MATCH - 1;
        if (hash_head !== 0 && s.prev_length < s.max_lazy_match && s.strstart - hash_head <= s.w_size - MIN_LOOKAHEAD) {
          s.match_length = longest_match(s, hash_head);
          if (s.match_length <= 5 && (s.strategy === Z_FILTERED || s.match_length === MIN_MATCH && s.strstart - s.match_start > 4096)) {
            s.match_length = MIN_MATCH - 1;
          }
        }
        if (s.prev_length >= MIN_MATCH && s.match_length <= s.prev_length) {
          max_insert = s.strstart + s.lookahead - MIN_MATCH;
          bflush = trees._tr_tally(s, s.strstart - 1 - s.prev_match, s.prev_length - MIN_MATCH);
          s.lookahead -= s.prev_length - 1;
          s.prev_length -= 2;
          do {
            if (++s.strstart <= max_insert) {
              s.ins_h = (s.ins_h << s.hash_shift ^ s.window[s.strstart + MIN_MATCH - 1]) & s.hash_mask;
              hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
              s.head[s.ins_h] = s.strstart;
            }
          } while (--s.prev_length !== 0);
          s.match_available = 0;
          s.match_length = MIN_MATCH - 1;
          s.strstart++;
          if (bflush) {
            flush_block_only(s, false);
            if (s.strm.avail_out === 0) {
              return BS_NEED_MORE;
            }
          }
        } else if (s.match_available) {
          bflush = trees._tr_tally(s, 0, s.window[s.strstart - 1]);
          if (bflush) {
            flush_block_only(s, false);
          }
          s.strstart++;
          s.lookahead--;
          if (s.strm.avail_out === 0) {
            return BS_NEED_MORE;
          }
        } else {
          s.match_available = 1;
          s.strstart++;
          s.lookahead--;
        }
      }
      if (s.match_available) {
        bflush = trees._tr_tally(s, 0, s.window[s.strstart - 1]);
        s.match_available = 0;
      }
      s.insert = s.strstart < MIN_MATCH - 1 ? s.strstart : MIN_MATCH - 1;
      if (flush === Z_FINISH) {
        flush_block_only(s, true);
        if (s.strm.avail_out === 0) {
          return BS_FINISH_STARTED;
        }
        return BS_FINISH_DONE;
      }
      if (s.last_lit) {
        flush_block_only(s, false);
        if (s.strm.avail_out === 0) {
          return BS_NEED_MORE;
        }
      }
      return BS_BLOCK_DONE;
    }
    function deflate_rle(s, flush) {
      var bflush;
      var prev;
      var scan, strend;
      var _win = s.window;
      for (; ; ) {
        if (s.lookahead <= MAX_MATCH) {
          fill_window(s);
          if (s.lookahead <= MAX_MATCH && flush === Z_NO_FLUSH) {
            return BS_NEED_MORE;
          }
          if (s.lookahead === 0) {
            break;
          }
        }
        s.match_length = 0;
        if (s.lookahead >= MIN_MATCH && s.strstart > 0) {
          scan = s.strstart - 1;
          prev = _win[scan];
          if (prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan]) {
            strend = s.strstart + MAX_MATCH;
            do {
            } while (prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && scan < strend);
            s.match_length = MAX_MATCH - (strend - scan);
            if (s.match_length > s.lookahead) {
              s.match_length = s.lookahead;
            }
          }
        }
        if (s.match_length >= MIN_MATCH) {
          bflush = trees._tr_tally(s, 1, s.match_length - MIN_MATCH);
          s.lookahead -= s.match_length;
          s.strstart += s.match_length;
          s.match_length = 0;
        } else {
          bflush = trees._tr_tally(s, 0, s.window[s.strstart]);
          s.lookahead--;
          s.strstart++;
        }
        if (bflush) {
          flush_block_only(s, false);
          if (s.strm.avail_out === 0) {
            return BS_NEED_MORE;
          }
        }
      }
      s.insert = 0;
      if (flush === Z_FINISH) {
        flush_block_only(s, true);
        if (s.strm.avail_out === 0) {
          return BS_FINISH_STARTED;
        }
        return BS_FINISH_DONE;
      }
      if (s.last_lit) {
        flush_block_only(s, false);
        if (s.strm.avail_out === 0) {
          return BS_NEED_MORE;
        }
      }
      return BS_BLOCK_DONE;
    }
    function deflate_huff(s, flush) {
      var bflush;
      for (; ; ) {
        if (s.lookahead === 0) {
          fill_window(s);
          if (s.lookahead === 0) {
            if (flush === Z_NO_FLUSH) {
              return BS_NEED_MORE;
            }
            break;
          }
        }
        s.match_length = 0;
        bflush = trees._tr_tally(s, 0, s.window[s.strstart]);
        s.lookahead--;
        s.strstart++;
        if (bflush) {
          flush_block_only(s, false);
          if (s.strm.avail_out === 0) {
            return BS_NEED_MORE;
          }
        }
      }
      s.insert = 0;
      if (flush === Z_FINISH) {
        flush_block_only(s, true);
        if (s.strm.avail_out === 0) {
          return BS_FINISH_STARTED;
        }
        return BS_FINISH_DONE;
      }
      if (s.last_lit) {
        flush_block_only(s, false);
        if (s.strm.avail_out === 0) {
          return BS_NEED_MORE;
        }
      }
      return BS_BLOCK_DONE;
    }
    function Config(good_length, max_lazy, nice_length, max_chain, func) {
      this.good_length = good_length;
      this.max_lazy = max_lazy;
      this.nice_length = nice_length;
      this.max_chain = max_chain;
      this.func = func;
    }
    var configuration_table;
    configuration_table = [
      /*      good lazy nice chain */
      new Config(0, 0, 0, 0, deflate_stored),
      /* 0 store only */
      new Config(4, 4, 8, 4, deflate_fast),
      /* 1 max speed, no lazy matches */
      new Config(4, 5, 16, 8, deflate_fast),
      /* 2 */
      new Config(4, 6, 32, 32, deflate_fast),
      /* 3 */
      new Config(4, 4, 16, 16, deflate_slow),
      /* 4 lazy matches */
      new Config(8, 16, 32, 32, deflate_slow),
      /* 5 */
      new Config(8, 16, 128, 128, deflate_slow),
      /* 6 */
      new Config(8, 32, 128, 256, deflate_slow),
      /* 7 */
      new Config(32, 128, 258, 1024, deflate_slow),
      /* 8 */
      new Config(32, 258, 258, 4096, deflate_slow)
      /* 9 max compression */
    ];
    function lm_init(s) {
      s.window_size = 2 * s.w_size;
      zero(s.head);
      s.max_lazy_match = configuration_table[s.level].max_lazy;
      s.good_match = configuration_table[s.level].good_length;
      s.nice_match = configuration_table[s.level].nice_length;
      s.max_chain_length = configuration_table[s.level].max_chain;
      s.strstart = 0;
      s.block_start = 0;
      s.lookahead = 0;
      s.insert = 0;
      s.match_length = s.prev_length = MIN_MATCH - 1;
      s.match_available = 0;
      s.ins_h = 0;
    }
    function DeflateState() {
      this.strm = null;
      this.status = 0;
      this.pending_buf = null;
      this.pending_buf_size = 0;
      this.pending_out = 0;
      this.pending = 0;
      this.wrap = 0;
      this.gzhead = null;
      this.gzindex = 0;
      this.method = Z_DEFLATED;
      this.last_flush = -1;
      this.w_size = 0;
      this.w_bits = 0;
      this.w_mask = 0;
      this.window = null;
      this.window_size = 0;
      this.prev = null;
      this.head = null;
      this.ins_h = 0;
      this.hash_size = 0;
      this.hash_bits = 0;
      this.hash_mask = 0;
      this.hash_shift = 0;
      this.block_start = 0;
      this.match_length = 0;
      this.prev_match = 0;
      this.match_available = 0;
      this.strstart = 0;
      this.match_start = 0;
      this.lookahead = 0;
      this.prev_length = 0;
      this.max_chain_length = 0;
      this.max_lazy_match = 0;
      this.level = 0;
      this.strategy = 0;
      this.good_match = 0;
      this.nice_match = 0;
      this.dyn_ltree = new utils.Buf16(HEAP_SIZE * 2);
      this.dyn_dtree = new utils.Buf16((2 * D_CODES + 1) * 2);
      this.bl_tree = new utils.Buf16((2 * BL_CODES + 1) * 2);
      zero(this.dyn_ltree);
      zero(this.dyn_dtree);
      zero(this.bl_tree);
      this.l_desc = null;
      this.d_desc = null;
      this.bl_desc = null;
      this.bl_count = new utils.Buf16(MAX_BITS + 1);
      this.heap = new utils.Buf16(2 * L_CODES + 1);
      zero(this.heap);
      this.heap_len = 0;
      this.heap_max = 0;
      this.depth = new utils.Buf16(2 * L_CODES + 1);
      zero(this.depth);
      this.l_buf = 0;
      this.lit_bufsize = 0;
      this.last_lit = 0;
      this.d_buf = 0;
      this.opt_len = 0;
      this.static_len = 0;
      this.matches = 0;
      this.insert = 0;
      this.bi_buf = 0;
      this.bi_valid = 0;
    }
    function deflateResetKeep(strm) {
      var s;
      if (!strm || !strm.state) {
        return err(strm, Z_STREAM_ERROR);
      }
      strm.total_in = strm.total_out = 0;
      strm.data_type = Z_UNKNOWN;
      s = strm.state;
      s.pending = 0;
      s.pending_out = 0;
      if (s.wrap < 0) {
        s.wrap = -s.wrap;
      }
      s.status = s.wrap ? INIT_STATE : BUSY_STATE;
      strm.adler = s.wrap === 2 ? 0 : 1;
      s.last_flush = Z_NO_FLUSH;
      trees._tr_init(s);
      return Z_OK;
    }
    function deflateReset(strm) {
      var ret2 = deflateResetKeep(strm);
      if (ret2 === Z_OK) {
        lm_init(strm.state);
      }
      return ret2;
    }
    function deflateSetHeader(strm, head) {
      if (!strm || !strm.state) {
        return Z_STREAM_ERROR;
      }
      if (strm.state.wrap !== 2) {
        return Z_STREAM_ERROR;
      }
      strm.state.gzhead = head;
      return Z_OK;
    }
    function deflateInit2(strm, level, method, windowBits, memLevel, strategy) {
      if (!strm) {
        return Z_STREAM_ERROR;
      }
      var wrap = 1;
      if (level === Z_DEFAULT_COMPRESSION) {
        level = 6;
      }
      if (windowBits < 0) {
        wrap = 0;
        windowBits = -windowBits;
      } else if (windowBits > 15) {
        wrap = 2;
        windowBits -= 16;
      }
      if (memLevel < 1 || memLevel > MAX_MEM_LEVEL || method !== Z_DEFLATED || windowBits < 8 || windowBits > 15 || level < 0 || level > 9 || strategy < 0 || strategy > Z_FIXED) {
        return err(strm, Z_STREAM_ERROR);
      }
      if (windowBits === 8) {
        windowBits = 9;
      }
      var s = new DeflateState();
      strm.state = s;
      s.strm = strm;
      s.wrap = wrap;
      s.gzhead = null;
      s.w_bits = windowBits;
      s.w_size = 1 << s.w_bits;
      s.w_mask = s.w_size - 1;
      s.hash_bits = memLevel + 7;
      s.hash_size = 1 << s.hash_bits;
      s.hash_mask = s.hash_size - 1;
      s.hash_shift = ~~((s.hash_bits + MIN_MATCH - 1) / MIN_MATCH);
      s.window = new utils.Buf8(s.w_size * 2);
      s.head = new utils.Buf16(s.hash_size);
      s.prev = new utils.Buf16(s.w_size);
      s.lit_bufsize = 1 << memLevel + 6;
      s.pending_buf_size = s.lit_bufsize * 4;
      s.pending_buf = new utils.Buf8(s.pending_buf_size);
      s.d_buf = 1 * s.lit_bufsize;
      s.l_buf = (1 + 2) * s.lit_bufsize;
      s.level = level;
      s.strategy = strategy;
      s.method = method;
      return deflateReset(strm);
    }
    function deflateInit(strm, level) {
      return deflateInit2(strm, level, Z_DEFLATED, MAX_WBITS, DEF_MEM_LEVEL, Z_DEFAULT_STRATEGY);
    }
    function deflate(strm, flush) {
      var old_flush, s;
      var beg, val;
      if (!strm || !strm.state || flush > Z_BLOCK || flush < 0) {
        return strm ? err(strm, Z_STREAM_ERROR) : Z_STREAM_ERROR;
      }
      s = strm.state;
      if (!strm.output || !strm.input && strm.avail_in !== 0 || s.status === FINISH_STATE && flush !== Z_FINISH) {
        return err(strm, strm.avail_out === 0 ? Z_BUF_ERROR : Z_STREAM_ERROR);
      }
      s.strm = strm;
      old_flush = s.last_flush;
      s.last_flush = flush;
      if (s.status === INIT_STATE) {
        if (s.wrap === 2) {
          strm.adler = 0;
          put_byte(s, 31);
          put_byte(s, 139);
          put_byte(s, 8);
          if (!s.gzhead) {
            put_byte(s, 0);
            put_byte(s, 0);
            put_byte(s, 0);
            put_byte(s, 0);
            put_byte(s, 0);
            put_byte(s, s.level === 9 ? 2 : s.strategy >= Z_HUFFMAN_ONLY || s.level < 2 ? 4 : 0);
            put_byte(s, OS_CODE);
            s.status = BUSY_STATE;
          } else {
            put_byte(
              s,
              (s.gzhead.text ? 1 : 0) + (s.gzhead.hcrc ? 2 : 0) + (!s.gzhead.extra ? 0 : 4) + (!s.gzhead.name ? 0 : 8) + (!s.gzhead.comment ? 0 : 16)
            );
            put_byte(s, s.gzhead.time & 255);
            put_byte(s, s.gzhead.time >> 8 & 255);
            put_byte(s, s.gzhead.time >> 16 & 255);
            put_byte(s, s.gzhead.time >> 24 & 255);
            put_byte(s, s.level === 9 ? 2 : s.strategy >= Z_HUFFMAN_ONLY || s.level < 2 ? 4 : 0);
            put_byte(s, s.gzhead.os & 255);
            if (s.gzhead.extra && s.gzhead.extra.length) {
              put_byte(s, s.gzhead.extra.length & 255);
              put_byte(s, s.gzhead.extra.length >> 8 & 255);
            }
            if (s.gzhead.hcrc) {
              strm.adler = crc32(strm.adler, s.pending_buf, s.pending, 0);
            }
            s.gzindex = 0;
            s.status = EXTRA_STATE;
          }
        } else {
          var header = Z_DEFLATED + (s.w_bits - 8 << 4) << 8;
          var level_flags = -1;
          if (s.strategy >= Z_HUFFMAN_ONLY || s.level < 2) {
            level_flags = 0;
          } else if (s.level < 6) {
            level_flags = 1;
          } else if (s.level === 6) {
            level_flags = 2;
          } else {
            level_flags = 3;
          }
          header |= level_flags << 6;
          if (s.strstart !== 0) {
            header |= PRESET_DICT;
          }
          header += 31 - header % 31;
          s.status = BUSY_STATE;
          putShortMSB(s, header);
          if (s.strstart !== 0) {
            putShortMSB(s, strm.adler >>> 16);
            putShortMSB(s, strm.adler & 65535);
          }
          strm.adler = 1;
        }
      }
      if (s.status === EXTRA_STATE) {
        if (s.gzhead.extra) {
          beg = s.pending;
          while (s.gzindex < (s.gzhead.extra.length & 65535)) {
            if (s.pending === s.pending_buf_size) {
              if (s.gzhead.hcrc && s.pending > beg) {
                strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
              }
              flush_pending(strm);
              beg = s.pending;
              if (s.pending === s.pending_buf_size) {
                break;
              }
            }
            put_byte(s, s.gzhead.extra[s.gzindex] & 255);
            s.gzindex++;
          }
          if (s.gzhead.hcrc && s.pending > beg) {
            strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
          }
          if (s.gzindex === s.gzhead.extra.length) {
            s.gzindex = 0;
            s.status = NAME_STATE;
          }
        } else {
          s.status = NAME_STATE;
        }
      }
      if (s.status === NAME_STATE) {
        if (s.gzhead.name) {
          beg = s.pending;
          do {
            if (s.pending === s.pending_buf_size) {
              if (s.gzhead.hcrc && s.pending > beg) {
                strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
              }
              flush_pending(strm);
              beg = s.pending;
              if (s.pending === s.pending_buf_size) {
                val = 1;
                break;
              }
            }
            if (s.gzindex < s.gzhead.name.length) {
              val = s.gzhead.name.charCodeAt(s.gzindex++) & 255;
            } else {
              val = 0;
            }
            put_byte(s, val);
          } while (val !== 0);
          if (s.gzhead.hcrc && s.pending > beg) {
            strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
          }
          if (val === 0) {
            s.gzindex = 0;
            s.status = COMMENT_STATE;
          }
        } else {
          s.status = COMMENT_STATE;
        }
      }
      if (s.status === COMMENT_STATE) {
        if (s.gzhead.comment) {
          beg = s.pending;
          do {
            if (s.pending === s.pending_buf_size) {
              if (s.gzhead.hcrc && s.pending > beg) {
                strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
              }
              flush_pending(strm);
              beg = s.pending;
              if (s.pending === s.pending_buf_size) {
                val = 1;
                break;
              }
            }
            if (s.gzindex < s.gzhead.comment.length) {
              val = s.gzhead.comment.charCodeAt(s.gzindex++) & 255;
            } else {
              val = 0;
            }
            put_byte(s, val);
          } while (val !== 0);
          if (s.gzhead.hcrc && s.pending > beg) {
            strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
          }
          if (val === 0) {
            s.status = HCRC_STATE;
          }
        } else {
          s.status = HCRC_STATE;
        }
      }
      if (s.status === HCRC_STATE) {
        if (s.gzhead.hcrc) {
          if (s.pending + 2 > s.pending_buf_size) {
            flush_pending(strm);
          }
          if (s.pending + 2 <= s.pending_buf_size) {
            put_byte(s, strm.adler & 255);
            put_byte(s, strm.adler >> 8 & 255);
            strm.adler = 0;
            s.status = BUSY_STATE;
          }
        } else {
          s.status = BUSY_STATE;
        }
      }
      if (s.pending !== 0) {
        flush_pending(strm);
        if (strm.avail_out === 0) {
          s.last_flush = -1;
          return Z_OK;
        }
      } else if (strm.avail_in === 0 && rank(flush) <= rank(old_flush) && flush !== Z_FINISH) {
        return err(strm, Z_BUF_ERROR);
      }
      if (s.status === FINISH_STATE && strm.avail_in !== 0) {
        return err(strm, Z_BUF_ERROR);
      }
      if (strm.avail_in !== 0 || s.lookahead !== 0 || flush !== Z_NO_FLUSH && s.status !== FINISH_STATE) {
        var bstate = s.strategy === Z_HUFFMAN_ONLY ? deflate_huff(s, flush) : s.strategy === Z_RLE ? deflate_rle(s, flush) : configuration_table[s.level].func(s, flush);
        if (bstate === BS_FINISH_STARTED || bstate === BS_FINISH_DONE) {
          s.status = FINISH_STATE;
        }
        if (bstate === BS_NEED_MORE || bstate === BS_FINISH_STARTED) {
          if (strm.avail_out === 0) {
            s.last_flush = -1;
          }
          return Z_OK;
        }
        if (bstate === BS_BLOCK_DONE) {
          if (flush === Z_PARTIAL_FLUSH) {
            trees._tr_align(s);
          } else if (flush !== Z_BLOCK) {
            trees._tr_stored_block(s, 0, 0, false);
            if (flush === Z_FULL_FLUSH) {
              zero(s.head);
              if (s.lookahead === 0) {
                s.strstart = 0;
                s.block_start = 0;
                s.insert = 0;
              }
            }
          }
          flush_pending(strm);
          if (strm.avail_out === 0) {
            s.last_flush = -1;
            return Z_OK;
          }
        }
      }
      if (flush !== Z_FINISH) {
        return Z_OK;
      }
      if (s.wrap <= 0) {
        return Z_STREAM_END;
      }
      if (s.wrap === 2) {
        put_byte(s, strm.adler & 255);
        put_byte(s, strm.adler >> 8 & 255);
        put_byte(s, strm.adler >> 16 & 255);
        put_byte(s, strm.adler >> 24 & 255);
        put_byte(s, strm.total_in & 255);
        put_byte(s, strm.total_in >> 8 & 255);
        put_byte(s, strm.total_in >> 16 & 255);
        put_byte(s, strm.total_in >> 24 & 255);
      } else {
        putShortMSB(s, strm.adler >>> 16);
        putShortMSB(s, strm.adler & 65535);
      }
      flush_pending(strm);
      if (s.wrap > 0) {
        s.wrap = -s.wrap;
      }
      return s.pending !== 0 ? Z_OK : Z_STREAM_END;
    }
    function deflateEnd(strm) {
      var status;
      if (!strm || !strm.state) {
        return Z_STREAM_ERROR;
      }
      status = strm.state.status;
      if (status !== INIT_STATE && status !== EXTRA_STATE && status !== NAME_STATE && status !== COMMENT_STATE && status !== HCRC_STATE && status !== BUSY_STATE && status !== FINISH_STATE) {
        return err(strm, Z_STREAM_ERROR);
      }
      strm.state = null;
      return status === BUSY_STATE ? err(strm, Z_DATA_ERROR) : Z_OK;
    }
    function deflateSetDictionary(strm, dictionary) {
      var dictLength = dictionary.length;
      var s;
      var str, n;
      var wrap;
      var avail;
      var next;
      var input;
      var tmpDict;
      if (!strm || !strm.state) {
        return Z_STREAM_ERROR;
      }
      s = strm.state;
      wrap = s.wrap;
      if (wrap === 2 || wrap === 1 && s.status !== INIT_STATE || s.lookahead) {
        return Z_STREAM_ERROR;
      }
      if (wrap === 1) {
        strm.adler = adler32(strm.adler, dictionary, dictLength, 0);
      }
      s.wrap = 0;
      if (dictLength >= s.w_size) {
        if (wrap === 0) {
          zero(s.head);
          s.strstart = 0;
          s.block_start = 0;
          s.insert = 0;
        }
        tmpDict = new utils.Buf8(s.w_size);
        utils.arraySet(tmpDict, dictionary, dictLength - s.w_size, s.w_size, 0);
        dictionary = tmpDict;
        dictLength = s.w_size;
      }
      avail = strm.avail_in;
      next = strm.next_in;
      input = strm.input;
      strm.avail_in = dictLength;
      strm.next_in = 0;
      strm.input = dictionary;
      fill_window(s);
      while (s.lookahead >= MIN_MATCH) {
        str = s.strstart;
        n = s.lookahead - (MIN_MATCH - 1);
        do {
          s.ins_h = (s.ins_h << s.hash_shift ^ s.window[str + MIN_MATCH - 1]) & s.hash_mask;
          s.prev[str & s.w_mask] = s.head[s.ins_h];
          s.head[s.ins_h] = str;
          str++;
        } while (--n);
        s.strstart = str;
        s.lookahead = MIN_MATCH - 1;
        fill_window(s);
      }
      s.strstart += s.lookahead;
      s.block_start = s.strstart;
      s.insert = s.lookahead;
      s.lookahead = 0;
      s.match_length = s.prev_length = MIN_MATCH - 1;
      s.match_available = 0;
      strm.next_in = next;
      strm.input = input;
      strm.avail_in = avail;
      s.wrap = wrap;
      return Z_OK;
    }
    exports2.deflateInit = deflateInit;
    exports2.deflateInit2 = deflateInit2;
    exports2.deflateReset = deflateReset;
    exports2.deflateResetKeep = deflateResetKeep;
    exports2.deflateSetHeader = deflateSetHeader;
    exports2.deflate = deflate;
    exports2.deflateEnd = deflateEnd;
    exports2.deflateSetDictionary = deflateSetDictionary;
    exports2.deflateInfo = "pako deflate (from Nodeca project)";
  }
});

// ../../../node_modules/pako/lib/utils/strings.js
var require_strings = __commonJS({
  "../../../node_modules/pako/lib/utils/strings.js"(exports2) {
    "use strict";
    var utils = require_common();
    var STR_APPLY_OK = true;
    var STR_APPLY_UIA_OK = true;
    try {
      String.fromCharCode.apply(null, [0]);
    } catch (__) {
      STR_APPLY_OK = false;
    }
    try {
      String.fromCharCode.apply(null, new Uint8Array(1));
    } catch (__) {
      STR_APPLY_UIA_OK = false;
    }
    var _utf8len = new utils.Buf8(256);
    for (q = 0; q < 256; q++) {
      _utf8len[q] = q >= 252 ? 6 : q >= 248 ? 5 : q >= 240 ? 4 : q >= 224 ? 3 : q >= 192 ? 2 : 1;
    }
    var q;
    _utf8len[254] = _utf8len[254] = 1;
    exports2.string2buf = function(str) {
      var buf, c, c2, m_pos, i, str_len = str.length, buf_len = 0;
      for (m_pos = 0; m_pos < str_len; m_pos++) {
        c = str.charCodeAt(m_pos);
        if ((c & 64512) === 55296 && m_pos + 1 < str_len) {
          c2 = str.charCodeAt(m_pos + 1);
          if ((c2 & 64512) === 56320) {
            c = 65536 + (c - 55296 << 10) + (c2 - 56320);
            m_pos++;
          }
        }
        buf_len += c < 128 ? 1 : c < 2048 ? 2 : c < 65536 ? 3 : 4;
      }
      buf = new utils.Buf8(buf_len);
      for (i = 0, m_pos = 0; i < buf_len; m_pos++) {
        c = str.charCodeAt(m_pos);
        if ((c & 64512) === 55296 && m_pos + 1 < str_len) {
          c2 = str.charCodeAt(m_pos + 1);
          if ((c2 & 64512) === 56320) {
            c = 65536 + (c - 55296 << 10) + (c2 - 56320);
            m_pos++;
          }
        }
        if (c < 128) {
          buf[i++] = c;
        } else if (c < 2048) {
          buf[i++] = 192 | c >>> 6;
          buf[i++] = 128 | c & 63;
        } else if (c < 65536) {
          buf[i++] = 224 | c >>> 12;
          buf[i++] = 128 | c >>> 6 & 63;
          buf[i++] = 128 | c & 63;
        } else {
          buf[i++] = 240 | c >>> 18;
          buf[i++] = 128 | c >>> 12 & 63;
          buf[i++] = 128 | c >>> 6 & 63;
          buf[i++] = 128 | c & 63;
        }
      }
      return buf;
    };
    function buf2binstring(buf, len) {
      if (len < 65534) {
        if (buf.subarray && STR_APPLY_UIA_OK || !buf.subarray && STR_APPLY_OK) {
          return String.fromCharCode.apply(null, utils.shrinkBuf(buf, len));
        }
      }
      var result = "";
      for (var i = 0; i < len; i++) {
        result += String.fromCharCode(buf[i]);
      }
      return result;
    }
    exports2.buf2binstring = function(buf) {
      return buf2binstring(buf, buf.length);
    };
    exports2.binstring2buf = function(str) {
      var buf = new utils.Buf8(str.length);
      for (var i = 0, len = buf.length; i < len; i++) {
        buf[i] = str.charCodeAt(i);
      }
      return buf;
    };
    exports2.buf2string = function(buf, max) {
      var i, out, c, c_len;
      var len = max || buf.length;
      var utf16buf = new Array(len * 2);
      for (out = 0, i = 0; i < len; ) {
        c = buf[i++];
        if (c < 128) {
          utf16buf[out++] = c;
          continue;
        }
        c_len = _utf8len[c];
        if (c_len > 4) {
          utf16buf[out++] = 65533;
          i += c_len - 1;
          continue;
        }
        c &= c_len === 2 ? 31 : c_len === 3 ? 15 : 7;
        while (c_len > 1 && i < len) {
          c = c << 6 | buf[i++] & 63;
          c_len--;
        }
        if (c_len > 1) {
          utf16buf[out++] = 65533;
          continue;
        }
        if (c < 65536) {
          utf16buf[out++] = c;
        } else {
          c -= 65536;
          utf16buf[out++] = 55296 | c >> 10 & 1023;
          utf16buf[out++] = 56320 | c & 1023;
        }
      }
      return buf2binstring(utf16buf, out);
    };
    exports2.utf8border = function(buf, max) {
      var pos;
      max = max || buf.length;
      if (max > buf.length) {
        max = buf.length;
      }
      pos = max - 1;
      while (pos >= 0 && (buf[pos] & 192) === 128) {
        pos--;
      }
      if (pos < 0) {
        return max;
      }
      if (pos === 0) {
        return max;
      }
      return pos + _utf8len[buf[pos]] > max ? pos : max;
    };
  }
});

// ../../../node_modules/pako/lib/zlib/zstream.js
var require_zstream = __commonJS({
  "../../../node_modules/pako/lib/zlib/zstream.js"(exports2, module2) {
    "use strict";
    function ZStream() {
      this.input = null;
      this.next_in = 0;
      this.avail_in = 0;
      this.total_in = 0;
      this.output = null;
      this.next_out = 0;
      this.avail_out = 0;
      this.total_out = 0;
      this.msg = "";
      this.state = null;
      this.data_type = 2;
      this.adler = 0;
    }
    module2.exports = ZStream;
  }
});

// ../../../node_modules/pako/lib/deflate.js
var require_deflate2 = __commonJS({
  "../../../node_modules/pako/lib/deflate.js"(exports2) {
    "use strict";
    var zlib_deflate = require_deflate();
    var utils = require_common();
    var strings = require_strings();
    var msg = require_messages();
    var ZStream = require_zstream();
    var toString = Object.prototype.toString;
    var Z_NO_FLUSH = 0;
    var Z_FINISH = 4;
    var Z_OK = 0;
    var Z_STREAM_END = 1;
    var Z_SYNC_FLUSH = 2;
    var Z_DEFAULT_COMPRESSION = -1;
    var Z_DEFAULT_STRATEGY = 0;
    var Z_DEFLATED = 8;
    function Deflate(options) {
      if (!(this instanceof Deflate))
        return new Deflate(options);
      this.options = utils.assign({
        level: Z_DEFAULT_COMPRESSION,
        method: Z_DEFLATED,
        chunkSize: 16384,
        windowBits: 15,
        memLevel: 8,
        strategy: Z_DEFAULT_STRATEGY,
        to: ""
      }, options || {});
      var opt = this.options;
      if (opt.raw && opt.windowBits > 0) {
        opt.windowBits = -opt.windowBits;
      } else if (opt.gzip && opt.windowBits > 0 && opt.windowBits < 16) {
        opt.windowBits += 16;
      }
      this.err = 0;
      this.msg = "";
      this.ended = false;
      this.chunks = [];
      this.strm = new ZStream();
      this.strm.avail_out = 0;
      var status = zlib_deflate.deflateInit2(
        this.strm,
        opt.level,
        opt.method,
        opt.windowBits,
        opt.memLevel,
        opt.strategy
      );
      if (status !== Z_OK) {
        throw new Error(msg[status]);
      }
      if (opt.header) {
        zlib_deflate.deflateSetHeader(this.strm, opt.header);
      }
      if (opt.dictionary) {
        var dict;
        if (typeof opt.dictionary === "string") {
          dict = strings.string2buf(opt.dictionary);
        } else if (toString.call(opt.dictionary) === "[object ArrayBuffer]") {
          dict = new Uint8Array(opt.dictionary);
        } else {
          dict = opt.dictionary;
        }
        status = zlib_deflate.deflateSetDictionary(this.strm, dict);
        if (status !== Z_OK) {
          throw new Error(msg[status]);
        }
        this._dict_set = true;
      }
    }
    Deflate.prototype.push = function(data, mode) {
      var strm = this.strm;
      var chunkSize = this.options.chunkSize;
      var status, _mode;
      if (this.ended) {
        return false;
      }
      _mode = mode === ~~mode ? mode : mode === true ? Z_FINISH : Z_NO_FLUSH;
      if (typeof data === "string") {
        strm.input = strings.string2buf(data);
      } else if (toString.call(data) === "[object ArrayBuffer]") {
        strm.input = new Uint8Array(data);
      } else {
        strm.input = data;
      }
      strm.next_in = 0;
      strm.avail_in = strm.input.length;
      do {
        if (strm.avail_out === 0) {
          strm.output = new utils.Buf8(chunkSize);
          strm.next_out = 0;
          strm.avail_out = chunkSize;
        }
        status = zlib_deflate.deflate(strm, _mode);
        if (status !== Z_STREAM_END && status !== Z_OK) {
          this.onEnd(status);
          this.ended = true;
          return false;
        }
        if (strm.avail_out === 0 || strm.avail_in === 0 && (_mode === Z_FINISH || _mode === Z_SYNC_FLUSH)) {
          if (this.options.to === "string") {
            this.onData(strings.buf2binstring(utils.shrinkBuf(strm.output, strm.next_out)));
          } else {
            this.onData(utils.shrinkBuf(strm.output, strm.next_out));
          }
        }
      } while ((strm.avail_in > 0 || strm.avail_out === 0) && status !== Z_STREAM_END);
      if (_mode === Z_FINISH) {
        status = zlib_deflate.deflateEnd(this.strm);
        this.onEnd(status);
        this.ended = true;
        return status === Z_OK;
      }
      if (_mode === Z_SYNC_FLUSH) {
        this.onEnd(Z_OK);
        strm.avail_out = 0;
        return true;
      }
      return true;
    };
    Deflate.prototype.onData = function(chunk) {
      this.chunks.push(chunk);
    };
    Deflate.prototype.onEnd = function(status) {
      if (status === Z_OK) {
        if (this.options.to === "string") {
          this.result = this.chunks.join("");
        } else {
          this.result = utils.flattenChunks(this.chunks);
        }
      }
      this.chunks = [];
      this.err = status;
      this.msg = this.strm.msg;
    };
    function deflate(input, options) {
      var deflator = new Deflate(options);
      deflator.push(input, true);
      if (deflator.err) {
        throw deflator.msg || msg[deflator.err];
      }
      return deflator.result;
    }
    function deflateRaw(input, options) {
      options = options || {};
      options.raw = true;
      return deflate(input, options);
    }
    function gzip(input, options) {
      options = options || {};
      options.gzip = true;
      return deflate(input, options);
    }
    exports2.Deflate = Deflate;
    exports2.deflate = deflate;
    exports2.deflateRaw = deflateRaw;
    exports2.gzip = gzip;
  }
});

// ../../../node_modules/pako/lib/zlib/inffast.js
var require_inffast = __commonJS({
  "../../../node_modules/pako/lib/zlib/inffast.js"(exports2, module2) {
    "use strict";
    var BAD = 30;
    var TYPE = 12;
    module2.exports = function inflate_fast(strm, start) {
      var state;
      var _in;
      var last;
      var _out;
      var beg;
      var end;
      var dmax;
      var wsize;
      var whave;
      var wnext;
      var s_window;
      var hold;
      var bits;
      var lcode;
      var dcode;
      var lmask;
      var dmask;
      var here;
      var op;
      var len;
      var dist;
      var from;
      var from_source;
      var input, output;
      state = strm.state;
      _in = strm.next_in;
      input = strm.input;
      last = _in + (strm.avail_in - 5);
      _out = strm.next_out;
      output = strm.output;
      beg = _out - (start - strm.avail_out);
      end = _out + (strm.avail_out - 257);
      dmax = state.dmax;
      wsize = state.wsize;
      whave = state.whave;
      wnext = state.wnext;
      s_window = state.window;
      hold = state.hold;
      bits = state.bits;
      lcode = state.lencode;
      dcode = state.distcode;
      lmask = (1 << state.lenbits) - 1;
      dmask = (1 << state.distbits) - 1;
      top:
        do {
          if (bits < 15) {
            hold += input[_in++] << bits;
            bits += 8;
            hold += input[_in++] << bits;
            bits += 8;
          }
          here = lcode[hold & lmask];
          dolen:
            for (; ; ) {
              op = here >>> 24;
              hold >>>= op;
              bits -= op;
              op = here >>> 16 & 255;
              if (op === 0) {
                output[_out++] = here & 65535;
              } else if (op & 16) {
                len = here & 65535;
                op &= 15;
                if (op) {
                  if (bits < op) {
                    hold += input[_in++] << bits;
                    bits += 8;
                  }
                  len += hold & (1 << op) - 1;
                  hold >>>= op;
                  bits -= op;
                }
                if (bits < 15) {
                  hold += input[_in++] << bits;
                  bits += 8;
                  hold += input[_in++] << bits;
                  bits += 8;
                }
                here = dcode[hold & dmask];
                dodist:
                  for (; ; ) {
                    op = here >>> 24;
                    hold >>>= op;
                    bits -= op;
                    op = here >>> 16 & 255;
                    if (op & 16) {
                      dist = here & 65535;
                      op &= 15;
                      if (bits < op) {
                        hold += input[_in++] << bits;
                        bits += 8;
                        if (bits < op) {
                          hold += input[_in++] << bits;
                          bits += 8;
                        }
                      }
                      dist += hold & (1 << op) - 1;
                      if (dist > dmax) {
                        strm.msg = "invalid distance too far back";
                        state.mode = BAD;
                        break top;
                      }
                      hold >>>= op;
                      bits -= op;
                      op = _out - beg;
                      if (dist > op) {
                        op = dist - op;
                        if (op > whave) {
                          if (state.sane) {
                            strm.msg = "invalid distance too far back";
                            state.mode = BAD;
                            break top;
                          }
                        }
                        from = 0;
                        from_source = s_window;
                        if (wnext === 0) {
                          from += wsize - op;
                          if (op < len) {
                            len -= op;
                            do {
                              output[_out++] = s_window[from++];
                            } while (--op);
                            from = _out - dist;
                            from_source = output;
                          }
                        } else if (wnext < op) {
                          from += wsize + wnext - op;
                          op -= wnext;
                          if (op < len) {
                            len -= op;
                            do {
                              output[_out++] = s_window[from++];
                            } while (--op);
                            from = 0;
                            if (wnext < len) {
                              op = wnext;
                              len -= op;
                              do {
                                output[_out++] = s_window[from++];
                              } while (--op);
                              from = _out - dist;
                              from_source = output;
                            }
                          }
                        } else {
                          from += wnext - op;
                          if (op < len) {
                            len -= op;
                            do {
                              output[_out++] = s_window[from++];
                            } while (--op);
                            from = _out - dist;
                            from_source = output;
                          }
                        }
                        while (len > 2) {
                          output[_out++] = from_source[from++];
                          output[_out++] = from_source[from++];
                          output[_out++] = from_source[from++];
                          len -= 3;
                        }
                        if (len) {
                          output[_out++] = from_source[from++];
                          if (len > 1) {
                            output[_out++] = from_source[from++];
                          }
                        }
                      } else {
                        from = _out - dist;
                        do {
                          output[_out++] = output[from++];
                          output[_out++] = output[from++];
                          output[_out++] = output[from++];
                          len -= 3;
                        } while (len > 2);
                        if (len) {
                          output[_out++] = output[from++];
                          if (len > 1) {
                            output[_out++] = output[from++];
                          }
                        }
                      }
                    } else if ((op & 64) === 0) {
                      here = dcode[(here & 65535) + (hold & (1 << op) - 1)];
                      continue dodist;
                    } else {
                      strm.msg = "invalid distance code";
                      state.mode = BAD;
                      break top;
                    }
                    break;
                  }
              } else if ((op & 64) === 0) {
                here = lcode[(here & 65535) + (hold & (1 << op) - 1)];
                continue dolen;
              } else if (op & 32) {
                state.mode = TYPE;
                break top;
              } else {
                strm.msg = "invalid literal/length code";
                state.mode = BAD;
                break top;
              }
              break;
            }
        } while (_in < last && _out < end);
      len = bits >> 3;
      _in -= len;
      bits -= len << 3;
      hold &= (1 << bits) - 1;
      strm.next_in = _in;
      strm.next_out = _out;
      strm.avail_in = _in < last ? 5 + (last - _in) : 5 - (_in - last);
      strm.avail_out = _out < end ? 257 + (end - _out) : 257 - (_out - end);
      state.hold = hold;
      state.bits = bits;
      return;
    };
  }
});

// ../../../node_modules/pako/lib/zlib/inftrees.js
var require_inftrees = __commonJS({
  "../../../node_modules/pako/lib/zlib/inftrees.js"(exports2, module2) {
    "use strict";
    var utils = require_common();
    var MAXBITS = 15;
    var ENOUGH_LENS = 852;
    var ENOUGH_DISTS = 592;
    var CODES = 0;
    var LENS = 1;
    var DISTS = 2;
    var lbase = [
      /* Length codes 257..285 base */
      3,
      4,
      5,
      6,
      7,
      8,
      9,
      10,
      11,
      13,
      15,
      17,
      19,
      23,
      27,
      31,
      35,
      43,
      51,
      59,
      67,
      83,
      99,
      115,
      131,
      163,
      195,
      227,
      258,
      0,
      0
    ];
    var lext = [
      /* Length codes 257..285 extra */
      16,
      16,
      16,
      16,
      16,
      16,
      16,
      16,
      17,
      17,
      17,
      17,
      18,
      18,
      18,
      18,
      19,
      19,
      19,
      19,
      20,
      20,
      20,
      20,
      21,
      21,
      21,
      21,
      16,
      72,
      78
    ];
    var dbase = [
      /* Distance codes 0..29 base */
      1,
      2,
      3,
      4,
      5,
      7,
      9,
      13,
      17,
      25,
      33,
      49,
      65,
      97,
      129,
      193,
      257,
      385,
      513,
      769,
      1025,
      1537,
      2049,
      3073,
      4097,
      6145,
      8193,
      12289,
      16385,
      24577,
      0,
      0
    ];
    var dext = [
      /* Distance codes 0..29 extra */
      16,
      16,
      16,
      16,
      17,
      17,
      18,
      18,
      19,
      19,
      20,
      20,
      21,
      21,
      22,
      22,
      23,
      23,
      24,
      24,
      25,
      25,
      26,
      26,
      27,
      27,
      28,
      28,
      29,
      29,
      64,
      64
    ];
    module2.exports = function inflate_table(type, lens, lens_index, codes, table, table_index, work, opts) {
      var bits = opts.bits;
      var len = 0;
      var sym = 0;
      var min = 0, max = 0;
      var root = 0;
      var curr = 0;
      var drop = 0;
      var left = 0;
      var used = 0;
      var huff = 0;
      var incr;
      var fill;
      var low;
      var mask;
      var next;
      var base = null;
      var base_index = 0;
      var end;
      var count = new utils.Buf16(MAXBITS + 1);
      var offs = new utils.Buf16(MAXBITS + 1);
      var extra = null;
      var extra_index = 0;
      var here_bits, here_op, here_val;
      for (len = 0; len <= MAXBITS; len++) {
        count[len] = 0;
      }
      for (sym = 0; sym < codes; sym++) {
        count[lens[lens_index + sym]]++;
      }
      root = bits;
      for (max = MAXBITS; max >= 1; max--) {
        if (count[max] !== 0) {
          break;
        }
      }
      if (root > max) {
        root = max;
      }
      if (max === 0) {
        table[table_index++] = 1 << 24 | 64 << 16 | 0;
        table[table_index++] = 1 << 24 | 64 << 16 | 0;
        opts.bits = 1;
        return 0;
      }
      for (min = 1; min < max; min++) {
        if (count[min] !== 0) {
          break;
        }
      }
      if (root < min) {
        root = min;
      }
      left = 1;
      for (len = 1; len <= MAXBITS; len++) {
        left <<= 1;
        left -= count[len];
        if (left < 0) {
          return -1;
        }
      }
      if (left > 0 && (type === CODES || max !== 1)) {
        return -1;
      }
      offs[1] = 0;
      for (len = 1; len < MAXBITS; len++) {
        offs[len + 1] = offs[len] + count[len];
      }
      for (sym = 0; sym < codes; sym++) {
        if (lens[lens_index + sym] !== 0) {
          work[offs[lens[lens_index + sym]]++] = sym;
        }
      }
      if (type === CODES) {
        base = extra = work;
        end = 19;
      } else if (type === LENS) {
        base = lbase;
        base_index -= 257;
        extra = lext;
        extra_index -= 257;
        end = 256;
      } else {
        base = dbase;
        extra = dext;
        end = -1;
      }
      huff = 0;
      sym = 0;
      len = min;
      next = table_index;
      curr = root;
      drop = 0;
      low = -1;
      used = 1 << root;
      mask = used - 1;
      if (type === LENS && used > ENOUGH_LENS || type === DISTS && used > ENOUGH_DISTS) {
        return 1;
      }
      for (; ; ) {
        here_bits = len - drop;
        if (work[sym] < end) {
          here_op = 0;
          here_val = work[sym];
        } else if (work[sym] > end) {
          here_op = extra[extra_index + work[sym]];
          here_val = base[base_index + work[sym]];
        } else {
          here_op = 32 + 64;
          here_val = 0;
        }
        incr = 1 << len - drop;
        fill = 1 << curr;
        min = fill;
        do {
          fill -= incr;
          table[next + (huff >> drop) + fill] = here_bits << 24 | here_op << 16 | here_val | 0;
        } while (fill !== 0);
        incr = 1 << len - 1;
        while (huff & incr) {
          incr >>= 1;
        }
        if (incr !== 0) {
          huff &= incr - 1;
          huff += incr;
        } else {
          huff = 0;
        }
        sym++;
        if (--count[len] === 0) {
          if (len === max) {
            break;
          }
          len = lens[lens_index + work[sym]];
        }
        if (len > root && (huff & mask) !== low) {
          if (drop === 0) {
            drop = root;
          }
          next += min;
          curr = len - drop;
          left = 1 << curr;
          while (curr + drop < max) {
            left -= count[curr + drop];
            if (left <= 0) {
              break;
            }
            curr++;
            left <<= 1;
          }
          used += 1 << curr;
          if (type === LENS && used > ENOUGH_LENS || type === DISTS && used > ENOUGH_DISTS) {
            return 1;
          }
          low = huff & mask;
          table[low] = root << 24 | curr << 16 | next - table_index | 0;
        }
      }
      if (huff !== 0) {
        table[next + huff] = len - drop << 24 | 64 << 16 | 0;
      }
      opts.bits = root;
      return 0;
    };
  }
});

// ../../../node_modules/pako/lib/zlib/inflate.js
var require_inflate = __commonJS({
  "../../../node_modules/pako/lib/zlib/inflate.js"(exports2) {
    "use strict";
    var utils = require_common();
    var adler32 = require_adler32();
    var crc32 = require_crc322();
    var inflate_fast = require_inffast();
    var inflate_table = require_inftrees();
    var CODES = 0;
    var LENS = 1;
    var DISTS = 2;
    var Z_FINISH = 4;
    var Z_BLOCK = 5;
    var Z_TREES = 6;
    var Z_OK = 0;
    var Z_STREAM_END = 1;
    var Z_NEED_DICT = 2;
    var Z_STREAM_ERROR = -2;
    var Z_DATA_ERROR = -3;
    var Z_MEM_ERROR = -4;
    var Z_BUF_ERROR = -5;
    var Z_DEFLATED = 8;
    var HEAD = 1;
    var FLAGS = 2;
    var TIME = 3;
    var OS = 4;
    var EXLEN = 5;
    var EXTRA = 6;
    var NAME = 7;
    var COMMENT = 8;
    var HCRC = 9;
    var DICTID = 10;
    var DICT = 11;
    var TYPE = 12;
    var TYPEDO = 13;
    var STORED = 14;
    var COPY_ = 15;
    var COPY = 16;
    var TABLE = 17;
    var LENLENS = 18;
    var CODELENS = 19;
    var LEN_ = 20;
    var LEN = 21;
    var LENEXT = 22;
    var DIST = 23;
    var DISTEXT = 24;
    var MATCH = 25;
    var LIT = 26;
    var CHECK = 27;
    var LENGTH = 28;
    var DONE = 29;
    var BAD = 30;
    var MEM = 31;
    var SYNC = 32;
    var ENOUGH_LENS = 852;
    var ENOUGH_DISTS = 592;
    var MAX_WBITS = 15;
    var DEF_WBITS = MAX_WBITS;
    function zswap32(q) {
      return (q >>> 24 & 255) + (q >>> 8 & 65280) + ((q & 65280) << 8) + ((q & 255) << 24);
    }
    function InflateState() {
      this.mode = 0;
      this.last = false;
      this.wrap = 0;
      this.havedict = false;
      this.flags = 0;
      this.dmax = 0;
      this.check = 0;
      this.total = 0;
      this.head = null;
      this.wbits = 0;
      this.wsize = 0;
      this.whave = 0;
      this.wnext = 0;
      this.window = null;
      this.hold = 0;
      this.bits = 0;
      this.length = 0;
      this.offset = 0;
      this.extra = 0;
      this.lencode = null;
      this.distcode = null;
      this.lenbits = 0;
      this.distbits = 0;
      this.ncode = 0;
      this.nlen = 0;
      this.ndist = 0;
      this.have = 0;
      this.next = null;
      this.lens = new utils.Buf16(320);
      this.work = new utils.Buf16(288);
      this.lendyn = null;
      this.distdyn = null;
      this.sane = 0;
      this.back = 0;
      this.was = 0;
    }
    function inflateResetKeep(strm) {
      var state;
      if (!strm || !strm.state) {
        return Z_STREAM_ERROR;
      }
      state = strm.state;
      strm.total_in = strm.total_out = state.total = 0;
      strm.msg = "";
      if (state.wrap) {
        strm.adler = state.wrap & 1;
      }
      state.mode = HEAD;
      state.last = 0;
      state.havedict = 0;
      state.dmax = 32768;
      state.head = null;
      state.hold = 0;
      state.bits = 0;
      state.lencode = state.lendyn = new utils.Buf32(ENOUGH_LENS);
      state.distcode = state.distdyn = new utils.Buf32(ENOUGH_DISTS);
      state.sane = 1;
      state.back = -1;
      return Z_OK;
    }
    function inflateReset(strm) {
      var state;
      if (!strm || !strm.state) {
        return Z_STREAM_ERROR;
      }
      state = strm.state;
      state.wsize = 0;
      state.whave = 0;
      state.wnext = 0;
      return inflateResetKeep(strm);
    }
    function inflateReset2(strm, windowBits) {
      var wrap;
      var state;
      if (!strm || !strm.state) {
        return Z_STREAM_ERROR;
      }
      state = strm.state;
      if (windowBits < 0) {
        wrap = 0;
        windowBits = -windowBits;
      } else {
        wrap = (windowBits >> 4) + 1;
        if (windowBits < 48) {
          windowBits &= 15;
        }
      }
      if (windowBits && (windowBits < 8 || windowBits > 15)) {
        return Z_STREAM_ERROR;
      }
      if (state.window !== null && state.wbits !== windowBits) {
        state.window = null;
      }
      state.wrap = wrap;
      state.wbits = windowBits;
      return inflateReset(strm);
    }
    function inflateInit2(strm, windowBits) {
      var ret2;
      var state;
      if (!strm) {
        return Z_STREAM_ERROR;
      }
      state = new InflateState();
      strm.state = state;
      state.window = null;
      ret2 = inflateReset2(strm, windowBits);
      if (ret2 !== Z_OK) {
        strm.state = null;
      }
      return ret2;
    }
    function inflateInit(strm) {
      return inflateInit2(strm, DEF_WBITS);
    }
    var virgin = true;
    var lenfix;
    var distfix;
    function fixedtables(state) {
      if (virgin) {
        var sym;
        lenfix = new utils.Buf32(512);
        distfix = new utils.Buf32(32);
        sym = 0;
        while (sym < 144) {
          state.lens[sym++] = 8;
        }
        while (sym < 256) {
          state.lens[sym++] = 9;
        }
        while (sym < 280) {
          state.lens[sym++] = 7;
        }
        while (sym < 288) {
          state.lens[sym++] = 8;
        }
        inflate_table(LENS, state.lens, 0, 288, lenfix, 0, state.work, { bits: 9 });
        sym = 0;
        while (sym < 32) {
          state.lens[sym++] = 5;
        }
        inflate_table(DISTS, state.lens, 0, 32, distfix, 0, state.work, { bits: 5 });
        virgin = false;
      }
      state.lencode = lenfix;
      state.lenbits = 9;
      state.distcode = distfix;
      state.distbits = 5;
    }
    function updatewindow(strm, src, end, copy) {
      var dist;
      var state = strm.state;
      if (state.window === null) {
        state.wsize = 1 << state.wbits;
        state.wnext = 0;
        state.whave = 0;
        state.window = new utils.Buf8(state.wsize);
      }
      if (copy >= state.wsize) {
        utils.arraySet(state.window, src, end - state.wsize, state.wsize, 0);
        state.wnext = 0;
        state.whave = state.wsize;
      } else {
        dist = state.wsize - state.wnext;
        if (dist > copy) {
          dist = copy;
        }
        utils.arraySet(state.window, src, end - copy, dist, state.wnext);
        copy -= dist;
        if (copy) {
          utils.arraySet(state.window, src, end - copy, copy, 0);
          state.wnext = copy;
          state.whave = state.wsize;
        } else {
          state.wnext += dist;
          if (state.wnext === state.wsize) {
            state.wnext = 0;
          }
          if (state.whave < state.wsize) {
            state.whave += dist;
          }
        }
      }
      return 0;
    }
    function inflate(strm, flush) {
      var state;
      var input, output;
      var next;
      var put;
      var have, left;
      var hold;
      var bits;
      var _in, _out;
      var copy;
      var from;
      var from_source;
      var here = 0;
      var here_bits, here_op, here_val;
      var last_bits, last_op, last_val;
      var len;
      var ret2;
      var hbuf = new utils.Buf8(4);
      var opts;
      var n;
      var order = (
        /* permutation of code lengths */
        [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15]
      );
      if (!strm || !strm.state || !strm.output || !strm.input && strm.avail_in !== 0) {
        return Z_STREAM_ERROR;
      }
      state = strm.state;
      if (state.mode === TYPE) {
        state.mode = TYPEDO;
      }
      put = strm.next_out;
      output = strm.output;
      left = strm.avail_out;
      next = strm.next_in;
      input = strm.input;
      have = strm.avail_in;
      hold = state.hold;
      bits = state.bits;
      _in = have;
      _out = left;
      ret2 = Z_OK;
      inf_leave:
        for (; ; ) {
          switch (state.mode) {
            case HEAD:
              if (state.wrap === 0) {
                state.mode = TYPEDO;
                break;
              }
              while (bits < 16) {
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              if (state.wrap & 2 && hold === 35615) {
                state.check = 0;
                hbuf[0] = hold & 255;
                hbuf[1] = hold >>> 8 & 255;
                state.check = crc32(state.check, hbuf, 2, 0);
                hold = 0;
                bits = 0;
                state.mode = FLAGS;
                break;
              }
              state.flags = 0;
              if (state.head) {
                state.head.done = false;
              }
              if (!(state.wrap & 1) || /* check if zlib header allowed */
              (((hold & 255) << 8) + (hold >> 8)) % 31) {
                strm.msg = "incorrect header check";
                state.mode = BAD;
                break;
              }
              if ((hold & 15) !== Z_DEFLATED) {
                strm.msg = "unknown compression method";
                state.mode = BAD;
                break;
              }
              hold >>>= 4;
              bits -= 4;
              len = (hold & 15) + 8;
              if (state.wbits === 0) {
                state.wbits = len;
              } else if (len > state.wbits) {
                strm.msg = "invalid window size";
                state.mode = BAD;
                break;
              }
              state.dmax = 1 << len;
              strm.adler = state.check = 1;
              state.mode = hold & 512 ? DICTID : TYPE;
              hold = 0;
              bits = 0;
              break;
            case FLAGS:
              while (bits < 16) {
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              state.flags = hold;
              if ((state.flags & 255) !== Z_DEFLATED) {
                strm.msg = "unknown compression method";
                state.mode = BAD;
                break;
              }
              if (state.flags & 57344) {
                strm.msg = "unknown header flags set";
                state.mode = BAD;
                break;
              }
              if (state.head) {
                state.head.text = hold >> 8 & 1;
              }
              if (state.flags & 512) {
                hbuf[0] = hold & 255;
                hbuf[1] = hold >>> 8 & 255;
                state.check = crc32(state.check, hbuf, 2, 0);
              }
              hold = 0;
              bits = 0;
              state.mode = TIME;
            case TIME:
              while (bits < 32) {
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              if (state.head) {
                state.head.time = hold;
              }
              if (state.flags & 512) {
                hbuf[0] = hold & 255;
                hbuf[1] = hold >>> 8 & 255;
                hbuf[2] = hold >>> 16 & 255;
                hbuf[3] = hold >>> 24 & 255;
                state.check = crc32(state.check, hbuf, 4, 0);
              }
              hold = 0;
              bits = 0;
              state.mode = OS;
            case OS:
              while (bits < 16) {
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              if (state.head) {
                state.head.xflags = hold & 255;
                state.head.os = hold >> 8;
              }
              if (state.flags & 512) {
                hbuf[0] = hold & 255;
                hbuf[1] = hold >>> 8 & 255;
                state.check = crc32(state.check, hbuf, 2, 0);
              }
              hold = 0;
              bits = 0;
              state.mode = EXLEN;
            case EXLEN:
              if (state.flags & 1024) {
                while (bits < 16) {
                  if (have === 0) {
                    break inf_leave;
                  }
                  have--;
                  hold += input[next++] << bits;
                  bits += 8;
                }
                state.length = hold;
                if (state.head) {
                  state.head.extra_len = hold;
                }
                if (state.flags & 512) {
                  hbuf[0] = hold & 255;
                  hbuf[1] = hold >>> 8 & 255;
                  state.check = crc32(state.check, hbuf, 2, 0);
                }
                hold = 0;
                bits = 0;
              } else if (state.head) {
                state.head.extra = null;
              }
              state.mode = EXTRA;
            case EXTRA:
              if (state.flags & 1024) {
                copy = state.length;
                if (copy > have) {
                  copy = have;
                }
                if (copy) {
                  if (state.head) {
                    len = state.head.extra_len - state.length;
                    if (!state.head.extra) {
                      state.head.extra = new Array(state.head.extra_len);
                    }
                    utils.arraySet(
                      state.head.extra,
                      input,
                      next,
                      // extra field is limited to 65536 bytes
                      // - no need for additional size check
                      copy,
                      /*len + copy > state.head.extra_max - len ? state.head.extra_max : copy,*/
                      len
                    );
                  }
                  if (state.flags & 512) {
                    state.check = crc32(state.check, input, copy, next);
                  }
                  have -= copy;
                  next += copy;
                  state.length -= copy;
                }
                if (state.length) {
                  break inf_leave;
                }
              }
              state.length = 0;
              state.mode = NAME;
            case NAME:
              if (state.flags & 2048) {
                if (have === 0) {
                  break inf_leave;
                }
                copy = 0;
                do {
                  len = input[next + copy++];
                  if (state.head && len && state.length < 65536) {
                    state.head.name += String.fromCharCode(len);
                  }
                } while (len && copy < have);
                if (state.flags & 512) {
                  state.check = crc32(state.check, input, copy, next);
                }
                have -= copy;
                next += copy;
                if (len) {
                  break inf_leave;
                }
              } else if (state.head) {
                state.head.name = null;
              }
              state.length = 0;
              state.mode = COMMENT;
            case COMMENT:
              if (state.flags & 4096) {
                if (have === 0) {
                  break inf_leave;
                }
                copy = 0;
                do {
                  len = input[next + copy++];
                  if (state.head && len && state.length < 65536) {
                    state.head.comment += String.fromCharCode(len);
                  }
                } while (len && copy < have);
                if (state.flags & 512) {
                  state.check = crc32(state.check, input, copy, next);
                }
                have -= copy;
                next += copy;
                if (len) {
                  break inf_leave;
                }
              } else if (state.head) {
                state.head.comment = null;
              }
              state.mode = HCRC;
            case HCRC:
              if (state.flags & 512) {
                while (bits < 16) {
                  if (have === 0) {
                    break inf_leave;
                  }
                  have--;
                  hold += input[next++] << bits;
                  bits += 8;
                }
                if (hold !== (state.check & 65535)) {
                  strm.msg = "header crc mismatch";
                  state.mode = BAD;
                  break;
                }
                hold = 0;
                bits = 0;
              }
              if (state.head) {
                state.head.hcrc = state.flags >> 9 & 1;
                state.head.done = true;
              }
              strm.adler = state.check = 0;
              state.mode = TYPE;
              break;
            case DICTID:
              while (bits < 32) {
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              strm.adler = state.check = zswap32(hold);
              hold = 0;
              bits = 0;
              state.mode = DICT;
            case DICT:
              if (state.havedict === 0) {
                strm.next_out = put;
                strm.avail_out = left;
                strm.next_in = next;
                strm.avail_in = have;
                state.hold = hold;
                state.bits = bits;
                return Z_NEED_DICT;
              }
              strm.adler = state.check = 1;
              state.mode = TYPE;
            case TYPE:
              if (flush === Z_BLOCK || flush === Z_TREES) {
                break inf_leave;
              }
            case TYPEDO:
              if (state.last) {
                hold >>>= bits & 7;
                bits -= bits & 7;
                state.mode = CHECK;
                break;
              }
              while (bits < 3) {
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              state.last = hold & 1;
              hold >>>= 1;
              bits -= 1;
              switch (hold & 3) {
                case 0:
                  state.mode = STORED;
                  break;
                case 1:
                  fixedtables(state);
                  state.mode = LEN_;
                  if (flush === Z_TREES) {
                    hold >>>= 2;
                    bits -= 2;
                    break inf_leave;
                  }
                  break;
                case 2:
                  state.mode = TABLE;
                  break;
                case 3:
                  strm.msg = "invalid block type";
                  state.mode = BAD;
              }
              hold >>>= 2;
              bits -= 2;
              break;
            case STORED:
              hold >>>= bits & 7;
              bits -= bits & 7;
              while (bits < 32) {
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              if ((hold & 65535) !== (hold >>> 16 ^ 65535)) {
                strm.msg = "invalid stored block lengths";
                state.mode = BAD;
                break;
              }
              state.length = hold & 65535;
              hold = 0;
              bits = 0;
              state.mode = COPY_;
              if (flush === Z_TREES) {
                break inf_leave;
              }
            case COPY_:
              state.mode = COPY;
            case COPY:
              copy = state.length;
              if (copy) {
                if (copy > have) {
                  copy = have;
                }
                if (copy > left) {
                  copy = left;
                }
                if (copy === 0) {
                  break inf_leave;
                }
                utils.arraySet(output, input, next, copy, put);
                have -= copy;
                next += copy;
                left -= copy;
                put += copy;
                state.length -= copy;
                break;
              }
              state.mode = TYPE;
              break;
            case TABLE:
              while (bits < 14) {
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              state.nlen = (hold & 31) + 257;
              hold >>>= 5;
              bits -= 5;
              state.ndist = (hold & 31) + 1;
              hold >>>= 5;
              bits -= 5;
              state.ncode = (hold & 15) + 4;
              hold >>>= 4;
              bits -= 4;
              if (state.nlen > 286 || state.ndist > 30) {
                strm.msg = "too many length or distance symbols";
                state.mode = BAD;
                break;
              }
              state.have = 0;
              state.mode = LENLENS;
            case LENLENS:
              while (state.have < state.ncode) {
                while (bits < 3) {
                  if (have === 0) {
                    break inf_leave;
                  }
                  have--;
                  hold += input[next++] << bits;
                  bits += 8;
                }
                state.lens[order[state.have++]] = hold & 7;
                hold >>>= 3;
                bits -= 3;
              }
              while (state.have < 19) {
                state.lens[order[state.have++]] = 0;
              }
              state.lencode = state.lendyn;
              state.lenbits = 7;
              opts = { bits: state.lenbits };
              ret2 = inflate_table(CODES, state.lens, 0, 19, state.lencode, 0, state.work, opts);
              state.lenbits = opts.bits;
              if (ret2) {
                strm.msg = "invalid code lengths set";
                state.mode = BAD;
                break;
              }
              state.have = 0;
              state.mode = CODELENS;
            case CODELENS:
              while (state.have < state.nlen + state.ndist) {
                for (; ; ) {
                  here = state.lencode[hold & (1 << state.lenbits) - 1];
                  here_bits = here >>> 24;
                  here_op = here >>> 16 & 255;
                  here_val = here & 65535;
                  if (here_bits <= bits) {
                    break;
                  }
                  if (have === 0) {
                    break inf_leave;
                  }
                  have--;
                  hold += input[next++] << bits;
                  bits += 8;
                }
                if (here_val < 16) {
                  hold >>>= here_bits;
                  bits -= here_bits;
                  state.lens[state.have++] = here_val;
                } else {
                  if (here_val === 16) {
                    n = here_bits + 2;
                    while (bits < n) {
                      if (have === 0) {
                        break inf_leave;
                      }
                      have--;
                      hold += input[next++] << bits;
                      bits += 8;
                    }
                    hold >>>= here_bits;
                    bits -= here_bits;
                    if (state.have === 0) {
                      strm.msg = "invalid bit length repeat";
                      state.mode = BAD;
                      break;
                    }
                    len = state.lens[state.have - 1];
                    copy = 3 + (hold & 3);
                    hold >>>= 2;
                    bits -= 2;
                  } else if (here_val === 17) {
                    n = here_bits + 3;
                    while (bits < n) {
                      if (have === 0) {
                        break inf_leave;
                      }
                      have--;
                      hold += input[next++] << bits;
                      bits += 8;
                    }
                    hold >>>= here_bits;
                    bits -= here_bits;
                    len = 0;
                    copy = 3 + (hold & 7);
                    hold >>>= 3;
                    bits -= 3;
                  } else {
                    n = here_bits + 7;
                    while (bits < n) {
                      if (have === 0) {
                        break inf_leave;
                      }
                      have--;
                      hold += input[next++] << bits;
                      bits += 8;
                    }
                    hold >>>= here_bits;
                    bits -= here_bits;
                    len = 0;
                    copy = 11 + (hold & 127);
                    hold >>>= 7;
                    bits -= 7;
                  }
                  if (state.have + copy > state.nlen + state.ndist) {
                    strm.msg = "invalid bit length repeat";
                    state.mode = BAD;
                    break;
                  }
                  while (copy--) {
                    state.lens[state.have++] = len;
                  }
                }
              }
              if (state.mode === BAD) {
                break;
              }
              if (state.lens[256] === 0) {
                strm.msg = "invalid code -- missing end-of-block";
                state.mode = BAD;
                break;
              }
              state.lenbits = 9;
              opts = { bits: state.lenbits };
              ret2 = inflate_table(LENS, state.lens, 0, state.nlen, state.lencode, 0, state.work, opts);
              state.lenbits = opts.bits;
              if (ret2) {
                strm.msg = "invalid literal/lengths set";
                state.mode = BAD;
                break;
              }
              state.distbits = 6;
              state.distcode = state.distdyn;
              opts = { bits: state.distbits };
              ret2 = inflate_table(DISTS, state.lens, state.nlen, state.ndist, state.distcode, 0, state.work, opts);
              state.distbits = opts.bits;
              if (ret2) {
                strm.msg = "invalid distances set";
                state.mode = BAD;
                break;
              }
              state.mode = LEN_;
              if (flush === Z_TREES) {
                break inf_leave;
              }
            case LEN_:
              state.mode = LEN;
            case LEN:
              if (have >= 6 && left >= 258) {
                strm.next_out = put;
                strm.avail_out = left;
                strm.next_in = next;
                strm.avail_in = have;
                state.hold = hold;
                state.bits = bits;
                inflate_fast(strm, _out);
                put = strm.next_out;
                output = strm.output;
                left = strm.avail_out;
                next = strm.next_in;
                input = strm.input;
                have = strm.avail_in;
                hold = state.hold;
                bits = state.bits;
                if (state.mode === TYPE) {
                  state.back = -1;
                }
                break;
              }
              state.back = 0;
              for (; ; ) {
                here = state.lencode[hold & (1 << state.lenbits) - 1];
                here_bits = here >>> 24;
                here_op = here >>> 16 & 255;
                here_val = here & 65535;
                if (here_bits <= bits) {
                  break;
                }
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              if (here_op && (here_op & 240) === 0) {
                last_bits = here_bits;
                last_op = here_op;
                last_val = here_val;
                for (; ; ) {
                  here = state.lencode[last_val + ((hold & (1 << last_bits + last_op) - 1) >> last_bits)];
                  here_bits = here >>> 24;
                  here_op = here >>> 16 & 255;
                  here_val = here & 65535;
                  if (last_bits + here_bits <= bits) {
                    break;
                  }
                  if (have === 0) {
                    break inf_leave;
                  }
                  have--;
                  hold += input[next++] << bits;
                  bits += 8;
                }
                hold >>>= last_bits;
                bits -= last_bits;
                state.back += last_bits;
              }
              hold >>>= here_bits;
              bits -= here_bits;
              state.back += here_bits;
              state.length = here_val;
              if (here_op === 0) {
                state.mode = LIT;
                break;
              }
              if (here_op & 32) {
                state.back = -1;
                state.mode = TYPE;
                break;
              }
              if (here_op & 64) {
                strm.msg = "invalid literal/length code";
                state.mode = BAD;
                break;
              }
              state.extra = here_op & 15;
              state.mode = LENEXT;
            case LENEXT:
              if (state.extra) {
                n = state.extra;
                while (bits < n) {
                  if (have === 0) {
                    break inf_leave;
                  }
                  have--;
                  hold += input[next++] << bits;
                  bits += 8;
                }
                state.length += hold & (1 << state.extra) - 1;
                hold >>>= state.extra;
                bits -= state.extra;
                state.back += state.extra;
              }
              state.was = state.length;
              state.mode = DIST;
            case DIST:
              for (; ; ) {
                here = state.distcode[hold & (1 << state.distbits) - 1];
                here_bits = here >>> 24;
                here_op = here >>> 16 & 255;
                here_val = here & 65535;
                if (here_bits <= bits) {
                  break;
                }
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              if ((here_op & 240) === 0) {
                last_bits = here_bits;
                last_op = here_op;
                last_val = here_val;
                for (; ; ) {
                  here = state.distcode[last_val + ((hold & (1 << last_bits + last_op) - 1) >> last_bits)];
                  here_bits = here >>> 24;
                  here_op = here >>> 16 & 255;
                  here_val = here & 65535;
                  if (last_bits + here_bits <= bits) {
                    break;
                  }
                  if (have === 0) {
                    break inf_leave;
                  }
                  have--;
                  hold += input[next++] << bits;
                  bits += 8;
                }
                hold >>>= last_bits;
                bits -= last_bits;
                state.back += last_bits;
              }
              hold >>>= here_bits;
              bits -= here_bits;
              state.back += here_bits;
              if (here_op & 64) {
                strm.msg = "invalid distance code";
                state.mode = BAD;
                break;
              }
              state.offset = here_val;
              state.extra = here_op & 15;
              state.mode = DISTEXT;
            case DISTEXT:
              if (state.extra) {
                n = state.extra;
                while (bits < n) {
                  if (have === 0) {
                    break inf_leave;
                  }
                  have--;
                  hold += input[next++] << bits;
                  bits += 8;
                }
                state.offset += hold & (1 << state.extra) - 1;
                hold >>>= state.extra;
                bits -= state.extra;
                state.back += state.extra;
              }
              if (state.offset > state.dmax) {
                strm.msg = "invalid distance too far back";
                state.mode = BAD;
                break;
              }
              state.mode = MATCH;
            case MATCH:
              if (left === 0) {
                break inf_leave;
              }
              copy = _out - left;
              if (state.offset > copy) {
                copy = state.offset - copy;
                if (copy > state.whave) {
                  if (state.sane) {
                    strm.msg = "invalid distance too far back";
                    state.mode = BAD;
                    break;
                  }
                }
                if (copy > state.wnext) {
                  copy -= state.wnext;
                  from = state.wsize - copy;
                } else {
                  from = state.wnext - copy;
                }
                if (copy > state.length) {
                  copy = state.length;
                }
                from_source = state.window;
              } else {
                from_source = output;
                from = put - state.offset;
                copy = state.length;
              }
              if (copy > left) {
                copy = left;
              }
              left -= copy;
              state.length -= copy;
              do {
                output[put++] = from_source[from++];
              } while (--copy);
              if (state.length === 0) {
                state.mode = LEN;
              }
              break;
            case LIT:
              if (left === 0) {
                break inf_leave;
              }
              output[put++] = state.length;
              left--;
              state.mode = LEN;
              break;
            case CHECK:
              if (state.wrap) {
                while (bits < 32) {
                  if (have === 0) {
                    break inf_leave;
                  }
                  have--;
                  hold |= input[next++] << bits;
                  bits += 8;
                }
                _out -= left;
                strm.total_out += _out;
                state.total += _out;
                if (_out) {
                  strm.adler = state.check = /*UPDATE(state.check, put - _out, _out);*/
                  state.flags ? crc32(state.check, output, _out, put - _out) : adler32(state.check, output, _out, put - _out);
                }
                _out = left;
                if ((state.flags ? hold : zswap32(hold)) !== state.check) {
                  strm.msg = "incorrect data check";
                  state.mode = BAD;
                  break;
                }
                hold = 0;
                bits = 0;
              }
              state.mode = LENGTH;
            case LENGTH:
              if (state.wrap && state.flags) {
                while (bits < 32) {
                  if (have === 0) {
                    break inf_leave;
                  }
                  have--;
                  hold += input[next++] << bits;
                  bits += 8;
                }
                if (hold !== (state.total & 4294967295)) {
                  strm.msg = "incorrect length check";
                  state.mode = BAD;
                  break;
                }
                hold = 0;
                bits = 0;
              }
              state.mode = DONE;
            case DONE:
              ret2 = Z_STREAM_END;
              break inf_leave;
            case BAD:
              ret2 = Z_DATA_ERROR;
              break inf_leave;
            case MEM:
              return Z_MEM_ERROR;
            case SYNC:
            default:
              return Z_STREAM_ERROR;
          }
        }
      strm.next_out = put;
      strm.avail_out = left;
      strm.next_in = next;
      strm.avail_in = have;
      state.hold = hold;
      state.bits = bits;
      if (state.wsize || _out !== strm.avail_out && state.mode < BAD && (state.mode < CHECK || flush !== Z_FINISH)) {
        if (updatewindow(strm, strm.output, strm.next_out, _out - strm.avail_out)) {
          state.mode = MEM;
          return Z_MEM_ERROR;
        }
      }
      _in -= strm.avail_in;
      _out -= strm.avail_out;
      strm.total_in += _in;
      strm.total_out += _out;
      state.total += _out;
      if (state.wrap && _out) {
        strm.adler = state.check = /*UPDATE(state.check, strm.next_out - _out, _out);*/
        state.flags ? crc32(state.check, output, _out, strm.next_out - _out) : adler32(state.check, output, _out, strm.next_out - _out);
      }
      strm.data_type = state.bits + (state.last ? 64 : 0) + (state.mode === TYPE ? 128 : 0) + (state.mode === LEN_ || state.mode === COPY_ ? 256 : 0);
      if ((_in === 0 && _out === 0 || flush === Z_FINISH) && ret2 === Z_OK) {
        ret2 = Z_BUF_ERROR;
      }
      return ret2;
    }
    function inflateEnd(strm) {
      if (!strm || !strm.state) {
        return Z_STREAM_ERROR;
      }
      var state = strm.state;
      if (state.window) {
        state.window = null;
      }
      strm.state = null;
      return Z_OK;
    }
    function inflateGetHeader(strm, head) {
      var state;
      if (!strm || !strm.state) {
        return Z_STREAM_ERROR;
      }
      state = strm.state;
      if ((state.wrap & 2) === 0) {
        return Z_STREAM_ERROR;
      }
      state.head = head;
      head.done = false;
      return Z_OK;
    }
    function inflateSetDictionary(strm, dictionary) {
      var dictLength = dictionary.length;
      var state;
      var dictid;
      var ret2;
      if (!strm || !strm.state) {
        return Z_STREAM_ERROR;
      }
      state = strm.state;
      if (state.wrap !== 0 && state.mode !== DICT) {
        return Z_STREAM_ERROR;
      }
      if (state.mode === DICT) {
        dictid = 1;
        dictid = adler32(dictid, dictionary, dictLength, 0);
        if (dictid !== state.check) {
          return Z_DATA_ERROR;
        }
      }
      ret2 = updatewindow(strm, dictionary, dictLength, dictLength);
      if (ret2) {
        state.mode = MEM;
        return Z_MEM_ERROR;
      }
      state.havedict = 1;
      return Z_OK;
    }
    exports2.inflateReset = inflateReset;
    exports2.inflateReset2 = inflateReset2;
    exports2.inflateResetKeep = inflateResetKeep;
    exports2.inflateInit = inflateInit;
    exports2.inflateInit2 = inflateInit2;
    exports2.inflate = inflate;
    exports2.inflateEnd = inflateEnd;
    exports2.inflateGetHeader = inflateGetHeader;
    exports2.inflateSetDictionary = inflateSetDictionary;
    exports2.inflateInfo = "pako inflate (from Nodeca project)";
  }
});

// ../../../node_modules/pako/lib/zlib/constants.js
var require_constants = __commonJS({
  "../../../node_modules/pako/lib/zlib/constants.js"(exports2, module2) {
    "use strict";
    module2.exports = {
      /* Allowed flush values; see deflate() and inflate() below for details */
      Z_NO_FLUSH: 0,
      Z_PARTIAL_FLUSH: 1,
      Z_SYNC_FLUSH: 2,
      Z_FULL_FLUSH: 3,
      Z_FINISH: 4,
      Z_BLOCK: 5,
      Z_TREES: 6,
      /* Return codes for the compression/decompression functions. Negative values
      * are errors, positive values are used for special but normal events.
      */
      Z_OK: 0,
      Z_STREAM_END: 1,
      Z_NEED_DICT: 2,
      Z_ERRNO: -1,
      Z_STREAM_ERROR: -2,
      Z_DATA_ERROR: -3,
      //Z_MEM_ERROR:     -4,
      Z_BUF_ERROR: -5,
      //Z_VERSION_ERROR: -6,
      /* compression levels */
      Z_NO_COMPRESSION: 0,
      Z_BEST_SPEED: 1,
      Z_BEST_COMPRESSION: 9,
      Z_DEFAULT_COMPRESSION: -1,
      Z_FILTERED: 1,
      Z_HUFFMAN_ONLY: 2,
      Z_RLE: 3,
      Z_FIXED: 4,
      Z_DEFAULT_STRATEGY: 0,
      /* Possible values of the data_type field (though see inflate()) */
      Z_BINARY: 0,
      Z_TEXT: 1,
      //Z_ASCII:                1, // = Z_TEXT (deprecated)
      Z_UNKNOWN: 2,
      /* The deflate compression method */
      Z_DEFLATED: 8
      //Z_NULL:                 null // Use -1 or null inline, depending on var type
    };
  }
});

// ../../../node_modules/pako/lib/zlib/gzheader.js
var require_gzheader = __commonJS({
  "../../../node_modules/pako/lib/zlib/gzheader.js"(exports2, module2) {
    "use strict";
    function GZheader() {
      this.text = 0;
      this.time = 0;
      this.xflags = 0;
      this.os = 0;
      this.extra = null;
      this.extra_len = 0;
      this.name = "";
      this.comment = "";
      this.hcrc = 0;
      this.done = false;
    }
    module2.exports = GZheader;
  }
});

// ../../../node_modules/pako/lib/inflate.js
var require_inflate2 = __commonJS({
  "../../../node_modules/pako/lib/inflate.js"(exports2) {
    "use strict";
    var zlib_inflate = require_inflate();
    var utils = require_common();
    var strings = require_strings();
    var c = require_constants();
    var msg = require_messages();
    var ZStream = require_zstream();
    var GZheader = require_gzheader();
    var toString = Object.prototype.toString;
    function Inflate(options) {
      if (!(this instanceof Inflate))
        return new Inflate(options);
      this.options = utils.assign({
        chunkSize: 16384,
        windowBits: 0,
        to: ""
      }, options || {});
      var opt = this.options;
      if (opt.raw && opt.windowBits >= 0 && opt.windowBits < 16) {
        opt.windowBits = -opt.windowBits;
        if (opt.windowBits === 0) {
          opt.windowBits = -15;
        }
      }
      if (opt.windowBits >= 0 && opt.windowBits < 16 && !(options && options.windowBits)) {
        opt.windowBits += 32;
      }
      if (opt.windowBits > 15 && opt.windowBits < 48) {
        if ((opt.windowBits & 15) === 0) {
          opt.windowBits |= 15;
        }
      }
      this.err = 0;
      this.msg = "";
      this.ended = false;
      this.chunks = [];
      this.strm = new ZStream();
      this.strm.avail_out = 0;
      var status = zlib_inflate.inflateInit2(
        this.strm,
        opt.windowBits
      );
      if (status !== c.Z_OK) {
        throw new Error(msg[status]);
      }
      this.header = new GZheader();
      zlib_inflate.inflateGetHeader(this.strm, this.header);
      if (opt.dictionary) {
        if (typeof opt.dictionary === "string") {
          opt.dictionary = strings.string2buf(opt.dictionary);
        } else if (toString.call(opt.dictionary) === "[object ArrayBuffer]") {
          opt.dictionary = new Uint8Array(opt.dictionary);
        }
        if (opt.raw) {
          status = zlib_inflate.inflateSetDictionary(this.strm, opt.dictionary);
          if (status !== c.Z_OK) {
            throw new Error(msg[status]);
          }
        }
      }
    }
    Inflate.prototype.push = function(data, mode) {
      var strm = this.strm;
      var chunkSize = this.options.chunkSize;
      var dictionary = this.options.dictionary;
      var status, _mode;
      var next_out_utf8, tail, utf8str;
      var allowBufError = false;
      if (this.ended) {
        return false;
      }
      _mode = mode === ~~mode ? mode : mode === true ? c.Z_FINISH : c.Z_NO_FLUSH;
      if (typeof data === "string") {
        strm.input = strings.binstring2buf(data);
      } else if (toString.call(data) === "[object ArrayBuffer]") {
        strm.input = new Uint8Array(data);
      } else {
        strm.input = data;
      }
      strm.next_in = 0;
      strm.avail_in = strm.input.length;
      do {
        if (strm.avail_out === 0) {
          strm.output = new utils.Buf8(chunkSize);
          strm.next_out = 0;
          strm.avail_out = chunkSize;
        }
        status = zlib_inflate.inflate(strm, c.Z_NO_FLUSH);
        if (status === c.Z_NEED_DICT && dictionary) {
          status = zlib_inflate.inflateSetDictionary(this.strm, dictionary);
        }
        if (status === c.Z_BUF_ERROR && allowBufError === true) {
          status = c.Z_OK;
          allowBufError = false;
        }
        if (status !== c.Z_STREAM_END && status !== c.Z_OK) {
          this.onEnd(status);
          this.ended = true;
          return false;
        }
        if (strm.next_out) {
          if (strm.avail_out === 0 || status === c.Z_STREAM_END || strm.avail_in === 0 && (_mode === c.Z_FINISH || _mode === c.Z_SYNC_FLUSH)) {
            if (this.options.to === "string") {
              next_out_utf8 = strings.utf8border(strm.output, strm.next_out);
              tail = strm.next_out - next_out_utf8;
              utf8str = strings.buf2string(strm.output, next_out_utf8);
              strm.next_out = tail;
              strm.avail_out = chunkSize - tail;
              if (tail) {
                utils.arraySet(strm.output, strm.output, next_out_utf8, tail, 0);
              }
              this.onData(utf8str);
            } else {
              this.onData(utils.shrinkBuf(strm.output, strm.next_out));
            }
          }
        }
        if (strm.avail_in === 0 && strm.avail_out === 0) {
          allowBufError = true;
        }
      } while ((strm.avail_in > 0 || strm.avail_out === 0) && status !== c.Z_STREAM_END);
      if (status === c.Z_STREAM_END) {
        _mode = c.Z_FINISH;
      }
      if (_mode === c.Z_FINISH) {
        status = zlib_inflate.inflateEnd(this.strm);
        this.onEnd(status);
        this.ended = true;
        return status === c.Z_OK;
      }
      if (_mode === c.Z_SYNC_FLUSH) {
        this.onEnd(c.Z_OK);
        strm.avail_out = 0;
        return true;
      }
      return true;
    };
    Inflate.prototype.onData = function(chunk) {
      this.chunks.push(chunk);
    };
    Inflate.prototype.onEnd = function(status) {
      if (status === c.Z_OK) {
        if (this.options.to === "string") {
          this.result = this.chunks.join("");
        } else {
          this.result = utils.flattenChunks(this.chunks);
        }
      }
      this.chunks = [];
      this.err = status;
      this.msg = this.strm.msg;
    };
    function inflate(input, options) {
      var inflator = new Inflate(options);
      inflator.push(input, true);
      if (inflator.err) {
        throw inflator.msg || msg[inflator.err];
      }
      return inflator.result;
    }
    function inflateRaw(input, options) {
      options = options || {};
      options.raw = true;
      return inflate(input, options);
    }
    exports2.Inflate = Inflate;
    exports2.inflate = inflate;
    exports2.inflateRaw = inflateRaw;
    exports2.ungzip = inflate;
  }
});

// ../../../node_modules/pako/index.js
var require_pako = __commonJS({
  "../../../node_modules/pako/index.js"(exports2, module2) {
    "use strict";
    var assign = require_common().assign;
    var deflate = require_deflate2();
    var inflate = require_inflate2();
    var constants = require_constants();
    var pako = {};
    assign(pako, deflate, inflate, constants);
    module2.exports = pako;
  }
});

// ../../../node_modules/jszip/lib/flate.js
var require_flate = __commonJS({
  "../../../node_modules/jszip/lib/flate.js"(exports2) {
    "use strict";
    var USE_TYPEDARRAY = typeof Uint8Array !== "undefined" && typeof Uint16Array !== "undefined" && typeof Uint32Array !== "undefined";
    var pako = require_pako();
    var utils = require_utils();
    var GenericWorker = require_GenericWorker();
    var ARRAY_TYPE = USE_TYPEDARRAY ? "uint8array" : "array";
    exports2.magic = "\b\0";
    function FlateWorker(action, options) {
      GenericWorker.call(this, "FlateWorker/" + action);
      this._pako = null;
      this._pakoAction = action;
      this._pakoOptions = options;
      this.meta = {};
    }
    utils.inherits(FlateWorker, GenericWorker);
    FlateWorker.prototype.processChunk = function(chunk) {
      this.meta = chunk.meta;
      if (this._pako === null) {
        this._createPako();
      }
      this._pako.push(utils.transformTo(ARRAY_TYPE, chunk.data), false);
    };
    FlateWorker.prototype.flush = function() {
      GenericWorker.prototype.flush.call(this);
      if (this._pako === null) {
        this._createPako();
      }
      this._pako.push([], true);
    };
    FlateWorker.prototype.cleanUp = function() {
      GenericWorker.prototype.cleanUp.call(this);
      this._pako = null;
    };
    FlateWorker.prototype._createPako = function() {
      this._pako = new pako[this._pakoAction]({
        raw: true,
        level: this._pakoOptions.level || -1
        // default compression
      });
      var self2 = this;
      this._pako.onData = function(data) {
        self2.push({
          data,
          meta: self2.meta
        });
      };
    };
    exports2.compressWorker = function(compressionOptions) {
      return new FlateWorker("Deflate", compressionOptions);
    };
    exports2.uncompressWorker = function() {
      return new FlateWorker("Inflate", {});
    };
  }
});

// ../../../node_modules/jszip/lib/compressions.js
var require_compressions = __commonJS({
  "../../../node_modules/jszip/lib/compressions.js"(exports2) {
    "use strict";
    var GenericWorker = require_GenericWorker();
    exports2.STORE = {
      magic: "\0\0",
      compressWorker: function() {
        return new GenericWorker("STORE compression");
      },
      uncompressWorker: function() {
        return new GenericWorker("STORE decompression");
      }
    };
    exports2.DEFLATE = require_flate();
  }
});

// ../../../node_modules/jszip/lib/signature.js
var require_signature = __commonJS({
  "../../../node_modules/jszip/lib/signature.js"(exports2) {
    "use strict";
    exports2.LOCAL_FILE_HEADER = "PK";
    exports2.CENTRAL_FILE_HEADER = "PK";
    exports2.CENTRAL_DIRECTORY_END = "PK";
    exports2.ZIP64_CENTRAL_DIRECTORY_LOCATOR = "PK\x07";
    exports2.ZIP64_CENTRAL_DIRECTORY_END = "PK";
    exports2.DATA_DESCRIPTOR = "PK\x07\b";
  }
});

// ../../../node_modules/jszip/lib/generate/ZipFileWorker.js
var require_ZipFileWorker = __commonJS({
  "../../../node_modules/jszip/lib/generate/ZipFileWorker.js"(exports2, module2) {
    "use strict";
    var utils = require_utils();
    var GenericWorker = require_GenericWorker();
    var utf8 = require_utf8();
    var crc32 = require_crc32();
    var signature = require_signature();
    var decToHex = function(dec, bytes) {
      var hex = "", i;
      for (i = 0; i < bytes; i++) {
        hex += String.fromCharCode(dec & 255);
        dec = dec >>> 8;
      }
      return hex;
    };
    var generateUnixExternalFileAttr = function(unixPermissions, isDir) {
      var result = unixPermissions;
      if (!unixPermissions) {
        result = isDir ? 16893 : 33204;
      }
      return (result & 65535) << 16;
    };
    var generateDosExternalFileAttr = function(dosPermissions) {
      return (dosPermissions || 0) & 63;
    };
    var generateZipParts = function(streamInfo, streamedContent, streamingEnded, offset, platform, encodeFileName) {
      var file = streamInfo["file"], compression = streamInfo["compression"], useCustomEncoding = encodeFileName !== utf8.utf8encode, encodedFileName = utils.transformTo("string", encodeFileName(file.name)), utfEncodedFileName = utils.transformTo("string", utf8.utf8encode(file.name)), comment = file.comment, encodedComment = utils.transformTo("string", encodeFileName(comment)), utfEncodedComment = utils.transformTo("string", utf8.utf8encode(comment)), useUTF8ForFileName = utfEncodedFileName.length !== file.name.length, useUTF8ForComment = utfEncodedComment.length !== comment.length, dosTime, dosDate, extraFields = "", unicodePathExtraField = "", unicodeCommentExtraField = "", dir = file.dir, date = file.date;
      var dataInfo = {
        crc32: 0,
        compressedSize: 0,
        uncompressedSize: 0
      };
      if (!streamedContent || streamingEnded) {
        dataInfo.crc32 = streamInfo["crc32"];
        dataInfo.compressedSize = streamInfo["compressedSize"];
        dataInfo.uncompressedSize = streamInfo["uncompressedSize"];
      }
      var bitflag = 0;
      if (streamedContent) {
        bitflag |= 8;
      }
      if (!useCustomEncoding && (useUTF8ForFileName || useUTF8ForComment)) {
        bitflag |= 2048;
      }
      var extFileAttr = 0;
      var versionMadeBy = 0;
      if (dir) {
        extFileAttr |= 16;
      }
      if (platform === "UNIX") {
        versionMadeBy = 798;
        extFileAttr |= generateUnixExternalFileAttr(file.unixPermissions, dir);
      } else {
        versionMadeBy = 20;
        extFileAttr |= generateDosExternalFileAttr(file.dosPermissions, dir);
      }
      dosTime = date.getUTCHours();
      dosTime = dosTime << 6;
      dosTime = dosTime | date.getUTCMinutes();
      dosTime = dosTime << 5;
      dosTime = dosTime | date.getUTCSeconds() / 2;
      dosDate = date.getUTCFullYear() - 1980;
      dosDate = dosDate << 4;
      dosDate = dosDate | date.getUTCMonth() + 1;
      dosDate = dosDate << 5;
      dosDate = dosDate | date.getUTCDate();
      if (useUTF8ForFileName) {
        unicodePathExtraField = // Version
        decToHex(1, 1) + // NameCRC32
        decToHex(crc32(encodedFileName), 4) + // UnicodeName
        utfEncodedFileName;
        extraFields += // Info-ZIP Unicode Path Extra Field
        "up" + // size
        decToHex(unicodePathExtraField.length, 2) + // content
        unicodePathExtraField;
      }
      if (useUTF8ForComment) {
        unicodeCommentExtraField = // Version
        decToHex(1, 1) + // CommentCRC32
        decToHex(crc32(encodedComment), 4) + // UnicodeName
        utfEncodedComment;
        extraFields += // Info-ZIP Unicode Path Extra Field
        "uc" + // size
        decToHex(unicodeCommentExtraField.length, 2) + // content
        unicodeCommentExtraField;
      }
      var header = "";
      header += "\n\0";
      header += decToHex(bitflag, 2);
      header += compression.magic;
      header += decToHex(dosTime, 2);
      header += decToHex(dosDate, 2);
      header += decToHex(dataInfo.crc32, 4);
      header += decToHex(dataInfo.compressedSize, 4);
      header += decToHex(dataInfo.uncompressedSize, 4);
      header += decToHex(encodedFileName.length, 2);
      header += decToHex(extraFields.length, 2);
      var fileRecord = signature.LOCAL_FILE_HEADER + header + encodedFileName + extraFields;
      var dirRecord = signature.CENTRAL_FILE_HEADER + // version made by (00: DOS)
      decToHex(versionMadeBy, 2) + // file header (common to file and central directory)
      header + // file comment length
      decToHex(encodedComment.length, 2) + // disk number start
      "\0\0\0\0" + // external file attributes
      decToHex(extFileAttr, 4) + // relative offset of local header
      decToHex(offset, 4) + // file name
      encodedFileName + // extra field
      extraFields + // file comment
      encodedComment;
      return {
        fileRecord,
        dirRecord
      };
    };
    var generateCentralDirectoryEnd = function(entriesCount, centralDirLength, localDirLength, comment, encodeFileName) {
      var dirEnd = "";
      var encodedComment = utils.transformTo("string", encodeFileName(comment));
      dirEnd = signature.CENTRAL_DIRECTORY_END + // number of this disk
      "\0\0\0\0" + // total number of entries in the central directory on this disk
      decToHex(entriesCount, 2) + // total number of entries in the central directory
      decToHex(entriesCount, 2) + // size of the central directory   4 bytes
      decToHex(centralDirLength, 4) + // offset of start of central directory with respect to the starting disk number
      decToHex(localDirLength, 4) + // .ZIP file comment length
      decToHex(encodedComment.length, 2) + // .ZIP file comment
      encodedComment;
      return dirEnd;
    };
    var generateDataDescriptors = function(streamInfo) {
      var descriptor = "";
      descriptor = signature.DATA_DESCRIPTOR + // crc-32                          4 bytes
      decToHex(streamInfo["crc32"], 4) + // compressed size                 4 bytes
      decToHex(streamInfo["compressedSize"], 4) + // uncompressed size               4 bytes
      decToHex(streamInfo["uncompressedSize"], 4);
      return descriptor;
    };
    function ZipFileWorker(streamFiles, comment, platform, encodeFileName) {
      GenericWorker.call(this, "ZipFileWorker");
      this.bytesWritten = 0;
      this.zipComment = comment;
      this.zipPlatform = platform;
      this.encodeFileName = encodeFileName;
      this.streamFiles = streamFiles;
      this.accumulate = false;
      this.contentBuffer = [];
      this.dirRecords = [];
      this.currentSourceOffset = 0;
      this.entriesCount = 0;
      this.currentFile = null;
      this._sources = [];
    }
    utils.inherits(ZipFileWorker, GenericWorker);
    ZipFileWorker.prototype.push = function(chunk) {
      var currentFilePercent = chunk.meta.percent || 0;
      var entriesCount = this.entriesCount;
      var remainingFiles = this._sources.length;
      if (this.accumulate) {
        this.contentBuffer.push(chunk);
      } else {
        this.bytesWritten += chunk.data.length;
        GenericWorker.prototype.push.call(this, {
          data: chunk.data,
          meta: {
            currentFile: this.currentFile,
            percent: entriesCount ? (currentFilePercent + 100 * (entriesCount - remainingFiles - 1)) / entriesCount : 100
          }
        });
      }
    };
    ZipFileWorker.prototype.openedSource = function(streamInfo) {
      this.currentSourceOffset = this.bytesWritten;
      this.currentFile = streamInfo["file"].name;
      var streamedContent = this.streamFiles && !streamInfo["file"].dir;
      if (streamedContent) {
        var record = generateZipParts(streamInfo, streamedContent, false, this.currentSourceOffset, this.zipPlatform, this.encodeFileName);
        this.push({
          data: record.fileRecord,
          meta: { percent: 0 }
        });
      } else {
        this.accumulate = true;
      }
    };
    ZipFileWorker.prototype.closedSource = function(streamInfo) {
      this.accumulate = false;
      var streamedContent = this.streamFiles && !streamInfo["file"].dir;
      var record = generateZipParts(streamInfo, streamedContent, true, this.currentSourceOffset, this.zipPlatform, this.encodeFileName);
      this.dirRecords.push(record.dirRecord);
      if (streamedContent) {
        this.push({
          data: generateDataDescriptors(streamInfo),
          meta: { percent: 100 }
        });
      } else {
        this.push({
          data: record.fileRecord,
          meta: { percent: 0 }
        });
        while (this.contentBuffer.length) {
          this.push(this.contentBuffer.shift());
        }
      }
      this.currentFile = null;
    };
    ZipFileWorker.prototype.flush = function() {
      var localDirLength = this.bytesWritten;
      for (var i = 0; i < this.dirRecords.length; i++) {
        this.push({
          data: this.dirRecords[i],
          meta: { percent: 100 }
        });
      }
      var centralDirLength = this.bytesWritten - localDirLength;
      var dirEnd = generateCentralDirectoryEnd(this.dirRecords.length, centralDirLength, localDirLength, this.zipComment, this.encodeFileName);
      this.push({
        data: dirEnd,
        meta: { percent: 100 }
      });
    };
    ZipFileWorker.prototype.prepareNextSource = function() {
      this.previous = this._sources.shift();
      this.openedSource(this.previous.streamInfo);
      if (this.isPaused) {
        this.previous.pause();
      } else {
        this.previous.resume();
      }
    };
    ZipFileWorker.prototype.registerPrevious = function(previous) {
      this._sources.push(previous);
      var self2 = this;
      previous.on("data", function(chunk) {
        self2.processChunk(chunk);
      });
      previous.on("end", function() {
        self2.closedSource(self2.previous.streamInfo);
        if (self2._sources.length) {
          self2.prepareNextSource();
        } else {
          self2.end();
        }
      });
      previous.on("error", function(e) {
        self2.error(e);
      });
      return this;
    };
    ZipFileWorker.prototype.resume = function() {
      if (!GenericWorker.prototype.resume.call(this)) {
        return false;
      }
      if (!this.previous && this._sources.length) {
        this.prepareNextSource();
        return true;
      }
      if (!this.previous && !this._sources.length && !this.generatedError) {
        this.end();
        return true;
      }
    };
    ZipFileWorker.prototype.error = function(e) {
      var sources = this._sources;
      if (!GenericWorker.prototype.error.call(this, e)) {
        return false;
      }
      for (var i = 0; i < sources.length; i++) {
        try {
          sources[i].error(e);
        } catch (e2) {
        }
      }
      return true;
    };
    ZipFileWorker.prototype.lock = function() {
      GenericWorker.prototype.lock.call(this);
      var sources = this._sources;
      for (var i = 0; i < sources.length; i++) {
        sources[i].lock();
      }
    };
    module2.exports = ZipFileWorker;
  }
});

// ../../../node_modules/jszip/lib/generate/index.js
var require_generate = __commonJS({
  "../../../node_modules/jszip/lib/generate/index.js"(exports2) {
    "use strict";
    var compressions = require_compressions();
    var ZipFileWorker = require_ZipFileWorker();
    var getCompression = function(fileCompression, zipCompression) {
      var compressionName = fileCompression || zipCompression;
      var compression = compressions[compressionName];
      if (!compression) {
        throw new Error(compressionName + " is not a valid compression method !");
      }
      return compression;
    };
    exports2.generateWorker = function(zip, options, comment) {
      var zipFileWorker = new ZipFileWorker(options.streamFiles, comment, options.platform, options.encodeFileName);
      var entriesCount = 0;
      try {
        zip.forEach(function(relativePath, file) {
          entriesCount++;
          var compression = getCompression(file.options.compression, options.compression);
          var compressionOptions = file.options.compressionOptions || options.compressionOptions || {};
          var dir = file.dir, date = file.date;
          file._compressWorker(compression, compressionOptions).withStreamInfo("file", {
            name: relativePath,
            dir,
            date,
            comment: file.comment || "",
            unixPermissions: file.unixPermissions,
            dosPermissions: file.dosPermissions
          }).pipe(zipFileWorker);
        });
        zipFileWorker.entriesCount = entriesCount;
      } catch (e) {
        zipFileWorker.error(e);
      }
      return zipFileWorker;
    };
  }
});

// ../../../node_modules/jszip/lib/nodejs/NodejsStreamInputAdapter.js
var require_NodejsStreamInputAdapter = __commonJS({
  "../../../node_modules/jszip/lib/nodejs/NodejsStreamInputAdapter.js"(exports2, module2) {
    "use strict";
    var utils = require_utils();
    var GenericWorker = require_GenericWorker();
    function NodejsStreamInputAdapter(filename, stream) {
      GenericWorker.call(this, "Nodejs stream input adapter for " + filename);
      this._upstreamEnded = false;
      this._bindStream(stream);
    }
    utils.inherits(NodejsStreamInputAdapter, GenericWorker);
    NodejsStreamInputAdapter.prototype._bindStream = function(stream) {
      var self2 = this;
      this._stream = stream;
      stream.pause();
      stream.on("data", function(chunk) {
        self2.push({
          data: chunk,
          meta: {
            percent: 0
          }
        });
      }).on("error", function(e) {
        if (self2.isPaused) {
          this.generatedError = e;
        } else {
          self2.error(e);
        }
      }).on("end", function() {
        if (self2.isPaused) {
          self2._upstreamEnded = true;
        } else {
          self2.end();
        }
      });
    };
    NodejsStreamInputAdapter.prototype.pause = function() {
      if (!GenericWorker.prototype.pause.call(this)) {
        return false;
      }
      this._stream.pause();
      return true;
    };
    NodejsStreamInputAdapter.prototype.resume = function() {
      if (!GenericWorker.prototype.resume.call(this)) {
        return false;
      }
      if (this._upstreamEnded) {
        this.end();
      } else {
        this._stream.resume();
      }
      return true;
    };
    module2.exports = NodejsStreamInputAdapter;
  }
});

// ../../../node_modules/jszip/lib/object.js
var require_object = __commonJS({
  "../../../node_modules/jszip/lib/object.js"(exports2, module2) {
    "use strict";
    var utf8 = require_utf8();
    var utils = require_utils();
    var GenericWorker = require_GenericWorker();
    var StreamHelper = require_StreamHelper();
    var defaults = require_defaults();
    var CompressedObject = require_compressedObject();
    var ZipObject = require_zipObject();
    var generate = require_generate();
    var nodejsUtils = require_nodejsUtils();
    var NodejsStreamInputAdapter = require_NodejsStreamInputAdapter();
    var fileAdd = function(name, data, originalOptions) {
      var dataType = utils.getTypeOf(data), parent;
      var o = utils.extend(originalOptions || {}, defaults);
      o.date = o.date || /* @__PURE__ */ new Date();
      if (o.compression !== null) {
        o.compression = o.compression.toUpperCase();
      }
      if (typeof o.unixPermissions === "string") {
        o.unixPermissions = parseInt(o.unixPermissions, 8);
      }
      if (o.unixPermissions && o.unixPermissions & 16384) {
        o.dir = true;
      }
      if (o.dosPermissions && o.dosPermissions & 16) {
        o.dir = true;
      }
      if (o.dir) {
        name = forceTrailingSlash(name);
      }
      if (o.createFolders && (parent = parentFolder(name))) {
        folderAdd.call(this, parent, true);
      }
      var isUnicodeString = dataType === "string" && o.binary === false && o.base64 === false;
      if (!originalOptions || typeof originalOptions.binary === "undefined") {
        o.binary = !isUnicodeString;
      }
      var isCompressedEmpty = data instanceof CompressedObject && data.uncompressedSize === 0;
      if (isCompressedEmpty || o.dir || !data || data.length === 0) {
        o.base64 = false;
        o.binary = true;
        data = "";
        o.compression = "STORE";
        dataType = "string";
      }
      var zipObjectContent = null;
      if (data instanceof CompressedObject || data instanceof GenericWorker) {
        zipObjectContent = data;
      } else if (nodejsUtils.isNode && nodejsUtils.isStream(data)) {
        zipObjectContent = new NodejsStreamInputAdapter(name, data);
      } else {
        zipObjectContent = utils.prepareContent(name, data, o.binary, o.optimizedBinaryString, o.base64);
      }
      var object = new ZipObject(name, zipObjectContent, o);
      this.files[name] = object;
    };
    var parentFolder = function(path) {
      if (path.slice(-1) === "/") {
        path = path.substring(0, path.length - 1);
      }
      var lastSlash = path.lastIndexOf("/");
      return lastSlash > 0 ? path.substring(0, lastSlash) : "";
    };
    var forceTrailingSlash = function(path) {
      if (path.slice(-1) !== "/") {
        path += "/";
      }
      return path;
    };
    var folderAdd = function(name, createFolders) {
      createFolders = typeof createFolders !== "undefined" ? createFolders : defaults.createFolders;
      name = forceTrailingSlash(name);
      if (!this.files[name]) {
        fileAdd.call(this, name, null, {
          dir: true,
          createFolders
        });
      }
      return this.files[name];
    };
    function isRegExp(object) {
      return Object.prototype.toString.call(object) === "[object RegExp]";
    }
    var out = {
      /**
       * @see loadAsync
       */
      load: function() {
        throw new Error("This method has been removed in JSZip 3.0, please check the upgrade guide.");
      },
      /**
       * Call a callback function for each entry at this folder level.
       * @param {Function} cb the callback function:
       * function (relativePath, file) {...}
       * It takes 2 arguments : the relative path and the file.
       */
      forEach: function(cb) {
        var filename, relativePath, file;
        for (filename in this.files) {
          file = this.files[filename];
          relativePath = filename.slice(this.root.length, filename.length);
          if (relativePath && filename.slice(0, this.root.length) === this.root) {
            cb(relativePath, file);
          }
        }
      },
      /**
       * Filter nested files/folders with the specified function.
       * @param {Function} search the predicate to use :
       * function (relativePath, file) {...}
       * It takes 2 arguments : the relative path and the file.
       * @return {Array} An array of matching elements.
       */
      filter: function(search) {
        var result = [];
        this.forEach(function(relativePath, entry) {
          if (search(relativePath, entry)) {
            result.push(entry);
          }
        });
        return result;
      },
      /**
       * Add a file to the zip file, or search a file.
       * @param   {string|RegExp} name The name of the file to add (if data is defined),
       * the name of the file to find (if no data) or a regex to match files.
       * @param   {String|ArrayBuffer|Uint8Array|Buffer} data  The file data, either raw or base64 encoded
       * @param   {Object} o     File options
       * @return  {JSZip|Object|Array} this JSZip object (when adding a file),
       * a file (when searching by string) or an array of files (when searching by regex).
       */
      file: function(name, data, o) {
        if (arguments.length === 1) {
          if (isRegExp(name)) {
            var regexp = name;
            return this.filter(function(relativePath, file) {
              return !file.dir && regexp.test(relativePath);
            });
          } else {
            var obj2 = this.files[this.root + name];
            if (obj2 && !obj2.dir) {
              return obj2;
            } else {
              return null;
            }
          }
        } else {
          name = this.root + name;
          fileAdd.call(this, name, data, o);
        }
        return this;
      },
      /**
       * Add a directory to the zip file, or search.
       * @param   {String|RegExp} arg The name of the directory to add, or a regex to search folders.
       * @return  {JSZip} an object with the new directory as the root, or an array containing matching folders.
       */
      folder: function(arg) {
        if (!arg) {
          return this;
        }
        if (isRegExp(arg)) {
          return this.filter(function(relativePath, file) {
            return file.dir && arg.test(relativePath);
          });
        }
        var name = this.root + arg;
        var newFolder = folderAdd.call(this, name);
        var ret2 = this.clone();
        ret2.root = newFolder.name;
        return ret2;
      },
      /**
       * Delete a file, or a directory and all sub-files, from the zip
       * @param {string} name the name of the file to delete
       * @return {JSZip} this JSZip object
       */
      remove: function(name) {
        name = this.root + name;
        var file = this.files[name];
        if (!file) {
          if (name.slice(-1) !== "/") {
            name += "/";
          }
          file = this.files[name];
        }
        if (file && !file.dir) {
          delete this.files[name];
        } else {
          var kids = this.filter(function(relativePath, file2) {
            return file2.name.slice(0, name.length) === name;
          });
          for (var i = 0; i < kids.length; i++) {
            delete this.files[kids[i].name];
          }
        }
        return this;
      },
      /**
       * @deprecated This method has been removed in JSZip 3.0, please check the upgrade guide.
       */
      generate: function() {
        throw new Error("This method has been removed in JSZip 3.0, please check the upgrade guide.");
      },
      /**
       * Generate the complete zip file as an internal stream.
       * @param {Object} options the options to generate the zip file :
       * - compression, "STORE" by default.
       * - type, "base64" by default. Values are : string, base64, uint8array, arraybuffer, blob.
       * @return {StreamHelper} the streamed zip file.
       */
      generateInternalStream: function(options) {
        var worker, opts = {};
        try {
          opts = utils.extend(options || {}, {
            streamFiles: false,
            compression: "STORE",
            compressionOptions: null,
            type: "",
            platform: "DOS",
            comment: null,
            mimeType: "application/zip",
            encodeFileName: utf8.utf8encode
          });
          opts.type = opts.type.toLowerCase();
          opts.compression = opts.compression.toUpperCase();
          if (opts.type === "binarystring") {
            opts.type = "string";
          }
          if (!opts.type) {
            throw new Error("No output type specified.");
          }
          utils.checkSupport(opts.type);
          if (opts.platform === "darwin" || opts.platform === "freebsd" || opts.platform === "linux" || opts.platform === "sunos") {
            opts.platform = "UNIX";
          }
          if (opts.platform === "win32") {
            opts.platform = "DOS";
          }
          var comment = opts.comment || this.comment || "";
          worker = generate.generateWorker(this, opts, comment);
        } catch (e) {
          worker = new GenericWorker("error");
          worker.error(e);
        }
        return new StreamHelper(worker, opts.type || "string", opts.mimeType);
      },
      /**
       * Generate the complete zip file asynchronously.
       * @see generateInternalStream
       */
      generateAsync: function(options, onUpdate) {
        return this.generateInternalStream(options).accumulate(onUpdate);
      },
      /**
       * Generate the complete zip file asynchronously.
       * @see generateInternalStream
       */
      generateNodeStream: function(options, onUpdate) {
        options = options || {};
        if (!options.type) {
          options.type = "nodebuffer";
        }
        return this.generateInternalStream(options).toNodejsStream(onUpdate);
      }
    };
    module2.exports = out;
  }
});

// ../../../node_modules/jszip/lib/reader/DataReader.js
var require_DataReader = __commonJS({
  "../../../node_modules/jszip/lib/reader/DataReader.js"(exports2, module2) {
    "use strict";
    var utils = require_utils();
    function DataReader(data) {
      this.data = data;
      this.length = data.length;
      this.index = 0;
      this.zero = 0;
    }
    DataReader.prototype = {
      /**
       * Check that the offset will not go too far.
       * @param {string} offset the additional offset to check.
       * @throws {Error} an Error if the offset is out of bounds.
       */
      checkOffset: function(offset) {
        this.checkIndex(this.index + offset);
      },
      /**
       * Check that the specified index will not be too far.
       * @param {string} newIndex the index to check.
       * @throws {Error} an Error if the index is out of bounds.
       */
      checkIndex: function(newIndex) {
        if (this.length < this.zero + newIndex || newIndex < 0) {
          throw new Error("End of data reached (data length = " + this.length + ", asked index = " + newIndex + "). Corrupted zip ?");
        }
      },
      /**
       * Change the index.
       * @param {number} newIndex The new index.
       * @throws {Error} if the new index is out of the data.
       */
      setIndex: function(newIndex) {
        this.checkIndex(newIndex);
        this.index = newIndex;
      },
      /**
       * Skip the next n bytes.
       * @param {number} n the number of bytes to skip.
       * @throws {Error} if the new index is out of the data.
       */
      skip: function(n) {
        this.setIndex(this.index + n);
      },
      /**
       * Get the byte at the specified index.
       * @param {number} i the index to use.
       * @return {number} a byte.
       */
      byteAt: function() {
      },
      /**
       * Get the next number with a given byte size.
       * @param {number} size the number of bytes to read.
       * @return {number} the corresponding number.
       */
      readInt: function(size) {
        var result = 0, i;
        this.checkOffset(size);
        for (i = this.index + size - 1; i >= this.index; i--) {
          result = (result << 8) + this.byteAt(i);
        }
        this.index += size;
        return result;
      },
      /**
       * Get the next string with a given byte size.
       * @param {number} size the number of bytes to read.
       * @return {string} the corresponding string.
       */
      readString: function(size) {
        return utils.transformTo("string", this.readData(size));
      },
      /**
       * Get raw data without conversion, <size> bytes.
       * @param {number} size the number of bytes to read.
       * @return {Object} the raw data, implementation specific.
       */
      readData: function() {
      },
      /**
       * Find the last occurrence of a zip signature (4 bytes).
       * @param {string} sig the signature to find.
       * @return {number} the index of the last occurrence, -1 if not found.
       */
      lastIndexOfSignature: function() {
      },
      /**
       * Read the signature (4 bytes) at the current position and compare it with sig.
       * @param {string} sig the expected signature
       * @return {boolean} true if the signature matches, false otherwise.
       */
      readAndCheckSignature: function() {
      },
      /**
       * Get the next date.
       * @return {Date} the date.
       */
      readDate: function() {
        var dostime = this.readInt(4);
        return new Date(Date.UTC(
          (dostime >> 25 & 127) + 1980,
          // year
          (dostime >> 21 & 15) - 1,
          // month
          dostime >> 16 & 31,
          // day
          dostime >> 11 & 31,
          // hour
          dostime >> 5 & 63,
          // minute
          (dostime & 31) << 1
        ));
      }
    };
    module2.exports = DataReader;
  }
});

// ../../../node_modules/jszip/lib/reader/ArrayReader.js
var require_ArrayReader = __commonJS({
  "../../../node_modules/jszip/lib/reader/ArrayReader.js"(exports2, module2) {
    "use strict";
    var DataReader = require_DataReader();
    var utils = require_utils();
    function ArrayReader(data) {
      DataReader.call(this, data);
      for (var i = 0; i < this.data.length; i++) {
        data[i] = data[i] & 255;
      }
    }
    utils.inherits(ArrayReader, DataReader);
    ArrayReader.prototype.byteAt = function(i) {
      return this.data[this.zero + i];
    };
    ArrayReader.prototype.lastIndexOfSignature = function(sig) {
      var sig0 = sig.charCodeAt(0), sig1 = sig.charCodeAt(1), sig2 = sig.charCodeAt(2), sig3 = sig.charCodeAt(3);
      for (var i = this.length - 4; i >= 0; --i) {
        if (this.data[i] === sig0 && this.data[i + 1] === sig1 && this.data[i + 2] === sig2 && this.data[i + 3] === sig3) {
          return i - this.zero;
        }
      }
      return -1;
    };
    ArrayReader.prototype.readAndCheckSignature = function(sig) {
      var sig0 = sig.charCodeAt(0), sig1 = sig.charCodeAt(1), sig2 = sig.charCodeAt(2), sig3 = sig.charCodeAt(3), data = this.readData(4);
      return sig0 === data[0] && sig1 === data[1] && sig2 === data[2] && sig3 === data[3];
    };
    ArrayReader.prototype.readData = function(size) {
      this.checkOffset(size);
      if (size === 0) {
        return [];
      }
      var result = this.data.slice(this.zero + this.index, this.zero + this.index + size);
      this.index += size;
      return result;
    };
    module2.exports = ArrayReader;
  }
});

// ../../../node_modules/jszip/lib/reader/StringReader.js
var require_StringReader = __commonJS({
  "../../../node_modules/jszip/lib/reader/StringReader.js"(exports2, module2) {
    "use strict";
    var DataReader = require_DataReader();
    var utils = require_utils();
    function StringReader(data) {
      DataReader.call(this, data);
    }
    utils.inherits(StringReader, DataReader);
    StringReader.prototype.byteAt = function(i) {
      return this.data.charCodeAt(this.zero + i);
    };
    StringReader.prototype.lastIndexOfSignature = function(sig) {
      return this.data.lastIndexOf(sig) - this.zero;
    };
    StringReader.prototype.readAndCheckSignature = function(sig) {
      var data = this.readData(4);
      return sig === data;
    };
    StringReader.prototype.readData = function(size) {
      this.checkOffset(size);
      var result = this.data.slice(this.zero + this.index, this.zero + this.index + size);
      this.index += size;
      return result;
    };
    module2.exports = StringReader;
  }
});

// ../../../node_modules/jszip/lib/reader/Uint8ArrayReader.js
var require_Uint8ArrayReader = __commonJS({
  "../../../node_modules/jszip/lib/reader/Uint8ArrayReader.js"(exports2, module2) {
    "use strict";
    var ArrayReader = require_ArrayReader();
    var utils = require_utils();
    function Uint8ArrayReader(data) {
      ArrayReader.call(this, data);
    }
    utils.inherits(Uint8ArrayReader, ArrayReader);
    Uint8ArrayReader.prototype.readData = function(size) {
      this.checkOffset(size);
      if (size === 0) {
        return new Uint8Array(0);
      }
      var result = this.data.subarray(this.zero + this.index, this.zero + this.index + size);
      this.index += size;
      return result;
    };
    module2.exports = Uint8ArrayReader;
  }
});

// ../../../node_modules/jszip/lib/reader/NodeBufferReader.js
var require_NodeBufferReader = __commonJS({
  "../../../node_modules/jszip/lib/reader/NodeBufferReader.js"(exports2, module2) {
    "use strict";
    var Uint8ArrayReader = require_Uint8ArrayReader();
    var utils = require_utils();
    function NodeBufferReader(data) {
      Uint8ArrayReader.call(this, data);
    }
    utils.inherits(NodeBufferReader, Uint8ArrayReader);
    NodeBufferReader.prototype.readData = function(size) {
      this.checkOffset(size);
      var result = this.data.slice(this.zero + this.index, this.zero + this.index + size);
      this.index += size;
      return result;
    };
    module2.exports = NodeBufferReader;
  }
});

// ../../../node_modules/jszip/lib/reader/readerFor.js
var require_readerFor = __commonJS({
  "../../../node_modules/jszip/lib/reader/readerFor.js"(exports2, module2) {
    "use strict";
    var utils = require_utils();
    var support = require_support();
    var ArrayReader = require_ArrayReader();
    var StringReader = require_StringReader();
    var NodeBufferReader = require_NodeBufferReader();
    var Uint8ArrayReader = require_Uint8ArrayReader();
    module2.exports = function(data) {
      var type = utils.getTypeOf(data);
      utils.checkSupport(type);
      if (type === "string" && !support.uint8array) {
        return new StringReader(data);
      }
      if (type === "nodebuffer") {
        return new NodeBufferReader(data);
      }
      if (support.uint8array) {
        return new Uint8ArrayReader(utils.transformTo("uint8array", data));
      }
      return new ArrayReader(utils.transformTo("array", data));
    };
  }
});

// ../../../node_modules/jszip/lib/zipEntry.js
var require_zipEntry = __commonJS({
  "../../../node_modules/jszip/lib/zipEntry.js"(exports2, module2) {
    "use strict";
    var readerFor = require_readerFor();
    var utils = require_utils();
    var CompressedObject = require_compressedObject();
    var crc32fn = require_crc32();
    var utf8 = require_utf8();
    var compressions = require_compressions();
    var support = require_support();
    var MADE_BY_DOS = 0;
    var MADE_BY_UNIX = 3;
    var findCompression = function(compressionMethod) {
      for (var method in compressions) {
        if (!Object.prototype.hasOwnProperty.call(compressions, method)) {
          continue;
        }
        if (compressions[method].magic === compressionMethod) {
          return compressions[method];
        }
      }
      return null;
    };
    function ZipEntry(options, loadOptions) {
      this.options = options;
      this.loadOptions = loadOptions;
    }
    ZipEntry.prototype = {
      /**
       * say if the file is encrypted.
       * @return {boolean} true if the file is encrypted, false otherwise.
       */
      isEncrypted: function() {
        return (this.bitFlag & 1) === 1;
      },
      /**
       * say if the file has utf-8 filename/comment.
       * @return {boolean} true if the filename/comment is in utf-8, false otherwise.
       */
      useUTF8: function() {
        return (this.bitFlag & 2048) === 2048;
      },
      /**
       * Read the local part of a zip file and add the info in this object.
       * @param {DataReader} reader the reader to use.
       */
      readLocalPart: function(reader) {
        var compression, localExtraFieldsLength;
        reader.skip(22);
        this.fileNameLength = reader.readInt(2);
        localExtraFieldsLength = reader.readInt(2);
        this.fileName = reader.readData(this.fileNameLength);
        reader.skip(localExtraFieldsLength);
        if (this.compressedSize === -1 || this.uncompressedSize === -1) {
          throw new Error("Bug or corrupted zip : didn't get enough information from the central directory (compressedSize === -1 || uncompressedSize === -1)");
        }
        compression = findCompression(this.compressionMethod);
        if (compression === null) {
          throw new Error("Corrupted zip : compression " + utils.pretty(this.compressionMethod) + " unknown (inner file : " + utils.transformTo("string", this.fileName) + ")");
        }
        this.decompressed = new CompressedObject(this.compressedSize, this.uncompressedSize, this.crc32, compression, reader.readData(this.compressedSize));
      },
      /**
       * Read the central part of a zip file and add the info in this object.
       * @param {DataReader} reader the reader to use.
       */
      readCentralPart: function(reader) {
        this.versionMadeBy = reader.readInt(2);
        reader.skip(2);
        this.bitFlag = reader.readInt(2);
        this.compressionMethod = reader.readString(2);
        this.date = reader.readDate();
        this.crc32 = reader.readInt(4);
        this.compressedSize = reader.readInt(4);
        this.uncompressedSize = reader.readInt(4);
        var fileNameLength = reader.readInt(2);
        this.extraFieldsLength = reader.readInt(2);
        this.fileCommentLength = reader.readInt(2);
        this.diskNumberStart = reader.readInt(2);
        this.internalFileAttributes = reader.readInt(2);
        this.externalFileAttributes = reader.readInt(4);
        this.localHeaderOffset = reader.readInt(4);
        if (this.isEncrypted()) {
          throw new Error("Encrypted zip are not supported");
        }
        reader.skip(fileNameLength);
        this.readExtraFields(reader);
        this.parseZIP64ExtraField(reader);
        this.fileComment = reader.readData(this.fileCommentLength);
      },
      /**
       * Parse the external file attributes and get the unix/dos permissions.
       */
      processAttributes: function() {
        this.unixPermissions = null;
        this.dosPermissions = null;
        var madeBy = this.versionMadeBy >> 8;
        this.dir = this.externalFileAttributes & 16 ? true : false;
        if (madeBy === MADE_BY_DOS) {
          this.dosPermissions = this.externalFileAttributes & 63;
        }
        if (madeBy === MADE_BY_UNIX) {
          this.unixPermissions = this.externalFileAttributes >> 16 & 65535;
        }
        if (!this.dir && this.fileNameStr.slice(-1) === "/") {
          this.dir = true;
        }
      },
      /**
       * Parse the ZIP64 extra field and merge the info in the current ZipEntry.
       * @param {DataReader} reader the reader to use.
       */
      parseZIP64ExtraField: function() {
        if (!this.extraFields[1]) {
          return;
        }
        var extraReader = readerFor(this.extraFields[1].value);
        if (this.uncompressedSize === utils.MAX_VALUE_32BITS) {
          this.uncompressedSize = extraReader.readInt(8);
        }
        if (this.compressedSize === utils.MAX_VALUE_32BITS) {
          this.compressedSize = extraReader.readInt(8);
        }
        if (this.localHeaderOffset === utils.MAX_VALUE_32BITS) {
          this.localHeaderOffset = extraReader.readInt(8);
        }
        if (this.diskNumberStart === utils.MAX_VALUE_32BITS) {
          this.diskNumberStart = extraReader.readInt(4);
        }
      },
      /**
       * Read the central part of a zip file and add the info in this object.
       * @param {DataReader} reader the reader to use.
       */
      readExtraFields: function(reader) {
        var end = reader.index + this.extraFieldsLength, extraFieldId, extraFieldLength, extraFieldValue;
        if (!this.extraFields) {
          this.extraFields = {};
        }
        while (reader.index + 4 < end) {
          extraFieldId = reader.readInt(2);
          extraFieldLength = reader.readInt(2);
          extraFieldValue = reader.readData(extraFieldLength);
          this.extraFields[extraFieldId] = {
            id: extraFieldId,
            length: extraFieldLength,
            value: extraFieldValue
          };
        }
        reader.setIndex(end);
      },
      /**
       * Apply an UTF8 transformation if needed.
       */
      handleUTF8: function() {
        var decodeParamType = support.uint8array ? "uint8array" : "array";
        if (this.useUTF8()) {
          this.fileNameStr = utf8.utf8decode(this.fileName);
          this.fileCommentStr = utf8.utf8decode(this.fileComment);
        } else {
          var upath = this.findExtraFieldUnicodePath();
          if (upath !== null) {
            this.fileNameStr = upath;
          } else {
            var fileNameByteArray = utils.transformTo(decodeParamType, this.fileName);
            this.fileNameStr = this.loadOptions.decodeFileName(fileNameByteArray);
          }
          var ucomment = this.findExtraFieldUnicodeComment();
          if (ucomment !== null) {
            this.fileCommentStr = ucomment;
          } else {
            var commentByteArray = utils.transformTo(decodeParamType, this.fileComment);
            this.fileCommentStr = this.loadOptions.decodeFileName(commentByteArray);
          }
        }
      },
      /**
       * Find the unicode path declared in the extra field, if any.
       * @return {String} the unicode path, null otherwise.
       */
      findExtraFieldUnicodePath: function() {
        var upathField = this.extraFields[28789];
        if (upathField) {
          var extraReader = readerFor(upathField.value);
          if (extraReader.readInt(1) !== 1) {
            return null;
          }
          if (crc32fn(this.fileName) !== extraReader.readInt(4)) {
            return null;
          }
          return utf8.utf8decode(extraReader.readData(upathField.length - 5));
        }
        return null;
      },
      /**
       * Find the unicode comment declared in the extra field, if any.
       * @return {String} the unicode comment, null otherwise.
       */
      findExtraFieldUnicodeComment: function() {
        var ucommentField = this.extraFields[25461];
        if (ucommentField) {
          var extraReader = readerFor(ucommentField.value);
          if (extraReader.readInt(1) !== 1) {
            return null;
          }
          if (crc32fn(this.fileComment) !== extraReader.readInt(4)) {
            return null;
          }
          return utf8.utf8decode(extraReader.readData(ucommentField.length - 5));
        }
        return null;
      }
    };
    module2.exports = ZipEntry;
  }
});

// ../../../node_modules/jszip/lib/zipEntries.js
var require_zipEntries = __commonJS({
  "../../../node_modules/jszip/lib/zipEntries.js"(exports2, module2) {
    "use strict";
    var readerFor = require_readerFor();
    var utils = require_utils();
    var sig = require_signature();
    var ZipEntry = require_zipEntry();
    var support = require_support();
    function ZipEntries(loadOptions) {
      this.files = [];
      this.loadOptions = loadOptions;
    }
    ZipEntries.prototype = {
      /**
       * Check that the reader is on the specified signature.
       * @param {string} expectedSignature the expected signature.
       * @throws {Error} if it is an other signature.
       */
      checkSignature: function(expectedSignature) {
        if (!this.reader.readAndCheckSignature(expectedSignature)) {
          this.reader.index -= 4;
          var signature = this.reader.readString(4);
          throw new Error("Corrupted zip or bug: unexpected signature (" + utils.pretty(signature) + ", expected " + utils.pretty(expectedSignature) + ")");
        }
      },
      /**
       * Check if the given signature is at the given index.
       * @param {number} askedIndex the index to check.
       * @param {string} expectedSignature the signature to expect.
       * @return {boolean} true if the signature is here, false otherwise.
       */
      isSignature: function(askedIndex, expectedSignature) {
        var currentIndex = this.reader.index;
        this.reader.setIndex(askedIndex);
        var signature = this.reader.readString(4);
        var result = signature === expectedSignature;
        this.reader.setIndex(currentIndex);
        return result;
      },
      /**
       * Read the end of the central directory.
       */
      readBlockEndOfCentral: function() {
        this.diskNumber = this.reader.readInt(2);
        this.diskWithCentralDirStart = this.reader.readInt(2);
        this.centralDirRecordsOnThisDisk = this.reader.readInt(2);
        this.centralDirRecords = this.reader.readInt(2);
        this.centralDirSize = this.reader.readInt(4);
        this.centralDirOffset = this.reader.readInt(4);
        this.zipCommentLength = this.reader.readInt(2);
        var zipComment = this.reader.readData(this.zipCommentLength);
        var decodeParamType = support.uint8array ? "uint8array" : "array";
        var decodeContent = utils.transformTo(decodeParamType, zipComment);
        this.zipComment = this.loadOptions.decodeFileName(decodeContent);
      },
      /**
       * Read the end of the Zip 64 central directory.
       * Not merged with the method readEndOfCentral :
       * The end of central can coexist with its Zip64 brother,
       * I don't want to read the wrong number of bytes !
       */
      readBlockZip64EndOfCentral: function() {
        this.zip64EndOfCentralSize = this.reader.readInt(8);
        this.reader.skip(4);
        this.diskNumber = this.reader.readInt(4);
        this.diskWithCentralDirStart = this.reader.readInt(4);
        this.centralDirRecordsOnThisDisk = this.reader.readInt(8);
        this.centralDirRecords = this.reader.readInt(8);
        this.centralDirSize = this.reader.readInt(8);
        this.centralDirOffset = this.reader.readInt(8);
        this.zip64ExtensibleData = {};
        var extraDataSize = this.zip64EndOfCentralSize - 44, index = 0, extraFieldId, extraFieldLength, extraFieldValue;
        while (index < extraDataSize) {
          extraFieldId = this.reader.readInt(2);
          extraFieldLength = this.reader.readInt(4);
          extraFieldValue = this.reader.readData(extraFieldLength);
          this.zip64ExtensibleData[extraFieldId] = {
            id: extraFieldId,
            length: extraFieldLength,
            value: extraFieldValue
          };
        }
      },
      /**
       * Read the end of the Zip 64 central directory locator.
       */
      readBlockZip64EndOfCentralLocator: function() {
        this.diskWithZip64CentralDirStart = this.reader.readInt(4);
        this.relativeOffsetEndOfZip64CentralDir = this.reader.readInt(8);
        this.disksCount = this.reader.readInt(4);
        if (this.disksCount > 1) {
          throw new Error("Multi-volumes zip are not supported");
        }
      },
      /**
       * Read the local files, based on the offset read in the central part.
       */
      readLocalFiles: function() {
        var i, file;
        for (i = 0; i < this.files.length; i++) {
          file = this.files[i];
          this.reader.setIndex(file.localHeaderOffset);
          this.checkSignature(sig.LOCAL_FILE_HEADER);
          file.readLocalPart(this.reader);
          file.handleUTF8();
          file.processAttributes();
        }
      },
      /**
       * Read the central directory.
       */
      readCentralDir: function() {
        var file;
        this.reader.setIndex(this.centralDirOffset);
        while (this.reader.readAndCheckSignature(sig.CENTRAL_FILE_HEADER)) {
          file = new ZipEntry({
            zip64: this.zip64
          }, this.loadOptions);
          file.readCentralPart(this.reader);
          this.files.push(file);
        }
        if (this.centralDirRecords !== this.files.length) {
          if (this.centralDirRecords !== 0 && this.files.length === 0) {
            throw new Error("Corrupted zip or bug: expected " + this.centralDirRecords + " records in central dir, got " + this.files.length);
          } else {
          }
        }
      },
      /**
       * Read the end of central directory.
       */
      readEndOfCentral: function() {
        var offset = this.reader.lastIndexOfSignature(sig.CENTRAL_DIRECTORY_END);
        if (offset < 0) {
          var isGarbage = !this.isSignature(0, sig.LOCAL_FILE_HEADER);
          if (isGarbage) {
            throw new Error("Can't find end of central directory : is this a zip file ? If it is, see https://stuk.github.io/jszip/documentation/howto/read_zip.html");
          } else {
            throw new Error("Corrupted zip: can't find end of central directory");
          }
        }
        this.reader.setIndex(offset);
        var endOfCentralDirOffset = offset;
        this.checkSignature(sig.CENTRAL_DIRECTORY_END);
        this.readBlockEndOfCentral();
        if (this.diskNumber === utils.MAX_VALUE_16BITS || this.diskWithCentralDirStart === utils.MAX_VALUE_16BITS || this.centralDirRecordsOnThisDisk === utils.MAX_VALUE_16BITS || this.centralDirRecords === utils.MAX_VALUE_16BITS || this.centralDirSize === utils.MAX_VALUE_32BITS || this.centralDirOffset === utils.MAX_VALUE_32BITS) {
          this.zip64 = true;
          offset = this.reader.lastIndexOfSignature(sig.ZIP64_CENTRAL_DIRECTORY_LOCATOR);
          if (offset < 0) {
            throw new Error("Corrupted zip: can't find the ZIP64 end of central directory locator");
          }
          this.reader.setIndex(offset);
          this.checkSignature(sig.ZIP64_CENTRAL_DIRECTORY_LOCATOR);
          this.readBlockZip64EndOfCentralLocator();
          if (!this.isSignature(this.relativeOffsetEndOfZip64CentralDir, sig.ZIP64_CENTRAL_DIRECTORY_END)) {
            this.relativeOffsetEndOfZip64CentralDir = this.reader.lastIndexOfSignature(sig.ZIP64_CENTRAL_DIRECTORY_END);
            if (this.relativeOffsetEndOfZip64CentralDir < 0) {
              throw new Error("Corrupted zip: can't find the ZIP64 end of central directory");
            }
          }
          this.reader.setIndex(this.relativeOffsetEndOfZip64CentralDir);
          this.checkSignature(sig.ZIP64_CENTRAL_DIRECTORY_END);
          this.readBlockZip64EndOfCentral();
        }
        var expectedEndOfCentralDirOffset = this.centralDirOffset + this.centralDirSize;
        if (this.zip64) {
          expectedEndOfCentralDirOffset += 20;
          expectedEndOfCentralDirOffset += 12 + this.zip64EndOfCentralSize;
        }
        var extraBytes = endOfCentralDirOffset - expectedEndOfCentralDirOffset;
        if (extraBytes > 0) {
          if (this.isSignature(endOfCentralDirOffset, sig.CENTRAL_FILE_HEADER)) {
          } else {
            this.reader.zero = extraBytes;
          }
        } else if (extraBytes < 0) {
          throw new Error("Corrupted zip: missing " + Math.abs(extraBytes) + " bytes.");
        }
      },
      prepareReader: function(data) {
        this.reader = readerFor(data);
      },
      /**
       * Read a zip file and create ZipEntries.
       * @param {String|ArrayBuffer|Uint8Array|Buffer} data the binary string representing a zip file.
       */
      load: function(data) {
        this.prepareReader(data);
        this.readEndOfCentral();
        this.readCentralDir();
        this.readLocalFiles();
      }
    };
    module2.exports = ZipEntries;
  }
});

// ../../../node_modules/jszip/lib/load.js
var require_load = __commonJS({
  "../../../node_modules/jszip/lib/load.js"(exports2, module2) {
    "use strict";
    var utils = require_utils();
    var external = require_external();
    var utf8 = require_utf8();
    var ZipEntries = require_zipEntries();
    var Crc32Probe = require_Crc32Probe();
    var nodejsUtils = require_nodejsUtils();
    function checkEntryCRC32(zipEntry) {
      return new external.Promise(function(resolve, reject) {
        var worker = zipEntry.decompressed.getContentWorker().pipe(new Crc32Probe());
        worker.on("error", function(e) {
          reject(e);
        }).on("end", function() {
          if (worker.streamInfo.crc32 !== zipEntry.decompressed.crc32) {
            reject(new Error("Corrupted zip : CRC32 mismatch"));
          } else {
            resolve();
          }
        }).resume();
      });
    }
    module2.exports = function(data, options) {
      var zip = this;
      options = utils.extend(options || {}, {
        base64: false,
        checkCRC32: false,
        optimizedBinaryString: false,
        createFolders: false,
        decodeFileName: utf8.utf8decode
      });
      if (nodejsUtils.isNode && nodejsUtils.isStream(data)) {
        return external.Promise.reject(new Error("JSZip can't accept a stream when loading a zip file."));
      }
      return utils.prepareContent("the loaded zip file", data, true, options.optimizedBinaryString, options.base64).then(function(data2) {
        var zipEntries = new ZipEntries(options);
        zipEntries.load(data2);
        return zipEntries;
      }).then(function checkCRC32(zipEntries) {
        var promises = [external.Promise.resolve(zipEntries)];
        var files = zipEntries.files;
        if (options.checkCRC32) {
          for (var i = 0; i < files.length; i++) {
            promises.push(checkEntryCRC32(files[i]));
          }
        }
        return external.Promise.all(promises);
      }).then(function addFiles(results) {
        var zipEntries = results.shift();
        var files = zipEntries.files;
        for (var i = 0; i < files.length; i++) {
          var input = files[i];
          var unsafeName = input.fileNameStr;
          var safeName = utils.resolve(input.fileNameStr);
          zip.file(safeName, input.decompressed, {
            binary: true,
            optimizedBinaryString: true,
            date: input.date,
            dir: input.dir,
            comment: input.fileCommentStr.length ? input.fileCommentStr : null,
            unixPermissions: input.unixPermissions,
            dosPermissions: input.dosPermissions,
            createFolders: options.createFolders
          });
          if (!input.dir) {
            zip.file(safeName).unsafeOriginalName = unsafeName;
          }
        }
        if (zipEntries.zipComment.length) {
          zip.comment = zipEntries.zipComment;
        }
        return zip;
      });
    };
  }
});

// ../../../node_modules/jszip/lib/index.js
var require_lib3 = __commonJS({
  "../../../node_modules/jszip/lib/index.js"(exports2, module2) {
    "use strict";
    function JSZip() {
      if (!(this instanceof JSZip)) {
        return new JSZip();
      }
      if (arguments.length) {
        throw new Error("The constructor with parameters has been removed in JSZip 3.0, please check the upgrade guide.");
      }
      this.files = /* @__PURE__ */ Object.create(null);
      this.comment = null;
      this.root = "";
      this.clone = function() {
        var newObj = new JSZip();
        for (var i in this) {
          if (typeof this[i] !== "function") {
            newObj[i] = this[i];
          }
        }
        return newObj;
      };
    }
    JSZip.prototype = require_object();
    JSZip.prototype.loadAsync = require_load();
    JSZip.support = require_support();
    JSZip.defaults = require_defaults();
    JSZip.version = "3.10.1";
    JSZip.loadAsync = function(content, options) {
      return new JSZip().loadAsync(content, options);
    };
    JSZip.external = require_external();
    module2.exports = JSZip;
  }
});

// ../../../node_modules/exceljs/node_modules/readable-stream/lib/internal/streams/stream.js
var require_stream2 = __commonJS({
  "../../../node_modules/exceljs/node_modules/readable-stream/lib/internal/streams/stream.js"(exports2, module2) {
    module2.exports = require("stream");
  }
});

// ../../../node_modules/exceljs/node_modules/readable-stream/lib/internal/streams/buffer_list.js
var require_buffer_list = __commonJS({
  "../../../node_modules/exceljs/node_modules/readable-stream/lib/internal/streams/buffer_list.js"(exports2, module2) {
    "use strict";
    function ownKeys(object, enumerableOnly) {
      var keys = Object.keys(object);
      if (Object.getOwnPropertySymbols) {
        var symbols = Object.getOwnPropertySymbols(object);
        enumerableOnly && (symbols = symbols.filter(function(sym) {
          return Object.getOwnPropertyDescriptor(object, sym).enumerable;
        })), keys.push.apply(keys, symbols);
      }
      return keys;
    }
    function _objectSpread(target) {
      for (var i = 1; i < arguments.length; i++) {
        var source = null != arguments[i] ? arguments[i] : {};
        i % 2 ? ownKeys(Object(source), true).forEach(function(key) {
          _defineProperty(target, key, source[key]);
        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function(key) {
          Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
        });
      }
      return target;
    }
    function _defineProperty(obj2, key, value) {
      key = _toPropertyKey(key);
      if (key in obj2) {
        Object.defineProperty(obj2, key, { value, enumerable: true, configurable: true, writable: true });
      } else {
        obj2[key] = value;
      }
      return obj2;
    }
    function _classCallCheck(instance, Constructor) {
      if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
      }
    }
    function _defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor)
          descriptor.writable = true;
        Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor);
      }
    }
    function _createClass(Constructor, protoProps, staticProps) {
      if (protoProps)
        _defineProperties(Constructor.prototype, protoProps);
      if (staticProps)
        _defineProperties(Constructor, staticProps);
      Object.defineProperty(Constructor, "prototype", { writable: false });
      return Constructor;
    }
    function _toPropertyKey(arg) {
      var key = _toPrimitive(arg, "string");
      return typeof key === "symbol" ? key : String(key);
    }
    function _toPrimitive(input, hint) {
      if (typeof input !== "object" || input === null)
        return input;
      var prim = input[Symbol.toPrimitive];
      if (prim !== void 0) {
        var res = prim.call(input, hint || "default");
        if (typeof res !== "object")
          return res;
        throw new TypeError("@@toPrimitive must return a primitive value.");
      }
      return (hint === "string" ? String : Number)(input);
    }
    var _require = require("buffer");
    var Buffer2 = _require.Buffer;
    var _require2 = require("util");
    var inspect = _require2.inspect;
    var custom = inspect && inspect.custom || "inspect";
    function copyBuffer(src, target, offset) {
      Buffer2.prototype.copy.call(src, target, offset);
    }
    module2.exports = /* @__PURE__ */ function() {
      function BufferList() {
        _classCallCheck(this, BufferList);
        this.head = null;
        this.tail = null;
        this.length = 0;
      }
      _createClass(BufferList, [{
        key: "push",
        value: function push(v) {
          var entry = {
            data: v,
            next: null
          };
          if (this.length > 0)
            this.tail.next = entry;
          else
            this.head = entry;
          this.tail = entry;
          ++this.length;
        }
      }, {
        key: "unshift",
        value: function unshift(v) {
          var entry = {
            data: v,
            next: this.head
          };
          if (this.length === 0)
            this.tail = entry;
          this.head = entry;
          ++this.length;
        }
      }, {
        key: "shift",
        value: function shift() {
          if (this.length === 0)
            return;
          var ret2 = this.head.data;
          if (this.length === 1)
            this.head = this.tail = null;
          else
            this.head = this.head.next;
          --this.length;
          return ret2;
        }
      }, {
        key: "clear",
        value: function clear() {
          this.head = this.tail = null;
          this.length = 0;
        }
      }, {
        key: "join",
        value: function join(s) {
          if (this.length === 0)
            return "";
          var p = this.head;
          var ret2 = "" + p.data;
          while (p = p.next)
            ret2 += s + p.data;
          return ret2;
        }
      }, {
        key: "concat",
        value: function concat(n) {
          if (this.length === 0)
            return Buffer2.alloc(0);
          var ret2 = Buffer2.allocUnsafe(n >>> 0);
          var p = this.head;
          var i = 0;
          while (p) {
            copyBuffer(p.data, ret2, i);
            i += p.data.length;
            p = p.next;
          }
          return ret2;
        }
        // Consumes a specified amount of bytes or characters from the buffered data.
      }, {
        key: "consume",
        value: function consume(n, hasStrings) {
          var ret2;
          if (n < this.head.data.length) {
            ret2 = this.head.data.slice(0, n);
            this.head.data = this.head.data.slice(n);
          } else if (n === this.head.data.length) {
            ret2 = this.shift();
          } else {
            ret2 = hasStrings ? this._getString(n) : this._getBuffer(n);
          }
          return ret2;
        }
      }, {
        key: "first",
        value: function first() {
          return this.head.data;
        }
        // Consumes a specified amount of characters from the buffered data.
      }, {
        key: "_getString",
        value: function _getString(n) {
          var p = this.head;
          var c = 1;
          var ret2 = p.data;
          n -= ret2.length;
          while (p = p.next) {
            var str = p.data;
            var nb = n > str.length ? str.length : n;
            if (nb === str.length)
              ret2 += str;
            else
              ret2 += str.slice(0, n);
            n -= nb;
            if (n === 0) {
              if (nb === str.length) {
                ++c;
                if (p.next)
                  this.head = p.next;
                else
                  this.head = this.tail = null;
              } else {
                this.head = p;
                p.data = str.slice(nb);
              }
              break;
            }
            ++c;
          }
          this.length -= c;
          return ret2;
        }
        // Consumes a specified amount of bytes from the buffered data.
      }, {
        key: "_getBuffer",
        value: function _getBuffer(n) {
          var ret2 = Buffer2.allocUnsafe(n);
          var p = this.head;
          var c = 1;
          p.data.copy(ret2);
          n -= p.data.length;
          while (p = p.next) {
            var buf = p.data;
            var nb = n > buf.length ? buf.length : n;
            buf.copy(ret2, ret2.length - n, 0, nb);
            n -= nb;
            if (n === 0) {
              if (nb === buf.length) {
                ++c;
                if (p.next)
                  this.head = p.next;
                else
                  this.head = this.tail = null;
              } else {
                this.head = p;
                p.data = buf.slice(nb);
              }
              break;
            }
            ++c;
          }
          this.length -= c;
          return ret2;
        }
        // Make sure the linked list only shows the minimal necessary information.
      }, {
        key: custom,
        value: function value(_2, options) {
          return inspect(this, _objectSpread(_objectSpread({}, options), {}, {
            // Only inspect one level.
            depth: 0,
            // It should not recurse.
            customInspect: false
          }));
        }
      }]);
      return BufferList;
    }();
  }
});

// ../../../node_modules/exceljs/node_modules/readable-stream/lib/internal/streams/destroy.js
var require_destroy2 = __commonJS({
  "../../../node_modules/exceljs/node_modules/readable-stream/lib/internal/streams/destroy.js"(exports2, module2) {
    "use strict";
    function destroy(err, cb) {
      var _this = this;
      var readableDestroyed = this._readableState && this._readableState.destroyed;
      var writableDestroyed = this._writableState && this._writableState.destroyed;
      if (readableDestroyed || writableDestroyed) {
        if (cb) {
          cb(err);
        } else if (err) {
          if (!this._writableState) {
            process.nextTick(emitErrorNT, this, err);
          } else if (!this._writableState.errorEmitted) {
            this._writableState.errorEmitted = true;
            process.nextTick(emitErrorNT, this, err);
          }
        }
        return this;
      }
      if (this._readableState) {
        this._readableState.destroyed = true;
      }
      if (this._writableState) {
        this._writableState.destroyed = true;
      }
      this._destroy(err || null, function(err2) {
        if (!cb && err2) {
          if (!_this._writableState) {
            process.nextTick(emitErrorAndCloseNT, _this, err2);
          } else if (!_this._writableState.errorEmitted) {
            _this._writableState.errorEmitted = true;
            process.nextTick(emitErrorAndCloseNT, _this, err2);
          } else {
            process.nextTick(emitCloseNT, _this);
          }
        } else if (cb) {
          process.nextTick(emitCloseNT, _this);
          cb(err2);
        } else {
          process.nextTick(emitCloseNT, _this);
        }
      });
      return this;
    }
    function emitErrorAndCloseNT(self2, err) {
      emitErrorNT(self2, err);
      emitCloseNT(self2);
    }
    function emitCloseNT(self2) {
      if (self2._writableState && !self2._writableState.emitClose)
        return;
      if (self2._readableState && !self2._readableState.emitClose)
        return;
      self2.emit("close");
    }
    function undestroy() {
      if (this._readableState) {
        this._readableState.destroyed = false;
        this._readableState.reading = false;
        this._readableState.ended = false;
        this._readableState.endEmitted = false;
      }
      if (this._writableState) {
        this._writableState.destroyed = false;
        this._writableState.ended = false;
        this._writableState.ending = false;
        this._writableState.finalCalled = false;
        this._writableState.prefinished = false;
        this._writableState.finished = false;
        this._writableState.errorEmitted = false;
      }
    }
    function emitErrorNT(self2, err) {
      self2.emit("error", err);
    }
    function errorOrDestroy(stream, err) {
      var rState = stream._readableState;
      var wState = stream._writableState;
      if (rState && rState.autoDestroy || wState && wState.autoDestroy)
        stream.destroy(err);
      else
        stream.emit("error", err);
    }
    module2.exports = {
      destroy,
      undestroy,
      errorOrDestroy
    };
  }
});

// ../../../node_modules/exceljs/node_modules/readable-stream/errors.js
var require_errors = __commonJS({
  "../../../node_modules/exceljs/node_modules/readable-stream/errors.js"(exports2, module2) {
    "use strict";
    var codes = {};
    function createErrorType(code, message, Base) {
      if (!Base) {
        Base = Error;
      }
      function getMessage(arg1, arg2, arg3) {
        if (typeof message === "string") {
          return message;
        } else {
          return message(arg1, arg2, arg3);
        }
      }
      class NodeError extends Base {
        constructor(arg1, arg2, arg3) {
          super(getMessage(arg1, arg2, arg3));
        }
      }
      NodeError.prototype.name = Base.name;
      NodeError.prototype.code = code;
      codes[code] = NodeError;
    }
    function oneOf(expected, thing) {
      if (Array.isArray(expected)) {
        const len = expected.length;
        expected = expected.map((i) => String(i));
        if (len > 2) {
          return `one of ${thing} ${expected.slice(0, len - 1).join(", ")}, or ` + expected[len - 1];
        } else if (len === 2) {
          return `one of ${thing} ${expected[0]} or ${expected[1]}`;
        } else {
          return `of ${thing} ${expected[0]}`;
        }
      } else {
        return `of ${thing} ${String(expected)}`;
      }
    }
    function startsWith(str, search, pos) {
      return str.substr(!pos || pos < 0 ? 0 : +pos, search.length) === search;
    }
    function endsWith(str, search, this_len) {
      if (this_len === void 0 || this_len > str.length) {
        this_len = str.length;
      }
      return str.substring(this_len - search.length, this_len) === search;
    }
    function includes(str, search, start) {
      if (typeof start !== "number") {
        start = 0;
      }
      if (start + search.length > str.length) {
        return false;
      } else {
        return str.indexOf(search, start) !== -1;
      }
    }
    createErrorType("ERR_INVALID_OPT_VALUE", function(name, value) {
      return 'The value "' + value + '" is invalid for option "' + name + '"';
    }, TypeError);
    createErrorType("ERR_INVALID_ARG_TYPE", function(name, expected, actual) {
      let determiner;
      if (typeof expected === "string" && startsWith(expected, "not ")) {
        determiner = "must not be";
        expected = expected.replace(/^not /, "");
      } else {
        determiner = "must be";
      }
      let msg;
      if (endsWith(name, " argument")) {
        msg = `The ${name} ${determiner} ${oneOf(expected, "type")}`;
      } else {
        const type = includes(name, ".") ? "property" : "argument";
        msg = `The "${name}" ${type} ${determiner} ${oneOf(expected, "type")}`;
      }
      msg += `. Received type ${typeof actual}`;
      return msg;
    }, TypeError);
    createErrorType("ERR_STREAM_PUSH_AFTER_EOF", "stream.push() after EOF");
    createErrorType("ERR_METHOD_NOT_IMPLEMENTED", function(name) {
      return "The " + name + " method is not implemented";
    });
    createErrorType("ERR_STREAM_PREMATURE_CLOSE", "Premature close");
    createErrorType("ERR_STREAM_DESTROYED", function(name) {
      return "Cannot call " + name + " after a stream was destroyed";
    });
    createErrorType("ERR_MULTIPLE_CALLBACK", "Callback called multiple times");
    createErrorType("ERR_STREAM_CANNOT_PIPE", "Cannot pipe, not readable");
    createErrorType("ERR_STREAM_WRITE_AFTER_END", "write after end");
    createErrorType("ERR_STREAM_NULL_VALUES", "May not write null values to stream", TypeError);
    createErrorType("ERR_UNKNOWN_ENCODING", function(arg) {
      return "Unknown encoding: " + arg;
    }, TypeError);
    createErrorType("ERR_STREAM_UNSHIFT_AFTER_END_EVENT", "stream.unshift() after end event");
    module2.exports.codes = codes;
  }
});

// ../../../node_modules/exceljs/node_modules/readable-stream/lib/internal/streams/state.js
var require_state = __commonJS({
  "../../../node_modules/exceljs/node_modules/readable-stream/lib/internal/streams/state.js"(exports2, module2) {
    "use strict";
    var ERR_INVALID_OPT_VALUE = require_errors().codes.ERR_INVALID_OPT_VALUE;
    function highWaterMarkFrom(options, isDuplex, duplexKey) {
      return options.highWaterMark != null ? options.highWaterMark : isDuplex ? options[duplexKey] : null;
    }
    function getHighWaterMark(state, options, duplexKey, isDuplex) {
      var hwm = highWaterMarkFrom(options, isDuplex, duplexKey);
      if (hwm != null) {
        if (!(isFinite(hwm) && Math.floor(hwm) === hwm) || hwm < 0) {
          var name = isDuplex ? duplexKey : "highWaterMark";
          throw new ERR_INVALID_OPT_VALUE(name, hwm);
        }
        return Math.floor(hwm);
      }
      return state.objectMode ? 16 : 16 * 1024;
    }
    module2.exports = {
      getHighWaterMark
    };
  }
});

// ../../../node_modules/exceljs/node_modules/readable-stream/lib/_stream_writable.js
var require_stream_writable2 = __commonJS({
  "../../../node_modules/exceljs/node_modules/readable-stream/lib/_stream_writable.js"(exports2, module2) {
    "use strict";
    module2.exports = Writable;
    function CorkedRequest(state) {
      var _this = this;
      this.next = null;
      this.entry = null;
      this.finish = function() {
        onCorkedFinish(_this, state);
      };
    }
    var Duplex;
    Writable.WritableState = WritableState;
    var internalUtil = {
      deprecate: require_node()
    };
    var Stream = require_stream2();
    var Buffer2 = require("buffer").Buffer;
    var OurUint8Array = (typeof global !== "undefined" ? global : typeof window !== "undefined" ? window : typeof self !== "undefined" ? self : {}).Uint8Array || function() {
    };
    function _uint8ArrayToBuffer(chunk) {
      return Buffer2.from(chunk);
    }
    function _isUint8Array(obj2) {
      return Buffer2.isBuffer(obj2) || obj2 instanceof OurUint8Array;
    }
    var destroyImpl = require_destroy2();
    var _require = require_state();
    var getHighWaterMark = _require.getHighWaterMark;
    var _require$codes = require_errors().codes;
    var ERR_INVALID_ARG_TYPE = _require$codes.ERR_INVALID_ARG_TYPE;
    var ERR_METHOD_NOT_IMPLEMENTED = _require$codes.ERR_METHOD_NOT_IMPLEMENTED;
    var ERR_MULTIPLE_CALLBACK = _require$codes.ERR_MULTIPLE_CALLBACK;
    var ERR_STREAM_CANNOT_PIPE = _require$codes.ERR_STREAM_CANNOT_PIPE;
    var ERR_STREAM_DESTROYED = _require$codes.ERR_STREAM_DESTROYED;
    var ERR_STREAM_NULL_VALUES = _require$codes.ERR_STREAM_NULL_VALUES;
    var ERR_STREAM_WRITE_AFTER_END = _require$codes.ERR_STREAM_WRITE_AFTER_END;
    var ERR_UNKNOWN_ENCODING = _require$codes.ERR_UNKNOWN_ENCODING;
    var errorOrDestroy = destroyImpl.errorOrDestroy;
    require_inherits()(Writable, Stream);
    function nop() {
    }
    function WritableState(options, stream, isDuplex) {
      Duplex = Duplex || require_stream_duplex2();
      options = options || {};
      if (typeof isDuplex !== "boolean")
        isDuplex = stream instanceof Duplex;
      this.objectMode = !!options.objectMode;
      if (isDuplex)
        this.objectMode = this.objectMode || !!options.writableObjectMode;
      this.highWaterMark = getHighWaterMark(this, options, "writableHighWaterMark", isDuplex);
      this.finalCalled = false;
      this.needDrain = false;
      this.ending = false;
      this.ended = false;
      this.finished = false;
      this.destroyed = false;
      var noDecode = options.decodeStrings === false;
      this.decodeStrings = !noDecode;
      this.defaultEncoding = options.defaultEncoding || "utf8";
      this.length = 0;
      this.writing = false;
      this.corked = 0;
      this.sync = true;
      this.bufferProcessing = false;
      this.onwrite = function(er) {
        onwrite(stream, er);
      };
      this.writecb = null;
      this.writelen = 0;
      this.bufferedRequest = null;
      this.lastBufferedRequest = null;
      this.pendingcb = 0;
      this.prefinished = false;
      this.errorEmitted = false;
      this.emitClose = options.emitClose !== false;
      this.autoDestroy = !!options.autoDestroy;
      this.bufferedRequestCount = 0;
      this.corkedRequestsFree = new CorkedRequest(this);
    }
    WritableState.prototype.getBuffer = function getBuffer() {
      var current = this.bufferedRequest;
      var out = [];
      while (current) {
        out.push(current);
        current = current.next;
      }
      return out;
    };
    (function() {
      try {
        Object.defineProperty(WritableState.prototype, "buffer", {
          get: internalUtil.deprecate(function writableStateBufferGetter() {
            return this.getBuffer();
          }, "_writableState.buffer is deprecated. Use _writableState.getBuffer instead.", "DEP0003")
        });
      } catch (_2) {
      }
    })();
    var realHasInstance;
    if (typeof Symbol === "function" && Symbol.hasInstance && typeof Function.prototype[Symbol.hasInstance] === "function") {
      realHasInstance = Function.prototype[Symbol.hasInstance];
      Object.defineProperty(Writable, Symbol.hasInstance, {
        value: function value(object) {
          if (realHasInstance.call(this, object))
            return true;
          if (this !== Writable)
            return false;
          return object && object._writableState instanceof WritableState;
        }
      });
    } else {
      realHasInstance = function realHasInstance2(object) {
        return object instanceof this;
      };
    }
    function Writable(options) {
      Duplex = Duplex || require_stream_duplex2();
      var isDuplex = this instanceof Duplex;
      if (!isDuplex && !realHasInstance.call(Writable, this))
        return new Writable(options);
      this._writableState = new WritableState(options, this, isDuplex);
      this.writable = true;
      if (options) {
        if (typeof options.write === "function")
          this._write = options.write;
        if (typeof options.writev === "function")
          this._writev = options.writev;
        if (typeof options.destroy === "function")
          this._destroy = options.destroy;
        if (typeof options.final === "function")
          this._final = options.final;
      }
      Stream.call(this);
    }
    Writable.prototype.pipe = function() {
      errorOrDestroy(this, new ERR_STREAM_CANNOT_PIPE());
    };
    function writeAfterEnd(stream, cb) {
      var er = new ERR_STREAM_WRITE_AFTER_END();
      errorOrDestroy(stream, er);
      process.nextTick(cb, er);
    }
    function validChunk(stream, state, chunk, cb) {
      var er;
      if (chunk === null) {
        er = new ERR_STREAM_NULL_VALUES();
      } else if (typeof chunk !== "string" && !state.objectMode) {
        er = new ERR_INVALID_ARG_TYPE("chunk", ["string", "Buffer"], chunk);
      }
      if (er) {
        errorOrDestroy(stream, er);
        process.nextTick(cb, er);
        return false;
      }
      return true;
    }
    Writable.prototype.write = function(chunk, encoding, cb) {
      var state = this._writableState;
      var ret2 = false;
      var isBuf = !state.objectMode && _isUint8Array(chunk);
      if (isBuf && !Buffer2.isBuffer(chunk)) {
        chunk = _uint8ArrayToBuffer(chunk);
      }
      if (typeof encoding === "function") {
        cb = encoding;
        encoding = null;
      }
      if (isBuf)
        encoding = "buffer";
      else if (!encoding)
        encoding = state.defaultEncoding;
      if (typeof cb !== "function")
        cb = nop;
      if (state.ending)
        writeAfterEnd(this, cb);
      else if (isBuf || validChunk(this, state, chunk, cb)) {
        state.pendingcb++;
        ret2 = writeOrBuffer(this, state, isBuf, chunk, encoding, cb);
      }
      return ret2;
    };
    Writable.prototype.cork = function() {
      this._writableState.corked++;
    };
    Writable.prototype.uncork = function() {
      var state = this._writableState;
      if (state.corked) {
        state.corked--;
        if (!state.writing && !state.corked && !state.bufferProcessing && state.bufferedRequest)
          clearBuffer(this, state);
      }
    };
    Writable.prototype.setDefaultEncoding = function setDefaultEncoding(encoding) {
      if (typeof encoding === "string")
        encoding = encoding.toLowerCase();
      if (!(["hex", "utf8", "utf-8", "ascii", "binary", "base64", "ucs2", "ucs-2", "utf16le", "utf-16le", "raw"].indexOf((encoding + "").toLowerCase()) > -1))
        throw new ERR_UNKNOWN_ENCODING(encoding);
      this._writableState.defaultEncoding = encoding;
      return this;
    };
    Object.defineProperty(Writable.prototype, "writableBuffer", {
      // making it explicit this property is not enumerable
      // because otherwise some prototype manipulation in
      // userland will fail
      enumerable: false,
      get: function get() {
        return this._writableState && this._writableState.getBuffer();
      }
    });
    function decodeChunk(state, chunk, encoding) {
      if (!state.objectMode && state.decodeStrings !== false && typeof chunk === "string") {
        chunk = Buffer2.from(chunk, encoding);
      }
      return chunk;
    }
    Object.defineProperty(Writable.prototype, "writableHighWaterMark", {
      // making it explicit this property is not enumerable
      // because otherwise some prototype manipulation in
      // userland will fail
      enumerable: false,
      get: function get() {
        return this._writableState.highWaterMark;
      }
    });
    function writeOrBuffer(stream, state, isBuf, chunk, encoding, cb) {
      if (!isBuf) {
        var newChunk = decodeChunk(state, chunk, encoding);
        if (chunk !== newChunk) {
          isBuf = true;
          encoding = "buffer";
          chunk = newChunk;
        }
      }
      var len = state.objectMode ? 1 : chunk.length;
      state.length += len;
      var ret2 = state.length < state.highWaterMark;
      if (!ret2)
        state.needDrain = true;
      if (state.writing || state.corked) {
        var last = state.lastBufferedRequest;
        state.lastBufferedRequest = {
          chunk,
          encoding,
          isBuf,
          callback: cb,
          next: null
        };
        if (last) {
          last.next = state.lastBufferedRequest;
        } else {
          state.bufferedRequest = state.lastBufferedRequest;
        }
        state.bufferedRequestCount += 1;
      } else {
        doWrite(stream, state, false, len, chunk, encoding, cb);
      }
      return ret2;
    }
    function doWrite(stream, state, writev, len, chunk, encoding, cb) {
      state.writelen = len;
      state.writecb = cb;
      state.writing = true;
      state.sync = true;
      if (state.destroyed)
        state.onwrite(new ERR_STREAM_DESTROYED("write"));
      else if (writev)
        stream._writev(chunk, state.onwrite);
      else
        stream._write(chunk, encoding, state.onwrite);
      state.sync = false;
    }
    function onwriteError(stream, state, sync, er, cb) {
      --state.pendingcb;
      if (sync) {
        process.nextTick(cb, er);
        process.nextTick(finishMaybe, stream, state);
        stream._writableState.errorEmitted = true;
        errorOrDestroy(stream, er);
      } else {
        cb(er);
        stream._writableState.errorEmitted = true;
        errorOrDestroy(stream, er);
        finishMaybe(stream, state);
      }
    }
    function onwriteStateUpdate(state) {
      state.writing = false;
      state.writecb = null;
      state.length -= state.writelen;
      state.writelen = 0;
    }
    function onwrite(stream, er) {
      var state = stream._writableState;
      var sync = state.sync;
      var cb = state.writecb;
      if (typeof cb !== "function")
        throw new ERR_MULTIPLE_CALLBACK();
      onwriteStateUpdate(state);
      if (er)
        onwriteError(stream, state, sync, er, cb);
      else {
        var finished = needFinish(state) || stream.destroyed;
        if (!finished && !state.corked && !state.bufferProcessing && state.bufferedRequest) {
          clearBuffer(stream, state);
        }
        if (sync) {
          process.nextTick(afterWrite, stream, state, finished, cb);
        } else {
          afterWrite(stream, state, finished, cb);
        }
      }
    }
    function afterWrite(stream, state, finished, cb) {
      if (!finished)
        onwriteDrain(stream, state);
      state.pendingcb--;
      cb();
      finishMaybe(stream, state);
    }
    function onwriteDrain(stream, state) {
      if (state.length === 0 && state.needDrain) {
        state.needDrain = false;
        stream.emit("drain");
      }
    }
    function clearBuffer(stream, state) {
      state.bufferProcessing = true;
      var entry = state.bufferedRequest;
      if (stream._writev && entry && entry.next) {
        var l2 = state.bufferedRequestCount;
        var buffer = new Array(l2);
        var holder = state.corkedRequestsFree;
        holder.entry = entry;
        var count = 0;
        var allBuffers = true;
        while (entry) {
          buffer[count] = entry;
          if (!entry.isBuf)
            allBuffers = false;
          entry = entry.next;
          count += 1;
        }
        buffer.allBuffers = allBuffers;
        doWrite(stream, state, true, state.length, buffer, "", holder.finish);
        state.pendingcb++;
        state.lastBufferedRequest = null;
        if (holder.next) {
          state.corkedRequestsFree = holder.next;
          holder.next = null;
        } else {
          state.corkedRequestsFree = new CorkedRequest(state);
        }
        state.bufferedRequestCount = 0;
      } else {
        while (entry) {
          var chunk = entry.chunk;
          var encoding = entry.encoding;
          var cb = entry.callback;
          var len = state.objectMode ? 1 : chunk.length;
          doWrite(stream, state, false, len, chunk, encoding, cb);
          entry = entry.next;
          state.bufferedRequestCount--;
          if (state.writing) {
            break;
          }
        }
        if (entry === null)
          state.lastBufferedRequest = null;
      }
      state.bufferedRequest = entry;
      state.bufferProcessing = false;
    }
    Writable.prototype._write = function(chunk, encoding, cb) {
      cb(new ERR_METHOD_NOT_IMPLEMENTED("_write()"));
    };
    Writable.prototype._writev = null;
    Writable.prototype.end = function(chunk, encoding, cb) {
      var state = this._writableState;
      if (typeof chunk === "function") {
        cb = chunk;
        chunk = null;
        encoding = null;
      } else if (typeof encoding === "function") {
        cb = encoding;
        encoding = null;
      }
      if (chunk !== null && chunk !== void 0)
        this.write(chunk, encoding);
      if (state.corked) {
        state.corked = 1;
        this.uncork();
      }
      if (!state.ending)
        endWritable(this, state, cb);
      return this;
    };
    Object.defineProperty(Writable.prototype, "writableLength", {
      // making it explicit this property is not enumerable
      // because otherwise some prototype manipulation in
      // userland will fail
      enumerable: false,
      get: function get() {
        return this._writableState.length;
      }
    });
    function needFinish(state) {
      return state.ending && state.length === 0 && state.bufferedRequest === null && !state.finished && !state.writing;
    }
    function callFinal(stream, state) {
      stream._final(function(err) {
        state.pendingcb--;
        if (err) {
          errorOrDestroy(stream, err);
        }
        state.prefinished = true;
        stream.emit("prefinish");
        finishMaybe(stream, state);
      });
    }
    function prefinish(stream, state) {
      if (!state.prefinished && !state.finalCalled) {
        if (typeof stream._final === "function" && !state.destroyed) {
          state.pendingcb++;
          state.finalCalled = true;
          process.nextTick(callFinal, stream, state);
        } else {
          state.prefinished = true;
          stream.emit("prefinish");
        }
      }
    }
    function finishMaybe(stream, state) {
      var need = needFinish(state);
      if (need) {
        prefinish(stream, state);
        if (state.pendingcb === 0) {
          state.finished = true;
          stream.emit("finish");
          if (state.autoDestroy) {
            var rState = stream._readableState;
            if (!rState || rState.autoDestroy && rState.endEmitted) {
              stream.destroy();
            }
          }
        }
      }
      return need;
    }
    function endWritable(stream, state, cb) {
      state.ending = true;
      finishMaybe(stream, state);
      if (cb) {
        if (state.finished)
          process.nextTick(cb);
        else
          stream.once("finish", cb);
      }
      state.ended = true;
      stream.writable = false;
    }
    function onCorkedFinish(corkReq, state, err) {
      var entry = corkReq.entry;
      corkReq.entry = null;
      while (entry) {
        var cb = entry.callback;
        state.pendingcb--;
        cb(err);
        entry = entry.next;
      }
      state.corkedRequestsFree.next = corkReq;
    }
    Object.defineProperty(Writable.prototype, "destroyed", {
      // making it explicit this property is not enumerable
      // because otherwise some prototype manipulation in
      // userland will fail
      enumerable: false,
      get: function get() {
        if (this._writableState === void 0) {
          return false;
        }
        return this._writableState.destroyed;
      },
      set: function set(value) {
        if (!this._writableState) {
          return;
        }
        this._writableState.destroyed = value;
      }
    });
    Writable.prototype.destroy = destroyImpl.destroy;
    Writable.prototype._undestroy = destroyImpl.undestroy;
    Writable.prototype._destroy = function(err, cb) {
      cb(err);
    };
  }
});

// ../../../node_modules/exceljs/node_modules/readable-stream/lib/_stream_duplex.js
var require_stream_duplex2 = __commonJS({
  "../../../node_modules/exceljs/node_modules/readable-stream/lib/_stream_duplex.js"(exports2, module2) {
    "use strict";
    var objectKeys = Object.keys || function(obj2) {
      var keys2 = [];
      for (var key in obj2)
        keys2.push(key);
      return keys2;
    };
    module2.exports = Duplex;
    var Readable = require_stream_readable2();
    var Writable = require_stream_writable2();
    require_inherits()(Duplex, Readable);
    {
      keys = objectKeys(Writable.prototype);
      for (v = 0; v < keys.length; v++) {
        method = keys[v];
        if (!Duplex.prototype[method])
          Duplex.prototype[method] = Writable.prototype[method];
      }
    }
    var keys;
    var method;
    var v;
    function Duplex(options) {
      if (!(this instanceof Duplex))
        return new Duplex(options);
      Readable.call(this, options);
      Writable.call(this, options);
      this.allowHalfOpen = true;
      if (options) {
        if (options.readable === false)
          this.readable = false;
        if (options.writable === false)
          this.writable = false;
        if (options.allowHalfOpen === false) {
          this.allowHalfOpen = false;
          this.once("end", onend);
        }
      }
    }
    Object.defineProperty(Duplex.prototype, "writableHighWaterMark", {
      // making it explicit this property is not enumerable
      // because otherwise some prototype manipulation in
      // userland will fail
      enumerable: false,
      get: function get() {
        return this._writableState.highWaterMark;
      }
    });
    Object.defineProperty(Duplex.prototype, "writableBuffer", {
      // making it explicit this property is not enumerable
      // because otherwise some prototype manipulation in
      // userland will fail
      enumerable: false,
      get: function get() {
        return this._writableState && this._writableState.getBuffer();
      }
    });
    Object.defineProperty(Duplex.prototype, "writableLength", {
      // making it explicit this property is not enumerable
      // because otherwise some prototype manipulation in
      // userland will fail
      enumerable: false,
      get: function get() {
        return this._writableState.length;
      }
    });
    function onend() {
      if (this._writableState.ended)
        return;
      process.nextTick(onEndNT, this);
    }
    function onEndNT(self2) {
      self2.end();
    }
    Object.defineProperty(Duplex.prototype, "destroyed", {
      // making it explicit this property is not enumerable
      // because otherwise some prototype manipulation in
      // userland will fail
      enumerable: false,
      get: function get() {
        if (this._readableState === void 0 || this._writableState === void 0) {
          return false;
        }
        return this._readableState.destroyed && this._writableState.destroyed;
      },
      set: function set(value) {
        if (this._readableState === void 0 || this._writableState === void 0) {
          return;
        }
        this._readableState.destroyed = value;
        this._writableState.destroyed = value;
      }
    });
  }
});

// ../../../node_modules/safe-buffer/index.js
var require_safe_buffer2 = __commonJS({
  "../../../node_modules/safe-buffer/index.js"(exports2, module2) {
    var buffer = require("buffer");
    var Buffer2 = buffer.Buffer;
    function copyProps(src, dst) {
      for (var key in src) {
        dst[key] = src[key];
      }
    }
    if (Buffer2.from && Buffer2.alloc && Buffer2.allocUnsafe && Buffer2.allocUnsafeSlow) {
      module2.exports = buffer;
    } else {
      copyProps(buffer, exports2);
      exports2.Buffer = SafeBuffer;
    }
    function SafeBuffer(arg, encodingOrOffset, length) {
      return Buffer2(arg, encodingOrOffset, length);
    }
    SafeBuffer.prototype = Object.create(Buffer2.prototype);
    copyProps(Buffer2, SafeBuffer);
    SafeBuffer.from = function(arg, encodingOrOffset, length) {
      if (typeof arg === "number") {
        throw new TypeError("Argument must not be a number");
      }
      return Buffer2(arg, encodingOrOffset, length);
    };
    SafeBuffer.alloc = function(size, fill, encoding) {
      if (typeof size !== "number") {
        throw new TypeError("Argument must be a number");
      }
      var buf = Buffer2(size);
      if (fill !== void 0) {
        if (typeof encoding === "string") {
          buf.fill(fill, encoding);
        } else {
          buf.fill(fill);
        }
      } else {
        buf.fill(0);
      }
      return buf;
    };
    SafeBuffer.allocUnsafe = function(size) {
      if (typeof size !== "number") {
        throw new TypeError("Argument must be a number");
      }
      return Buffer2(size);
    };
    SafeBuffer.allocUnsafeSlow = function(size) {
      if (typeof size !== "number") {
        throw new TypeError("Argument must be a number");
      }
      return buffer.SlowBuffer(size);
    };
  }
});

// ../../../node_modules/exceljs/node_modules/string_decoder/lib/string_decoder.js
var require_string_decoder2 = __commonJS({
  "../../../node_modules/exceljs/node_modules/string_decoder/lib/string_decoder.js"(exports2) {
    "use strict";
    var Buffer2 = require_safe_buffer2().Buffer;
    var isEncoding = Buffer2.isEncoding || function(encoding) {
      encoding = "" + encoding;
      switch (encoding && encoding.toLowerCase()) {
        case "hex":
        case "utf8":
        case "utf-8":
        case "ascii":
        case "binary":
        case "base64":
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
        case "raw":
          return true;
        default:
          return false;
      }
    };
    function _normalizeEncoding(enc) {
      if (!enc)
        return "utf8";
      var retried;
      while (true) {
        switch (enc) {
          case "utf8":
          case "utf-8":
            return "utf8";
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
            return "utf16le";
          case "latin1":
          case "binary":
            return "latin1";
          case "base64":
          case "ascii":
          case "hex":
            return enc;
          default:
            if (retried)
              return;
            enc = ("" + enc).toLowerCase();
            retried = true;
        }
      }
    }
    function normalizeEncoding(enc) {
      var nenc = _normalizeEncoding(enc);
      if (typeof nenc !== "string" && (Buffer2.isEncoding === isEncoding || !isEncoding(enc)))
        throw new Error("Unknown encoding: " + enc);
      return nenc || enc;
    }
    exports2.StringDecoder = StringDecoder;
    function StringDecoder(encoding) {
      this.encoding = normalizeEncoding(encoding);
      var nb;
      switch (this.encoding) {
        case "utf16le":
          this.text = utf16Text;
          this.end = utf16End;
          nb = 4;
          break;
        case "utf8":
          this.fillLast = utf8FillLast;
          nb = 4;
          break;
        case "base64":
          this.text = base64Text;
          this.end = base64End;
          nb = 3;
          break;
        default:
          this.write = simpleWrite;
          this.end = simpleEnd;
          return;
      }
      this.lastNeed = 0;
      this.lastTotal = 0;
      this.lastChar = Buffer2.allocUnsafe(nb);
    }
    StringDecoder.prototype.write = function(buf) {
      if (buf.length === 0)
        return "";
      var r;
      var i;
      if (this.lastNeed) {
        r = this.fillLast(buf);
        if (r === void 0)
          return "";
        i = this.lastNeed;
        this.lastNeed = 0;
      } else {
        i = 0;
      }
      if (i < buf.length)
        return r ? r + this.text(buf, i) : this.text(buf, i);
      return r || "";
    };
    StringDecoder.prototype.end = utf8End;
    StringDecoder.prototype.text = utf8Text;
    StringDecoder.prototype.fillLast = function(buf) {
      if (this.lastNeed <= buf.length) {
        buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, this.lastNeed);
        return this.lastChar.toString(this.encoding, 0, this.lastTotal);
      }
      buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, buf.length);
      this.lastNeed -= buf.length;
    };
    function utf8CheckByte(byte) {
      if (byte <= 127)
        return 0;
      else if (byte >> 5 === 6)
        return 2;
      else if (byte >> 4 === 14)
        return 3;
      else if (byte >> 3 === 30)
        return 4;
      return byte >> 6 === 2 ? -1 : -2;
    }
    function utf8CheckIncomplete(self2, buf, i) {
      var j = buf.length - 1;
      if (j < i)
        return 0;
      var nb = utf8CheckByte(buf[j]);
      if (nb >= 0) {
        if (nb > 0)
          self2.lastNeed = nb - 1;
        return nb;
      }
      if (--j < i || nb === -2)
        return 0;
      nb = utf8CheckByte(buf[j]);
      if (nb >= 0) {
        if (nb > 0)
          self2.lastNeed = nb - 2;
        return nb;
      }
      if (--j < i || nb === -2)
        return 0;
      nb = utf8CheckByte(buf[j]);
      if (nb >= 0) {
        if (nb > 0) {
          if (nb === 2)
            nb = 0;
          else
            self2.lastNeed = nb - 3;
        }
        return nb;
      }
      return 0;
    }
    function utf8CheckExtraBytes(self2, buf, p) {
      if ((buf[0] & 192) !== 128) {
        self2.lastNeed = 0;
        return "\uFFFD";
      }
      if (self2.lastNeed > 1 && buf.length > 1) {
        if ((buf[1] & 192) !== 128) {
          self2.lastNeed = 1;
          return "\uFFFD";
        }
        if (self2.lastNeed > 2 && buf.length > 2) {
          if ((buf[2] & 192) !== 128) {
            self2.lastNeed = 2;
            return "\uFFFD";
          }
        }
      }
    }
    function utf8FillLast(buf) {
      var p = this.lastTotal - this.lastNeed;
      var r = utf8CheckExtraBytes(this, buf, p);
      if (r !== void 0)
        return r;
      if (this.lastNeed <= buf.length) {
        buf.copy(this.lastChar, p, 0, this.lastNeed);
        return this.lastChar.toString(this.encoding, 0, this.lastTotal);
      }
      buf.copy(this.lastChar, p, 0, buf.length);
      this.lastNeed -= buf.length;
    }
    function utf8Text(buf, i) {
      var total = utf8CheckIncomplete(this, buf, i);
      if (!this.lastNeed)
        return buf.toString("utf8", i);
      this.lastTotal = total;
      var end = buf.length - (total - this.lastNeed);
      buf.copy(this.lastChar, 0, end);
      return buf.toString("utf8", i, end);
    }
    function utf8End(buf) {
      var r = buf && buf.length ? this.write(buf) : "";
      if (this.lastNeed)
        return r + "\uFFFD";
      return r;
    }
    function utf16Text(buf, i) {
      if ((buf.length - i) % 2 === 0) {
        var r = buf.toString("utf16le", i);
        if (r) {
          var c = r.charCodeAt(r.length - 1);
          if (c >= 55296 && c <= 56319) {
            this.lastNeed = 2;
            this.lastTotal = 4;
            this.lastChar[0] = buf[buf.length - 2];
            this.lastChar[1] = buf[buf.length - 1];
            return r.slice(0, -1);
          }
        }
        return r;
      }
      this.lastNeed = 1;
      this.lastTotal = 2;
      this.lastChar[0] = buf[buf.length - 1];
      return buf.toString("utf16le", i, buf.length - 1);
    }
    function utf16End(buf) {
      var r = buf && buf.length ? this.write(buf) : "";
      if (this.lastNeed) {
        var end = this.lastTotal - this.lastNeed;
        return r + this.lastChar.toString("utf16le", 0, end);
      }
      return r;
    }
    function base64Text(buf, i) {
      var n = (buf.length - i) % 3;
      if (n === 0)
        return buf.toString("base64", i);
      this.lastNeed = 3 - n;
      this.lastTotal = 3;
      if (n === 1) {
        this.lastChar[0] = buf[buf.length - 1];
      } else {
        this.lastChar[0] = buf[buf.length - 2];
        this.lastChar[1] = buf[buf.length - 1];
      }
      return buf.toString("base64", i, buf.length - n);
    }
    function base64End(buf) {
      var r = buf && buf.length ? this.write(buf) : "";
      if (this.lastNeed)
        return r + this.lastChar.toString("base64", 0, 3 - this.lastNeed);
      return r;
    }
    function simpleWrite(buf) {
      return buf.toString(this.encoding);
    }
    function simpleEnd(buf) {
      return buf && buf.length ? this.write(buf) : "";
    }
  }
});

// ../../../node_modules/exceljs/node_modules/readable-stream/lib/internal/streams/end-of-stream.js
var require_end_of_stream = __commonJS({
  "../../../node_modules/exceljs/node_modules/readable-stream/lib/internal/streams/end-of-stream.js"(exports2, module2) {
    "use strict";
    var ERR_STREAM_PREMATURE_CLOSE = require_errors().codes.ERR_STREAM_PREMATURE_CLOSE;
    function once(callback) {
      var called = false;
      return function() {
        if (called)
          return;
        called = true;
        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }
        callback.apply(this, args);
      };
    }
    function noop() {
    }
    function isRequest(stream) {
      return stream.setHeader && typeof stream.abort === "function";
    }
    function eos(stream, opts, callback) {
      if (typeof opts === "function")
        return eos(stream, null, opts);
      if (!opts)
        opts = {};
      callback = once(callback || noop);
      var readable = opts.readable || opts.readable !== false && stream.readable;
      var writable = opts.writable || opts.writable !== false && stream.writable;
      var onlegacyfinish = function onlegacyfinish2() {
        if (!stream.writable)
          onfinish();
      };
      var writableEnded = stream._writableState && stream._writableState.finished;
      var onfinish = function onfinish2() {
        writable = false;
        writableEnded = true;
        if (!readable)
          callback.call(stream);
      };
      var readableEnded = stream._readableState && stream._readableState.endEmitted;
      var onend = function onend2() {
        readable = false;
        readableEnded = true;
        if (!writable)
          callback.call(stream);
      };
      var onerror = function onerror2(err) {
        callback.call(stream, err);
      };
      var onclose = function onclose2() {
        var err;
        if (readable && !readableEnded) {
          if (!stream._readableState || !stream._readableState.ended)
            err = new ERR_STREAM_PREMATURE_CLOSE();
          return callback.call(stream, err);
        }
        if (writable && !writableEnded) {
          if (!stream._writableState || !stream._writableState.ended)
            err = new ERR_STREAM_PREMATURE_CLOSE();
          return callback.call(stream, err);
        }
      };
      var onrequest = function onrequest2() {
        stream.req.on("finish", onfinish);
      };
      if (isRequest(stream)) {
        stream.on("complete", onfinish);
        stream.on("abort", onclose);
        if (stream.req)
          onrequest();
        else
          stream.on("request", onrequest);
      } else if (writable && !stream._writableState) {
        stream.on("end", onlegacyfinish);
        stream.on("close", onlegacyfinish);
      }
      stream.on("end", onend);
      stream.on("finish", onfinish);
      if (opts.error !== false)
        stream.on("error", onerror);
      stream.on("close", onclose);
      return function() {
        stream.removeListener("complete", onfinish);
        stream.removeListener("abort", onclose);
        stream.removeListener("request", onrequest);
        if (stream.req)
          stream.req.removeListener("finish", onfinish);
        stream.removeListener("end", onlegacyfinish);
        stream.removeListener("close", onlegacyfinish);
        stream.removeListener("finish", onfinish);
        stream.removeListener("end", onend);
        stream.removeListener("error", onerror);
        stream.removeListener("close", onclose);
      };
    }
    module2.exports = eos;
  }
});

// ../../../node_modules/exceljs/node_modules/readable-stream/lib/internal/streams/async_iterator.js
var require_async_iterator = __commonJS({
  "../../../node_modules/exceljs/node_modules/readable-stream/lib/internal/streams/async_iterator.js"(exports2, module2) {
    "use strict";
    var _Object$setPrototypeO;
    function _defineProperty(obj2, key, value) {
      key = _toPropertyKey(key);
      if (key in obj2) {
        Object.defineProperty(obj2, key, { value, enumerable: true, configurable: true, writable: true });
      } else {
        obj2[key] = value;
      }
      return obj2;
    }
    function _toPropertyKey(arg) {
      var key = _toPrimitive(arg, "string");
      return typeof key === "symbol" ? key : String(key);
    }
    function _toPrimitive(input, hint) {
      if (typeof input !== "object" || input === null)
        return input;
      var prim = input[Symbol.toPrimitive];
      if (prim !== void 0) {
        var res = prim.call(input, hint || "default");
        if (typeof res !== "object")
          return res;
        throw new TypeError("@@toPrimitive must return a primitive value.");
      }
      return (hint === "string" ? String : Number)(input);
    }
    var finished = require_end_of_stream();
    var kLastResolve = Symbol("lastResolve");
    var kLastReject = Symbol("lastReject");
    var kError = Symbol("error");
    var kEnded = Symbol("ended");
    var kLastPromise = Symbol("lastPromise");
    var kHandlePromise = Symbol("handlePromise");
    var kStream = Symbol("stream");
    function createIterResult(value, done) {
      return {
        value,
        done
      };
    }
    function readAndResolve(iter) {
      var resolve = iter[kLastResolve];
      if (resolve !== null) {
        var data = iter[kStream].read();
        if (data !== null) {
          iter[kLastPromise] = null;
          iter[kLastResolve] = null;
          iter[kLastReject] = null;
          resolve(createIterResult(data, false));
        }
      }
    }
    function onReadable(iter) {
      process.nextTick(readAndResolve, iter);
    }
    function wrapForNext(lastPromise, iter) {
      return function(resolve, reject) {
        lastPromise.then(function() {
          if (iter[kEnded]) {
            resolve(createIterResult(void 0, true));
            return;
          }
          iter[kHandlePromise](resolve, reject);
        }, reject);
      };
    }
    var AsyncIteratorPrototype = Object.getPrototypeOf(function() {
    });
    var ReadableStreamAsyncIteratorPrototype = Object.setPrototypeOf((_Object$setPrototypeO = {
      get stream() {
        return this[kStream];
      },
      next: function next() {
        var _this = this;
        var error = this[kError];
        if (error !== null) {
          return Promise.reject(error);
        }
        if (this[kEnded]) {
          return Promise.resolve(createIterResult(void 0, true));
        }
        if (this[kStream].destroyed) {
          return new Promise(function(resolve, reject) {
            process.nextTick(function() {
              if (_this[kError]) {
                reject(_this[kError]);
              } else {
                resolve(createIterResult(void 0, true));
              }
            });
          });
        }
        var lastPromise = this[kLastPromise];
        var promise;
        if (lastPromise) {
          promise = new Promise(wrapForNext(lastPromise, this));
        } else {
          var data = this[kStream].read();
          if (data !== null) {
            return Promise.resolve(createIterResult(data, false));
          }
          promise = new Promise(this[kHandlePromise]);
        }
        this[kLastPromise] = promise;
        return promise;
      }
    }, _defineProperty(_Object$setPrototypeO, Symbol.asyncIterator, function() {
      return this;
    }), _defineProperty(_Object$setPrototypeO, "return", function _return() {
      var _this2 = this;
      return new Promise(function(resolve, reject) {
        _this2[kStream].destroy(null, function(err) {
          if (err) {
            reject(err);
            return;
          }
          resolve(createIterResult(void 0, true));
        });
      });
    }), _Object$setPrototypeO), AsyncIteratorPrototype);
    var createReadableStreamAsyncIterator = function createReadableStreamAsyncIterator2(stream) {
      var _Object$create;
      var iterator = Object.create(ReadableStreamAsyncIteratorPrototype, (_Object$create = {}, _defineProperty(_Object$create, kStream, {
        value: stream,
        writable: true
      }), _defineProperty(_Object$create, kLastResolve, {
        value: null,
        writable: true
      }), _defineProperty(_Object$create, kLastReject, {
        value: null,
        writable: true
      }), _defineProperty(_Object$create, kError, {
        value: null,
        writable: true
      }), _defineProperty(_Object$create, kEnded, {
        value: stream._readableState.endEmitted,
        writable: true
      }), _defineProperty(_Object$create, kHandlePromise, {
        value: function value(resolve, reject) {
          var data = iterator[kStream].read();
          if (data) {
            iterator[kLastPromise] = null;
            iterator[kLastResolve] = null;
            iterator[kLastReject] = null;
            resolve(createIterResult(data, false));
          } else {
            iterator[kLastResolve] = resolve;
            iterator[kLastReject] = reject;
          }
        },
        writable: true
      }), _Object$create));
      iterator[kLastPromise] = null;
      finished(stream, function(err) {
        if (err && err.code !== "ERR_STREAM_PREMATURE_CLOSE") {
          var reject = iterator[kLastReject];
          if (reject !== null) {
            iterator[kLastPromise] = null;
            iterator[kLastResolve] = null;
            iterator[kLastReject] = null;
            reject(err);
          }
          iterator[kError] = err;
          return;
        }
        var resolve = iterator[kLastResolve];
        if (resolve !== null) {
          iterator[kLastPromise] = null;
          iterator[kLastResolve] = null;
          iterator[kLastReject] = null;
          resolve(createIterResult(void 0, true));
        }
        iterator[kEnded] = true;
      });
      stream.on("readable", onReadable.bind(null, iterator));
      return iterator;
    };
    module2.exports = createReadableStreamAsyncIterator;
  }
});

// ../../../node_modules/exceljs/node_modules/readable-stream/lib/internal/streams/from.js
var require_from = __commonJS({
  "../../../node_modules/exceljs/node_modules/readable-stream/lib/internal/streams/from.js"(exports2, module2) {
    "use strict";
    function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {
      try {
        var info = gen[key](arg);
        var value = info.value;
      } catch (error) {
        reject(error);
        return;
      }
      if (info.done) {
        resolve(value);
      } else {
        Promise.resolve(value).then(_next, _throw);
      }
    }
    function _asyncToGenerator(fn) {
      return function() {
        var self2 = this, args = arguments;
        return new Promise(function(resolve, reject) {
          var gen = fn.apply(self2, args);
          function _next(value) {
            asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value);
          }
          function _throw(err) {
            asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err);
          }
          _next(void 0);
        });
      };
    }
    function ownKeys(object, enumerableOnly) {
      var keys = Object.keys(object);
      if (Object.getOwnPropertySymbols) {
        var symbols = Object.getOwnPropertySymbols(object);
        enumerableOnly && (symbols = symbols.filter(function(sym) {
          return Object.getOwnPropertyDescriptor(object, sym).enumerable;
        })), keys.push.apply(keys, symbols);
      }
      return keys;
    }
    function _objectSpread(target) {
      for (var i = 1; i < arguments.length; i++) {
        var source = null != arguments[i] ? arguments[i] : {};
        i % 2 ? ownKeys(Object(source), true).forEach(function(key) {
          _defineProperty(target, key, source[key]);
        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function(key) {
          Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
        });
      }
      return target;
    }
    function _defineProperty(obj2, key, value) {
      key = _toPropertyKey(key);
      if (key in obj2) {
        Object.defineProperty(obj2, key, { value, enumerable: true, configurable: true, writable: true });
      } else {
        obj2[key] = value;
      }
      return obj2;
    }
    function _toPropertyKey(arg) {
      var key = _toPrimitive(arg, "string");
      return typeof key === "symbol" ? key : String(key);
    }
    function _toPrimitive(input, hint) {
      if (typeof input !== "object" || input === null)
        return input;
      var prim = input[Symbol.toPrimitive];
      if (prim !== void 0) {
        var res = prim.call(input, hint || "default");
        if (typeof res !== "object")
          return res;
        throw new TypeError("@@toPrimitive must return a primitive value.");
      }
      return (hint === "string" ? String : Number)(input);
    }
    var ERR_INVALID_ARG_TYPE = require_errors().codes.ERR_INVALID_ARG_TYPE;
    function from(Readable, iterable, opts) {
      var iterator;
      if (iterable && typeof iterable.next === "function") {
        iterator = iterable;
      } else if (iterable && iterable[Symbol.asyncIterator])
        iterator = iterable[Symbol.asyncIterator]();
      else if (iterable && iterable[Symbol.iterator])
        iterator = iterable[Symbol.iterator]();
      else
        throw new ERR_INVALID_ARG_TYPE("iterable", ["Iterable"], iterable);
      var readable = new Readable(_objectSpread({
        objectMode: true
      }, opts));
      var reading = false;
      readable._read = function() {
        if (!reading) {
          reading = true;
          next();
        }
      };
      function next() {
        return _next2.apply(this, arguments);
      }
      function _next2() {
        _next2 = _asyncToGenerator(function* () {
          try {
            var _yield$iterator$next = yield iterator.next(), value = _yield$iterator$next.value, done = _yield$iterator$next.done;
            if (done) {
              readable.push(null);
            } else if (readable.push(yield value)) {
              next();
            } else {
              reading = false;
            }
          } catch (err) {
            readable.destroy(err);
          }
        });
        return _next2.apply(this, arguments);
      }
      return readable;
    }
    module2.exports = from;
  }
});

// ../../../node_modules/exceljs/node_modules/readable-stream/lib/_stream_readable.js
var require_stream_readable2 = __commonJS({
  "../../../node_modules/exceljs/node_modules/readable-stream/lib/_stream_readable.js"(exports2, module2) {
    "use strict";
    module2.exports = Readable;
    var Duplex;
    Readable.ReadableState = ReadableState;
    var EE = require("events").EventEmitter;
    var EElistenerCount = function EElistenerCount2(emitter, type) {
      return emitter.listeners(type).length;
    };
    var Stream = require_stream2();
    var Buffer2 = require("buffer").Buffer;
    var OurUint8Array = (typeof global !== "undefined" ? global : typeof window !== "undefined" ? window : typeof self !== "undefined" ? self : {}).Uint8Array || function() {
    };
    function _uint8ArrayToBuffer(chunk) {
      return Buffer2.from(chunk);
    }
    function _isUint8Array(obj2) {
      return Buffer2.isBuffer(obj2) || obj2 instanceof OurUint8Array;
    }
    var debugUtil = require("util");
    var debug;
    if (debugUtil && debugUtil.debuglog) {
      debug = debugUtil.debuglog("stream");
    } else {
      debug = function debug2() {
      };
    }
    var BufferList = require_buffer_list();
    var destroyImpl = require_destroy2();
    var _require = require_state();
    var getHighWaterMark = _require.getHighWaterMark;
    var _require$codes = require_errors().codes;
    var ERR_INVALID_ARG_TYPE = _require$codes.ERR_INVALID_ARG_TYPE;
    var ERR_STREAM_PUSH_AFTER_EOF = _require$codes.ERR_STREAM_PUSH_AFTER_EOF;
    var ERR_METHOD_NOT_IMPLEMENTED = _require$codes.ERR_METHOD_NOT_IMPLEMENTED;
    var ERR_STREAM_UNSHIFT_AFTER_END_EVENT = _require$codes.ERR_STREAM_UNSHIFT_AFTER_END_EVENT;
    var StringDecoder;
    var createReadableStreamAsyncIterator;
    var from;
    require_inherits()(Readable, Stream);
    var errorOrDestroy = destroyImpl.errorOrDestroy;
    var kProxyEvents = ["error", "close", "destroy", "pause", "resume"];
    function prependListener(emitter, event, fn) {
      if (typeof emitter.prependListener === "function")
        return emitter.prependListener(event, fn);
      if (!emitter._events || !emitter._events[event])
        emitter.on(event, fn);
      else if (Array.isArray(emitter._events[event]))
        emitter._events[event].unshift(fn);
      else
        emitter._events[event] = [fn, emitter._events[event]];
    }
    function ReadableState(options, stream, isDuplex) {
      Duplex = Duplex || require_stream_duplex2();
      options = options || {};
      if (typeof isDuplex !== "boolean")
        isDuplex = stream instanceof Duplex;
      this.objectMode = !!options.objectMode;
      if (isDuplex)
        this.objectMode = this.objectMode || !!options.readableObjectMode;
      this.highWaterMark = getHighWaterMark(this, options, "readableHighWaterMark", isDuplex);
      this.buffer = new BufferList();
      this.length = 0;
      this.pipes = null;
      this.pipesCount = 0;
      this.flowing = null;
      this.ended = false;
      this.endEmitted = false;
      this.reading = false;
      this.sync = true;
      this.needReadable = false;
      this.emittedReadable = false;
      this.readableListening = false;
      this.resumeScheduled = false;
      this.paused = true;
      this.emitClose = options.emitClose !== false;
      this.autoDestroy = !!options.autoDestroy;
      this.destroyed = false;
      this.defaultEncoding = options.defaultEncoding || "utf8";
      this.awaitDrain = 0;
      this.readingMore = false;
      this.decoder = null;
      this.encoding = null;
      if (options.encoding) {
        if (!StringDecoder)
          StringDecoder = require_string_decoder2().StringDecoder;
        this.decoder = new StringDecoder(options.encoding);
        this.encoding = options.encoding;
      }
    }
    function Readable(options) {
      Duplex = Duplex || require_stream_duplex2();
      if (!(this instanceof Readable))
        return new Readable(options);
      var isDuplex = this instanceof Duplex;
      this._readableState = new ReadableState(options, this, isDuplex);
      this.readable = true;
      if (options) {
        if (typeof options.read === "function")
          this._read = options.read;
        if (typeof options.destroy === "function")
          this._destroy = options.destroy;
      }
      Stream.call(this);
    }
    Object.defineProperty(Readable.prototype, "destroyed", {
      // making it explicit this property is not enumerable
      // because otherwise some prototype manipulation in
      // userland will fail
      enumerable: false,
      get: function get() {
        if (this._readableState === void 0) {
          return false;
        }
        return this._readableState.destroyed;
      },
      set: function set(value) {
        if (!this._readableState) {
          return;
        }
        this._readableState.destroyed = value;
      }
    });
    Readable.prototype.destroy = destroyImpl.destroy;
    Readable.prototype._undestroy = destroyImpl.undestroy;
    Readable.prototype._destroy = function(err, cb) {
      cb(err);
    };
    Readable.prototype.push = function(chunk, encoding) {
      var state = this._readableState;
      var skipChunkCheck;
      if (!state.objectMode) {
        if (typeof chunk === "string") {
          encoding = encoding || state.defaultEncoding;
          if (encoding !== state.encoding) {
            chunk = Buffer2.from(chunk, encoding);
            encoding = "";
          }
          skipChunkCheck = true;
        }
      } else {
        skipChunkCheck = true;
      }
      return readableAddChunk(this, chunk, encoding, false, skipChunkCheck);
    };
    Readable.prototype.unshift = function(chunk) {
      return readableAddChunk(this, chunk, null, true, false);
    };
    function readableAddChunk(stream, chunk, encoding, addToFront, skipChunkCheck) {
      debug("readableAddChunk", chunk);
      var state = stream._readableState;
      if (chunk === null) {
        state.reading = false;
        onEofChunk(stream, state);
      } else {
        var er;
        if (!skipChunkCheck)
          er = chunkInvalid(state, chunk);
        if (er) {
          errorOrDestroy(stream, er);
        } else if (state.objectMode || chunk && chunk.length > 0) {
          if (typeof chunk !== "string" && !state.objectMode && Object.getPrototypeOf(chunk) !== Buffer2.prototype) {
            chunk = _uint8ArrayToBuffer(chunk);
          }
          if (addToFront) {
            if (state.endEmitted)
              errorOrDestroy(stream, new ERR_STREAM_UNSHIFT_AFTER_END_EVENT());
            else
              addChunk(stream, state, chunk, true);
          } else if (state.ended) {
            errorOrDestroy(stream, new ERR_STREAM_PUSH_AFTER_EOF());
          } else if (state.destroyed) {
            return false;
          } else {
            state.reading = false;
            if (state.decoder && !encoding) {
              chunk = state.decoder.write(chunk);
              if (state.objectMode || chunk.length !== 0)
                addChunk(stream, state, chunk, false);
              else
                maybeReadMore(stream, state);
            } else {
              addChunk(stream, state, chunk, false);
            }
          }
        } else if (!addToFront) {
          state.reading = false;
          maybeReadMore(stream, state);
        }
      }
      return !state.ended && (state.length < state.highWaterMark || state.length === 0);
    }
    function addChunk(stream, state, chunk, addToFront) {
      if (state.flowing && state.length === 0 && !state.sync) {
        state.awaitDrain = 0;
        stream.emit("data", chunk);
      } else {
        state.length += state.objectMode ? 1 : chunk.length;
        if (addToFront)
          state.buffer.unshift(chunk);
        else
          state.buffer.push(chunk);
        if (state.needReadable)
          emitReadable(stream);
      }
      maybeReadMore(stream, state);
    }
    function chunkInvalid(state, chunk) {
      var er;
      if (!_isUint8Array(chunk) && typeof chunk !== "string" && chunk !== void 0 && !state.objectMode) {
        er = new ERR_INVALID_ARG_TYPE("chunk", ["string", "Buffer", "Uint8Array"], chunk);
      }
      return er;
    }
    Readable.prototype.isPaused = function() {
      return this._readableState.flowing === false;
    };
    Readable.prototype.setEncoding = function(enc) {
      if (!StringDecoder)
        StringDecoder = require_string_decoder2().StringDecoder;
      var decoder = new StringDecoder(enc);
      this._readableState.decoder = decoder;
      this._readableState.encoding = this._readableState.decoder.encoding;
      var p = this._readableState.buffer.head;
      var content = "";
      while (p !== null) {
        content += decoder.write(p.data);
        p = p.next;
      }
      this._readableState.buffer.clear();
      if (content !== "")
        this._readableState.buffer.push(content);
      this._readableState.length = content.length;
      return this;
    };
    var MAX_HWM = 1073741824;
    function computeNewHighWaterMark(n) {
      if (n >= MAX_HWM) {
        n = MAX_HWM;
      } else {
        n--;
        n |= n >>> 1;
        n |= n >>> 2;
        n |= n >>> 4;
        n |= n >>> 8;
        n |= n >>> 16;
        n++;
      }
      return n;
    }
    function howMuchToRead(n, state) {
      if (n <= 0 || state.length === 0 && state.ended)
        return 0;
      if (state.objectMode)
        return 1;
      if (n !== n) {
        if (state.flowing && state.length)
          return state.buffer.head.data.length;
        else
          return state.length;
      }
      if (n > state.highWaterMark)
        state.highWaterMark = computeNewHighWaterMark(n);
      if (n <= state.length)
        return n;
      if (!state.ended) {
        state.needReadable = true;
        return 0;
      }
      return state.length;
    }
    Readable.prototype.read = function(n) {
      debug("read", n);
      n = parseInt(n, 10);
      var state = this._readableState;
      var nOrig = n;
      if (n !== 0)
        state.emittedReadable = false;
      if (n === 0 && state.needReadable && ((state.highWaterMark !== 0 ? state.length >= state.highWaterMark : state.length > 0) || state.ended)) {
        debug("read: emitReadable", state.length, state.ended);
        if (state.length === 0 && state.ended)
          endReadable(this);
        else
          emitReadable(this);
        return null;
      }
      n = howMuchToRead(n, state);
      if (n === 0 && state.ended) {
        if (state.length === 0)
          endReadable(this);
        return null;
      }
      var doRead = state.needReadable;
      debug("need readable", doRead);
      if (state.length === 0 || state.length - n < state.highWaterMark) {
        doRead = true;
        debug("length less than watermark", doRead);
      }
      if (state.ended || state.reading) {
        doRead = false;
        debug("reading or ended", doRead);
      } else if (doRead) {
        debug("do read");
        state.reading = true;
        state.sync = true;
        if (state.length === 0)
          state.needReadable = true;
        this._read(state.highWaterMark);
        state.sync = false;
        if (!state.reading)
          n = howMuchToRead(nOrig, state);
      }
      var ret2;
      if (n > 0)
        ret2 = fromList(n, state);
      else
        ret2 = null;
      if (ret2 === null) {
        state.needReadable = state.length <= state.highWaterMark;
        n = 0;
      } else {
        state.length -= n;
        state.awaitDrain = 0;
      }
      if (state.length === 0) {
        if (!state.ended)
          state.needReadable = true;
        if (nOrig !== n && state.ended)
          endReadable(this);
      }
      if (ret2 !== null)
        this.emit("data", ret2);
      return ret2;
    };
    function onEofChunk(stream, state) {
      debug("onEofChunk");
      if (state.ended)
        return;
      if (state.decoder) {
        var chunk = state.decoder.end();
        if (chunk && chunk.length) {
          state.buffer.push(chunk);
          state.length += state.objectMode ? 1 : chunk.length;
        }
      }
      state.ended = true;
      if (state.sync) {
        emitReadable(stream);
      } else {
        state.needReadable = false;
        if (!state.emittedReadable) {
          state.emittedReadable = true;
          emitReadable_(stream);
        }
      }
    }
    function emitReadable(stream) {
      var state = stream._readableState;
      debug("emitReadable", state.needReadable, state.emittedReadable);
      state.needReadable = false;
      if (!state.emittedReadable) {
        debug("emitReadable", state.flowing);
        state.emittedReadable = true;
        process.nextTick(emitReadable_, stream);
      }
    }
    function emitReadable_(stream) {
      var state = stream._readableState;
      debug("emitReadable_", state.destroyed, state.length, state.ended);
      if (!state.destroyed && (state.length || state.ended)) {
        stream.emit("readable");
        state.emittedReadable = false;
      }
      state.needReadable = !state.flowing && !state.ended && state.length <= state.highWaterMark;
      flow(stream);
    }
    function maybeReadMore(stream, state) {
      if (!state.readingMore) {
        state.readingMore = true;
        process.nextTick(maybeReadMore_, stream, state);
      }
    }
    function maybeReadMore_(stream, state) {
      while (!state.reading && !state.ended && (state.length < state.highWaterMark || state.flowing && state.length === 0)) {
        var len = state.length;
        debug("maybeReadMore read 0");
        stream.read(0);
        if (len === state.length)
          break;
      }
      state.readingMore = false;
    }
    Readable.prototype._read = function(n) {
      errorOrDestroy(this, new ERR_METHOD_NOT_IMPLEMENTED("_read()"));
    };
    Readable.prototype.pipe = function(dest, pipeOpts) {
      var src = this;
      var state = this._readableState;
      switch (state.pipesCount) {
        case 0:
          state.pipes = dest;
          break;
        case 1:
          state.pipes = [state.pipes, dest];
          break;
        default:
          state.pipes.push(dest);
          break;
      }
      state.pipesCount += 1;
      debug("pipe count=%d opts=%j", state.pipesCount, pipeOpts);
      var doEnd = (!pipeOpts || pipeOpts.end !== false) && dest !== process.stdout && dest !== process.stderr;
      var endFn = doEnd ? onend : unpipe;
      if (state.endEmitted)
        process.nextTick(endFn);
      else
        src.once("end", endFn);
      dest.on("unpipe", onunpipe);
      function onunpipe(readable, unpipeInfo) {
        debug("onunpipe");
        if (readable === src) {
          if (unpipeInfo && unpipeInfo.hasUnpiped === false) {
            unpipeInfo.hasUnpiped = true;
            cleanup();
          }
        }
      }
      function onend() {
        debug("onend");
        dest.end();
      }
      var ondrain = pipeOnDrain(src);
      dest.on("drain", ondrain);
      var cleanedUp = false;
      function cleanup() {
        debug("cleanup");
        dest.removeListener("close", onclose);
        dest.removeListener("finish", onfinish);
        dest.removeListener("drain", ondrain);
        dest.removeListener("error", onerror);
        dest.removeListener("unpipe", onunpipe);
        src.removeListener("end", onend);
        src.removeListener("end", unpipe);
        src.removeListener("data", ondata);
        cleanedUp = true;
        if (state.awaitDrain && (!dest._writableState || dest._writableState.needDrain))
          ondrain();
      }
      src.on("data", ondata);
      function ondata(chunk) {
        debug("ondata");
        var ret2 = dest.write(chunk);
        debug("dest.write", ret2);
        if (ret2 === false) {
          if ((state.pipesCount === 1 && state.pipes === dest || state.pipesCount > 1 && indexOf(state.pipes, dest) !== -1) && !cleanedUp) {
            debug("false write response, pause", state.awaitDrain);
            state.awaitDrain++;
          }
          src.pause();
        }
      }
      function onerror(er) {
        debug("onerror", er);
        unpipe();
        dest.removeListener("error", onerror);
        if (EElistenerCount(dest, "error") === 0)
          errorOrDestroy(dest, er);
      }
      prependListener(dest, "error", onerror);
      function onclose() {
        dest.removeListener("finish", onfinish);
        unpipe();
      }
      dest.once("close", onclose);
      function onfinish() {
        debug("onfinish");
        dest.removeListener("close", onclose);
        unpipe();
      }
      dest.once("finish", onfinish);
      function unpipe() {
        debug("unpipe");
        src.unpipe(dest);
      }
      dest.emit("pipe", src);
      if (!state.flowing) {
        debug("pipe resume");
        src.resume();
      }
      return dest;
    };
    function pipeOnDrain(src) {
      return function pipeOnDrainFunctionResult() {
        var state = src._readableState;
        debug("pipeOnDrain", state.awaitDrain);
        if (state.awaitDrain)
          state.awaitDrain--;
        if (state.awaitDrain === 0 && EElistenerCount(src, "data")) {
          state.flowing = true;
          flow(src);
        }
      };
    }
    Readable.prototype.unpipe = function(dest) {
      var state = this._readableState;
      var unpipeInfo = {
        hasUnpiped: false
      };
      if (state.pipesCount === 0)
        return this;
      if (state.pipesCount === 1) {
        if (dest && dest !== state.pipes)
          return this;
        if (!dest)
          dest = state.pipes;
        state.pipes = null;
        state.pipesCount = 0;
        state.flowing = false;
        if (dest)
          dest.emit("unpipe", this, unpipeInfo);
        return this;
      }
      if (!dest) {
        var dests = state.pipes;
        var len = state.pipesCount;
        state.pipes = null;
        state.pipesCount = 0;
        state.flowing = false;
        for (var i = 0; i < len; i++)
          dests[i].emit("unpipe", this, {
            hasUnpiped: false
          });
        return this;
      }
      var index = indexOf(state.pipes, dest);
      if (index === -1)
        return this;
      state.pipes.splice(index, 1);
      state.pipesCount -= 1;
      if (state.pipesCount === 1)
        state.pipes = state.pipes[0];
      dest.emit("unpipe", this, unpipeInfo);
      return this;
    };
    Readable.prototype.on = function(ev, fn) {
      var res = Stream.prototype.on.call(this, ev, fn);
      var state = this._readableState;
      if (ev === "data") {
        state.readableListening = this.listenerCount("readable") > 0;
        if (state.flowing !== false)
          this.resume();
      } else if (ev === "readable") {
        if (!state.endEmitted && !state.readableListening) {
          state.readableListening = state.needReadable = true;
          state.flowing = false;
          state.emittedReadable = false;
          debug("on readable", state.length, state.reading);
          if (state.length) {
            emitReadable(this);
          } else if (!state.reading) {
            process.nextTick(nReadingNextTick, this);
          }
        }
      }
      return res;
    };
    Readable.prototype.addListener = Readable.prototype.on;
    Readable.prototype.removeListener = function(ev, fn) {
      var res = Stream.prototype.removeListener.call(this, ev, fn);
      if (ev === "readable") {
        process.nextTick(updateReadableListening, this);
      }
      return res;
    };
    Readable.prototype.removeAllListeners = function(ev) {
      var res = Stream.prototype.removeAllListeners.apply(this, arguments);
      if (ev === "readable" || ev === void 0) {
        process.nextTick(updateReadableListening, this);
      }
      return res;
    };
    function updateReadableListening(self2) {
      var state = self2._readableState;
      state.readableListening = self2.listenerCount("readable") > 0;
      if (state.resumeScheduled && !state.paused) {
        state.flowing = true;
      } else if (self2.listenerCount("data") > 0) {
        self2.resume();
      }
    }
    function nReadingNextTick(self2) {
      debug("readable nexttick read 0");
      self2.read(0);
    }
    Readable.prototype.resume = function() {
      var state = this._readableState;
      if (!state.flowing) {
        debug("resume");
        state.flowing = !state.readableListening;
        resume(this, state);
      }
      state.paused = false;
      return this;
    };
    function resume(stream, state) {
      if (!state.resumeScheduled) {
        state.resumeScheduled = true;
        process.nextTick(resume_, stream, state);
      }
    }
    function resume_(stream, state) {
      debug("resume", state.reading);
      if (!state.reading) {
        stream.read(0);
      }
      state.resumeScheduled = false;
      stream.emit("resume");
      flow(stream);
      if (state.flowing && !state.reading)
        stream.read(0);
    }
    Readable.prototype.pause = function() {
      debug("call pause flowing=%j", this._readableState.flowing);
      if (this._readableState.flowing !== false) {
        debug("pause");
        this._readableState.flowing = false;
        this.emit("pause");
      }
      this._readableState.paused = true;
      return this;
    };
    function flow(stream) {
      var state = stream._readableState;
      debug("flow", state.flowing);
      while (state.flowing && stream.read() !== null)
        ;
    }
    Readable.prototype.wrap = function(stream) {
      var _this = this;
      var state = this._readableState;
      var paused = false;
      stream.on("end", function() {
        debug("wrapped end");
        if (state.decoder && !state.ended) {
          var chunk = state.decoder.end();
          if (chunk && chunk.length)
            _this.push(chunk);
        }
        _this.push(null);
      });
      stream.on("data", function(chunk) {
        debug("wrapped data");
        if (state.decoder)
          chunk = state.decoder.write(chunk);
        if (state.objectMode && (chunk === null || chunk === void 0))
          return;
        else if (!state.objectMode && (!chunk || !chunk.length))
          return;
        var ret2 = _this.push(chunk);
        if (!ret2) {
          paused = true;
          stream.pause();
        }
      });
      for (var i in stream) {
        if (this[i] === void 0 && typeof stream[i] === "function") {
          this[i] = /* @__PURE__ */ function methodWrap(method) {
            return function methodWrapReturnFunction() {
              return stream[method].apply(stream, arguments);
            };
          }(i);
        }
      }
      for (var n = 0; n < kProxyEvents.length; n++) {
        stream.on(kProxyEvents[n], this.emit.bind(this, kProxyEvents[n]));
      }
      this._read = function(n2) {
        debug("wrapped _read", n2);
        if (paused) {
          paused = false;
          stream.resume();
        }
      };
      return this;
    };
    if (typeof Symbol === "function") {
      Readable.prototype[Symbol.asyncIterator] = function() {
        if (createReadableStreamAsyncIterator === void 0) {
          createReadableStreamAsyncIterator = require_async_iterator();
        }
        return createReadableStreamAsyncIterator(this);
      };
    }
    Object.defineProperty(Readable.prototype, "readableHighWaterMark", {
      // making it explicit this property is not enumerable
      // because otherwise some prototype manipulation in
      // userland will fail
      enumerable: false,
      get: function get() {
        return this._readableState.highWaterMark;
      }
    });
    Object.defineProperty(Readable.prototype, "readableBuffer", {
      // making it explicit this property is not enumerable
      // because otherwise some prototype manipulation in
      // userland will fail
      enumerable: false,
      get: function get() {
        return this._readableState && this._readableState.buffer;
      }
    });
    Object.defineProperty(Readable.prototype, "readableFlowing", {
      // making it explicit this property is not enumerable
      // because otherwise some prototype manipulation in
      // userland will fail
      enumerable: false,
      get: function get() {
        return this._readableState.flowing;
      },
      set: function set(state) {
        if (this._readableState) {
          this._readableState.flowing = state;
        }
      }
    });
    Readable._fromList = fromList;
    Object.defineProperty(Readable.prototype, "readableLength", {
      // making it explicit this property is not enumerable
      // because otherwise some prototype manipulation in
      // userland will fail
      enumerable: false,
      get: function get() {
        return this._readableState.length;
      }
    });
    function fromList(n, state) {
      if (state.length === 0)
        return null;
      var ret2;
      if (state.objectMode)
        ret2 = state.buffer.shift();
      else if (!n || n >= state.length) {
        if (state.decoder)
          ret2 = state.buffer.join("");
        else if (state.buffer.length === 1)
          ret2 = state.buffer.first();
        else
          ret2 = state.buffer.concat(state.length);
        state.buffer.clear();
      } else {
        ret2 = state.buffer.consume(n, state.decoder);
      }
      return ret2;
    }
    function endReadable(stream) {
      var state = stream._readableState;
      debug("endReadable", state.endEmitted);
      if (!state.endEmitted) {
        state.ended = true;
        process.nextTick(endReadableNT, state, stream);
      }
    }
    function endReadableNT(state, stream) {
      debug("endReadableNT", state.endEmitted, state.length);
      if (!state.endEmitted && state.length === 0) {
        state.endEmitted = true;
        stream.readable = false;
        stream.emit("end");
        if (state.autoDestroy) {
          var wState = stream._writableState;
          if (!wState || wState.autoDestroy && wState.finished) {
            stream.destroy();
          }
        }
      }
    }
    if (typeof Symbol === "function") {
      Readable.from = function(iterable, opts) {
        if (from === void 0) {
          from = require_from();
        }
        return from(Readable, iterable, opts);
      };
    }
    function indexOf(xs, x) {
      for (var i = 0, l2 = xs.length; i < l2; i++) {
        if (xs[i] === x)
          return i;
      }
      return -1;
    }
  }
});

// ../../../node_modules/exceljs/node_modules/readable-stream/lib/_stream_transform.js
var require_stream_transform2 = __commonJS({
  "../../../node_modules/exceljs/node_modules/readable-stream/lib/_stream_transform.js"(exports2, module2) {
    "use strict";
    module2.exports = Transform;
    var _require$codes = require_errors().codes;
    var ERR_METHOD_NOT_IMPLEMENTED = _require$codes.ERR_METHOD_NOT_IMPLEMENTED;
    var ERR_MULTIPLE_CALLBACK = _require$codes.ERR_MULTIPLE_CALLBACK;
    var ERR_TRANSFORM_ALREADY_TRANSFORMING = _require$codes.ERR_TRANSFORM_ALREADY_TRANSFORMING;
    var ERR_TRANSFORM_WITH_LENGTH_0 = _require$codes.ERR_TRANSFORM_WITH_LENGTH_0;
    var Duplex = require_stream_duplex2();
    require_inherits()(Transform, Duplex);
    function afterTransform(er, data) {
      var ts = this._transformState;
      ts.transforming = false;
      var cb = ts.writecb;
      if (cb === null) {
        return this.emit("error", new ERR_MULTIPLE_CALLBACK());
      }
      ts.writechunk = null;
      ts.writecb = null;
      if (data != null)
        this.push(data);
      cb(er);
      var rs = this._readableState;
      rs.reading = false;
      if (rs.needReadable || rs.length < rs.highWaterMark) {
        this._read(rs.highWaterMark);
      }
    }
    function Transform(options) {
      if (!(this instanceof Transform))
        return new Transform(options);
      Duplex.call(this, options);
      this._transformState = {
        afterTransform: afterTransform.bind(this),
        needTransform: false,
        transforming: false,
        writecb: null,
        writechunk: null,
        writeencoding: null
      };
      this._readableState.needReadable = true;
      this._readableState.sync = false;
      if (options) {
        if (typeof options.transform === "function")
          this._transform = options.transform;
        if (typeof options.flush === "function")
          this._flush = options.flush;
      }
      this.on("prefinish", prefinish);
    }
    function prefinish() {
      var _this = this;
      if (typeof this._flush === "function" && !this._readableState.destroyed) {
        this._flush(function(er, data) {
          done(_this, er, data);
        });
      } else {
        done(this, null, null);
      }
    }
    Transform.prototype.push = function(chunk, encoding) {
      this._transformState.needTransform = false;
      return Duplex.prototype.push.call(this, chunk, encoding);
    };
    Transform.prototype._transform = function(chunk, encoding, cb) {
      cb(new ERR_METHOD_NOT_IMPLEMENTED("_transform()"));
    };
    Transform.prototype._write = function(chunk, encoding, cb) {
      var ts = this._transformState;
      ts.writecb = cb;
      ts.writechunk = chunk;
      ts.writeencoding = encoding;
      if (!ts.transforming) {
        var rs = this._readableState;
        if (ts.needTransform || rs.needReadable || rs.length < rs.highWaterMark)
          this._read(rs.highWaterMark);
      }
    };
    Transform.prototype._read = function(n) {
      var ts = this._transformState;
      if (ts.writechunk !== null && !ts.transforming) {
        ts.transforming = true;
        this._transform(ts.writechunk, ts.writeencoding, ts.afterTransform);
      } else {
        ts.needTransform = true;
      }
    };
    Transform.prototype._destroy = function(err, cb) {
      Duplex.prototype._destroy.call(this, err, function(err2) {
        cb(err2);
      });
    };
    function done(stream, er, data) {
      if (er)
        return stream.emit("error", er);
      if (data != null)
        stream.push(data);
      if (stream._writableState.length)
        throw new ERR_TRANSFORM_WITH_LENGTH_0();
      if (stream._transformState.transforming)
        throw new ERR_TRANSFORM_ALREADY_TRANSFORMING();
      return stream.push(null);
    }
  }
});

// ../../../node_modules/exceljs/node_modules/readable-stream/lib/_stream_passthrough.js
var require_stream_passthrough2 = __commonJS({
  "../../../node_modules/exceljs/node_modules/readable-stream/lib/_stream_passthrough.js"(exports2, module2) {
    "use strict";
    module2.exports = PassThrough;
    var Transform = require_stream_transform2();
    require_inherits()(PassThrough, Transform);
    function PassThrough(options) {
      if (!(this instanceof PassThrough))
        return new PassThrough(options);
      Transform.call(this, options);
    }
    PassThrough.prototype._transform = function(chunk, encoding, cb) {
      cb(null, chunk);
    };
  }
});

// ../../../node_modules/exceljs/node_modules/readable-stream/lib/internal/streams/pipeline.js
var require_pipeline = __commonJS({
  "../../../node_modules/exceljs/node_modules/readable-stream/lib/internal/streams/pipeline.js"(exports2, module2) {
    "use strict";
    var eos;
    function once(callback) {
      var called = false;
      return function() {
        if (called)
          return;
        called = true;
        callback.apply(void 0, arguments);
      };
    }
    var _require$codes = require_errors().codes;
    var ERR_MISSING_ARGS = _require$codes.ERR_MISSING_ARGS;
    var ERR_STREAM_DESTROYED = _require$codes.ERR_STREAM_DESTROYED;
    function noop(err) {
      if (err)
        throw err;
    }
    function isRequest(stream) {
      return stream.setHeader && typeof stream.abort === "function";
    }
    function destroyer(stream, reading, writing, callback) {
      callback = once(callback);
      var closed = false;
      stream.on("close", function() {
        closed = true;
      });
      if (eos === void 0)
        eos = require_end_of_stream();
      eos(stream, {
        readable: reading,
        writable: writing
      }, function(err) {
        if (err)
          return callback(err);
        closed = true;
        callback();
      });
      var destroyed = false;
      return function(err) {
        if (closed)
          return;
        if (destroyed)
          return;
        destroyed = true;
        if (isRequest(stream))
          return stream.abort();
        if (typeof stream.destroy === "function")
          return stream.destroy();
        callback(err || new ERR_STREAM_DESTROYED("pipe"));
      };
    }
    function call(fn) {
      fn();
    }
    function pipe(from, to) {
      return from.pipe(to);
    }
    function popCallback(streams) {
      if (!streams.length)
        return noop;
      if (typeof streams[streams.length - 1] !== "function")
        return noop;
      return streams.pop();
    }
    function pipeline() {
      for (var _len = arguments.length, streams = new Array(_len), _key = 0; _key < _len; _key++) {
        streams[_key] = arguments[_key];
      }
      var callback = popCallback(streams);
      if (Array.isArray(streams[0]))
        streams = streams[0];
      if (streams.length < 2) {
        throw new ERR_MISSING_ARGS("streams");
      }
      var error;
      var destroys = streams.map(function(stream, i) {
        var reading = i < streams.length - 1;
        var writing = i > 0;
        return destroyer(stream, reading, writing, function(err) {
          if (!error)
            error = err;
          if (err)
            destroys.forEach(call);
          if (reading)
            return;
          destroys.forEach(call);
          callback(error);
        });
      });
      return streams.reduce(pipe);
    }
    module2.exports = pipeline;
  }
});

// ../../../node_modules/exceljs/node_modules/readable-stream/readable.js
var require_readable2 = __commonJS({
  "../../../node_modules/exceljs/node_modules/readable-stream/readable.js"(exports2, module2) {
    var Stream = require("stream");
    if (process.env.READABLE_STREAM === "disable" && Stream) {
      module2.exports = Stream.Readable;
      Object.assign(module2.exports, Stream);
      module2.exports.Stream = Stream;
    } else {
      exports2 = module2.exports = require_stream_readable2();
      exports2.Stream = Stream || exports2;
      exports2.Readable = exports2;
      exports2.Writable = require_stream_writable2();
      exports2.Duplex = require_stream_duplex2();
      exports2.Transform = require_stream_transform2();
      exports2.PassThrough = require_stream_passthrough2();
      exports2.finished = require_end_of_stream();
      exports2.pipeline = require_pipeline();
    }
  }
});

// ../../../node_modules/exceljs/lib/utils/utils.js
var require_utils2 = __commonJS({
  "../../../node_modules/exceljs/lib/utils/utils.js"(exports2, module2) {
    var fs = require("fs");
    var inherits2 = function(cls, superCtor, statics, prototype) {
      cls.super_ = superCtor;
      if (!prototype) {
        prototype = statics;
        statics = null;
      }
      if (statics) {
        Object.keys(statics).forEach((i) => {
          Object.defineProperty(cls, i, Object.getOwnPropertyDescriptor(statics, i));
        });
      }
      const properties = {
        constructor: {
          value: cls,
          enumerable: false,
          writable: false,
          configurable: true
        }
      };
      if (prototype) {
        Object.keys(prototype).forEach((i) => {
          properties[i] = Object.getOwnPropertyDescriptor(prototype, i);
        });
      }
      cls.prototype = Object.create(superCtor.prototype, properties);
    };
    var xmlDecodeRegex = /[<>&'"\x7F\x00-\x08\x0B-\x0C\x0E-\x1F]/;
    var utils = {
      nop() {
      },
      promiseImmediate(value) {
        return new Promise((resolve) => {
          if (global.setImmediate) {
            setImmediate(() => {
              resolve(value);
            });
          } else {
            setTimeout(() => {
              resolve(value);
            }, 1);
          }
        });
      },
      inherits: inherits2,
      dateToExcel(d, date1904) {
        return 25569 + d.getTime() / (24 * 3600 * 1e3) - (date1904 ? 1462 : 0);
      },
      excelToDate(v, date1904) {
        const millisecondSinceEpoch = Math.round((v - 25569 + (date1904 ? 1462 : 0)) * 24 * 3600 * 1e3);
        return new Date(millisecondSinceEpoch);
      },
      parsePath(filepath) {
        const last = filepath.lastIndexOf("/");
        return {
          path: filepath.substring(0, last),
          name: filepath.substring(last + 1)
        };
      },
      getRelsPath(filepath) {
        const path = utils.parsePath(filepath);
        return `${path.path}/_rels/${path.name}.rels`;
      },
      xmlEncode(text) {
        const regexResult = xmlDecodeRegex.exec(text);
        if (!regexResult)
          return text;
        let result = "";
        let escape = "";
        let lastIndex = 0;
        let i = regexResult.index;
        for (; i < text.length; i++) {
          const charCode = text.charCodeAt(i);
          switch (charCode) {
            case 34:
              escape = "&quot;";
              break;
            case 38:
              escape = "&amp;";
              break;
            case 39:
              escape = "&apos;";
              break;
            case 60:
              escape = "&lt;";
              break;
            case 62:
              escape = "&gt;";
              break;
            case 127:
              escape = "";
              break;
            default: {
              if (charCode <= 31 && (charCode <= 8 || charCode >= 11 && charCode !== 13)) {
                escape = "";
                break;
              }
              continue;
            }
          }
          if (lastIndex !== i)
            result += text.substring(lastIndex, i);
          lastIndex = i + 1;
          if (escape)
            result += escape;
        }
        if (lastIndex !== i)
          return result + text.substring(lastIndex, i);
        return result;
      },
      xmlDecode(text) {
        return text.replace(/&([a-z]*);/g, (c) => {
          switch (c) {
            case "&lt;":
              return "<";
            case "&gt;":
              return ">";
            case "&amp;":
              return "&";
            case "&apos;":
              return "'";
            case "&quot;":
              return '"';
            default:
              return c;
          }
        });
      },
      validInt(value) {
        const i = parseInt(value, 10);
        return !Number.isNaN(i) ? i : 0;
      },
      isDateFmt(fmt) {
        if (!fmt) {
          return false;
        }
        fmt = fmt.replace(/\[[^\]]*]/g, "");
        fmt = fmt.replace(/"[^"]*"/g, "");
        const result = fmt.match(/[ymdhMsb]+/) !== null;
        return result;
      },
      fs: {
        exists(path) {
          return new Promise((resolve) => {
            fs.access(path, fs.constants.F_OK, (err) => {
              resolve(!err);
            });
          });
        }
      },
      toIsoDateString(dt) {
        return dt.toIsoString().subsstr(0, 10);
      },
      parseBoolean(value) {
        return value === true || value === "true" || value === 1 || value === "1";
      }
    };
    module2.exports = utils;
  }
});

// ../../../node_modules/exceljs/lib/utils/string-buf.js
var require_string_buf = __commonJS({
  "../../../node_modules/exceljs/lib/utils/string-buf.js"(exports2, module2) {
    var StringBuf = class {
      constructor(options) {
        this._buf = Buffer.alloc(options && options.size || 16384);
        this._encoding = options && options.encoding || "utf8";
        this._inPos = 0;
        this._buffer = void 0;
      }
      get length() {
        return this._inPos;
      }
      get capacity() {
        return this._buf.length;
      }
      get buffer() {
        return this._buf;
      }
      toBuffer() {
        if (!this._buffer) {
          this._buffer = Buffer.alloc(this.length);
          this._buf.copy(this._buffer, 0, 0, this.length);
        }
        return this._buffer;
      }
      reset(position) {
        position = position || 0;
        this._buffer = void 0;
        this._inPos = position;
      }
      _grow(min) {
        let size = this._buf.length * 2;
        while (size < min) {
          size *= 2;
        }
        const buf = Buffer.alloc(size);
        this._buf.copy(buf, 0);
        this._buf = buf;
      }
      addText(text) {
        this._buffer = void 0;
        let inPos = this._inPos + this._buf.write(text, this._inPos, this._encoding);
        while (inPos >= this._buf.length - 4) {
          this._grow(this._inPos + text.length);
          inPos = this._inPos + this._buf.write(text, this._inPos, this._encoding);
        }
        this._inPos = inPos;
      }
      addStringBuf(inBuf) {
        if (inBuf.length) {
          this._buffer = void 0;
          if (this.length + inBuf.length > this.capacity) {
            this._grow(this.length + inBuf.length);
          }
          inBuf._buf.copy(this._buf, this._inPos, 0, inBuf.length);
          this._inPos += inBuf.length;
        }
      }
    };
    module2.exports = StringBuf;
  }
});

// ../../../node_modules/exceljs/lib/utils/stream-buf.js
var require_stream_buf = __commonJS({
  "../../../node_modules/exceljs/lib/utils/stream-buf.js"(exports2, module2) {
    var Stream = require_readable2();
    var utils = require_utils2();
    var StringBuf = require_string_buf();
    var StringChunk = class {
      constructor(data, encoding) {
        this._data = data;
        this._encoding = encoding;
      }
      get length() {
        return this.toBuffer().length;
      }
      // copy to target buffer
      copy(target, targetOffset, offset, length) {
        return this.toBuffer().copy(target, targetOffset, offset, length);
      }
      toBuffer() {
        if (!this._buffer) {
          this._buffer = Buffer.from(this._data, this._encoding);
        }
        return this._buffer;
      }
    };
    var StringBufChunk = class {
      constructor(data) {
        this._data = data;
      }
      get length() {
        return this._data.length;
      }
      // copy to target buffer
      copy(target, targetOffset, offset, length) {
        return this._data._buf.copy(target, targetOffset, offset, length);
      }
      toBuffer() {
        return this._data.toBuffer();
      }
    };
    var BufferChunk = class {
      constructor(data) {
        this._data = data;
      }
      get length() {
        return this._data.length;
      }
      // copy to target buffer
      copy(target, targetOffset, offset, length) {
        this._data.copy(target, targetOffset, offset, length);
      }
      toBuffer() {
        return this._data;
      }
    };
    var ReadWriteBuf = class {
      constructor(size) {
        this.size = size;
        this.buffer = Buffer.alloc(size);
        this.iRead = 0;
        this.iWrite = 0;
      }
      toBuffer() {
        if (this.iRead === 0 && this.iWrite === this.size) {
          return this.buffer;
        }
        const buf = Buffer.alloc(this.iWrite - this.iRead);
        this.buffer.copy(buf, 0, this.iRead, this.iWrite);
        return buf;
      }
      get length() {
        return this.iWrite - this.iRead;
      }
      get eod() {
        return this.iRead === this.iWrite;
      }
      get full() {
        return this.iWrite === this.size;
      }
      read(size) {
        let buf;
        if (size === 0) {
          return null;
        }
        if (size === void 0 || size >= this.length) {
          buf = this.toBuffer();
          this.iRead = this.iWrite;
          return buf;
        }
        buf = Buffer.alloc(size);
        this.buffer.copy(buf, 0, this.iRead, size);
        this.iRead += size;
        return buf;
      }
      write(chunk, offset, length) {
        const size = Math.min(length, this.size - this.iWrite);
        chunk.copy(this.buffer, this.iWrite, offset, offset + size);
        this.iWrite += size;
        return size;
      }
    };
    var StreamBuf = function(options) {
      options = options || {};
      this.bufSize = options.bufSize || 1024 * 1024;
      this.buffers = [];
      this.batch = options.batch || false;
      this.corked = false;
      this.inPos = 0;
      this.outPos = 0;
      this.pipes = [];
      this.paused = false;
      this.encoding = null;
    };
    utils.inherits(StreamBuf, Stream.Duplex, {
      toBuffer() {
        switch (this.buffers.length) {
          case 0:
            return null;
          case 1:
            return this.buffers[0].toBuffer();
          default:
            return Buffer.concat(this.buffers.map((rwBuf) => rwBuf.toBuffer()));
        }
      },
      // writable
      // event drain - if write returns false (which it won't), indicates when safe to write again.
      // finish - end() has been called
      // pipe(src) - pipe() has been called on readable
      // unpipe(src) - unpipe() has been called on readable
      // error - duh
      _getWritableBuffer() {
        if (this.buffers.length) {
          const last = this.buffers[this.buffers.length - 1];
          if (!last.full) {
            return last;
          }
        }
        const buf = new ReadWriteBuf(this.bufSize);
        this.buffers.push(buf);
        return buf;
      },
      async _pipe(chunk) {
        const write = function(pipe) {
          return new Promise((resolve) => {
            pipe.write(chunk.toBuffer(), () => {
              resolve();
            });
          });
        };
        await Promise.all(this.pipes.map(write));
      },
      _writeToBuffers(chunk) {
        let inPos = 0;
        const inLen = chunk.length;
        while (inPos < inLen) {
          const buffer = this._getWritableBuffer();
          inPos += buffer.write(chunk, inPos, inLen - inPos);
        }
      },
      async write(data, encoding, callback) {
        if (encoding instanceof Function) {
          callback = encoding;
          encoding = "utf8";
        }
        callback = callback || utils.nop;
        let chunk;
        if (data instanceof StringBuf) {
          chunk = new StringBufChunk(data);
        } else if (data instanceof Buffer) {
          chunk = new BufferChunk(data);
        } else if (typeof data === "string" || data instanceof String || data instanceof ArrayBuffer) {
          chunk = new StringChunk(data, encoding);
        } else {
          throw new Error("Chunk must be one of type String, Buffer or StringBuf.");
        }
        if (this.pipes.length) {
          if (this.batch) {
            this._writeToBuffers(chunk);
            while (!this.corked && this.buffers.length > 1) {
              this._pipe(this.buffers.shift());
            }
          } else if (!this.corked) {
            await this._pipe(chunk);
            callback();
          } else {
            this._writeToBuffers(chunk);
            process.nextTick(callback);
          }
        } else {
          if (!this.paused) {
            this.emit("data", chunk.toBuffer());
          }
          this._writeToBuffers(chunk);
          this.emit("readable");
        }
        return true;
      },
      cork() {
        this.corked = true;
      },
      _flush() {
        if (this.pipes.length) {
          while (this.buffers.length) {
            this._pipe(this.buffers.shift());
          }
        }
      },
      uncork() {
        this.corked = false;
        this._flush();
      },
      end(chunk, encoding, callback) {
        const writeComplete = (error) => {
          if (error) {
            callback(error);
          } else {
            this._flush();
            this.pipes.forEach((pipe) => {
              pipe.end();
            });
            this.emit("finish");
          }
        };
        if (chunk) {
          this.write(chunk, encoding, writeComplete);
        } else {
          writeComplete();
        }
      },
      // readable
      // event readable - some data is now available
      // event data - switch to flowing mode - feeds chunks to handler
      // event end - no more data
      // event close - optional, indicates upstream close
      // event error - duh
      read(size) {
        let buffers;
        if (size) {
          buffers = [];
          while (size && this.buffers.length && !this.buffers[0].eod) {
            const first = this.buffers[0];
            const buffer = first.read(size);
            size -= buffer.length;
            buffers.push(buffer);
            if (first.eod && first.full) {
              this.buffers.shift();
            }
          }
          return Buffer.concat(buffers);
        }
        buffers = this.buffers.map((buf) => buf.toBuffer()).filter(Boolean);
        this.buffers = [];
        return Buffer.concat(buffers);
      },
      setEncoding(encoding) {
        this.encoding = encoding;
      },
      pause() {
        this.paused = true;
      },
      resume() {
        this.paused = false;
      },
      isPaused() {
        return !!this.paused;
      },
      pipe(destination) {
        this.pipes.push(destination);
        if (!this.paused && this.buffers.length) {
          this.end();
        }
      },
      unpipe(destination) {
        this.pipes = this.pipes.filter((pipe) => pipe !== destination);
      },
      unshift() {
        throw new Error("Not Implemented");
      },
      wrap() {
        throw new Error("Not Implemented");
      }
    });
    module2.exports = StreamBuf;
  }
});

// ../../../node_modules/exceljs/lib/utils/browser-buffer-encode.js
var require_browser_buffer_encode = __commonJS({
  "../../../node_modules/exceljs/lib/utils/browser-buffer-encode.js"(exports2) {
    var textEncoder = typeof TextEncoder === "undefined" ? null : new TextEncoder("utf-8");
    var { Buffer: Buffer2 } = require("buffer");
    function stringToBuffer(str) {
      if (typeof str !== "string") {
        return str;
      }
      if (textEncoder) {
        return Buffer2.from(textEncoder.encode(str).buffer);
      }
      return Buffer2.from(str);
    }
    exports2.stringToBuffer = stringToBuffer;
  }
});

// ../../../node_modules/exceljs/lib/utils/zip-stream.js
var require_zip_stream = __commonJS({
  "../../../node_modules/exceljs/lib/utils/zip-stream.js"(exports2, module2) {
    var events = require("events");
    var JSZip = require_lib3();
    var StreamBuf = require_stream_buf();
    var { stringToBuffer } = require_browser_buffer_encode();
    var ZipWriter = class extends events.EventEmitter {
      constructor(options) {
        super();
        this.options = Object.assign(
          {
            type: "nodebuffer",
            compression: "DEFLATE"
          },
          options
        );
        this.zip = new JSZip();
        this.stream = new StreamBuf();
      }
      append(data, options) {
        if (options.hasOwnProperty("base64") && options.base64) {
          this.zip.file(options.name, data, { base64: true });
        } else {
          if (process.browser && typeof data === "string") {
            data = stringToBuffer(data);
          }
          this.zip.file(options.name, data);
        }
      }
      async finalize() {
        const content = await this.zip.generateAsync(this.options);
        this.stream.end(content);
        this.emit("finish");
      }
      // ==========================================================================
      // Stream.Readable interface
      read(size) {
        return this.stream.read(size);
      }
      setEncoding(encoding) {
        return this.stream.setEncoding(encoding);
      }
      pause() {
        return this.stream.pause();
      }
      resume() {
        return this.stream.resume();
      }
      isPaused() {
        return this.stream.isPaused();
      }
      pipe(destination, options) {
        return this.stream.pipe(destination, options);
      }
      unpipe(destination) {
        return this.stream.unpipe(destination);
      }
      unshift(chunk) {
        return this.stream.unshift(chunk);
      }
      wrap(stream) {
        return this.stream.wrap(stream);
      }
    };
    module2.exports = {
      ZipWriter
    };
  }
});

// ../../../node_modules/exceljs/lib/utils/xml-stream.js
var require_xml_stream = __commonJS({
  "../../../node_modules/exceljs/lib/utils/xml-stream.js"(exports2, module2) {
    var _2 = require_under_dash();
    var utils = require_utils2();
    var OPEN_ANGLE = "<";
    var CLOSE_ANGLE = ">";
    var OPEN_ANGLE_SLASH = "</";
    var CLOSE_SLASH_ANGLE = "/>";
    function pushAttribute(xml, name, value) {
      xml.push(` ${name}="${utils.xmlEncode(value.toString())}"`);
    }
    function pushAttributes(xml, attributes) {
      if (attributes) {
        const tmp = [];
        _2.each(attributes, (value, name) => {
          if (value !== void 0) {
            pushAttribute(tmp, name, value);
          }
        });
        xml.push(tmp.join(""));
      }
    }
    var XmlStream = class {
      constructor() {
        this._xml = [];
        this._stack = [];
        this._rollbacks = [];
      }
      get tos() {
        return this._stack.length ? this._stack[this._stack.length - 1] : void 0;
      }
      get cursor() {
        return this._xml.length;
      }
      openXml(docAttributes) {
        const xml = this._xml;
        xml.push("<?xml");
        pushAttributes(xml, docAttributes);
        xml.push("?>\n");
      }
      openNode(name, attributes) {
        const parent = this.tos;
        const xml = this._xml;
        if (parent && this.open) {
          xml.push(CLOSE_ANGLE);
        }
        this._stack.push(name);
        xml.push(OPEN_ANGLE);
        xml.push(name);
        pushAttributes(xml, attributes);
        this.leaf = true;
        this.open = true;
      }
      addAttribute(name, value) {
        if (!this.open) {
          throw new Error("Cannot write attributes to node if it is not open");
        }
        if (value !== void 0) {
          pushAttribute(this._xml, name, value);
        }
      }
      addAttributes(attrs) {
        if (!this.open) {
          throw new Error("Cannot write attributes to node if it is not open");
        }
        pushAttributes(this._xml, attrs);
      }
      writeText(text) {
        const xml = this._xml;
        if (this.open) {
          xml.push(CLOSE_ANGLE);
          this.open = false;
        }
        this.leaf = false;
        xml.push(utils.xmlEncode(text.toString()));
      }
      writeXml(xml) {
        if (this.open) {
          this._xml.push(CLOSE_ANGLE);
          this.open = false;
        }
        this.leaf = false;
        this._xml.push(xml);
      }
      closeNode() {
        const node = this._stack.pop();
        const xml = this._xml;
        if (this.leaf) {
          xml.push(CLOSE_SLASH_ANGLE);
        } else {
          xml.push(OPEN_ANGLE_SLASH);
          xml.push(node);
          xml.push(CLOSE_ANGLE);
        }
        this.open = false;
        this.leaf = false;
      }
      leafNode(name, attributes, text) {
        this.openNode(name, attributes);
        if (text !== void 0) {
          this.writeText(text);
        }
        this.closeNode();
      }
      closeAll() {
        while (this._stack.length) {
          this.closeNode();
        }
      }
      addRollback() {
        this._rollbacks.push({
          xml: this._xml.length,
          stack: this._stack.length,
          leaf: this.leaf,
          open: this.open
        });
        return this.cursor;
      }
      commit() {
        this._rollbacks.pop();
      }
      rollback() {
        const r = this._rollbacks.pop();
        if (this._xml.length > r.xml) {
          this._xml.splice(r.xml, this._xml.length - r.xml);
        }
        if (this._stack.length > r.stack) {
          this._stack.splice(r.stack, this._stack.length - r.stack);
        }
        this.leaf = r.leaf;
        this.open = r.open;
      }
      get xml() {
        this.closeAll();
        return this._xml.join("");
      }
    };
    XmlStream.StdDocAttributes = {
      version: "1.0",
      encoding: "UTF-8",
      standalone: "yes"
    };
    module2.exports = XmlStream;
  }
});

// ../../../node_modules/exceljs/lib/utils/browser-buffer-decode.js
var require_browser_buffer_decode = __commonJS({
  "../../../node_modules/exceljs/lib/utils/browser-buffer-decode.js"(exports2) {
    var textDecoder = typeof TextDecoder === "undefined" ? null : new TextDecoder("utf-8");
    function bufferToString(chunk) {
      if (typeof chunk === "string") {
        return chunk;
      }
      if (textDecoder) {
        return textDecoder.decode(chunk);
      }
      return chunk.toString();
    }
    exports2.bufferToString = bufferToString;
  }
});

// ../../../node_modules/xmlchars/xml/1.0/ed5.js
var require_ed5 = __commonJS({
  "../../../node_modules/xmlchars/xml/1.0/ed5.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.CHAR = "	\n\r -\uD7FF\uE000-\uFFFD\u{10000}-\u{10FFFF}";
    exports2.S = " 	\r\n";
    exports2.NAME_START_CHAR = ":A-Z_a-z\xC0-\xD6\xD8-\xF6\xF8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\u{10000}-\u{EFFFF}";
    exports2.NAME_CHAR = "-" + exports2.NAME_START_CHAR + ".0-9\xB7\u0300-\u036F\u203F-\u2040";
    exports2.CHAR_RE = new RegExp("^[" + exports2.CHAR + "]$", "u");
    exports2.S_RE = new RegExp("^[" + exports2.S + "]+$", "u");
    exports2.NAME_START_CHAR_RE = new RegExp("^[" + exports2.NAME_START_CHAR + "]$", "u");
    exports2.NAME_CHAR_RE = new RegExp("^[" + exports2.NAME_CHAR + "]$", "u");
    exports2.NAME_RE = new RegExp("^[" + exports2.NAME_START_CHAR + "][" + exports2.NAME_CHAR + "]*$", "u");
    exports2.NMTOKEN_RE = new RegExp("^[" + exports2.NAME_CHAR + "]+$", "u");
    var TAB = 9;
    var NL = 10;
    var CR = 13;
    var SPACE = 32;
    exports2.S_LIST = [SPACE, NL, CR, TAB];
    function isChar(c) {
      return c >= SPACE && c <= 55295 || c === NL || c === CR || c === TAB || c >= 57344 && c <= 65533 || c >= 65536 && c <= 1114111;
    }
    exports2.isChar = isChar;
    function isS(c) {
      return c === SPACE || c === NL || c === CR || c === TAB;
    }
    exports2.isS = isS;
    function isNameStartChar(c) {
      return c >= 65 && c <= 90 || c >= 97 && c <= 122 || c === 58 || c === 95 || c === 8204 || c === 8205 || c >= 192 && c <= 214 || c >= 216 && c <= 246 || c >= 248 && c <= 767 || c >= 880 && c <= 893 || c >= 895 && c <= 8191 || c >= 8304 && c <= 8591 || c >= 11264 && c <= 12271 || c >= 12289 && c <= 55295 || c >= 63744 && c <= 64975 || c >= 65008 && c <= 65533 || c >= 65536 && c <= 983039;
    }
    exports2.isNameStartChar = isNameStartChar;
    function isNameChar(c) {
      return isNameStartChar(c) || c >= 48 && c <= 57 || c === 45 || c === 46 || c === 183 || c >= 768 && c <= 879 || c >= 8255 && c <= 8256;
    }
    exports2.isNameChar = isNameChar;
  }
});

// ../../../node_modules/xmlchars/xml/1.1/ed2.js
var require_ed2 = __commonJS({
  "../../../node_modules/xmlchars/xml/1.1/ed2.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.CHAR = "-\uD7FF\uE000-\uFFFD\u{10000}-\u{10FFFF}";
    exports2.RESTRICTED_CHAR = "-\b\v\f-\x7F-\x84\x86-\x9F";
    exports2.S = " 	\r\n";
    exports2.NAME_START_CHAR = ":A-Z_a-z\xC0-\xD6\xD8-\xF6\xF8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\u{10000}-\u{EFFFF}";
    exports2.NAME_CHAR = "-" + exports2.NAME_START_CHAR + ".0-9\xB7\u0300-\u036F\u203F-\u2040";
    exports2.CHAR_RE = new RegExp("^[" + exports2.CHAR + "]$", "u");
    exports2.RESTRICTED_CHAR_RE = new RegExp("^[" + exports2.RESTRICTED_CHAR + "]$", "u");
    exports2.S_RE = new RegExp("^[" + exports2.S + "]+$", "u");
    exports2.NAME_START_CHAR_RE = new RegExp("^[" + exports2.NAME_START_CHAR + "]$", "u");
    exports2.NAME_CHAR_RE = new RegExp("^[" + exports2.NAME_CHAR + "]$", "u");
    exports2.NAME_RE = new RegExp("^[" + exports2.NAME_START_CHAR + "][" + exports2.NAME_CHAR + "]*$", "u");
    exports2.NMTOKEN_RE = new RegExp("^[" + exports2.NAME_CHAR + "]+$", "u");
    var TAB = 9;
    var NL = 10;
    var CR = 13;
    var SPACE = 32;
    exports2.S_LIST = [SPACE, NL, CR, TAB];
    function isChar(c) {
      return c >= 1 && c <= 55295 || c >= 57344 && c <= 65533 || c >= 65536 && c <= 1114111;
    }
    exports2.isChar = isChar;
    function isRestrictedChar(c) {
      return c >= 1 && c <= 8 || c === 11 || c === 12 || c >= 14 && c <= 31 || c >= 127 && c <= 132 || c >= 134 && c <= 159;
    }
    exports2.isRestrictedChar = isRestrictedChar;
    function isCharAndNotRestricted(c) {
      return c === 9 || c === 10 || c === 13 || c > 31 && c < 127 || c === 133 || c > 159 && c <= 55295 || c >= 57344 && c <= 65533 || c >= 65536 && c <= 1114111;
    }
    exports2.isCharAndNotRestricted = isCharAndNotRestricted;
    function isS(c) {
      return c === SPACE || c === NL || c === CR || c === TAB;
    }
    exports2.isS = isS;
    function isNameStartChar(c) {
      return c >= 65 && c <= 90 || c >= 97 && c <= 122 || c === 58 || c === 95 || c === 8204 || c === 8205 || c >= 192 && c <= 214 || c >= 216 && c <= 246 || c >= 248 && c <= 767 || c >= 880 && c <= 893 || c >= 895 && c <= 8191 || c >= 8304 && c <= 8591 || c >= 11264 && c <= 12271 || c >= 12289 && c <= 55295 || c >= 63744 && c <= 64975 || c >= 65008 && c <= 65533 || c >= 65536 && c <= 983039;
    }
    exports2.isNameStartChar = isNameStartChar;
    function isNameChar(c) {
      return isNameStartChar(c) || c >= 48 && c <= 57 || c === 45 || c === 46 || c === 183 || c >= 768 && c <= 879 || c >= 8255 && c <= 8256;
    }
    exports2.isNameChar = isNameChar;
  }
});

// ../../../node_modules/xmlchars/xmlns/1.0/ed3.js
var require_ed3 = __commonJS({
  "../../../node_modules/xmlchars/xmlns/1.0/ed3.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.NC_NAME_START_CHAR = "A-Z_a-z\xC0-\xD6\xD8-\xF6\xF8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\u{10000}-\u{EFFFF}";
    exports2.NC_NAME_CHAR = "-" + exports2.NC_NAME_START_CHAR + ".0-9\xB7\u0300-\u036F\u203F-\u2040";
    exports2.NC_NAME_START_CHAR_RE = new RegExp("^[" + exports2.NC_NAME_START_CHAR + "]$", "u");
    exports2.NC_NAME_CHAR_RE = new RegExp("^[" + exports2.NC_NAME_CHAR + "]$", "u");
    exports2.NC_NAME_RE = new RegExp("^[" + exports2.NC_NAME_START_CHAR + "][" + exports2.NC_NAME_CHAR + "]*$", "u");
    function isNCNameStartChar(c) {
      return c >= 65 && c <= 90 || c === 95 || c >= 97 && c <= 122 || c >= 192 && c <= 214 || c >= 216 && c <= 246 || c >= 248 && c <= 767 || c >= 880 && c <= 893 || c >= 895 && c <= 8191 || c >= 8204 && c <= 8205 || c >= 8304 && c <= 8591 || c >= 11264 && c <= 12271 || c >= 12289 && c <= 55295 || c >= 63744 && c <= 64975 || c >= 65008 && c <= 65533 || c >= 65536 && c <= 983039;
    }
    exports2.isNCNameStartChar = isNCNameStartChar;
    function isNCNameChar(c) {
      return isNCNameStartChar(c) || (c === 45 || c === 46 || c >= 48 && c <= 57 || c === 183 || c >= 768 && c <= 879 || c >= 8255 && c <= 8256);
    }
    exports2.isNCNameChar = isNCNameChar;
  }
});

// ../../../node_modules/saxes/saxes.js
var require_saxes = __commonJS({
  "../../../node_modules/saxes/saxes.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var ed5 = require_ed5();
    var ed2 = require_ed2();
    var NSed3 = require_ed3();
    var isS = ed5.isS;
    var isChar10 = ed5.isChar;
    var isNameStartChar = ed5.isNameStartChar;
    var isNameChar = ed5.isNameChar;
    var S_LIST = ed5.S_LIST;
    var NAME_RE = ed5.NAME_RE;
    var isChar11 = ed2.isChar;
    var isNCNameStartChar = NSed3.isNCNameStartChar;
    var isNCNameChar = NSed3.isNCNameChar;
    var NC_NAME_RE = NSed3.NC_NAME_RE;
    var XML_NAMESPACE = "http://www.w3.org/XML/1998/namespace";
    var XMLNS_NAMESPACE = "http://www.w3.org/2000/xmlns/";
    var rootNS = {
      // eslint-disable-next-line @typescript-eslint/no-explicit-any
      __proto__: null,
      xml: XML_NAMESPACE,
      xmlns: XMLNS_NAMESPACE
    };
    var XML_ENTITIES = {
      // eslint-disable-next-line @typescript-eslint/no-explicit-any
      __proto__: null,
      amp: "&",
      gt: ">",
      lt: "<",
      quot: '"',
      apos: "'"
    };
    var EOC = -1;
    var NL_LIKE = -2;
    var S_BEGIN = 0;
    var S_BEGIN_WHITESPACE = 1;
    var S_DOCTYPE = 2;
    var S_DOCTYPE_QUOTE = 3;
    var S_DTD = 4;
    var S_DTD_QUOTED = 5;
    var S_DTD_OPEN_WAKA = 6;
    var S_DTD_OPEN_WAKA_BANG = 7;
    var S_DTD_COMMENT = 8;
    var S_DTD_COMMENT_ENDING = 9;
    var S_DTD_COMMENT_ENDED = 10;
    var S_DTD_PI = 11;
    var S_DTD_PI_ENDING = 12;
    var S_TEXT = 13;
    var S_ENTITY = 14;
    var S_OPEN_WAKA = 15;
    var S_OPEN_WAKA_BANG = 16;
    var S_COMMENT = 17;
    var S_COMMENT_ENDING = 18;
    var S_COMMENT_ENDED = 19;
    var S_CDATA = 20;
    var S_CDATA_ENDING = 21;
    var S_CDATA_ENDING_2 = 22;
    var S_PI_FIRST_CHAR = 23;
    var S_PI_REST = 24;
    var S_PI_BODY = 25;
    var S_PI_ENDING = 26;
    var S_XML_DECL_NAME_START = 27;
    var S_XML_DECL_NAME = 28;
    var S_XML_DECL_EQ = 29;
    var S_XML_DECL_VALUE_START = 30;
    var S_XML_DECL_VALUE = 31;
    var S_XML_DECL_SEPARATOR = 32;
    var S_XML_DECL_ENDING = 33;
    var S_OPEN_TAG = 34;
    var S_OPEN_TAG_SLASH = 35;
    var S_ATTRIB = 36;
    var S_ATTRIB_NAME = 37;
    var S_ATTRIB_NAME_SAW_WHITE = 38;
    var S_ATTRIB_VALUE = 39;
    var S_ATTRIB_VALUE_QUOTED = 40;
    var S_ATTRIB_VALUE_CLOSED = 41;
    var S_ATTRIB_VALUE_UNQUOTED = 42;
    var S_CLOSE_TAG = 43;
    var S_CLOSE_TAG_SAW_WHITE = 44;
    var TAB = 9;
    var NL = 10;
    var CR = 13;
    var SPACE = 32;
    var BANG = 33;
    var DQUOTE = 34;
    var AMP = 38;
    var SQUOTE = 39;
    var MINUS = 45;
    var FORWARD_SLASH = 47;
    var SEMICOLON = 59;
    var LESS = 60;
    var EQUAL = 61;
    var GREATER = 62;
    var QUESTION = 63;
    var OPEN_BRACKET = 91;
    var CLOSE_BRACKET = 93;
    var NEL = 133;
    var LS = 8232;
    var isQuote = (c) => c === DQUOTE || c === SQUOTE;
    var QUOTES = [DQUOTE, SQUOTE];
    var DOCTYPE_TERMINATOR = [...QUOTES, OPEN_BRACKET, GREATER];
    var DTD_TERMINATOR = [...QUOTES, LESS, CLOSE_BRACKET];
    var XML_DECL_NAME_TERMINATOR = [EQUAL, QUESTION, ...S_LIST];
    var ATTRIB_VALUE_UNQUOTED_TERMINATOR = [...S_LIST, GREATER, AMP, LESS];
    function nsPairCheck(parser, prefix, uri) {
      switch (prefix) {
        case "xml":
          if (uri !== XML_NAMESPACE) {
            parser.fail(`xml prefix must be bound to ${XML_NAMESPACE}.`);
          }
          break;
        case "xmlns":
          if (uri !== XMLNS_NAMESPACE) {
            parser.fail(`xmlns prefix must be bound to ${XMLNS_NAMESPACE}.`);
          }
          break;
        default:
      }
      switch (uri) {
        case XMLNS_NAMESPACE:
          parser.fail(prefix === "" ? `the default namespace may not be set to ${uri}.` : `may not assign a prefix (even "xmlns") to the URI ${XMLNS_NAMESPACE}.`);
          break;
        case XML_NAMESPACE:
          switch (prefix) {
            case "xml":
              break;
            case "":
              parser.fail(`the default namespace may not be set to ${uri}.`);
              break;
            default:
              parser.fail("may not assign the xml namespace to another prefix.");
          }
          break;
        default:
      }
    }
    function nsMappingCheck(parser, mapping) {
      for (const local of Object.keys(mapping)) {
        nsPairCheck(parser, local, mapping[local]);
      }
    }
    var isNCName = (name) => NC_NAME_RE.test(name);
    var isName = (name) => NAME_RE.test(name);
    var FORBIDDEN_START = 0;
    var FORBIDDEN_BRACKET = 1;
    var FORBIDDEN_BRACKET_BRACKET = 2;
    exports2.EVENTS = [
      "xmldecl",
      "text",
      "processinginstruction",
      "doctype",
      "comment",
      "opentagstart",
      "attribute",
      "opentag",
      "closetag",
      "cdata",
      "error",
      "end",
      "ready"
    ];
    var EVENT_NAME_TO_HANDLER_NAME = {
      xmldecl: "xmldeclHandler",
      text: "textHandler",
      processinginstruction: "piHandler",
      doctype: "doctypeHandler",
      comment: "commentHandler",
      opentagstart: "openTagStartHandler",
      attribute: "attributeHandler",
      opentag: "openTagHandler",
      closetag: "closeTagHandler",
      cdata: "cdataHandler",
      error: "errorHandler",
      end: "endHandler",
      ready: "readyHandler"
    };
    var SaxesParser = class {
      /**
       * @param opt The parser options.
       */
      constructor(opt) {
        this.opt = opt !== null && opt !== void 0 ? opt : {};
        this.fragmentOpt = !!this.opt.fragment;
        const xmlnsOpt = this.xmlnsOpt = !!this.opt.xmlns;
        this.trackPosition = this.opt.position !== false;
        this.fileName = this.opt.fileName;
        if (xmlnsOpt) {
          this.nameStartCheck = isNCNameStartChar;
          this.nameCheck = isNCNameChar;
          this.isName = isNCName;
          this.processAttribs = this.processAttribsNS;
          this.pushAttrib = this.pushAttribNS;
          this.ns = Object.assign({ __proto__: null }, rootNS);
          const additional = this.opt.additionalNamespaces;
          if (additional != null) {
            nsMappingCheck(this, additional);
            Object.assign(this.ns, additional);
          }
        } else {
          this.nameStartCheck = isNameStartChar;
          this.nameCheck = isNameChar;
          this.isName = isName;
          this.processAttribs = this.processAttribsPlain;
          this.pushAttrib = this.pushAttribPlain;
        }
        this.stateTable = [
          /* eslint-disable @typescript-eslint/unbound-method */
          this.sBegin,
          this.sBeginWhitespace,
          this.sDoctype,
          this.sDoctypeQuote,
          this.sDTD,
          this.sDTDQuoted,
          this.sDTDOpenWaka,
          this.sDTDOpenWakaBang,
          this.sDTDComment,
          this.sDTDCommentEnding,
          this.sDTDCommentEnded,
          this.sDTDPI,
          this.sDTDPIEnding,
          this.sText,
          this.sEntity,
          this.sOpenWaka,
          this.sOpenWakaBang,
          this.sComment,
          this.sCommentEnding,
          this.sCommentEnded,
          this.sCData,
          this.sCDataEnding,
          this.sCDataEnding2,
          this.sPIFirstChar,
          this.sPIRest,
          this.sPIBody,
          this.sPIEnding,
          this.sXMLDeclNameStart,
          this.sXMLDeclName,
          this.sXMLDeclEq,
          this.sXMLDeclValueStart,
          this.sXMLDeclValue,
          this.sXMLDeclSeparator,
          this.sXMLDeclEnding,
          this.sOpenTag,
          this.sOpenTagSlash,
          this.sAttrib,
          this.sAttribName,
          this.sAttribNameSawWhite,
          this.sAttribValue,
          this.sAttribValueQuoted,
          this.sAttribValueClosed,
          this.sAttribValueUnquoted,
          this.sCloseTag,
          this.sCloseTagSawWhite
        ];
        this._init();
      }
      /**
       * Indicates whether or not the parser is closed. If ``true``, wait for
       * the ``ready`` event to write again.
       */
      get closed() {
        return this._closed;
      }
      _init() {
        var _a;
        this.openWakaBang = "";
        this.text = "";
        this.name = "";
        this.piTarget = "";
        this.entity = "";
        this.q = null;
        this.tags = [];
        this.tag = null;
        this.topNS = null;
        this.chunk = "";
        this.chunkPosition = 0;
        this.i = 0;
        this.prevI = 0;
        this.carriedFromPrevious = void 0;
        this.forbiddenState = FORBIDDEN_START;
        this.attribList = [];
        const { fragmentOpt } = this;
        this.state = fragmentOpt ? S_TEXT : S_BEGIN;
        this.reportedTextBeforeRoot = this.reportedTextAfterRoot = this.closedRoot = this.sawRoot = fragmentOpt;
        this.xmlDeclPossible = !fragmentOpt;
        this.xmlDeclExpects = ["version"];
        this.entityReturnState = void 0;
        let { defaultXMLVersion } = this.opt;
        if (defaultXMLVersion === void 0) {
          if (this.opt.forceXMLVersion === true) {
            throw new Error("forceXMLVersion set but defaultXMLVersion is not set");
          }
          defaultXMLVersion = "1.0";
        }
        this.setXMLVersion(defaultXMLVersion);
        this.positionAtNewLine = 0;
        this.doctype = false;
        this._closed = false;
        this.xmlDecl = {
          version: void 0,
          encoding: void 0,
          standalone: void 0
        };
        this.line = 1;
        this.column = 0;
        this.ENTITIES = Object.create(XML_ENTITIES);
        (_a = this.readyHandler) === null || _a === void 0 ? void 0 : _a.call(this);
      }
      /**
       * The stream position the parser is currently looking at. This field is
       * zero-based.
       *
       * This field is not based on counting Unicode characters but is to be
       * interpreted as a plain index into a JavaScript string.
       */
      get position() {
        return this.chunkPosition + this.i;
      }
      /**
       * The column number of the next character to be read by the parser.  *
       * This field is zero-based. (The first column in a line is 0.)
       *
       * This field reports the index at which the next character would be in the
       * line if the line were represented as a JavaScript string.  Note that this
       * *can* be different to a count based on the number of *Unicode characters*
       * due to how JavaScript handles astral plane characters.
       *
       * See [[column]] for a number that corresponds to a count of Unicode
       * characters.
       */
      get columnIndex() {
        return this.position - this.positionAtNewLine;
      }
      /**
       * Set an event listener on an event. The parser supports one handler per
       * event type. If you try to set an event handler over an existing handler,
       * the old handler is silently overwritten.
       *
       * @param name The event to listen to.
       *
       * @param handler The handler to set.
       */
      on(name, handler) {
        this[EVENT_NAME_TO_HANDLER_NAME[name]] = handler;
      }
      /**
       * Unset an event handler.
       *
       * @parma name The event to stop listening to.
       */
      off(name) {
        this[EVENT_NAME_TO_HANDLER_NAME[name]] = void 0;
      }
      /**
       * Make an error object. The error object will have a message that contains
       * the ``fileName`` option passed at the creation of the parser. If position
       * tracking was turned on, it will also have line and column number
       * information.
       *
       * @param message The message describing the error to report.
       *
       * @returns An error object with a properly formatted message.
       */
      makeError(message) {
        var _a;
        let msg = (_a = this.fileName) !== null && _a !== void 0 ? _a : "";
        if (this.trackPosition) {
          if (msg.length > 0) {
            msg += ":";
          }
          msg += `${this.line}:${this.column}`;
        }
        if (msg.length > 0) {
          msg += ": ";
        }
        return new Error(msg + message);
      }
      /**
       * Report a parsing error. This method is made public so that client code may
       * check for issues that are outside the scope of this project and can report
       * errors.
       *
       * @param message The error to report.
       *
       * @returns this
       */
      fail(message) {
        const err = this.makeError(message);
        const handler = this.errorHandler;
        if (handler === void 0) {
          throw err;
        } else {
          handler(err);
        }
        return this;
      }
      /**
       * Write a XML data to the parser.
       *
       * @param chunk The XML data to write.
       *
       * @returns this
       */
      write(chunk) {
        if (this.closed) {
          return this.fail("cannot write after close; assign an onready handler.");
        }
        let end = false;
        if (chunk === null) {
          end = true;
          chunk = "";
        } else if (typeof chunk === "object") {
          chunk = chunk.toString();
        }
        if (this.carriedFromPrevious !== void 0) {
          chunk = `${this.carriedFromPrevious}${chunk}`;
          this.carriedFromPrevious = void 0;
        }
        let limit = chunk.length;
        const lastCode = chunk.charCodeAt(limit - 1);
        if (!end && // A trailing CR or surrogate must be carried over to the next
        // chunk.
        (lastCode === CR || lastCode >= 55296 && lastCode <= 56319)) {
          this.carriedFromPrevious = chunk[limit - 1];
          limit--;
          chunk = chunk.slice(0, limit);
        }
        const { stateTable } = this;
        this.chunk = chunk;
        this.i = 0;
        while (this.i < limit) {
          stateTable[this.state].call(this);
        }
        this.chunkPosition += limit;
        return end ? this.end() : this;
      }
      /**
       * Close the current stream. Perform final well-formedness checks and reset
       * the parser tstate.
       *
       * @returns this
       */
      close() {
        return this.write(null);
      }
      /**
       * Get a single code point out of the current chunk. This updates the current
       * position if we do position tracking.
       *
       * This is the algorithm to use for XML 1.0.
       *
       * @returns The character read.
       */
      getCode10() {
        const { chunk, i } = this;
        this.prevI = i;
        this.i = i + 1;
        if (i >= chunk.length) {
          return EOC;
        }
        const code = chunk.charCodeAt(i);
        this.column++;
        if (code < 55296) {
          if (code >= SPACE || code === TAB) {
            return code;
          }
          switch (code) {
            case NL:
              this.line++;
              this.column = 0;
              this.positionAtNewLine = this.position;
              return NL;
            case CR:
              if (chunk.charCodeAt(i + 1) === NL) {
                this.i = i + 2;
              }
              this.line++;
              this.column = 0;
              this.positionAtNewLine = this.position;
              return NL_LIKE;
            default:
              this.fail("disallowed character.");
              return code;
          }
        }
        if (code > 56319) {
          if (!(code >= 57344 && code <= 65533)) {
            this.fail("disallowed character.");
          }
          return code;
        }
        const final = 65536 + (code - 55296) * 1024 + (chunk.charCodeAt(i + 1) - 56320);
        this.i = i + 2;
        if (final > 1114111) {
          this.fail("disallowed character.");
        }
        return final;
      }
      /**
       * Get a single code point out of the current chunk. This updates the current
       * position if we do position tracking.
       *
       * This is the algorithm to use for XML 1.1.
       *
       * @returns {number} The character read.
       */
      getCode11() {
        const { chunk, i } = this;
        this.prevI = i;
        this.i = i + 1;
        if (i >= chunk.length) {
          return EOC;
        }
        const code = chunk.charCodeAt(i);
        this.column++;
        if (code < 55296) {
          if (code > 31 && code < 127 || code > 159 && code !== LS || code === TAB) {
            return code;
          }
          switch (code) {
            case NL:
              this.line++;
              this.column = 0;
              this.positionAtNewLine = this.position;
              return NL;
            case CR: {
              const next = chunk.charCodeAt(i + 1);
              if (next === NL || next === NEL) {
                this.i = i + 2;
              }
            }
            case NEL:
            case LS:
              this.line++;
              this.column = 0;
              this.positionAtNewLine = this.position;
              return NL_LIKE;
            default:
              this.fail("disallowed character.");
              return code;
          }
        }
        if (code > 56319) {
          if (!(code >= 57344 && code <= 65533)) {
            this.fail("disallowed character.");
          }
          return code;
        }
        const final = 65536 + (code - 55296) * 1024 + (chunk.charCodeAt(i + 1) - 56320);
        this.i = i + 2;
        if (final > 1114111) {
          this.fail("disallowed character.");
        }
        return final;
      }
      /**
       * Like ``getCode`` but with the return value normalized so that ``NL`` is
       * returned for ``NL_LIKE``.
       */
      getCodeNorm() {
        const c = this.getCode();
        return c === NL_LIKE ? NL : c;
      }
      unget() {
        this.i = this.prevI;
        this.column--;
      }
      /**
       * Capture characters into a buffer until encountering one of a set of
       * characters.
       *
       * @param chars An array of codepoints. Encountering a character in the array
       * ends the capture. (``chars`` may safely contain ``NL``.)
       *
       * @return The character code that made the capture end, or ``EOC`` if we hit
       * the end of the chunk. The return value cannot be NL_LIKE: NL is returned
       * instead.
       */
      captureTo(chars) {
        let { i: start } = this;
        const { chunk } = this;
        while (true) {
          const c = this.getCode();
          const isNLLike = c === NL_LIKE;
          const final = isNLLike ? NL : c;
          if (final === EOC || chars.includes(final)) {
            this.text += chunk.slice(start, this.prevI);
            return final;
          }
          if (isNLLike) {
            this.text += `${chunk.slice(start, this.prevI)}
`;
            start = this.i;
          }
        }
      }
      /**
       * Capture characters into a buffer until encountering a character.
       *
       * @param char The codepoint that ends the capture. **NOTE ``char`` MAY NOT
       * CONTAIN ``NL``.** Passing ``NL`` will result in buggy behavior.
       *
       * @return ``true`` if we ran into the character. Otherwise, we ran into the
       * end of the current chunk.
       */
      captureToChar(char) {
        let { i: start } = this;
        const { chunk } = this;
        while (true) {
          let c = this.getCode();
          switch (c) {
            case NL_LIKE:
              this.text += `${chunk.slice(start, this.prevI)}
`;
              start = this.i;
              c = NL;
              break;
            case EOC:
              this.text += chunk.slice(start);
              return false;
            default:
          }
          if (c === char) {
            this.text += chunk.slice(start, this.prevI);
            return true;
          }
        }
      }
      /**
       * Capture characters that satisfy ``isNameChar`` into the ``name`` field of
       * this parser.
       *
       * @return The character code that made the test fail, or ``EOC`` if we hit
       * the end of the chunk. The return value cannot be NL_LIKE: NL is returned
       * instead.
       */
      captureNameChars() {
        const { chunk, i: start } = this;
        while (true) {
          const c = this.getCode();
          if (c === EOC) {
            this.name += chunk.slice(start);
            return EOC;
          }
          if (!isNameChar(c)) {
            this.name += chunk.slice(start, this.prevI);
            return c === NL_LIKE ? NL : c;
          }
        }
      }
      /**
       * Skip white spaces.
       *
       * @return The character that ended the skip, or ``EOC`` if we hit
       * the end of the chunk. The return value cannot be NL_LIKE: NL is returned
       * instead.
       */
      skipSpaces() {
        while (true) {
          const c = this.getCodeNorm();
          if (c === EOC || !isS(c)) {
            return c;
          }
        }
      }
      setXMLVersion(version2) {
        this.currentXMLVersion = version2;
        if (version2 === "1.0") {
          this.isChar = isChar10;
          this.getCode = this.getCode10;
        } else {
          this.isChar = isChar11;
          this.getCode = this.getCode11;
        }
      }
      // STATE ENGINE METHODS
      // This needs to be a state separate from S_BEGIN_WHITESPACE because we want
      // to be sure never to come back to this state later.
      sBegin() {
        if (this.chunk.charCodeAt(0) === 65279) {
          this.i++;
          this.column++;
        }
        this.state = S_BEGIN_WHITESPACE;
      }
      sBeginWhitespace() {
        const iBefore = this.i;
        const c = this.skipSpaces();
        if (this.prevI !== iBefore) {
          this.xmlDeclPossible = false;
        }
        switch (c) {
          case LESS:
            this.state = S_OPEN_WAKA;
            if (this.text.length !== 0) {
              throw new Error("no-empty text at start");
            }
            break;
          case EOC:
            break;
          default:
            this.unget();
            this.state = S_TEXT;
            this.xmlDeclPossible = false;
        }
      }
      sDoctype() {
        var _a;
        const c = this.captureTo(DOCTYPE_TERMINATOR);
        switch (c) {
          case GREATER: {
            (_a = this.doctypeHandler) === null || _a === void 0 ? void 0 : _a.call(this, this.text);
            this.text = "";
            this.state = S_TEXT;
            this.doctype = true;
            break;
          }
          case EOC:
            break;
          default:
            this.text += String.fromCodePoint(c);
            if (c === OPEN_BRACKET) {
              this.state = S_DTD;
            } else if (isQuote(c)) {
              this.state = S_DOCTYPE_QUOTE;
              this.q = c;
            }
        }
      }
      sDoctypeQuote() {
        const q = this.q;
        if (this.captureToChar(q)) {
          this.text += String.fromCodePoint(q);
          this.q = null;
          this.state = S_DOCTYPE;
        }
      }
      sDTD() {
        const c = this.captureTo(DTD_TERMINATOR);
        if (c === EOC) {
          return;
        }
        this.text += String.fromCodePoint(c);
        if (c === CLOSE_BRACKET) {
          this.state = S_DOCTYPE;
        } else if (c === LESS) {
          this.state = S_DTD_OPEN_WAKA;
        } else if (isQuote(c)) {
          this.state = S_DTD_QUOTED;
          this.q = c;
        }
      }
      sDTDQuoted() {
        const q = this.q;
        if (this.captureToChar(q)) {
          this.text += String.fromCodePoint(q);
          this.state = S_DTD;
          this.q = null;
        }
      }
      sDTDOpenWaka() {
        const c = this.getCodeNorm();
        this.text += String.fromCodePoint(c);
        switch (c) {
          case BANG:
            this.state = S_DTD_OPEN_WAKA_BANG;
            this.openWakaBang = "";
            break;
          case QUESTION:
            this.state = S_DTD_PI;
            break;
          default:
            this.state = S_DTD;
        }
      }
      sDTDOpenWakaBang() {
        const char = String.fromCodePoint(this.getCodeNorm());
        const owb = this.openWakaBang += char;
        this.text += char;
        if (owb !== "-") {
          this.state = owb === "--" ? S_DTD_COMMENT : S_DTD;
          this.openWakaBang = "";
        }
      }
      sDTDComment() {
        if (this.captureToChar(MINUS)) {
          this.text += "-";
          this.state = S_DTD_COMMENT_ENDING;
        }
      }
      sDTDCommentEnding() {
        const c = this.getCodeNorm();
        this.text += String.fromCodePoint(c);
        this.state = c === MINUS ? S_DTD_COMMENT_ENDED : S_DTD_COMMENT;
      }
      sDTDCommentEnded() {
        const c = this.getCodeNorm();
        this.text += String.fromCodePoint(c);
        if (c === GREATER) {
          this.state = S_DTD;
        } else {
          this.fail("malformed comment.");
          this.state = S_DTD_COMMENT;
        }
      }
      sDTDPI() {
        if (this.captureToChar(QUESTION)) {
          this.text += "?";
          this.state = S_DTD_PI_ENDING;
        }
      }
      sDTDPIEnding() {
        const c = this.getCodeNorm();
        this.text += String.fromCodePoint(c);
        if (c === GREATER) {
          this.state = S_DTD;
        }
      }
      sText() {
        if (this.tags.length !== 0) {
          this.handleTextInRoot();
        } else {
          this.handleTextOutsideRoot();
        }
      }
      sEntity() {
        let { i: start } = this;
        const { chunk } = this;
        loop:
          while (true) {
            switch (this.getCode()) {
              case NL_LIKE:
                this.entity += `${chunk.slice(start, this.prevI)}
`;
                start = this.i;
                break;
              case SEMICOLON: {
                const { entityReturnState } = this;
                const entity = this.entity + chunk.slice(start, this.prevI);
                this.state = entityReturnState;
                let parsed;
                if (entity === "") {
                  this.fail("empty entity name.");
                  parsed = "&;";
                } else {
                  parsed = this.parseEntity(entity);
                  this.entity = "";
                }
                if (entityReturnState !== S_TEXT || this.textHandler !== void 0) {
                  this.text += parsed;
                }
                break loop;
              }
              case EOC:
                this.entity += chunk.slice(start);
                break loop;
              default:
            }
          }
      }
      sOpenWaka() {
        const c = this.getCode();
        if (isNameStartChar(c)) {
          this.state = S_OPEN_TAG;
          this.unget();
          this.xmlDeclPossible = false;
        } else {
          switch (c) {
            case FORWARD_SLASH:
              this.state = S_CLOSE_TAG;
              this.xmlDeclPossible = false;
              break;
            case BANG:
              this.state = S_OPEN_WAKA_BANG;
              this.openWakaBang = "";
              this.xmlDeclPossible = false;
              break;
            case QUESTION:
              this.state = S_PI_FIRST_CHAR;
              break;
            default:
              this.fail("disallowed character in tag name");
              this.state = S_TEXT;
              this.xmlDeclPossible = false;
          }
        }
      }
      sOpenWakaBang() {
        this.openWakaBang += String.fromCodePoint(this.getCodeNorm());
        switch (this.openWakaBang) {
          case "[CDATA[":
            if (!this.sawRoot && !this.reportedTextBeforeRoot) {
              this.fail("text data outside of root node.");
              this.reportedTextBeforeRoot = true;
            }
            if (this.closedRoot && !this.reportedTextAfterRoot) {
              this.fail("text data outside of root node.");
              this.reportedTextAfterRoot = true;
            }
            this.state = S_CDATA;
            this.openWakaBang = "";
            break;
          case "--":
            this.state = S_COMMENT;
            this.openWakaBang = "";
            break;
          case "DOCTYPE":
            this.state = S_DOCTYPE;
            if (this.doctype || this.sawRoot) {
              this.fail("inappropriately located doctype declaration.");
            }
            this.openWakaBang = "";
            break;
          default:
            if (this.openWakaBang.length >= 7) {
              this.fail("incorrect syntax.");
            }
        }
      }
      sComment() {
        if (this.captureToChar(MINUS)) {
          this.state = S_COMMENT_ENDING;
        }
      }
      sCommentEnding() {
        var _a;
        const c = this.getCodeNorm();
        if (c === MINUS) {
          this.state = S_COMMENT_ENDED;
          (_a = this.commentHandler) === null || _a === void 0 ? void 0 : _a.call(this, this.text);
          this.text = "";
        } else {
          this.text += `-${String.fromCodePoint(c)}`;
          this.state = S_COMMENT;
        }
      }
      sCommentEnded() {
        const c = this.getCodeNorm();
        if (c !== GREATER) {
          this.fail("malformed comment.");
          this.text += `--${String.fromCodePoint(c)}`;
          this.state = S_COMMENT;
        } else {
          this.state = S_TEXT;
        }
      }
      sCData() {
        if (this.captureToChar(CLOSE_BRACKET)) {
          this.state = S_CDATA_ENDING;
        }
      }
      sCDataEnding() {
        const c = this.getCodeNorm();
        if (c === CLOSE_BRACKET) {
          this.state = S_CDATA_ENDING_2;
        } else {
          this.text += `]${String.fromCodePoint(c)}`;
          this.state = S_CDATA;
        }
      }
      sCDataEnding2() {
        var _a;
        const c = this.getCodeNorm();
        switch (c) {
          case GREATER: {
            (_a = this.cdataHandler) === null || _a === void 0 ? void 0 : _a.call(this, this.text);
            this.text = "";
            this.state = S_TEXT;
            break;
          }
          case CLOSE_BRACKET:
            this.text += "]";
            break;
          default:
            this.text += `]]${String.fromCodePoint(c)}`;
            this.state = S_CDATA;
        }
      }
      // We need this separate state to check the first character fo the pi target
      // with this.nameStartCheck which allows less characters than this.nameCheck.
      sPIFirstChar() {
        const c = this.getCodeNorm();
        if (this.nameStartCheck(c)) {
          this.piTarget += String.fromCodePoint(c);
          this.state = S_PI_REST;
        } else if (c === QUESTION || isS(c)) {
          this.fail("processing instruction without a target.");
          this.state = c === QUESTION ? S_PI_ENDING : S_PI_BODY;
        } else {
          this.fail("disallowed character in processing instruction name.");
          this.piTarget += String.fromCodePoint(c);
          this.state = S_PI_REST;
        }
      }
      sPIRest() {
        const { chunk, i: start } = this;
        while (true) {
          const c = this.getCodeNorm();
          if (c === EOC) {
            this.piTarget += chunk.slice(start);
            return;
          }
          if (!this.nameCheck(c)) {
            this.piTarget += chunk.slice(start, this.prevI);
            const isQuestion = c === QUESTION;
            if (isQuestion || isS(c)) {
              if (this.piTarget === "xml") {
                if (!this.xmlDeclPossible) {
                  this.fail("an XML declaration must be at the start of the document.");
                }
                this.state = isQuestion ? S_XML_DECL_ENDING : S_XML_DECL_NAME_START;
              } else {
                this.state = isQuestion ? S_PI_ENDING : S_PI_BODY;
              }
            } else {
              this.fail("disallowed character in processing instruction name.");
              this.piTarget += String.fromCodePoint(c);
            }
            break;
          }
        }
      }
      sPIBody() {
        if (this.text.length === 0) {
          const c = this.getCodeNorm();
          if (c === QUESTION) {
            this.state = S_PI_ENDING;
          } else if (!isS(c)) {
            this.text = String.fromCodePoint(c);
          }
        } else if (this.captureToChar(QUESTION)) {
          this.state = S_PI_ENDING;
        }
      }
      sPIEnding() {
        var _a;
        const c = this.getCodeNorm();
        if (c === GREATER) {
          const { piTarget } = this;
          if (piTarget.toLowerCase() === "xml") {
            this.fail("the XML declaration must appear at the start of the document.");
          }
          (_a = this.piHandler) === null || _a === void 0 ? void 0 : _a.call(this, {
            target: piTarget,
            body: this.text
          });
          this.piTarget = this.text = "";
          this.state = S_TEXT;
        } else if (c === QUESTION) {
          this.text += "?";
        } else {
          this.text += `?${String.fromCodePoint(c)}`;
          this.state = S_PI_BODY;
        }
        this.xmlDeclPossible = false;
      }
      sXMLDeclNameStart() {
        const c = this.skipSpaces();
        if (c === QUESTION) {
          this.state = S_XML_DECL_ENDING;
          return;
        }
        if (c !== EOC) {
          this.state = S_XML_DECL_NAME;
          this.name = String.fromCodePoint(c);
        }
      }
      sXMLDeclName() {
        const c = this.captureTo(XML_DECL_NAME_TERMINATOR);
        if (c === QUESTION) {
          this.state = S_XML_DECL_ENDING;
          this.name += this.text;
          this.text = "";
          this.fail("XML declaration is incomplete.");
          return;
        }
        if (!(isS(c) || c === EQUAL)) {
          return;
        }
        this.name += this.text;
        this.text = "";
        if (!this.xmlDeclExpects.includes(this.name)) {
          switch (this.name.length) {
            case 0:
              this.fail("did not expect any more name/value pairs.");
              break;
            case 1:
              this.fail(`expected the name ${this.xmlDeclExpects[0]}.`);
              break;
            default:
              this.fail(`expected one of ${this.xmlDeclExpects.join(", ")}`);
          }
        }
        this.state = c === EQUAL ? S_XML_DECL_VALUE_START : S_XML_DECL_EQ;
      }
      sXMLDeclEq() {
        const c = this.getCodeNorm();
        if (c === QUESTION) {
          this.state = S_XML_DECL_ENDING;
          this.fail("XML declaration is incomplete.");
          return;
        }
        if (isS(c)) {
          return;
        }
        if (c !== EQUAL) {
          this.fail("value required.");
        }
        this.state = S_XML_DECL_VALUE_START;
      }
      sXMLDeclValueStart() {
        const c = this.getCodeNorm();
        if (c === QUESTION) {
          this.state = S_XML_DECL_ENDING;
          this.fail("XML declaration is incomplete.");
          return;
        }
        if (isS(c)) {
          return;
        }
        if (!isQuote(c)) {
          this.fail("value must be quoted.");
          this.q = SPACE;
        } else {
          this.q = c;
        }
        this.state = S_XML_DECL_VALUE;
      }
      sXMLDeclValue() {
        const c = this.captureTo([this.q, QUESTION]);
        if (c === QUESTION) {
          this.state = S_XML_DECL_ENDING;
          this.text = "";
          this.fail("XML declaration is incomplete.");
          return;
        }
        if (c === EOC) {
          return;
        }
        const value = this.text;
        this.text = "";
        switch (this.name) {
          case "version": {
            this.xmlDeclExpects = ["encoding", "standalone"];
            const version2 = value;
            this.xmlDecl.version = version2;
            if (!/^1\.[0-9]+$/.test(version2)) {
              this.fail("version number must match /^1\\.[0-9]+$/.");
            } else if (!this.opt.forceXMLVersion) {
              this.setXMLVersion(version2);
            }
            break;
          }
          case "encoding":
            if (!/^[A-Za-z][A-Za-z0-9._-]*$/.test(value)) {
              this.fail("encoding value must match /^[A-Za-z0-9][A-Za-z0-9._-]*$/.");
            }
            this.xmlDeclExpects = ["standalone"];
            this.xmlDecl.encoding = value;
            break;
          case "standalone":
            if (value !== "yes" && value !== "no") {
              this.fail('standalone value must match "yes" or "no".');
            }
            this.xmlDeclExpects = [];
            this.xmlDecl.standalone = value;
            break;
          default:
        }
        this.name = "";
        this.state = S_XML_DECL_SEPARATOR;
      }
      sXMLDeclSeparator() {
        const c = this.getCodeNorm();
        if (c === QUESTION) {
          this.state = S_XML_DECL_ENDING;
          return;
        }
        if (!isS(c)) {
          this.fail("whitespace required.");
          this.unget();
        }
        this.state = S_XML_DECL_NAME_START;
      }
      sXMLDeclEnding() {
        var _a;
        const c = this.getCodeNorm();
        if (c === GREATER) {
          if (this.piTarget !== "xml") {
            this.fail("processing instructions are not allowed before root.");
          } else if (this.name !== "version" && this.xmlDeclExpects.includes("version")) {
            this.fail("XML declaration must contain a version.");
          }
          (_a = this.xmldeclHandler) === null || _a === void 0 ? void 0 : _a.call(this, this.xmlDecl);
          this.name = "";
          this.piTarget = this.text = "";
          this.state = S_TEXT;
        } else {
          this.fail("The character ? is disallowed anywhere in XML declarations.");
        }
        this.xmlDeclPossible = false;
      }
      sOpenTag() {
        var _a;
        const c = this.captureNameChars();
        if (c === EOC) {
          return;
        }
        const tag = this.tag = {
          name: this.name,
          attributes: /* @__PURE__ */ Object.create(null)
        };
        this.name = "";
        if (this.xmlnsOpt) {
          this.topNS = tag.ns = /* @__PURE__ */ Object.create(null);
        }
        (_a = this.openTagStartHandler) === null || _a === void 0 ? void 0 : _a.call(this, tag);
        this.sawRoot = true;
        if (!this.fragmentOpt && this.closedRoot) {
          this.fail("documents may contain only one root.");
        }
        switch (c) {
          case GREATER:
            this.openTag();
            break;
          case FORWARD_SLASH:
            this.state = S_OPEN_TAG_SLASH;
            break;
          default:
            if (!isS(c)) {
              this.fail("disallowed character in tag name.");
            }
            this.state = S_ATTRIB;
        }
      }
      sOpenTagSlash() {
        if (this.getCode() === GREATER) {
          this.openSelfClosingTag();
        } else {
          this.fail("forward-slash in opening tag not followed by >.");
          this.state = S_ATTRIB;
        }
      }
      sAttrib() {
        const c = this.skipSpaces();
        if (c === EOC) {
          return;
        }
        if (isNameStartChar(c)) {
          this.unget();
          this.state = S_ATTRIB_NAME;
        } else if (c === GREATER) {
          this.openTag();
        } else if (c === FORWARD_SLASH) {
          this.state = S_OPEN_TAG_SLASH;
        } else {
          this.fail("disallowed character in attribute name.");
        }
      }
      sAttribName() {
        const c = this.captureNameChars();
        if (c === EQUAL) {
          this.state = S_ATTRIB_VALUE;
        } else if (isS(c)) {
          this.state = S_ATTRIB_NAME_SAW_WHITE;
        } else if (c === GREATER) {
          this.fail("attribute without value.");
          this.pushAttrib(this.name, this.name);
          this.name = this.text = "";
          this.openTag();
        } else if (c !== EOC) {
          this.fail("disallowed character in attribute name.");
        }
      }
      sAttribNameSawWhite() {
        const c = this.skipSpaces();
        switch (c) {
          case EOC:
            return;
          case EQUAL:
            this.state = S_ATTRIB_VALUE;
            break;
          default:
            this.fail("attribute without value.");
            this.text = "";
            this.name = "";
            if (c === GREATER) {
              this.openTag();
            } else if (isNameStartChar(c)) {
              this.unget();
              this.state = S_ATTRIB_NAME;
            } else {
              this.fail("disallowed character in attribute name.");
              this.state = S_ATTRIB;
            }
        }
      }
      sAttribValue() {
        const c = this.getCodeNorm();
        if (isQuote(c)) {
          this.q = c;
          this.state = S_ATTRIB_VALUE_QUOTED;
        } else if (!isS(c)) {
          this.fail("unquoted attribute value.");
          this.state = S_ATTRIB_VALUE_UNQUOTED;
          this.unget();
        }
      }
      sAttribValueQuoted() {
        const { q, chunk } = this;
        let { i: start } = this;
        while (true) {
          switch (this.getCode()) {
            case q:
              this.pushAttrib(this.name, this.text + chunk.slice(start, this.prevI));
              this.name = this.text = "";
              this.q = null;
              this.state = S_ATTRIB_VALUE_CLOSED;
              return;
            case AMP:
              this.text += chunk.slice(start, this.prevI);
              this.state = S_ENTITY;
              this.entityReturnState = S_ATTRIB_VALUE_QUOTED;
              return;
            case NL:
            case NL_LIKE:
            case TAB:
              this.text += `${chunk.slice(start, this.prevI)} `;
              start = this.i;
              break;
            case LESS:
              this.text += chunk.slice(start, this.prevI);
              this.fail("disallowed character.");
              return;
            case EOC:
              this.text += chunk.slice(start);
              return;
            default:
          }
        }
      }
      sAttribValueClosed() {
        const c = this.getCodeNorm();
        if (isS(c)) {
          this.state = S_ATTRIB;
        } else if (c === GREATER) {
          this.openTag();
        } else if (c === FORWARD_SLASH) {
          this.state = S_OPEN_TAG_SLASH;
        } else if (isNameStartChar(c)) {
          this.fail("no whitespace between attributes.");
          this.unget();
          this.state = S_ATTRIB_NAME;
        } else {
          this.fail("disallowed character in attribute name.");
        }
      }
      sAttribValueUnquoted() {
        const c = this.captureTo(ATTRIB_VALUE_UNQUOTED_TERMINATOR);
        switch (c) {
          case AMP:
            this.state = S_ENTITY;
            this.entityReturnState = S_ATTRIB_VALUE_UNQUOTED;
            break;
          case LESS:
            this.fail("disallowed character.");
            break;
          case EOC:
            break;
          default:
            if (this.text.includes("]]>")) {
              this.fail('the string "]]>" is disallowed in char data.');
            }
            this.pushAttrib(this.name, this.text);
            this.name = this.text = "";
            if (c === GREATER) {
              this.openTag();
            } else {
              this.state = S_ATTRIB;
            }
        }
      }
      sCloseTag() {
        const c = this.captureNameChars();
        if (c === GREATER) {
          this.closeTag();
        } else if (isS(c)) {
          this.state = S_CLOSE_TAG_SAW_WHITE;
        } else if (c !== EOC) {
          this.fail("disallowed character in closing tag.");
        }
      }
      sCloseTagSawWhite() {
        switch (this.skipSpaces()) {
          case GREATER:
            this.closeTag();
            break;
          case EOC:
            break;
          default:
            this.fail("disallowed character in closing tag.");
        }
      }
      // END OF STATE ENGINE METHODS
      handleTextInRoot() {
        let { i: start, forbiddenState } = this;
        const { chunk, textHandler: handler } = this;
        scanLoop:
          while (true) {
            switch (this.getCode()) {
              case LESS: {
                this.state = S_OPEN_WAKA;
                if (handler !== void 0) {
                  const { text } = this;
                  const slice = chunk.slice(start, this.prevI);
                  if (text.length !== 0) {
                    handler(text + slice);
                    this.text = "";
                  } else if (slice.length !== 0) {
                    handler(slice);
                  }
                }
                forbiddenState = FORBIDDEN_START;
                break scanLoop;
              }
              case AMP:
                this.state = S_ENTITY;
                this.entityReturnState = S_TEXT;
                if (handler !== void 0) {
                  this.text += chunk.slice(start, this.prevI);
                }
                forbiddenState = FORBIDDEN_START;
                break scanLoop;
              case CLOSE_BRACKET:
                switch (forbiddenState) {
                  case FORBIDDEN_START:
                    forbiddenState = FORBIDDEN_BRACKET;
                    break;
                  case FORBIDDEN_BRACKET:
                    forbiddenState = FORBIDDEN_BRACKET_BRACKET;
                    break;
                  case FORBIDDEN_BRACKET_BRACKET:
                    break;
                  default:
                    throw new Error("impossible state");
                }
                break;
              case GREATER:
                if (forbiddenState === FORBIDDEN_BRACKET_BRACKET) {
                  this.fail('the string "]]>" is disallowed in char data.');
                }
                forbiddenState = FORBIDDEN_START;
                break;
              case NL_LIKE:
                if (handler !== void 0) {
                  this.text += `${chunk.slice(start, this.prevI)}
`;
                }
                start = this.i;
                forbiddenState = FORBIDDEN_START;
                break;
              case EOC:
                if (handler !== void 0) {
                  this.text += chunk.slice(start);
                }
                break scanLoop;
              default:
                forbiddenState = FORBIDDEN_START;
            }
          }
        this.forbiddenState = forbiddenState;
      }
      handleTextOutsideRoot() {
        let { i: start } = this;
        const { chunk, textHandler: handler } = this;
        let nonSpace = false;
        outRootLoop:
          while (true) {
            const code = this.getCode();
            switch (code) {
              case LESS: {
                this.state = S_OPEN_WAKA;
                if (handler !== void 0) {
                  const { text } = this;
                  const slice = chunk.slice(start, this.prevI);
                  if (text.length !== 0) {
                    handler(text + slice);
                    this.text = "";
                  } else if (slice.length !== 0) {
                    handler(slice);
                  }
                }
                break outRootLoop;
              }
              case AMP:
                this.state = S_ENTITY;
                this.entityReturnState = S_TEXT;
                if (handler !== void 0) {
                  this.text += chunk.slice(start, this.prevI);
                }
                nonSpace = true;
                break outRootLoop;
              case NL_LIKE:
                if (handler !== void 0) {
                  this.text += `${chunk.slice(start, this.prevI)}
`;
                }
                start = this.i;
                break;
              case EOC:
                if (handler !== void 0) {
                  this.text += chunk.slice(start);
                }
                break outRootLoop;
              default:
                if (!isS(code)) {
                  nonSpace = true;
                }
            }
          }
        if (!nonSpace) {
          return;
        }
        if (!this.sawRoot && !this.reportedTextBeforeRoot) {
          this.fail("text data outside of root node.");
          this.reportedTextBeforeRoot = true;
        }
        if (this.closedRoot && !this.reportedTextAfterRoot) {
          this.fail("text data outside of root node.");
          this.reportedTextAfterRoot = true;
        }
      }
      pushAttribNS(name, value) {
        var _a;
        const { prefix, local } = this.qname(name);
        const attr = { name, prefix, local, value };
        this.attribList.push(attr);
        (_a = this.attributeHandler) === null || _a === void 0 ? void 0 : _a.call(this, attr);
        if (prefix === "xmlns") {
          const trimmed = value.trim();
          if (this.currentXMLVersion === "1.0" && trimmed === "") {
            this.fail("invalid attempt to undefine prefix in XML 1.0");
          }
          this.topNS[local] = trimmed;
          nsPairCheck(this, local, trimmed);
        } else if (name === "xmlns") {
          const trimmed = value.trim();
          this.topNS[""] = trimmed;
          nsPairCheck(this, "", trimmed);
        }
      }
      pushAttribPlain(name, value) {
        var _a;
        const attr = { name, value };
        this.attribList.push(attr);
        (_a = this.attributeHandler) === null || _a === void 0 ? void 0 : _a.call(this, attr);
      }
      /**
       * End parsing. This performs final well-formedness checks and resets the
       * parser to a clean state.
       *
       * @returns this
       */
      end() {
        var _a, _b;
        if (!this.sawRoot) {
          this.fail("document must contain a root element.");
        }
        const { tags } = this;
        while (tags.length > 0) {
          const tag = tags.pop();
          this.fail(`unclosed tag: ${tag.name}`);
        }
        if (this.state !== S_BEGIN && this.state !== S_TEXT) {
          this.fail("unexpected end.");
        }
        const { text } = this;
        if (text.length !== 0) {
          (_a = this.textHandler) === null || _a === void 0 ? void 0 : _a.call(this, text);
          this.text = "";
        }
        this._closed = true;
        (_b = this.endHandler) === null || _b === void 0 ? void 0 : _b.call(this);
        this._init();
        return this;
      }
      /**
       * Resolve a namespace prefix.
       *
       * @param prefix The prefix to resolve.
       *
       * @returns The namespace URI or ``undefined`` if the prefix is not defined.
       */
      resolve(prefix) {
        var _a, _b;
        let uri = this.topNS[prefix];
        if (uri !== void 0) {
          return uri;
        }
        const { tags } = this;
        for (let index = tags.length - 1; index >= 0; index--) {
          uri = tags[index].ns[prefix];
          if (uri !== void 0) {
            return uri;
          }
        }
        uri = this.ns[prefix];
        if (uri !== void 0) {
          return uri;
        }
        return (_b = (_a = this.opt).resolvePrefix) === null || _b === void 0 ? void 0 : _b.call(_a, prefix);
      }
      /**
       * Parse a qname into its prefix and local name parts.
       *
       * @param name The name to parse
       *
       * @returns
       */
      qname(name) {
        const colon = name.indexOf(":");
        if (colon === -1) {
          return { prefix: "", local: name };
        }
        const local = name.slice(colon + 1);
        const prefix = name.slice(0, colon);
        if (prefix === "" || local === "" || local.includes(":")) {
          this.fail(`malformed name: ${name}.`);
        }
        return { prefix, local };
      }
      processAttribsNS() {
        var _a;
        const { attribList } = this;
        const tag = this.tag;
        {
          const { prefix, local } = this.qname(tag.name);
          tag.prefix = prefix;
          tag.local = local;
          const uri = tag.uri = (_a = this.resolve(prefix)) !== null && _a !== void 0 ? _a : "";
          if (prefix !== "") {
            if (prefix === "xmlns") {
              this.fail('tags may not have "xmlns" as prefix.');
            }
            if (uri === "") {
              this.fail(`unbound namespace prefix: ${JSON.stringify(prefix)}.`);
              tag.uri = prefix;
            }
          }
        }
        if (attribList.length === 0) {
          return;
        }
        const { attributes } = tag;
        const seen = /* @__PURE__ */ new Set();
        for (const attr of attribList) {
          const { name, prefix, local } = attr;
          let uri;
          let eqname;
          if (prefix === "") {
            uri = name === "xmlns" ? XMLNS_NAMESPACE : "";
            eqname = name;
          } else {
            uri = this.resolve(prefix);
            if (uri === void 0) {
              this.fail(`unbound namespace prefix: ${JSON.stringify(prefix)}.`);
              uri = prefix;
            }
            eqname = `{${uri}}${local}`;
          }
          if (seen.has(eqname)) {
            this.fail(`duplicate attribute: ${eqname}.`);
          }
          seen.add(eqname);
          attr.uri = uri;
          attributes[name] = attr;
        }
        this.attribList = [];
      }
      processAttribsPlain() {
        const { attribList } = this;
        const attributes = this.tag.attributes;
        for (const { name, value } of attribList) {
          if (attributes[name] !== void 0) {
            this.fail(`duplicate attribute: ${name}.`);
          }
          attributes[name] = value;
        }
        this.attribList = [];
      }
      /**
       * Handle a complete open tag. This parser code calls this once it has seen
       * the whole tag. This method checks for well-formeness and then emits
       * ``onopentag``.
       */
      openTag() {
        var _a;
        this.processAttribs();
        const { tags } = this;
        const tag = this.tag;
        tag.isSelfClosing = false;
        (_a = this.openTagHandler) === null || _a === void 0 ? void 0 : _a.call(this, tag);
        tags.push(tag);
        this.state = S_TEXT;
        this.name = "";
      }
      /**
       * Handle a complete self-closing tag. This parser code calls this once it has
       * seen the whole tag. This method checks for well-formeness and then emits
       * ``onopentag`` and ``onclosetag``.
       */
      openSelfClosingTag() {
        var _a, _b, _c;
        this.processAttribs();
        const { tags } = this;
        const tag = this.tag;
        tag.isSelfClosing = true;
        (_a = this.openTagHandler) === null || _a === void 0 ? void 0 : _a.call(this, tag);
        (_b = this.closeTagHandler) === null || _b === void 0 ? void 0 : _b.call(this, tag);
        const top = this.tag = (_c = tags[tags.length - 1]) !== null && _c !== void 0 ? _c : null;
        if (top === null) {
          this.closedRoot = true;
        }
        this.state = S_TEXT;
        this.name = "";
      }
      /**
       * Handle a complete close tag. This parser code calls this once it has seen
       * the whole tag. This method checks for well-formeness and then emits
       * ``onclosetag``.
       */
      closeTag() {
        const { tags, name } = this;
        this.state = S_TEXT;
        this.name = "";
        if (name === "") {
          this.fail("weird empty close tag.");
          this.text += "</>";
          return;
        }
        const handler = this.closeTagHandler;
        let l2 = tags.length;
        while (l2-- > 0) {
          const tag = this.tag = tags.pop();
          this.topNS = tag.ns;
          handler === null || handler === void 0 ? void 0 : handler(tag);
          if (tag.name === name) {
            break;
          }
          this.fail("unexpected close tag.");
        }
        if (l2 === 0) {
          this.closedRoot = true;
        } else if (l2 < 0) {
          this.fail(`unmatched closing tag: ${name}.`);
          this.text += `</${name}>`;
        }
      }
      /**
       * Resolves an entity. Makes any necessary well-formedness checks.
       *
       * @param entity The entity to resolve.
       *
       * @returns The parsed entity.
       */
      parseEntity(entity) {
        if (entity[0] !== "#") {
          const defined = this.ENTITIES[entity];
          if (defined !== void 0) {
            return defined;
          }
          this.fail(this.isName(entity) ? "undefined entity." : "disallowed character in entity name.");
          return `&${entity};`;
        }
        let num = NaN;
        if (entity[1] === "x" && /^#x[0-9a-f]+$/i.test(entity)) {
          num = parseInt(entity.slice(2), 16);
        } else if (/^#[0-9]+$/.test(entity)) {
          num = parseInt(entity.slice(1), 10);
        }
        if (!this.isChar(num)) {
          this.fail("malformed character entity.");
          return `&${entity};`;
        }
        return String.fromCodePoint(num);
      }
    };
    exports2.SaxesParser = SaxesParser;
  }
});

// ../../../node_modules/exceljs/lib/utils/parse-sax.js
var require_parse_sax = __commonJS({
  "../../../node_modules/exceljs/lib/utils/parse-sax.js"(exports2, module2) {
    var { SaxesParser } = require_saxes();
    var { PassThrough } = require_readable2();
    var { bufferToString } = require_browser_buffer_decode();
    module2.exports = async function* (iterable) {
      if (iterable.pipe && !iterable[Symbol.asyncIterator]) {
        iterable = iterable.pipe(new PassThrough());
      }
      const saxesParser = new SaxesParser();
      let error;
      saxesParser.on("error", (err) => {
        error = err;
      });
      let events = [];
      saxesParser.on("opentag", (value) => events.push({ eventType: "opentag", value }));
      saxesParser.on("text", (value) => events.push({ eventType: "text", value }));
      saxesParser.on("closetag", (value) => events.push({ eventType: "closetag", value }));
      for await (const chunk of iterable) {
        saxesParser.write(bufferToString(chunk));
        if (error)
          throw error;
        yield events;
        events = [];
      }
    };
  }
});

// ../../../node_modules/exceljs/lib/xlsx/xform/base-xform.js
var require_base_xform = __commonJS({
  "../../../node_modules/exceljs/lib/xlsx/xform/base-xform.js"(exports2, module2) {
    var parseSax = require_parse_sax();
    var XmlStream = require_xml_stream();
    var BaseXform = class _BaseXform {
      // constructor(/* model, name */) {}
      // ============================================================
      // Virtual Interface
      prepare() {
      }
      render() {
      }
      parseOpen(node) {
      }
      parseText(text) {
      }
      parseClose(name) {
      }
      reconcile(model, options) {
      }
      // ============================================================
      reset() {
        this.model = null;
        if (this.map) {
          Object.values(this.map).forEach((xform) => {
            if (xform instanceof _BaseXform) {
              xform.reset();
            } else if (xform.xform) {
              xform.xform.reset();
            }
          });
        }
      }
      mergeModel(obj2) {
        this.model = Object.assign(this.model || {}, obj2);
      }
      async parse(saxParser) {
        for await (const events of saxParser) {
          for (const { eventType, value } of events) {
            if (eventType === "opentag") {
              this.parseOpen(value);
            } else if (eventType === "text") {
              this.parseText(value);
            } else if (eventType === "closetag") {
              if (!this.parseClose(value.name)) {
                return this.model;
              }
            }
          }
        }
        return this.model;
      }
      async parseStream(stream) {
        return this.parse(parseSax(stream));
      }
      get xml() {
        return this.toXml(this.model);
      }
      toXml(model) {
        const xmlStream = new XmlStream();
        this.render(xmlStream, model);
        return xmlStream.xml;
      }
      // ============================================================
      // Useful Utilities
      static toAttribute(value, dflt, always = false) {
        if (value === void 0) {
          if (always) {
            return dflt;
          }
        } else if (always || value !== dflt) {
          return value.toString();
        }
        return void 0;
      }
      static toStringAttribute(value, dflt, always = false) {
        return _BaseXform.toAttribute(value, dflt, always);
      }
      static toStringValue(attr, dflt) {
        return attr === void 0 ? dflt : attr;
      }
      static toBoolAttribute(value, dflt, always = false) {
        if (value === void 0) {
          if (always) {
            return dflt;
          }
        } else if (always || value !== dflt) {
          return value ? "1" : "0";
        }
        return void 0;
      }
      static toBoolValue(attr, dflt) {
        return attr === void 0 ? dflt : attr === "1";
      }
      static toIntAttribute(value, dflt, always = false) {
        return _BaseXform.toAttribute(value, dflt, always);
      }
      static toIntValue(attr, dflt) {
        return attr === void 0 ? dflt : parseInt(attr, 10);
      }
      static toFloatAttribute(value, dflt, always = false) {
        return _BaseXform.toAttribute(value, dflt, always);
      }
      static toFloatValue(attr, dflt) {
        return attr === void 0 ? dflt : parseFloat(attr);
      }
    };
    module2.exports = BaseXform;
  }
});

// ../../../node_modules/exceljs/lib/xlsx/xform/static-xform.js
var require_static_xform = __commonJS({
  "../../../node_modules/exceljs/lib/xlsx/xform/static-xform.js"(exports2, module2) {
    var BaseXform = require_base_xform();
    var XmlStream = require_xml_stream();
    function build(xmlStream, model) {
      xmlStream.openNode(model.tag, model.$);
      if (model.c) {
        model.c.forEach((child) => {
          build(xmlStream, child);
        });
      }
      if (model.t) {
        xmlStream.writeText(model.t);
      }
      xmlStream.closeNode();
    }
    var StaticXform = class extends BaseXform {
      constructor(model) {
        super();
        this._model = model;
      }
      render(xmlStream) {
        if (!this._xml) {
          const stream = new XmlStream();
          build(stream, this._model);
          this._xml = stream.xml;
        }
        xmlStream.writeXml(this._xml);
      }
      parseOpen() {
        return true;
      }
      parseText() {
      }
      parseClose(name) {
        switch (name) {
          case this._model.tag:
            return false;
          default:
            return true;
        }
      }
    };
    module2.exports = StaticXform;
  }
});

// ../../../node_modules/exceljs/lib/xlsx/xform/list-xform.js
var require_list_xform = __commonJS({
  "../../../node_modules/exceljs/lib/xlsx/xform/list-xform.js"(exports2, module2) {
    var BaseXform = require_base_xform();
    var ListXform = class extends BaseXform {
      constructor(options) {
        super();
        this.tag = options.tag;
        this.always = !!options.always;
        this.count = options.count;
        this.empty = options.empty;
        this.$count = options.$count || "count";
        this.$ = options.$;
        this.childXform = options.childXform;
        this.maxItems = options.maxItems;
      }
      prepare(model, options) {
        const { childXform } = this;
        if (model) {
          model.forEach((childModel, index) => {
            options.index = index;
            childXform.prepare(childModel, options);
          });
        }
      }
      render(xmlStream, model) {
        if (this.always || model && model.length) {
          xmlStream.openNode(this.tag, this.$);
          if (this.count) {
            xmlStream.addAttribute(this.$count, model && model.length || 0);
          }
          const { childXform } = this;
          (model || []).forEach((childModel, index) => {
            childXform.render(xmlStream, childModel, index);
          });
          xmlStream.closeNode();
        } else if (this.empty) {
          xmlStream.leafNode(this.tag);
        }
      }
      parseOpen(node) {
        if (this.parser) {
          this.parser.parseOpen(node);
          return true;
        }
        switch (node.name) {
          case this.tag:
            this.model = [];
            return true;
          default:
            if (this.childXform.parseOpen(node)) {
              this.parser = this.childXform;
              return true;
            }
            return false;
        }
      }
      parseText(text) {
        if (this.parser) {
          this.parser.parseText(text);
        }
      }
      parseClose(name) {
        if (this.parser) {
          if (!this.parser.parseClose(name)) {
            this.model.push(this.parser.model);
            this.parser = void 0;
            if (this.maxItems && this.model.length > this.maxItems) {
              throw new Error(`Max ${this.childXform.tag} count (${this.maxItems}) exceeded`);
            }
          }
          return true;
        }
        return false;
      }
      reconcile(model, options) {
        if (model) {
          const { childXform } = this;
          model.forEach((childModel) => {
            childXform.reconcile(childModel, options);
          });
        }
      }
    };
    module2.exports = ListXform;
  }
});

// ../../../node_modules/exceljs/lib/xlsx/xform/style/color-xform.js
var require_color_xform = __commonJS({
  "../../../node_modules/exceljs/lib/xlsx/xform/style/color-xform.js"(exports2, module2) {
    var BaseXform = require_base_xform();
    var ColorXform = class extends BaseXform {
      constructor(name) {
        super();
        this.name = name || "color";
      }
      get tag() {
        return this.name;
      }
      render(xmlStream, model) {
        if (model) {
          xmlStream.openNode(this.name);
          if (model.argb) {
            xmlStream.addAttribute("rgb", model.argb);
          } else if (model.theme !== void 0) {
            xmlStream.addAttribute("theme", model.theme);
            if (model.tint !== void 0) {
              xmlStream.addAttribute("tint", model.tint);
            }
          } else if (model.indexed !== void 0) {
            xmlStream.addAttribute("indexed", model.indexed);
          } else {
            xmlStream.addAttribute("auto", "1");
          }
          xmlStream.closeNode();
          return true;
        }
        return false;
      }
      parseOpen(node) {
        if (node.name === this.name) {
          if (node.attributes.rgb) {
            this.model = { argb: node.attributes.rgb };
          } else if (node.attributes.theme) {
            this.model = { theme: parseInt(node.attributes.theme, 10) };
            if (node.attributes.tint) {
              this.model.tint = parseFloat(node.attributes.tint);
            }
          } else if (node.attributes.indexed) {
            this.model = { indexed: parseInt(node.attributes.indexed, 10) };
          } else {
            this.model = void 0;
          }
          return true;
        }
        return false;
      }
      parseText() {
      }
      parseClose() {
        return false;
      }
    };
    module2.exports = ColorXform;
  }
});

// ../../../node_modules/exceljs/lib/xlsx/xform/simple/boolean-xform.js
var require_boolean_xform = __commonJS({
  "../../../node_modules/exceljs/lib/xlsx/xform/simple/boolean-xform.js"(exports2, module2) {
    var BaseXform = require_base_xform();
    var BooleanXform = class extends BaseXform {
      constructor(options) {
        super();
        this.tag = options.tag;
        this.attr = options.attr;
      }
      render(xmlStream, model) {
        if (model) {
          xmlStream.openNode(this.tag);
          xmlStream.closeNode();
        }
      }
      parseOpen(node) {
        if (node.name === this.tag) {
          this.model = true;
        }
      }
      parseText() {
      }
      parseClose() {
        return false;
      }
    };
    module2.exports = BooleanXform;
  }
});

// ../../../node_modules/exceljs/lib/xlsx/xform/simple/integer-xform.js
var require_integer_xform = __commonJS({
  "../../../node_modules/exceljs/lib/xlsx/xform/simple/integer-xform.js"(exports2, module2) {
    var BaseXform = require_base_xform();
    var IntegerXform = class extends BaseXform {
      constructor(options) {
        super();
        this.tag = options.tag;
        this.attr = options.attr;
        this.attrs = options.attrs;
        this.zero = options.zero;
      }
      render(xmlStream, model) {
        if (model || this.zero) {
          xmlStream.openNode(this.tag);
          if (this.attrs) {
            xmlStream.addAttributes(this.attrs);
          }
          if (this.attr) {
            xmlStream.addAttribute(this.attr, model);
          } else {
            xmlStream.writeText(model);
          }
          xmlStream.closeNode();
        }
      }
      parseOpen(node) {
        if (node.name === this.tag) {
          if (this.attr) {
            this.model = parseInt(node.attributes[this.attr], 10);
          } else {
            this.text = [];
          }
          return true;
        }
        return false;
      }
      parseText(text) {
        if (!this.attr) {
          this.text.push(text);
        }
      }
      parseClose() {
        if (!this.attr) {
          this.model = parseInt(this.text.join("") || 0, 10);
        }
        return false;
      }
    };
    module2.exports = IntegerXform;
  }
});

// ../../../node_modules/exceljs/lib/xlsx/xform/simple/string-xform.js
var require_string_xform = __commonJS({
  "../../../node_modules/exceljs/lib/xlsx/xform/simple/string-xform.js"(exports2, module2) {
    var BaseXform = require_base_xform();
    var StringXform = class extends BaseXform {
      constructor(options) {
        super();
        this.tag = options.tag;
        this.attr = options.attr;
        this.attrs = options.attrs;
      }
      render(xmlStream, model) {
        if (model !== void 0) {
          xmlStream.openNode(this.tag);
          if (this.attrs) {
            xmlStream.addAttributes(this.attrs);
          }
          if (this.attr) {
            xmlStream.addAttribute(this.attr, model);
          } else {
            xmlStream.writeText(model);
          }
          xmlStream.closeNode();
        }
      }
      parseOpen(node) {
        if (node.name === this.tag) {
          if (this.attr) {
            this.model = node.attributes[this.attr];
          } else {
            this.text = [];
          }
        }
      }
      parseText(text) {
        if (!this.attr) {
          this.text.push(text);
        }
      }
      parseClose() {
        if (!this.attr) {
          this.model = this.text.join("");
        }
        return false;
      }
    };
    module2.exports = StringXform;
  }
});

// ../../../node_modules/exceljs/lib/xlsx/xform/style/underline-xform.js
var require_underline_xform = __commonJS({
  "../../../node_modules/exceljs/lib/xlsx/xform/style/underline-xform.js"(exports2, module2) {
    var BaseXform = require_base_xform();
    var UnderlineXform = class _UnderlineXform extends BaseXform {
      constructor(model) {
        super();
        this.model = model;
      }
      get tag() {
        return "u";
      }
      render(xmlStream, model) {
        model = model || this.model;
        if (model === true) {
          xmlStream.leafNode("u");
        } else {
          const attr = _UnderlineXform.Attributes[model];
          if (attr) {
            xmlStream.leafNode("u", attr);
          }
        }
      }
      parseOpen(node) {
        if (node.name === "u") {
          this.model = node.attributes.val || true;
        }
      }
      parseText() {
      }
      parseClose() {
        return false;
      }
    };
    UnderlineXform.Attributes = {
      single: {},
      double: { val: "double" },
      singleAccounting: { val: "singleAccounting" },
      doubleAccounting: { val: "doubleAccounting" }
    };
    module2.exports = UnderlineXform;
  }
});

// ../../../node_modules/exceljs/lib/xlsx/xform/style/font-xform.js
var require_font_xform = __commonJS({
  "../../../node_modules/exceljs/lib/xlsx/xform/style/font-xform.js"(exports2, module2) {
    "use strict";
    var ColorXform = require_color_xform();
    var BooleanXform = require_boolean_xform();
    var IntegerXform = require_integer_xform();
    var StringXform = require_string_xform();
    var UnderlineXform = require_underline_xform();
    var _2 = require_under_dash();
    var BaseXform = require_base_xform();
    var FontXform = class _FontXform extends BaseXform {
      constructor(options) {
        super();
        this.options = options || _FontXform.OPTIONS;
        this.map = {
          b: { prop: "bold", xform: new BooleanXform({ tag: "b", attr: "val" }) },
          i: { prop: "italic", xform: new BooleanXform({ tag: "i", attr: "val" }) },
          u: { prop: "underline", xform: new UnderlineXform() },
          charset: { prop: "charset", xform: new IntegerXform({ tag: "charset", attr: "val" }) },
          color: { prop: "color", xform: new ColorXform() },
          condense: { prop: "condense", xform: new BooleanXform({ tag: "condense", attr: "val" }) },
          extend: { prop: "extend", xform: new BooleanXform({ tag: "extend", attr: "val" }) },
          family: { prop: "family", xform: new IntegerXform({ tag: "family", attr: "val" }) },
          outline: { prop: "outline", xform: new BooleanXform({ tag: "outline", attr: "val" }) },
          vertAlign: { prop: "vertAlign", xform: new StringXform({ tag: "vertAlign", attr: "val" }) },
          scheme: { prop: "scheme", xform: new StringXform({ tag: "scheme", attr: "val" }) },
          shadow: { prop: "shadow", xform: new BooleanXform({ tag: "shadow", attr: "val" }) },
          strike: { prop: "strike", xform: new BooleanXform({ tag: "strike", attr: "val" }) },
          sz: { prop: "size", xform: new IntegerXform({ tag: "sz", attr: "val" }) }
        };
        this.map[this.options.fontNameTag] = {
          prop: "name",
          xform: new StringXform({ tag: this.options.fontNameTag, attr: "val" })
        };
      }
      get tag() {
        return this.options.tagName;
      }
      render(xmlStream, model) {
        const { map } = this;
        xmlStream.openNode(this.options.tagName);
        _2.each(this.map, (defn, tag) => {
          map[tag].xform.render(xmlStream, model[defn.prop]);
        });
        xmlStream.closeNode();
      }
      parseOpen(node) {
        if (this.parser) {
          this.parser.parseOpen(node);
          return true;
        }
        if (this.map[node.name]) {
          this.parser = this.map[node.name].xform;
          return this.parser.parseOpen(node);
        }
        switch (node.name) {
          case this.options.tagName:
            this.model = {};
            return true;
          default:
            return false;
        }
      }
      parseText(text) {
        if (this.parser) {
          this.parser.parseText(text);
        }
      }
      parseClose(name) {
        if (this.parser && !this.parser.parseClose(name)) {
          const item = this.map[name];
          if (this.parser.model) {
            this.model[item.prop] = this.parser.model;
          }
          this.parser = void 0;
          return true;
        }
        switch (name) {
          case this.options.tagName:
            return false;
          default:
            return true;
        }
      }
    };
    FontXform.OPTIONS = {
      tagName: "font",
      fontNameTag: "name"
    };
    module2.exports = FontXform;
  }
});

// ../../../node_modules/exceljs/lib/xlsx/xform/style/fill-xform.js
var require_fill_xform = __commonJS({
  "../../../node_modules/exceljs/lib/xlsx/xform/style/fill-xform.js"(exports2, module2) {
    var BaseXform = require_base_xform();
    var ColorXform = require_color_xform();
    var StopXform = class extends BaseXform {
      constructor() {
        super();
        this.map = {
          color: new ColorXform()
        };
      }
      get tag() {
        return "stop";
      }
      render(xmlStream, model) {
        xmlStream.openNode("stop");
        xmlStream.addAttribute("position", model.position);
        this.map.color.render(xmlStream, model.color);
        xmlStream.closeNode();
      }
      parseOpen(node) {
        if (this.parser) {
          this.parser.parseOpen(node);
          return true;
        }
        switch (node.name) {
          case "stop":
            this.model = {
              position: parseFloat(node.attributes.position)
            };
            return true;
          case "color":
            this.parser = this.map.color;
            this.parser.parseOpen(node);
            return true;
          default:
            return false;
        }
      }
      parseText() {
      }
      parseClose(name) {
        if (this.parser) {
          if (!this.parser.parseClose(name)) {
            this.model.color = this.parser.model;
            this.parser = void 0;
          }
          return true;
        }
        return false;
      }
    };
    var PatternFillXform = class extends BaseXform {
      constructor() {
        super();
        this.map = {
          fgColor: new ColorXform("fgColor"),
          bgColor: new ColorXform("bgColor")
        };
      }
      get name() {
        return "pattern";
      }
      get tag() {
        return "patternFill";
      }
      render(xmlStream, model) {
        xmlStream.openNode("patternFill");
        xmlStream.addAttribute("patternType", model.pattern);
        if (model.fgColor) {
          this.map.fgColor.render(xmlStream, model.fgColor);
        }
        if (model.bgColor) {
          this.map.bgColor.render(xmlStream, model.bgColor);
        }
        xmlStream.closeNode();
      }
      parseOpen(node) {
        if (this.parser) {
          this.parser.parseOpen(node);
          return true;
        }
        switch (node.name) {
          case "patternFill":
            this.model = {
              type: "pattern",
              pattern: node.attributes.patternType
            };
            return true;
          default:
            this.parser = this.map[node.name];
            if (this.parser) {
              this.parser.parseOpen(node);
              return true;
            }
            return false;
        }
      }
      parseText(text) {
        if (this.parser) {
          this.parser.parseText(text);
        }
      }
      parseClose(name) {
        if (this.parser) {
          if (!this.parser.parseClose(name)) {
            if (this.parser.model) {
              this.model[name] = this.parser.model;
            }
            this.parser = void 0;
          }
          return true;
        }
        return false;
      }
    };
    var GradientFillXform = class extends BaseXform {
      constructor() {
        super();
        this.map = {
          stop: new StopXform()
        };
      }
      get name() {
        return "gradient";
      }
      get tag() {
        return "gradientFill";
      }
      render(xmlStream, model) {
        xmlStream.openNode("gradientFill");
        switch (model.gradient) {
          case "angle":
            xmlStream.addAttribute("degree", model.degree);
            break;
          case "path":
            xmlStream.addAttribute("type", "path");
            if (model.center.left) {
              xmlStream.addAttribute("left", model.center.left);
              if (model.center.right === void 0) {
                xmlStream.addAttribute("right", model.center.left);
              }
            }
            if (model.center.right) {
              xmlStream.addAttribute("right", model.center.right);
            }
            if (model.center.top) {
              xmlStream.addAttribute("top", model.center.top);
              if (model.center.bottom === void 0) {
                xmlStream.addAttribute("bottom", model.center.top);
              }
            }
            if (model.center.bottom) {
              xmlStream.addAttribute("bottom", model.center.bottom);
            }
            break;
          default:
            break;
        }
        const stopXform = this.map.stop;
        model.stops.forEach((stopModel) => {
          stopXform.render(xmlStream, stopModel);
        });
        xmlStream.closeNode();
      }
      parseOpen(node) {
        if (this.parser) {
          this.parser.parseOpen(node);
          return true;
        }
        switch (node.name) {
          case "gradientFill": {
            const model = this.model = {
              stops: []
            };
            if (node.attributes.degree) {
              model.gradient = "angle";
              model.degree = parseInt(node.attributes.degree, 10);
            } else if (node.attributes.type === "path") {
              model.gradient = "path";
              model.center = {
                left: node.attributes.left ? parseFloat(node.attributes.left) : 0,
                top: node.attributes.top ? parseFloat(node.attributes.top) : 0
              };
              if (node.attributes.right !== node.attributes.left) {
                model.center.right = node.attributes.right ? parseFloat(node.attributes.right) : 0;
              }
              if (node.attributes.bottom !== node.attributes.top) {
                model.center.bottom = node.attributes.bottom ? parseFloat(node.attributes.bottom) : 0;
              }
            }
            return true;
          }
          case "stop":
            this.parser = this.map.stop;
            this.parser.parseOpen(node);
            return true;
          default:
            return false;
        }
      }
      parseText(text) {
        if (this.parser) {
          this.parser.parseText(text);
        }
      }
      parseClose(name) {
        if (this.parser) {
          if (!this.parser.parseClose(name)) {
            this.model.stops.push(this.parser.model);
            this.parser = void 0;
          }
          return true;
        }
        return false;
      }
    };
    var FillXform = class _FillXform extends BaseXform {
      constructor() {
        super();
        this.map = {
          patternFill: new PatternFillXform(),
          gradientFill: new GradientFillXform()
        };
      }
      get tag() {
        return "fill";
      }
      render(xmlStream, model) {
        xmlStream.addRollback();
        xmlStream.openNode("fill");
        switch (model.type) {
          case "pattern":
            this.map.patternFill.render(xmlStream, model);
            break;
          case "gradient":
            this.map.gradientFill.render(xmlStream, model);
            break;
          default:
            xmlStream.rollback();
            return;
        }
        xmlStream.closeNode();
        xmlStream.commit();
      }
      parseOpen(node) {
        if (this.parser) {
          this.parser.parseOpen(node);
          return true;
        }
        switch (node.name) {
          case "fill":
            this.model = {};
            return true;
          default:
            this.parser = this.map[node.name];
            if (this.parser) {
              this.parser.parseOpen(node);
              return true;
            }
            return false;
        }
      }
      parseText(text) {
        if (this.parser) {
          this.parser.parseText(text);
        }
      }
      parseClose(name) {
        if (this.parser) {
          if (!this.parser.parseClose(name)) {
            this.model = this.parser.model;
            this.model.type = this.parser.name;
            this.parser = void 0;
          }
          return true;
        }
        return false;
      }
      validStyle(value) {
        return _FillXform.validPatternValues[value];
      }
    };
    FillXform.validPatternValues = [
      "none",
      "solid",
      "darkVertical",
      "darkGray",
      "mediumGray",
      "lightGray",
      "gray125",
      "gray0625",
      "darkHorizontal",
      "darkVertical",
      "darkDown",
      "darkUp",
      "darkGrid",
      "darkTrellis",
      "lightHorizontal",
      "lightVertical",
      "lightDown",
      "lightUp",
      "lightGrid",
      "lightTrellis",
      "lightGrid"
    ].reduce((p, v) => {
      p[v] = true;
      return p;
    }, {});
    FillXform.StopXform = StopXform;
    FillXform.PatternFillXform = PatternFillXform;
    FillXform.GradientFillXform = GradientFillXform;
    module2.exports = FillXform;
  }
});

// ../../../node_modules/exceljs/lib/xlsx/xform/style/border-xform.js
var require_border_xform = __commonJS({
  "../../../node_modules/exceljs/lib/xlsx/xform/style/border-xform.js"(exports2, module2) {
    var BaseXform = require_base_xform();
    var utils = require_utils2();
    var ColorXform = require_color_xform();
    var EdgeXform = class _EdgeXform extends BaseXform {
      constructor(name) {
        super();
        this.name = name;
        this.map = {
          color: new ColorXform()
        };
      }
      get tag() {
        return this.name;
      }
      render(xmlStream, model, defaultColor) {
        const color = model && model.color || defaultColor || this.defaultColor;
        xmlStream.openNode(this.name);
        if (model && model.style) {
          xmlStream.addAttribute("style", model.style);
          if (color) {
            this.map.color.render(xmlStream, color);
          }
        }
        xmlStream.closeNode();
      }
      parseOpen(node) {
        if (this.parser) {
          this.parser.parseOpen(node);
          return true;
        }
        switch (node.name) {
          case this.name: {
            const { style } = node.attributes;
            if (style) {
              this.model = {
                style
              };
            } else {
              this.model = void 0;
            }
            return true;
          }
          case "color":
            this.parser = this.map.color;
            this.parser.parseOpen(node);
            return true;
          default:
            return false;
        }
      }
      parseText(text) {
        if (this.parser) {
          this.parser.parseText(text);
        }
      }
      parseClose(name) {
        if (this.parser) {
          if (!this.parser.parseClose(name)) {
            this.parser = void 0;
          }
          return true;
        }
        if (name === this.name) {
          if (this.map.color.model) {
            if (!this.model) {
              this.model = {};
            }
            this.model.color = this.map.color.model;
          }
        }
        return false;
      }
      validStyle(value) {
        return _EdgeXform.validStyleValues[value];
      }
    };
    EdgeXform.validStyleValues = [
      "thin",
      "dashed",
      "dotted",
      "dashDot",
      "hair",
      "dashDotDot",
      "slantDashDot",
      "mediumDashed",
      "mediumDashDotDot",
      "mediumDashDot",
      "medium",
      "double",
      "thick"
    ].reduce((p, v) => {
      p[v] = true;
      return p;
    }, {});
    var BorderXform = class extends BaseXform {
      constructor() {
        super();
        this.map = {
          top: new EdgeXform("top"),
          left: new EdgeXform("left"),
          bottom: new EdgeXform("bottom"),
          right: new EdgeXform("right"),
          diagonal: new EdgeXform("diagonal")
        };
      }
      render(xmlStream, model) {
        const { color } = model;
        xmlStream.openNode("border");
        if (model.diagonal && model.diagonal.style) {
          if (model.diagonal.up) {
            xmlStream.addAttribute("diagonalUp", "1");
          }
          if (model.diagonal.down) {
            xmlStream.addAttribute("diagonalDown", "1");
          }
        }
        function add(edgeModel, edgeXform) {
          if (edgeModel && !edgeModel.color && model.color) {
            edgeModel = {
              ...edgeModel,
              color: model.color
            };
          }
          edgeXform.render(xmlStream, edgeModel, color);
        }
        add(model.left, this.map.left);
        add(model.right, this.map.right);
        add(model.top, this.map.top);
        add(model.bottom, this.map.bottom);
        add(model.diagonal, this.map.diagonal);
        xmlStream.closeNode();
      }
      parseOpen(node) {
        if (this.parser) {
          this.parser.parseOpen(node);
          return true;
        }
        switch (node.name) {
          case "border":
            this.reset();
            this.diagonalUp = utils.parseBoolean(node.attributes.diagonalUp);
            this.diagonalDown = utils.parseBoolean(node.attributes.diagonalDown);
            return true;
          default:
            this.parser = this.map[node.name];
            if (this.parser) {
              this.parser.parseOpen(node);
              return true;
            }
            return false;
        }
      }
      parseText(text) {
        if (this.parser) {
          this.parser.parseText(text);
        }
      }
      parseClose(name) {
        if (this.parser) {
          if (!this.parser.parseClose(name)) {
            this.parser = void 0;
          }
          return true;
        }
        if (name === "border") {
          const model = this.model = {};
          const add = function(key, edgeModel, extensions) {
            if (edgeModel) {
              if (extensions) {
                Object.assign(edgeModel, extensions);
              }
              model[key] = edgeModel;
            }
          };
          add("left", this.map.left.model);
          add("right", this.map.right.model);
          add("top", this.map.top.model);
          add("bottom", this.map.bottom.model);
          add("diagonal", this.map.diagonal.model, { up: this.diagonalUp, down: this.diagonalDown });
        }
        return false;
      }
    };
    module2.exports = BorderXform;
  }
});

// ../../../node_modules/exceljs/lib/xlsx/defaultnumformats.js
var require_defaultnumformats = __commonJS({
  "../../../node_modules/exceljs/lib/xlsx/defaultnumformats.js"(exports2, module2) {
    module2.exports = {
      0: { f: "General" },
      1: { f: "0" },
      2: { f: "0.00" },
      3: { f: "#,##0" },
      4: { f: "#,##0.00" },
      9: { f: "0%" },
      10: { f: "0.00%" },
      11: { f: "0.00E+00" },
      12: { f: "# ?/?" },
      13: { f: "# ??/??" },
      14: { f: "mm-dd-yy" },
      15: { f: "d-mmm-yy" },
      16: { f: "d-mmm" },
      17: { f: "mmm-yy" },
      18: { f: "h:mm AM/PM" },
      19: { f: "h:mm:ss AM/PM" },
      20: { f: "h:mm" },
      21: { f: "h:mm:ss" },
      22: { f: 'm/d/yy "h":mm' },
      27: {
        "zh-tw": "[$-404]e/m/d",
        "zh-cn": 'yyyy"\u5E74"m"\u6708"',
        "ja-jp": "[$-411]ge.m.d",
        "ko-kr": 'yyyy"\u5E74" mm"\u6708" dd"\u65E5"'
      },
      28: {
        "zh-tw": '[$-404]e"\u5E74"m"\u6708"d"\u65E5"',
        "zh-cn": 'm"\u6708"d"\u65E5"',
        "ja-jp": '[$-411]ggge"\u5E74"m"\u6708"d"\u65E5"',
        "ko-kr": "mm-dd"
      },
      29: {
        "zh-tw": '[$-404]e"\u5E74"m"\u6708"d"\u65E5"',
        "zh-cn": 'm"\u6708"d"\u65E5"',
        "ja-jp": '[$-411]ggge"\u5E74"m"\u6708"d"\u65E5"',
        "ko-kr": "mm-dd"
      },
      30: { "zh-tw": "m/d/yy ", "zh-cn": "m-d-yy", "ja-jp": "m/d/yy", "ko-kr": "mm-dd-yy" },
      31: {
        "zh-tw": 'yyyy"\u5E74"m"\u6708"d"\u65E5"',
        "zh-cn": 'yyyy"\u5E74"m"\u6708"d"\u65E5"',
        "ja-jp": 'yyyy"\u5E74"m"\u6708"d"\u65E5"',
        "ko-kr": 'yyyy"\uB144" mm"\uC6D4" dd"\uC77C"'
      },
      32: {
        "zh-tw": 'hh"\u6642"mm"\u5206"',
        "zh-cn": 'h"\u65F6"mm"\u5206"',
        "ja-jp": 'h"\u6642"mm"\u5206"',
        "ko-kr": 'h"\uC2DC" mm"\uBD84"'
      },
      33: {
        "zh-tw": 'hh"\u6642"mm"\u5206"ss"\u79D2"',
        "zh-cn": 'h"\u65F6"mm"\u5206"ss"\u79D2"',
        "ja-jp": 'h"\u6642"mm"\u5206"ss"\u79D2"',
        "ko-kr": 'h"\uC2DC" mm"\uBD84" ss"\uCD08"'
      },
      34: {
        "zh-tw": '\u4E0A\u5348/\u4E0B\u5348 hh"\u6642"mm"\u5206"',
        "zh-cn": '\u4E0A\u5348/\u4E0B\u5348 h"\u65F6"mm"\u5206"',
        "ja-jp": 'yyyy"\u5E74"m"\u6708"',
        "ko-kr": "yyyy-mm-dd"
      },
      35: {
        "zh-tw": '\u4E0A\u5348/\u4E0B\u5348 hh"\u6642"mm"\u5206"ss"\u79D2"',
        "zh-cn": '\u4E0A\u5348/\u4E0B\u5348 h"\u65F6"mm"\u5206"ss"\u79D2"',
        "ja-jp": 'm"\u6708"d"\u65E5"',
        "ko-kr": "yyyy-mm-dd"
      },
      36: {
        "zh-tw": "[$-404]e/m/d",
        "zh-cn": 'yyyy"\u5E74"m"\u6708"',
        "ja-jp": "[$-411]ge.m.d",
        "ko-kr": 'yyyy"\u5E74" mm"\u6708" dd"\u65E5"'
      },
      37: { f: "#,##0 ;(#,##0)" },
      38: { f: "#,##0 ;[Red](#,##0)" },
      39: { f: "#,##0.00 ;(#,##0.00)" },
      40: { f: "#,##0.00 ;[Red](#,##0.00)" },
      45: { f: "mm:ss" },
      46: { f: "[h]:mm:ss" },
      47: { f: "mmss.0" },
      48: { f: "##0.0E+0" },
      49: { f: "@" },
      50: {
        "zh-tw": "[$-404]e/m/d",
        "zh-cn": 'yyyy"\u5E74"m"\u6708"',
        "ja-jp": "[$-411]ge.m.d",
        "ko-kr": 'yyyy"\u5E74" mm"\u6708" dd"\u65E5"'
      },
      51: {
        "zh-tw": '[$-404]e"\u5E74"m"\u6708"d"\u65E5"',
        "zh-cn": 'm"\u6708"d"\u65E5"',
        "ja-jp": '[$-411]ggge"\u5E74"m"\u6708"d"\u65E5"',
        "ko-kr": "mm-dd"
      },
      52: {
        "zh-tw": '\u4E0A\u5348/\u4E0B\u5348 hh"\u6642"mm"\u5206"',
        "zh-cn": 'yyyy"\u5E74"m"\u6708"',
        "ja-jp": 'yyyy"\u5E74"m"\u6708"',
        "ko-kr": "yyyy-mm-dd"
      },
      53: {
        "zh-tw": '\u4E0A\u5348/\u4E0B\u5348 hh"\u6642"mm"\u5206"ss"\u79D2"',
        "zh-cn": 'm"\u6708"d"\u65E5"',
        "ja-jp": 'm"\u6708"d"\u65E5"',
        "ko-kr": "yyyy-mm-dd"
      },
      54: {
        "zh-tw": '[$-404]e"\u5E74"m"\u6708"d"\u65E5"',
        "zh-cn": 'm"\u6708"d"\u65E5"',
        "ja-jp": '[$-411]ggge"\u5E74"m"\u6708"d"\u65E5"',
        "ko-kr": "mm-dd"
      },
      55: {
        "zh-tw": '\u4E0A\u5348/\u4E0B\u5348 hh"\u6642"mm"\u5206"',
        "zh-cn": '\u4E0A\u5348/\u4E0B\u5348 h"\u65F6"mm"\u5206"',
        "ja-jp": 'yyyy"\u5E74"m"\u6708"',
        "ko-kr": "yyyy-mm-dd"
      },
      56: {
        "zh-tw": '\u4E0A\u5348/\u4E0B\u5348 hh"\u6642"mm"\u5206"ss"\u79D2"',
        "zh-cn": '\u4E0A\u5348/\u4E0B\u5348 h"\u65F6"mm"\u5206"ss"\u79D2"',
        "ja-jp": 'm"\u6708"d"\u65E5"',
        "ko-kr": "yyyy-mm-dd"
      },
      57: {
        "zh-tw": "[$-404]e/m/d",
        "zh-cn": 'yyyy"\u5E74"m"\u6708"',
        "ja-jp": "[$-411]ge.m.d",
        "ko-kr": 'yyyy"\u5E74" mm"\u6708" dd"\u65E5"'
      },
      58: {
        "zh-tw": '[$-404]e"\u5E74"m"\u6708"d"\u65E5"',
        "zh-cn": 'm"\u6708"d"\u65E5"',
        "ja-jp": '[$-411]ggge"\u5E74"m"\u6708"d"\u65E5"',
        "ko-kr": "mm-dd"
      },
      59: { "th-th": "t0" },
      60: { "th-th": "t0.00" },
      61: { "th-th": "t#,##0" },
      62: { "th-th": "t#,##0.00" },
      67: { "th-th": "t0%" },
      68: { "th-th": "t0.00%" },
      69: { "th-th": "t# ?/?" },
      70: { "th-th": "t# ??/??" },
      81: { "th-th": "d/m/bb" }
    };
  }
});

// ../../../node_modules/exceljs/lib/xlsx/xform/style/numfmt-xform.js
var require_numfmt_xform = __commonJS({
  "../../../node_modules/exceljs/lib/xlsx/xform/style/numfmt-xform.js"(exports2, module2) {
    var _2 = require_under_dash();
    var defaultNumFormats = require_defaultnumformats();
    var BaseXform = require_base_xform();
    function hashDefaultFormats() {
      const hash = {};
      _2.each(defaultNumFormats, (dnf, id) => {
        if (dnf.f) {
          hash[dnf.f] = parseInt(id, 10);
        }
      });
      return hash;
    }
    var defaultFmtHash = hashDefaultFormats();
    var NumFmtXform = class extends BaseXform {
      constructor(id, formatCode) {
        super();
        this.id = id;
        this.formatCode = formatCode;
      }
      get tag() {
        return "numFmt";
      }
      render(xmlStream, model) {
        xmlStream.leafNode("numFmt", { numFmtId: model.id, formatCode: model.formatCode });
      }
      parseOpen(node) {
        switch (node.name) {
          case "numFmt":
            this.model = {
              id: parseInt(node.attributes.numFmtId, 10),
              formatCode: node.attributes.formatCode.replace(/[\\](.)/g, "$1")
            };
            return true;
          default:
            return false;
        }
      }
      parseText() {
      }
      parseClose() {
        return false;
      }
    };
    NumFmtXform.getDefaultFmtId = function getDefaultFmtId(formatCode) {
      return defaultFmtHash[formatCode];
    };
    NumFmtXform.getDefaultFmtCode = function getDefaultFmtCode(numFmtId) {
      return defaultNumFormats[numFmtId] && defaultNumFormats[numFmtId].f;
    };
    module2.exports = NumFmtXform;
  }
});

// ../../../node_modules/exceljs/lib/xlsx/xform/style/alignment-xform.js
var require_alignment_xform = __commonJS({
  "../../../node_modules/exceljs/lib/xlsx/xform/style/alignment-xform.js"(exports2, module2) {
    var Enums = require_enums();
    var utils = require_utils2();
    var BaseXform = require_base_xform();
    var validation = {
      horizontalValues: [
        "left",
        "center",
        "right",
        "fill",
        "centerContinuous",
        "distributed",
        "justify"
      ].reduce((p, v) => {
        p[v] = true;
        return p;
      }, {}),
      horizontal(value) {
        return this.horizontalValues[value] ? value : void 0;
      },
      verticalValues: ["top", "middle", "bottom", "distributed", "justify"].reduce((p, v) => {
        p[v] = true;
        return p;
      }, {}),
      vertical(value) {
        if (value === "middle")
          return "center";
        return this.verticalValues[value] ? value : void 0;
      },
      wrapText(value) {
        return value ? true : void 0;
      },
      shrinkToFit(value) {
        return value ? true : void 0;
      },
      textRotation(value) {
        switch (value) {
          case "vertical":
            return value;
          default:
            value = utils.validInt(value);
            return value >= -90 && value <= 90 ? value : void 0;
        }
      },
      indent(value) {
        value = utils.validInt(value);
        return Math.max(0, value);
      },
      readingOrder(value) {
        switch (value) {
          case "ltr":
            return Enums.ReadingOrder.LeftToRight;
          case "rtl":
            return Enums.ReadingOrder.RightToLeft;
          default:
            return void 0;
        }
      }
    };
    var textRotationXform = {
      toXml(textRotation) {
        textRotation = validation.textRotation(textRotation);
        if (textRotation) {
          if (textRotation === "vertical") {
            return 255;
          }
          const tr = Math.round(textRotation);
          if (tr >= 0 && tr <= 90) {
            return tr;
          }
          if (tr < 0 && tr >= -90) {
            return 90 - tr;
          }
        }
        return void 0;
      },
      toModel(textRotation) {
        const tr = utils.validInt(textRotation);
        if (tr !== void 0) {
          if (tr === 255) {
            return "vertical";
          }
          if (tr >= 0 && tr <= 90) {
            return tr;
          }
          if (tr > 90 && tr <= 180) {
            return 90 - tr;
          }
        }
        return void 0;
      }
    };
    var AlignmentXform = class extends BaseXform {
      get tag() {
        return "alignment";
      }
      render(xmlStream, model) {
        xmlStream.addRollback();
        xmlStream.openNode("alignment");
        let isValid = false;
        function add(name, value) {
          if (value) {
            xmlStream.addAttribute(name, value);
            isValid = true;
          }
        }
        add("horizontal", validation.horizontal(model.horizontal));
        add("vertical", validation.vertical(model.vertical));
        add("wrapText", validation.wrapText(model.wrapText) ? "1" : false);
        add("shrinkToFit", validation.shrinkToFit(model.shrinkToFit) ? "1" : false);
        add("indent", validation.indent(model.indent));
        add("textRotation", textRotationXform.toXml(model.textRotation));
        add("readingOrder", validation.readingOrder(model.readingOrder));
        xmlStream.closeNode();
        if (isValid) {
          xmlStream.commit();
        } else {
          xmlStream.rollback();
        }
      }
      parseOpen(node) {
        const model = {};
        let valid = false;
        function add(truthy, name, value) {
          if (truthy) {
            model[name] = value;
            valid = true;
          }
        }
        add(node.attributes.horizontal, "horizontal", node.attributes.horizontal);
        add(
          node.attributes.vertical,
          "vertical",
          node.attributes.vertical === "center" ? "middle" : node.attributes.vertical
        );
        add(node.attributes.wrapText, "wrapText", utils.parseBoolean(node.attributes.wrapText));
        add(node.attributes.shrinkToFit, "shrinkToFit", utils.parseBoolean(node.attributes.shrinkToFit));
        add(node.attributes.indent, "indent", parseInt(node.attributes.indent, 10));
        add(
          node.attributes.textRotation,
          "textRotation",
          textRotationXform.toModel(node.attributes.textRotation)
        );
        add(
          node.attributes.readingOrder,
          "readingOrder",
          node.attributes.readingOrder === "2" ? "rtl" : "ltr"
        );
        this.model = valid ? model : null;
      }
      parseText() {
      }
      parseClose() {
        return false;
      }
    };
    module2.exports = AlignmentXform;
  }
});

// ../../../node_modules/exceljs/lib/xlsx/xform/style/protection-xform.js
var require_protection_xform = __commonJS({
  "../../../node_modules/exceljs/lib/xlsx/xform/style/protection-xform.js"(exports2, module2) {
    var BaseXform = require_base_xform();
    var validation = {
      boolean(value, dflt) {
        if (value === void 0) {
          return dflt;
        }
        return value;
      }
    };
    var ProtectionXform = class extends BaseXform {
      get tag() {
        return "protection";
      }
      render(xmlStream, model) {
        xmlStream.addRollback();
        xmlStream.openNode("protection");
        let isValid = false;
        function add(name, value) {
          if (value !== void 0) {
            xmlStream.addAttribute(name, value);
            isValid = true;
          }
        }
        add("locked", validation.boolean(model.locked, true) ? void 0 : "0");
        add("hidden", validation.boolean(model.hidden, false) ? "1" : void 0);
        xmlStream.closeNode();
        if (isValid) {
          xmlStream.commit();
        } else {
          xmlStream.rollback();
        }
      }
      parseOpen(node) {
        const model = {
          locked: !(node.attributes.locked === "0"),
          hidden: node.attributes.hidden === "1"
        };
        const isSignificant = !model.locked || model.hidden;
        this.model = isSignificant ? model : null;
      }
      parseText() {
      }
      parseClose() {
        return false;
      }
    };
    module2.exports = ProtectionXform;
  }
});

// ../../../node_modules/exceljs/lib/xlsx/xform/style/style-xform.js
var require_style_xform = __commonJS({
  "../../../node_modules/exceljs/lib/xlsx/xform/style/style-xform.js"(exports2, module2) {
    var BaseXform = require_base_xform();
    var AlignmentXform = require_alignment_xform();
    var ProtectionXform = require_protection_xform();
    var StyleXform = class extends BaseXform {
      constructor(options) {
        super();
        this.xfId = !!(options && options.xfId);
        this.map = {
          alignment: new AlignmentXform(),
          protection: new ProtectionXform()
        };
      }
      get tag() {
        return "xf";
      }
      render(xmlStream, model) {
        xmlStream.openNode("xf", {
          numFmtId: model.numFmtId || 0,
          fontId: model.fontId || 0,
          fillId: model.fillId || 0,
          borderId: model.borderId || 0
        });
        if (this.xfId) {
          xmlStream.addAttribute("xfId", model.xfId || 0);
        }
        if (model.numFmtId) {
          xmlStream.addAttribute("applyNumberFormat", "1");
        }
        if (model.fontId) {
          xmlStream.addAttribute("applyFont", "1");
        }
        if (model.fillId) {
          xmlStream.addAttribute("applyFill", "1");
        }
        if (model.borderId) {
          xmlStream.addAttribute("applyBorder", "1");
        }
        if (model.alignment) {
          xmlStream.addAttribute("applyAlignment", "1");
        }
        if (model.protection) {
          xmlStream.addAttribute("applyProtection", "1");
        }
        if (model.alignment) {
          this.map.alignment.render(xmlStream, model.alignment);
        }
        if (model.protection) {
          this.map.protection.render(xmlStream, model.protection);
        }
        xmlStream.closeNode();
      }
      parseOpen(node) {
        if (this.parser) {
          this.parser.parseOpen(node);
          return true;
        }
        switch (node.name) {
          case "xf":
            this.model = {
              numFmtId: parseInt(node.attributes.numFmtId, 10),
              fontId: parseInt(node.attributes.fontId, 10),
              fillId: parseInt(node.attributes.fillId, 10),
              borderId: parseInt(node.attributes.borderId, 10)
            };
            if (this.xfId) {
              this.model.xfId = parseInt(node.attributes.xfId, 10);
            }
            return true;
          case "alignment":
            this.parser = this.map.alignment;
            this.parser.parseOpen(node);
            return true;
          case "protection":
            this.parser = this.map.protection;
            this.parser.parseOpen(node);
            return true;
          default:
            return false;
        }
      }
      parseText(text) {
        if (this.parser) {
          this.parser.parseText(text);
        }
      }
      parseClose(name) {
        if (this.parser) {
          if (!this.parser.parseClose(name)) {
            if (this.map.protection === this.parser) {
              this.model.protection = this.parser.model;
            } else {
              this.model.alignment = this.parser.model;
            }
            this.parser = void 0;
          }
          return true;
        }
        return name !== "xf";
      }
    };
    module2.exports = StyleXform;
  }
});

// ../../../node_modules/exceljs/lib/xlsx/xform/style/dxf-xform.js
var require_dxf_xform = __commonJS({
  "../../../node_modules/exceljs/lib/xlsx/xform/style/dxf-xform.js"(exports2, module2) {
    var BaseXform = require_base_xform();
    var AlignmentXform = require_alignment_xform();
    var BorderXform = require_border_xform();
    var FillXform = require_fill_xform();
    var FontXform = require_font_xform();
    var NumFmtXform = require_numfmt_xform();
    var ProtectionXform = require_protection_xform();
    var DxfXform = class extends BaseXform {
      constructor() {
        super();
        this.map = {
          alignment: new AlignmentXform(),
          border: new BorderXform(),
          fill: new FillXform(),
          font: new FontXform(),
          numFmt: new NumFmtXform(),
          protection: new ProtectionXform()
        };
      }
      get tag() {
        return "dxf";
      }
      // how do we generate dxfid?
      render(xmlStream, model) {
        xmlStream.openNode(this.tag);
        if (model.font) {
          this.map.font.render(xmlStream, model.font);
        }
        if (model.numFmt && model.numFmtId) {
          const numFmtModel = { id: model.numFmtId, formatCode: model.numFmt };
          this.map.numFmt.render(xmlStream, numFmtModel);
        }
        if (model.fill) {
          this.map.fill.render(xmlStream, model.fill);
        }
        if (model.alignment) {
          this.map.alignment.render(xmlStream, model.alignment);
        }
        if (model.border) {
          this.map.border.render(xmlStream, model.border);
        }
        if (model.protection) {
          this.map.protection.render(xmlStream, model.protection);
        }
        xmlStream.closeNode();
      }
      parseOpen(node) {
        if (this.parser) {
          this.parser.parseOpen(node);
          return true;
        }
        switch (node.name) {
          case this.tag:
            this.reset();
            return true;
          default:
            this.parser = this.map[node.name];
            if (this.parser) {
              this.parser.parseOpen(node);
            }
            return true;
        }
      }
      parseText(text) {
        if (this.parser) {
          this.parser.parseText(text);
        }
      }
      parseClose(name) {
        if (this.parser) {
          if (!this.parser.parseClose(name)) {
            this.parser = void 0;
          }
          return true;
        }
        if (name === this.tag) {
          this.model = {
            alignment: this.map.alignment.model,
            border: this.map.border.model,
            fill: this.map.fill.model,
            font: this.map.font.model,
            numFmt: this.map.numFmt.model,
            protection: this.map.protection.model
          };
          return false;
        }
        return true;
      }
    };
    module2.exports = DxfXform;
  }
});

// ../../../node_modules/exceljs/lib/xlsx/xform/style/styles-xform.js
var require_styles_xform = __commonJS({
  "../../../node_modules/exceljs/lib/xlsx/xform/style/styles-xform.js"(exports2, module2) {
    var Enums = require_enums();
    var XmlStream = require_xml_stream();
    var BaseXform = require_base_xform();
    var StaticXform = require_static_xform();
    var ListXform = require_list_xform();
    var FontXform = require_font_xform();
    var FillXform = require_fill_xform();
    var BorderXform = require_border_xform();
    var NumFmtXform = require_numfmt_xform();
    var StyleXform = require_style_xform();
    var DxfXform = require_dxf_xform();
    var NUMFMT_BASE = 164;
    var StylesXform = class _StylesXform extends BaseXform {
      constructor(initialise) {
        super();
        this.map = {
          numFmts: new ListXform({ tag: "numFmts", count: true, childXform: new NumFmtXform() }),
          fonts: new ListXform({
            tag: "fonts",
            count: true,
            childXform: new FontXform(),
            $: { "x14ac:knownFonts": 1 }
          }),
          fills: new ListXform({ tag: "fills", count: true, childXform: new FillXform() }),
          borders: new ListXform({ tag: "borders", count: true, childXform: new BorderXform() }),
          cellStyleXfs: new ListXform({ tag: "cellStyleXfs", count: true, childXform: new StyleXform() }),
          cellXfs: new ListXform({
            tag: "cellXfs",
            count: true,
            childXform: new StyleXform({ xfId: true })
          }),
          dxfs: new ListXform({ tag: "dxfs", always: true, count: true, childXform: new DxfXform() }),
          // for style manager
          numFmt: new NumFmtXform(),
          font: new FontXform(),
          fill: new FillXform(),
          border: new BorderXform(),
          style: new StyleXform({ xfId: true }),
          cellStyles: _StylesXform.STATIC_XFORMS.cellStyles,
          tableStyles: _StylesXform.STATIC_XFORMS.tableStyles,
          extLst: _StylesXform.STATIC_XFORMS.extLst
        };
        if (initialise) {
          this.init();
        }
      }
      initIndex() {
        this.index = {
          style: {},
          numFmt: {},
          numFmtNextId: 164,
          // start custom format ids here
          font: {},
          border: {},
          fill: {}
        };
      }
      init() {
        this.model = {
          styles: [],
          numFmts: [],
          fonts: [],
          borders: [],
          fills: [],
          dxfs: []
        };
        this.initIndex();
        this._addBorder({});
        this._addStyle({ numFmtId: 0, fontId: 0, fillId: 0, borderId: 0, xfId: 0 });
        this._addFill({ type: "pattern", pattern: "none" });
        this._addFill({ type: "pattern", pattern: "gray125" });
        this.weakMap = /* @__PURE__ */ new WeakMap();
      }
      render(xmlStream, model) {
        model = model || this.model;
        xmlStream.openXml(XmlStream.StdDocAttributes);
        xmlStream.openNode("styleSheet", _StylesXform.STYLESHEET_ATTRIBUTES);
        if (this.index) {
          if (model.numFmts && model.numFmts.length) {
            xmlStream.openNode("numFmts", { count: model.numFmts.length });
            model.numFmts.forEach((numFmtXml) => {
              xmlStream.writeXml(numFmtXml);
            });
            xmlStream.closeNode();
          }
          if (!model.fonts.length) {
            this._addFont({ size: 11, color: { theme: 1 }, name: "Calibri", family: 2, scheme: "minor" });
          }
          xmlStream.openNode("fonts", { count: model.fonts.length, "x14ac:knownFonts": 1 });
          model.fonts.forEach((fontXml) => {
            xmlStream.writeXml(fontXml);
          });
          xmlStream.closeNode();
          xmlStream.openNode("fills", { count: model.fills.length });
          model.fills.forEach((fillXml) => {
            xmlStream.writeXml(fillXml);
          });
          xmlStream.closeNode();
          xmlStream.openNode("borders", { count: model.borders.length });
          model.borders.forEach((borderXml) => {
            xmlStream.writeXml(borderXml);
          });
          xmlStream.closeNode();
          this.map.cellStyleXfs.render(xmlStream, [{ numFmtId: 0, fontId: 0, fillId: 0, borderId: 0, xfId: 0 }]);
          xmlStream.openNode("cellXfs", { count: model.styles.length });
          model.styles.forEach((styleXml) => {
            xmlStream.writeXml(styleXml);
          });
          xmlStream.closeNode();
        } else {
          this.map.numFmts.render(xmlStream, model.numFmts);
          this.map.fonts.render(xmlStream, model.fonts);
          this.map.fills.render(xmlStream, model.fills);
          this.map.borders.render(xmlStream, model.borders);
          this.map.cellStyleXfs.render(xmlStream, [{ numFmtId: 0, fontId: 0, fillId: 0, borderId: 0, xfId: 0 }]);
          this.map.cellXfs.render(xmlStream, model.styles);
        }
        _StylesXform.STATIC_XFORMS.cellStyles.render(xmlStream);
        this.map.dxfs.render(xmlStream, model.dxfs);
        _StylesXform.STATIC_XFORMS.tableStyles.render(xmlStream);
        _StylesXform.STATIC_XFORMS.extLst.render(xmlStream);
        xmlStream.closeNode();
      }
      parseOpen(node) {
        if (this.parser) {
          this.parser.parseOpen(node);
          return true;
        }
        switch (node.name) {
          case "styleSheet":
            this.initIndex();
            return true;
          default:
            this.parser = this.map[node.name];
            if (this.parser) {
              this.parser.parseOpen(node);
            }
            return true;
        }
      }
      parseText(text) {
        if (this.parser) {
          this.parser.parseText(text);
        }
      }
      parseClose(name) {
        if (this.parser) {
          if (!this.parser.parseClose(name)) {
            this.parser = void 0;
          }
          return true;
        }
        switch (name) {
          case "styleSheet": {
            this.model = {};
            const add = (propName, xform) => {
              if (xform.model && xform.model.length) {
                this.model[propName] = xform.model;
              }
            };
            add("numFmts", this.map.numFmts);
            add("fonts", this.map.fonts);
            add("fills", this.map.fills);
            add("borders", this.map.borders);
            add("styles", this.map.cellXfs);
            add("dxfs", this.map.dxfs);
            this.index = {
              model: [],
              numFmt: []
            };
            if (this.model.numFmts) {
              const numFmtIndex = this.index.numFmt;
              this.model.numFmts.forEach((numFmt) => {
                numFmtIndex[numFmt.id] = numFmt.formatCode;
              });
            }
            return false;
          }
          default:
            return true;
        }
      }
      // add a cell's style model to the collection
      // each style property is processed and cross-referenced, etc.
      // the styleId is returned. Note: cellType is used when numFmt not defined
      addStyleModel(model, cellType) {
        if (!model) {
          return 0;
        }
        if (!this.model.fonts.length) {
          this._addFont({ size: 11, color: { theme: 1 }, name: "Calibri", family: 2, scheme: "minor" });
        }
        if (this.weakMap && this.weakMap.has(model)) {
          return this.weakMap.get(model);
        }
        const style = {};
        cellType = cellType || Enums.ValueType.Number;
        if (model.numFmt) {
          style.numFmtId = this._addNumFmtStr(model.numFmt);
        } else {
          switch (cellType) {
            case Enums.ValueType.Number:
              style.numFmtId = this._addNumFmtStr("General");
              break;
            case Enums.ValueType.Date:
              style.numFmtId = this._addNumFmtStr("mm-dd-yy");
              break;
            default:
              break;
          }
        }
        if (model.font) {
          style.fontId = this._addFont(model.font);
        }
        if (model.border) {
          style.borderId = this._addBorder(model.border);
        }
        if (model.fill) {
          style.fillId = this._addFill(model.fill);
        }
        if (model.alignment) {
          style.alignment = model.alignment;
        }
        if (model.protection) {
          style.protection = model.protection;
        }
        const styleId = this._addStyle(style);
        if (this.weakMap) {
          this.weakMap.set(model, styleId);
        }
        return styleId;
      }
      // given a styleId (i.e. s="n"), get the cell's style model
      // objects are shared where possible.
      getStyleModel(id) {
        const style = this.model.styles[id];
        if (!style)
          return null;
        let model = this.index.model[id];
        if (model)
          return model;
        model = this.index.model[id] = {};
        if (style.numFmtId) {
          const numFmt = this.index.numFmt[style.numFmtId] || NumFmtXform.getDefaultFmtCode(style.numFmtId);
          if (numFmt) {
            model.numFmt = numFmt;
          }
        }
        function addStyle(name, group, styleId) {
          if (styleId || styleId === 0) {
            const part = group[styleId];
            if (part) {
              model[name] = part;
            }
          }
        }
        addStyle("font", this.model.fonts, style.fontId);
        addStyle("border", this.model.borders, style.borderId);
        addStyle("fill", this.model.fills, style.fillId);
        if (style.alignment) {
          model.alignment = style.alignment;
        }
        if (style.protection) {
          model.protection = style.protection;
        }
        return model;
      }
      addDxfStyle(style) {
        if (style.numFmt) {
          style.numFmtId = this._addNumFmtStr(style.numFmt);
        }
        this.model.dxfs.push(style);
        return this.model.dxfs.length - 1;
      }
      getDxfStyle(id) {
        return this.model.dxfs[id];
      }
      // =========================================================================
      // Private Interface
      _addStyle(style) {
        const xml = this.map.style.toXml(style);
        let index = this.index.style[xml];
        if (index === void 0) {
          index = this.index.style[xml] = this.model.styles.length;
          this.model.styles.push(xml);
        }
        return index;
      }
      // =========================================================================
      // Number Formats
      _addNumFmtStr(formatCode) {
        let index = NumFmtXform.getDefaultFmtId(formatCode);
        if (index !== void 0)
          return index;
        index = this.index.numFmt[formatCode];
        if (index !== void 0)
          return index;
        index = this.index.numFmt[formatCode] = NUMFMT_BASE + this.model.numFmts.length;
        const xml = this.map.numFmt.toXml({ id: index, formatCode });
        this.model.numFmts.push(xml);
        return index;
      }
      // =========================================================================
      // Fonts
      _addFont(font) {
        const xml = this.map.font.toXml(font);
        let index = this.index.font[xml];
        if (index === void 0) {
          index = this.index.font[xml] = this.model.fonts.length;
          this.model.fonts.push(xml);
        }
        return index;
      }
      // =========================================================================
      // Borders
      _addBorder(border) {
        const xml = this.map.border.toXml(border);
        let index = this.index.border[xml];
        if (index === void 0) {
          index = this.index.border[xml] = this.model.borders.length;
          this.model.borders.push(xml);
        }
        return index;
      }
      // =========================================================================
      // Fills
      _addFill(fill) {
        const xml = this.map.fill.toXml(fill);
        let index = this.index.fill[xml];
        if (index === void 0) {
          index = this.index.fill[xml] = this.model.fills.length;
          this.model.fills.push(xml);
        }
        return index;
      }
      // =========================================================================
    };
    StylesXform.STYLESHEET_ATTRIBUTES = {
      xmlns: "http://schemas.openxmlformats.org/spreadsheetml/2006/main",
      "xmlns:mc": "http://schemas.openxmlformats.org/markup-compatibility/2006",
      "mc:Ignorable": "x14ac x16r2",
      "xmlns:x14ac": "http://schemas.microsoft.com/office/spreadsheetml/2009/9/ac",
      "xmlns:x16r2": "http://schemas.microsoft.com/office/spreadsheetml/2015/02/main"
    };
    StylesXform.STATIC_XFORMS = {
      cellStyles: new StaticXform({
        tag: "cellStyles",
        $: { count: 1 },
        c: [{ tag: "cellStyle", $: { name: "Normal", xfId: 0, builtinId: 0 } }]
      }),
      dxfs: new StaticXform({ tag: "dxfs", $: { count: 0 } }),
      tableStyles: new StaticXform({
        tag: "tableStyles",
        $: { count: 0, defaultTableStyle: "TableStyleMedium2", defaultPivotStyle: "PivotStyleLight16" }
      }),
      extLst: new StaticXform({
        tag: "extLst",
        c: [
          {
            tag: "ext",
            $: {
              uri: "{EB79DEF2-80B8-43e5-95BD-54CBDDF9020C}",
              "xmlns:x14": "http://schemas.microsoft.com/office/spreadsheetml/2009/9/main"
            },
            c: [{ tag: "x14:slicerStyles", $: { defaultSlicerStyle: "SlicerStyleLight1" } }]
          },
          {
            tag: "ext",
            $: {
              uri: "{9260A510-F301-46a8-8635-F512D64BE5F5}",
              "xmlns:x15": "http://schemas.microsoft.com/office/spreadsheetml/2010/11/main"
            },
            c: [{ tag: "x15:timelineStyles", $: { defaultTimelineStyle: "TimeSlicerStyleLight1" } }]
          }
        ]
      })
    };
    var StylesXformMock = class extends StylesXform {
      constructor() {
        super();
        this.model = {
          styles: [{ numFmtId: 0, fontId: 0, fillId: 0, borderId: 0, xfId: 0 }],
          numFmts: [],
          fonts: [{ size: 11, color: { theme: 1 }, name: "Calibri", family: 2, scheme: "minor" }],
          borders: [{}],
          fills: [
            { type: "pattern", pattern: "none" },
            { type: "pattern", pattern: "gray125" }
          ]
        };
      }
      // =========================================================================
      // Style Manager Interface
      // override normal behaviour - consume and dispose
      parseStream(stream) {
        stream.autodrain();
        return Promise.resolve();
      }
      // add a cell's style model to the collection
      // each style property is processed and cross-referenced, etc.
      // the styleId is returned. Note: cellType is used when numFmt not defined
      addStyleModel(model, cellType) {
        switch (cellType) {
          case Enums.ValueType.Date:
            return this.dateStyleId;
          default:
            return 0;
        }
      }
      get dateStyleId() {
        if (!this._dateStyleId) {
          const dateStyle = {
            numFmtId: NumFmtXform.getDefaultFmtId("mm-dd-yy")
          };
          this._dateStyleId = this.model.styles.length;
          this.model.styles.push(dateStyle);
        }
        return this._dateStyleId;
      }
      // given a styleId (i.e. s="n"), get the cell's style model
      // objects are shared where possible.
      getStyleModel() {
        return {};
      }
    };
    StylesXform.Mock = StylesXformMock;
    module2.exports = StylesXform;
  }
});

// ../../../node_modules/exceljs/lib/xlsx/xform/simple/date-xform.js
var require_date_xform = __commonJS({
  "../../../node_modules/exceljs/lib/xlsx/xform/simple/date-xform.js"(exports2, module2) {
    var BaseXform = require_base_xform();
    var DateXform = class extends BaseXform {
      constructor(options) {
        super();
        this.tag = options.tag;
        this.attr = options.attr;
        this.attrs = options.attrs;
        this._format = options.format || function(dt) {
          try {
            if (Number.isNaN(dt.getTime()))
              return "";
            return dt.toISOString();
          } catch (e) {
            return "";
          }
        };
        this._parse = options.parse || function(str) {
          return new Date(str);
        };
      }
      render(xmlStream, model) {
        if (model) {
          xmlStream.openNode(this.tag);
          if (this.attrs) {
            xmlStream.addAttributes(this.attrs);
          }
          if (this.attr) {
            xmlStream.addAttribute(this.attr, this._format(model));
          } else {
            xmlStream.writeText(this._format(model));
          }
          xmlStream.closeNode();
        }
      }
      parseOpen(node) {
        if (node.name === this.tag) {
          if (this.attr) {
            this.model = this._parse(node.attributes[this.attr]);
          } else {
            this.text = [];
          }
        }
      }
      parseText(text) {
        if (!this.attr) {
          this.text.push(text);
        }
      }
      parseClose() {
        if (!this.attr) {
          this.model = this._parse(this.text.join(""));
        }
        return false;
      }
    };
    module2.exports = DateXform;
  }
});

// ../../../node_modules/exceljs/lib/xlsx/xform/core/core-xform.js
var require_core_xform = __commonJS({
  "../../../node_modules/exceljs/lib/xlsx/xform/core/core-xform.js"(exports2, module2) {
    var XmlStream = require_xml_stream();
    var BaseXform = require_base_xform();
    var DateXform = require_date_xform();
    var StringXform = require_string_xform();
    var IntegerXform = require_integer_xform();
    var CoreXform = class _CoreXform extends BaseXform {
      constructor() {
        super();
        this.map = {
          "dc:creator": new StringXform({ tag: "dc:creator" }),
          "dc:title": new StringXform({ tag: "dc:title" }),
          "dc:subject": new StringXform({ tag: "dc:subject" }),
          "dc:description": new StringXform({ tag: "dc:description" }),
          "dc:identifier": new StringXform({ tag: "dc:identifier" }),
          "dc:language": new StringXform({ tag: "dc:language" }),
          "cp:keywords": new StringXform({ tag: "cp:keywords" }),
          "cp:category": new StringXform({ tag: "cp:category" }),
          "cp:lastModifiedBy": new StringXform({ tag: "cp:lastModifiedBy" }),
          "cp:lastPrinted": new DateXform({ tag: "cp:lastPrinted", format: _CoreXform.DateFormat }),
          "cp:revision": new IntegerXform({ tag: "cp:revision" }),
          "cp:version": new StringXform({ tag: "cp:version" }),
          "cp:contentStatus": new StringXform({ tag: "cp:contentStatus" }),
          "cp:contentType": new StringXform({ tag: "cp:contentType" }),
          "dcterms:created": new DateXform({
            tag: "dcterms:created",
            attrs: _CoreXform.DateAttrs,
            format: _CoreXform.DateFormat
          }),
          "dcterms:modified": new DateXform({
            tag: "dcterms:modified",
            attrs: _CoreXform.DateAttrs,
            format: _CoreXform.DateFormat
          })
        };
      }
      render(xmlStream, model) {
        xmlStream.openXml(XmlStream.StdDocAttributes);
        xmlStream.openNode("cp:coreProperties", _CoreXform.CORE_PROPERTY_ATTRIBUTES);
        this.map["dc:creator"].render(xmlStream, model.creator);
        this.map["dc:title"].render(xmlStream, model.title);
        this.map["dc:subject"].render(xmlStream, model.subject);
        this.map["dc:description"].render(xmlStream, model.description);
        this.map["dc:identifier"].render(xmlStream, model.identifier);
        this.map["dc:language"].render(xmlStream, model.language);
        this.map["cp:keywords"].render(xmlStream, model.keywords);
        this.map["cp:category"].render(xmlStream, model.category);
        this.map["cp:lastModifiedBy"].render(xmlStream, model.lastModifiedBy);
        this.map["cp:lastPrinted"].render(xmlStream, model.lastPrinted);
        this.map["cp:revision"].render(xmlStream, model.revision);
        this.map["cp:version"].render(xmlStream, model.version);
        this.map["cp:contentStatus"].render(xmlStream, model.contentStatus);
        this.map["cp:contentType"].render(xmlStream, model.contentType);
        this.map["dcterms:created"].render(xmlStream, model.created);
        this.map["dcterms:modified"].render(xmlStream, model.modified);
        xmlStream.closeNode();
      }
      parseOpen(node) {
        if (this.parser) {
          this.parser.parseOpen(node);
          return true;
        }
        switch (node.name) {
          case "cp:coreProperties":
          case "coreProperties":
            return true;
          default:
            this.parser = this.map[node.name];
            if (this.parser) {
              this.parser.parseOpen(node);
              return true;
            }
            throw new Error(`Unexpected xml node in parseOpen: ${JSON.stringify(node)}`);
        }
      }
      parseText(text) {
        if (this.parser) {
          this.parser.parseText(text);
        }
      }
      parseClose(name) {
        if (this.parser) {
          if (!this.parser.parseClose(name)) {
            this.parser = void 0;
          }
          return true;
        }
        switch (name) {
          case "cp:coreProperties":
          case "coreProperties":
            this.model = {
              creator: this.map["dc:creator"].model,
              title: this.map["dc:title"].model,
              subject: this.map["dc:subject"].model,
              description: this.map["dc:description"].model,
              identifier: this.map["dc:identifier"].model,
              language: this.map["dc:language"].model,
              keywords: this.map["cp:keywords"].model,
              category: this.map["cp:category"].model,
              lastModifiedBy: this.map["cp:lastModifiedBy"].model,
              lastPrinted: this.map["cp:lastPrinted"].model,
              revision: this.map["cp:revision"].model,
              contentStatus: this.map["cp:contentStatus"].model,
              contentType: this.map["cp:contentType"].model,
              created: this.map["dcterms:created"].model,
              modified: this.map["dcterms:modified"].model
            };
            return false;
          default:
            throw new Error(`Unexpected xml node in parseClose: ${name}`);
        }
      }
    };
    CoreXform.DateFormat = function(dt) {
      return dt.toISOString().replace(/[.]\d{3}/, "");
    };
    CoreXform.DateAttrs = { "xsi:type": "dcterms:W3CDTF" };
    CoreXform.CORE_PROPERTY_ATTRIBUTES = {
      "xmlns:cp": "http://schemas.openxmlformats.org/package/2006/metadata/core-properties",
      "xmlns:dc": "http://purl.org/dc/elements/1.1/",
      "xmlns:dcterms": "http://purl.org/dc/terms/",
      "xmlns:dcmitype": "http://purl.org/dc/dcmitype/",
      "xmlns:xsi": "http://www.w3.org/2001/XMLSchema-instance"
    };
    module2.exports = CoreXform;
  }
});

// ../../../node_modules/exceljs/lib/xlsx/xform/strings/text-xform.js
var require_text_xform = __commonJS({
  "../../../node_modules/exceljs/lib/xlsx/xform/strings/text-xform.js"(exports2, module2) {
    var BaseXform = require_base_xform();
    var TextXform = class extends BaseXform {
      get tag() {
        return "t";
      }
      render(xmlStream, model) {
        xmlStream.openNode("t");
        if (/^\s|\n|\s$/.test(model)) {
          xmlStream.addAttribute("xml:space", "preserve");
        }
        xmlStream.writeText(model);
        xmlStream.closeNode();
      }
      get model() {
        return this._text.join("").replace(/_x([0-9A-F]{4})_/g, ($0, $1) => String.fromCharCode(parseInt($1, 16)));
      }
      parseOpen(node) {
        switch (node.name) {
          case "t":
            this._text = [];
            return true;
          default:
            return false;
        }
      }
      parseText(text) {
        this._text.push(text);
      }
      parseClose() {
        return false;
      }
    };
    module2.exports = TextXform;
  }
});

// ../../../node_modules/exceljs/lib/xlsx/xform/strings/rich-text-xform.js
var require_rich_text_xform = __commonJS({
  "../../../node_modules/exceljs/lib/xlsx/xform/strings/rich-text-xform.js"(exports2, module2) {
    var TextXform = require_text_xform();
    var FontXform = require_font_xform();
    var BaseXform = require_base_xform();
    var RichTextXform = class _RichTextXform extends BaseXform {
      constructor(model) {
        super();
        this.model = model;
      }
      get tag() {
        return "r";
      }
      get textXform() {
        return this._textXform || (this._textXform = new TextXform());
      }
      get fontXform() {
        return this._fontXform || (this._fontXform = new FontXform(_RichTextXform.FONT_OPTIONS));
      }
      render(xmlStream, model) {
        model = model || this.model;
        xmlStream.openNode("r");
        if (model.font) {
          this.fontXform.render(xmlStream, model.font);
        }
        this.textXform.render(xmlStream, model.text);
        xmlStream.closeNode();
      }
      parseOpen(node) {
        if (this.parser) {
          this.parser.parseOpen(node);
          return true;
        }
        switch (node.name) {
          case "r":
            this.model = {};
            return true;
          case "t":
            this.parser = this.textXform;
            this.parser.parseOpen(node);
            return true;
          case "rPr":
            this.parser = this.fontXform;
            this.parser.parseOpen(node);
            return true;
          default:
            return false;
        }
      }
      parseText(text) {
        if (this.parser) {
          this.parser.parseText(text);
        }
      }
      parseClose(name) {
        switch (name) {
          case "r":
            return false;
          case "t":
            this.model.text = this.parser.model;
            this.parser = void 0;
            return true;
          case "rPr":
            this.model.font = this.parser.model;
            this.parser = void 0;
            return true;
          default:
            if (this.parser) {
              this.parser.parseClose(name);
            }
            return true;
        }
      }
    };
    RichTextXform.FONT_OPTIONS = {
      tagName: "rPr",
      fontNameTag: "rFont"
    };
    module2.exports = RichTextXform;
  }
});

// ../../../node_modules/exceljs/lib/xlsx/xform/strings/phonetic-text-xform.js
var require_phonetic_text_xform = __commonJS({
  "../../../node_modules/exceljs/lib/xlsx/xform/strings/phonetic-text-xform.js"(exports2, module2) {
    var TextXform = require_text_xform();
    var RichTextXform = require_rich_text_xform();
    var BaseXform = require_base_xform();
    var PhoneticTextXform = class extends BaseXform {
      constructor() {
        super();
        this.map = {
          r: new RichTextXform(),
          t: new TextXform()
        };
      }
      get tag() {
        return "rPh";
      }
      render(xmlStream, model) {
        xmlStream.openNode(this.tag, {
          sb: model.sb || 0,
          eb: model.eb || 0
        });
        if (model && model.hasOwnProperty("richText") && model.richText) {
          const { r } = this.map;
          model.richText.forEach((text) => {
            r.render(xmlStream, text);
          });
        } else if (model) {
          this.map.t.render(xmlStream, model.text);
        }
        xmlStream.closeNode();
      }
      parseOpen(node) {
        const { name } = node;
        if (this.parser) {
          this.parser.parseOpen(node);
          return true;
        }
        if (name === this.tag) {
          this.model = {
            sb: parseInt(node.attributes.sb, 10),
            eb: parseInt(node.attributes.eb, 10)
          };
          return true;
        }
        this.parser = this.map[name];
        if (this.parser) {
          this.parser.parseOpen(node);
          return true;
        }
        return false;
      }
      parseText(text) {
        if (this.parser) {
          this.parser.parseText(text);
        }
      }
      parseClose(name) {
        if (this.parser) {
          if (!this.parser.parseClose(name)) {
            switch (name) {
              case "r": {
                let rt = this.model.richText;
                if (!rt) {
                  rt = this.model.richText = [];
                }
                rt.push(this.parser.model);
                break;
              }
              case "t":
                this.model.text = this.parser.model;
                break;
              default:
                break;
            }
            this.parser = void 0;
          }
          return true;
        }
        switch (name) {
          case this.tag:
            return false;
          default:
            return true;
        }
      }
    };
    module2.exports = PhoneticTextXform;
  }
});

// ../../../node_modules/exceljs/lib/xlsx/xform/strings/shared-string-xform.js
var require_shared_string_xform = __commonJS({
  "../../../node_modules/exceljs/lib/xlsx/xform/strings/shared-string-xform.js"(exports2, module2) {
    var TextXform = require_text_xform();
    var RichTextXform = require_rich_text_xform();
    var PhoneticTextXform = require_phonetic_text_xform();
    var BaseXform = require_base_xform();
    var SharedStringXform = class extends BaseXform {
      constructor(model) {
        super();
        this.model = model;
        this.map = {
          r: new RichTextXform(),
          t: new TextXform(),
          rPh: new PhoneticTextXform()
        };
      }
      get tag() {
        return "si";
      }
      render(xmlStream, model) {
        xmlStream.openNode(this.tag);
        if (model && model.hasOwnProperty("richText") && model.richText) {
          if (model.richText.length) {
            model.richText.forEach((text) => {
              this.map.r.render(xmlStream, text);
            });
          } else {
            this.map.t.render(xmlStream, "");
          }
        } else if (model !== void 0 && model !== null) {
          this.map.t.render(xmlStream, model);
        }
        xmlStream.closeNode();
      }
      parseOpen(node) {
        const { name } = node;
        if (this.parser) {
          this.parser.parseOpen(node);
          return true;
        }
        if (name === this.tag) {
          this.model = {};
          return true;
        }
        this.parser = this.map[name];
        if (this.parser) {
          this.parser.parseOpen(node);
          return true;
        }
        return false;
      }
      parseText(text) {
        if (this.parser) {
          this.parser.parseText(text);
        }
      }
      parseClose(name) {
        if (this.parser) {
          if (!this.parser.parseClose(name)) {
            switch (name) {
              case "r": {
                let rt = this.model.richText;
                if (!rt) {
                  rt = this.model.richText = [];
                }
                rt.push(this.parser.model);
                break;
              }
              case "t":
                this.model = this.parser.model;
                break;
              default:
                break;
            }
            this.parser = void 0;
          }
          return true;
        }
        switch (name) {
          case this.tag:
            return false;
          default:
            return true;
        }
      }
    };
    module2.exports = SharedStringXform;
  }
});

// ../../../node_modules/exceljs/lib/xlsx/xform/strings/shared-strings-xform.js
var require_shared_strings_xform = __commonJS({
  "../../../node_modules/exceljs/lib/xlsx/xform/strings/shared-strings-xform.js"(exports2, module2) {
    var XmlStream = require_xml_stream();
    var BaseXform = require_base_xform();
    var SharedStringXform = require_shared_string_xform();
    var SharedStringsXform = class extends BaseXform {
      constructor(model) {
        super();
        this.model = model || {
          values: [],
          count: 0
        };
        this.hash = /* @__PURE__ */ Object.create(null);
        this.rich = /* @__PURE__ */ Object.create(null);
      }
      get sharedStringXform() {
        return this._sharedStringXform || (this._sharedStringXform = new SharedStringXform());
      }
      get values() {
        return this.model.values;
      }
      get uniqueCount() {
        return this.model.values.length;
      }
      get count() {
        return this.model.count;
      }
      getString(index) {
        return this.model.values[index];
      }
      add(value) {
        return value.richText ? this.addRichText(value) : this.addText(value);
      }
      addText(value) {
        let index = this.hash[value];
        if (index === void 0) {
          index = this.hash[value] = this.model.values.length;
          this.model.values.push(value);
        }
        this.model.count++;
        return index;
      }
      addRichText(value) {
        const xml = this.sharedStringXform.toXml(value);
        let index = this.rich[xml];
        if (index === void 0) {
          index = this.rich[xml] = this.model.values.length;
          this.model.values.push(value);
        }
        this.model.count++;
        return index;
      }
      // <?xml version="1.0" encoding="UTF-8" standalone="yes"?>
      // <sst xmlns="http://schemas.openxmlformats.org/spreadsheetml/2006/main" count="<%=totalRefs%>" uniqueCount="<%=count%>">
      //   <si><t><%=text%></t></si>
      //   <si><r><rPr></rPr><t></t></r></si>
      // </sst>
      render(xmlStream, model) {
        model = model || this._values;
        xmlStream.openXml(XmlStream.StdDocAttributes);
        xmlStream.openNode("sst", {
          xmlns: "http://schemas.openxmlformats.org/spreadsheetml/2006/main",
          count: model.count,
          uniqueCount: model.values.length
        });
        const sx = this.sharedStringXform;
        model.values.forEach((sharedString) => {
          sx.render(xmlStream, sharedString);
        });
        xmlStream.closeNode();
      }
      parseOpen(node) {
        if (this.parser) {
          this.parser.parseOpen(node);
          return true;
        }
        switch (node.name) {
          case "sst":
            return true;
          case "si":
            this.parser = this.sharedStringXform;
            this.parser.parseOpen(node);
            return true;
          default:
            throw new Error(`Unexpected xml node in parseOpen: ${JSON.stringify(node)}`);
        }
      }
      parseText(text) {
        if (this.parser) {
          this.parser.parseText(text);
        }
      }
      parseClose(name) {
        if (this.parser) {
          if (!this.parser.parseClose(name)) {
            this.model.values.push(this.parser.model);
            this.model.count++;
            this.parser = void 0;
          }
          return true;
        }
        switch (name) {
          case "sst":
            return false;
          default:
            throw new Error(`Unexpected xml node in parseClose: ${name}`);
        }
      }
    };
    module2.exports = SharedStringsXform;
  }
});

// ../../../node_modules/exceljs/lib/xlsx/xform/core/relationship-xform.js
var require_relationship_xform = __commonJS({
  "../../../node_modules/exceljs/lib/xlsx/xform/core/relationship-xform.js"(exports2, module2) {
    var BaseXform = require_base_xform();
    var RelationshipXform = class extends BaseXform {
      render(xmlStream, model) {
        xmlStream.leafNode("Relationship", model);
      }
      parseOpen(node) {
        switch (node.name) {
          case "Relationship":
            this.model = node.attributes;
            return true;
          default:
            return false;
        }
      }
      parseText() {
      }
      parseClose() {
        return false;
      }
    };
    module2.exports = RelationshipXform;
  }
});

// ../../../node_modules/exceljs/lib/xlsx/xform/core/relationships-xform.js
var require_relationships_xform = __commonJS({
  "../../../node_modules/exceljs/lib/xlsx/xform/core/relationships-xform.js"(exports2, module2) {
    var XmlStream = require_xml_stream();
    var BaseXform = require_base_xform();
    var RelationshipXform = require_relationship_xform();
    var RelationshipsXform = class _RelationshipsXform extends BaseXform {
      constructor() {
        super();
        this.map = {
          Relationship: new RelationshipXform()
        };
      }
      render(xmlStream, model) {
        model = model || this._values;
        xmlStream.openXml(XmlStream.StdDocAttributes);
        xmlStream.openNode("Relationships", _RelationshipsXform.RELATIONSHIPS_ATTRIBUTES);
        model.forEach((relationship) => {
          this.map.Relationship.render(xmlStream, relationship);
        });
        xmlStream.closeNode();
      }
      parseOpen(node) {
        if (this.parser) {
          this.parser.parseOpen(node);
          return true;
        }
        switch (node.name) {
          case "Relationships":
            this.model = [];
            return true;
          default:
            this.parser = this.map[node.name];
            if (this.parser) {
              this.parser.parseOpen(node);
              return true;
            }
            throw new Error(`Unexpected xml node in parseOpen: ${JSON.stringify(node)}`);
        }
      }
      parseText(text) {
        if (this.parser) {
          this.parser.parseText(text);
        }
      }
      parseClose(name) {
        if (this.parser) {
          if (!this.parser.parseClose(name)) {
            this.model.push(this.parser.model);
            this.parser = void 0;
          }
          return true;
        }
        switch (name) {
          case "Relationships":
            return false;
          default:
            throw new Error(`Unexpected xml node in parseClose: ${name}`);
        }
      }
    };
    RelationshipsXform.RELATIONSHIPS_ATTRIBUTES = {
      xmlns: "http://schemas.openxmlformats.org/package/2006/relationships"
    };
    module2.exports = RelationshipsXform;
  }
});

// ../../../node_modules/exceljs/lib/xlsx/xform/core/content-types-xform.js
var require_content_types_xform = __commonJS({
  "../../../node_modules/exceljs/lib/xlsx/xform/core/content-types-xform.js"(exports2, module2) {
    var XmlStream = require_xml_stream();
    var BaseXform = require_base_xform();
    var ContentTypesXform = class _ContentTypesXform extends BaseXform {
      render(xmlStream, model) {
        xmlStream.openXml(XmlStream.StdDocAttributes);
        xmlStream.openNode("Types", _ContentTypesXform.PROPERTY_ATTRIBUTES);
        const mediaHash = {};
        (model.media || []).forEach((medium) => {
          if (medium.type === "image") {
            const imageType = medium.extension;
            if (!mediaHash[imageType]) {
              mediaHash[imageType] = true;
              xmlStream.leafNode("Default", { Extension: imageType, ContentType: `image/${imageType}` });
            }
          }
        });
        xmlStream.leafNode("Default", {
          Extension: "rels",
          ContentType: "application/vnd.openxmlformats-package.relationships+xml"
        });
        xmlStream.leafNode("Default", { Extension: "xml", ContentType: "application/xml" });
        xmlStream.leafNode("Override", {
          PartName: "/xl/workbook.xml",
          ContentType: "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet.main+xml"
        });
        model.worksheets.forEach((worksheet) => {
          const name = `/xl/worksheets/sheet${worksheet.id}.xml`;
          xmlStream.leafNode("Override", {
            PartName: name,
            ContentType: "application/vnd.openxmlformats-officedocument.spreadsheetml.worksheet+xml"
          });
        });
        xmlStream.leafNode("Override", {
          PartName: "/xl/theme/theme1.xml",
          ContentType: "application/vnd.openxmlformats-officedocument.theme+xml"
        });
        xmlStream.leafNode("Override", {
          PartName: "/xl/styles.xml",
          ContentType: "application/vnd.openxmlformats-officedocument.spreadsheetml.styles+xml"
        });
        const hasSharedStrings = model.sharedStrings && model.sharedStrings.count;
        if (hasSharedStrings) {
          xmlStream.leafNode("Override", {
            PartName: "/xl/sharedStrings.xml",
            ContentType: "application/vnd.openxmlformats-officedocument.spreadsheetml.sharedStrings+xml"
          });
        }
        if (model.tables) {
          model.tables.forEach((table) => {
            xmlStream.leafNode("Override", {
              PartName: `/xl/tables/${table.target}`,
              ContentType: "application/vnd.openxmlformats-officedocument.spreadsheetml.table+xml"
            });
          });
        }
        if (model.drawings) {
          model.drawings.forEach((drawing) => {
            xmlStream.leafNode("Override", {
              PartName: `/xl/drawings/${drawing.name}.xml`,
              ContentType: "application/vnd.openxmlformats-officedocument.drawing+xml"
            });
          });
        }
        if (model.commentRefs) {
          xmlStream.leafNode("Default", {
            Extension: "vml",
            ContentType: "application/vnd.openxmlformats-officedocument.vmlDrawing"
          });
          model.commentRefs.forEach(({ commentName }) => {
            xmlStream.leafNode("Override", {
              PartName: `/xl/${commentName}.xml`,
              ContentType: "application/vnd.openxmlformats-officedocument.spreadsheetml.comments+xml"
            });
          });
        }
        xmlStream.leafNode("Override", {
          PartName: "/docProps/core.xml",
          ContentType: "application/vnd.openxmlformats-package.core-properties+xml"
        });
        xmlStream.leafNode("Override", {
          PartName: "/docProps/app.xml",
          ContentType: "application/vnd.openxmlformats-officedocument.extended-properties+xml"
        });
        xmlStream.closeNode();
      }
      parseOpen() {
        return false;
      }
      parseText() {
      }
      parseClose() {
        return false;
      }
    };
    ContentTypesXform.PROPERTY_ATTRIBUTES = {
      xmlns: "http://schemas.openxmlformats.org/package/2006/content-types"
    };
    module2.exports = ContentTypesXform;
  }
});

// ../../../node_modules/exceljs/lib/xlsx/xform/core/app-heading-pairs-xform.js
var require_app_heading_pairs_xform = __commonJS({
  "../../../node_modules/exceljs/lib/xlsx/xform/core/app-heading-pairs-xform.js"(exports2, module2) {
    var BaseXform = require_base_xform();
    var AppHeadingPairsXform = class extends BaseXform {
      render(xmlStream, model) {
        xmlStream.openNode("HeadingPairs");
        xmlStream.openNode("vt:vector", { size: 2, baseType: "variant" });
        xmlStream.openNode("vt:variant");
        xmlStream.leafNode("vt:lpstr", void 0, "Worksheets");
        xmlStream.closeNode();
        xmlStream.openNode("vt:variant");
        xmlStream.leafNode("vt:i4", void 0, model.length);
        xmlStream.closeNode();
        xmlStream.closeNode();
        xmlStream.closeNode();
      }
      parseOpen(node) {
        return node.name === "HeadingPairs";
      }
      parseText() {
      }
      parseClose(name) {
        return name !== "HeadingPairs";
      }
    };
    module2.exports = AppHeadingPairsXform;
  }
});

// ../../../node_modules/exceljs/lib/xlsx/xform/core/app-titles-of-parts-xform.js
var require_app_titles_of_parts_xform = __commonJS({
  "../../../node_modules/exceljs/lib/xlsx/xform/core/app-titles-of-parts-xform.js"(exports2, module2) {
    var BaseXform = require_base_xform();
    var AppTitlesOfPartsXform = class extends BaseXform {
      render(xmlStream, model) {
        xmlStream.openNode("TitlesOfParts");
        xmlStream.openNode("vt:vector", { size: model.length, baseType: "lpstr" });
        model.forEach((sheet) => {
          xmlStream.leafNode("vt:lpstr", void 0, sheet.name);
        });
        xmlStream.closeNode();
        xmlStream.closeNode();
      }
      parseOpen(node) {
        return node.name === "TitlesOfParts";
      }
      parseText() {
      }
      parseClose(name) {
        return name !== "TitlesOfParts";
      }
    };
    module2.exports = AppTitlesOfPartsXform;
  }
});

// ../../../node_modules/exceljs/lib/xlsx/xform/core/app-xform.js
var require_app_xform = __commonJS({
  "../../../node_modules/exceljs/lib/xlsx/xform/core/app-xform.js"(exports2, module2) {
    var XmlStream = require_xml_stream();
    var BaseXform = require_base_xform();
    var StringXform = require_string_xform();
    var AppHeadingPairsXform = require_app_heading_pairs_xform();
    var AppTitleOfPartsXform = require_app_titles_of_parts_xform();
    var AppXform = class _AppXform extends BaseXform {
      constructor() {
        super();
        this.map = {
          Company: new StringXform({ tag: "Company" }),
          Manager: new StringXform({ tag: "Manager" }),
          HeadingPairs: new AppHeadingPairsXform(),
          TitleOfParts: new AppTitleOfPartsXform()
        };
      }
      render(xmlStream, model) {
        xmlStream.openXml(XmlStream.StdDocAttributes);
        xmlStream.openNode("Properties", _AppXform.PROPERTY_ATTRIBUTES);
        xmlStream.leafNode("Application", void 0, "Microsoft Excel");
        xmlStream.leafNode("DocSecurity", void 0, "0");
        xmlStream.leafNode("ScaleCrop", void 0, "false");
        this.map.HeadingPairs.render(xmlStream, model.worksheets);
        this.map.TitleOfParts.render(xmlStream, model.worksheets);
        this.map.Company.render(xmlStream, model.company || "");
        this.map.Manager.render(xmlStream, model.manager);
        xmlStream.leafNode("LinksUpToDate", void 0, "false");
        xmlStream.leafNode("SharedDoc", void 0, "false");
        xmlStream.leafNode("HyperlinksChanged", void 0, "false");
        xmlStream.leafNode("AppVersion", void 0, "16.0300");
        xmlStream.closeNode();
      }
      parseOpen(node) {
        if (this.parser) {
          this.parser.parseOpen(node);
          return true;
        }
        switch (node.name) {
          case "Properties":
            return true;
          default:
            this.parser = this.map[node.name];
            if (this.parser) {
              this.parser.parseOpen(node);
              return true;
            }
            return false;
        }
      }
      parseText(text) {
        if (this.parser) {
          this.parser.parseText(text);
        }
      }
      parseClose(name) {
        if (this.parser) {
          if (!this.parser.parseClose(name)) {
            this.parser = void 0;
          }
          return true;
        }
        switch (name) {
          case "Properties":
            this.model = {
              worksheets: this.map.TitleOfParts.model,
              company: this.map.Company.model,
              manager: this.map.Manager.model
            };
            return false;
          default:
            return true;
        }
      }
    };
    AppXform.DateFormat = function(dt) {
      return dt.toISOString().replace(/[.]\d{3,6}/, "");
    };
    AppXform.DateAttrs = { "xsi:type": "dcterms:W3CDTF" };
    AppXform.PROPERTY_ATTRIBUTES = {
      xmlns: "http://schemas.openxmlformats.org/officeDocument/2006/extended-properties",
      "xmlns:vt": "http://schemas.openxmlformats.org/officeDocument/2006/docPropsVTypes"
    };
    module2.exports = AppXform;
  }
});

// ../../../node_modules/exceljs/lib/xlsx/xform/book/defined-name-xform.js
var require_defined_name_xform = __commonJS({
  "../../../node_modules/exceljs/lib/xlsx/xform/book/defined-name-xform.js"(exports2, module2) {
    var BaseXform = require_base_xform();
    var colCache = require_col_cache();
    var DefinedNamesXform = class extends BaseXform {
      render(xmlStream, model) {
        xmlStream.openNode("definedName", {
          name: model.name,
          localSheetId: model.localSheetId
        });
        xmlStream.writeText(model.ranges.join(","));
        xmlStream.closeNode();
      }
      parseOpen(node) {
        switch (node.name) {
          case "definedName":
            this._parsedName = node.attributes.name;
            this._parsedLocalSheetId = node.attributes.localSheetId;
            this._parsedText = [];
            return true;
          default:
            return false;
        }
      }
      parseText(text) {
        this._parsedText.push(text);
      }
      parseClose() {
        this.model = {
          name: this._parsedName,
          ranges: extractRanges(this._parsedText.join(""))
        };
        if (this._parsedLocalSheetId !== void 0) {
          this.model.localSheetId = parseInt(this._parsedLocalSheetId, 10);
        }
        return false;
      }
    };
    function isValidRange(range) {
      try {
        colCache.decodeEx(range);
        return true;
      } catch (err) {
        return false;
      }
    }
    function extractRanges(parsedText) {
      const ranges = [];
      let quotesOpened = false;
      let last = "";
      parsedText.split(",").forEach((item) => {
        if (!item) {
          return;
        }
        const quotes = (item.match(/'/g) || []).length;
        if (!quotes) {
          if (quotesOpened) {
            last += `${item},`;
          } else if (isValidRange(item)) {
            ranges.push(item);
          }
          return;
        }
        const quotesEven = quotes % 2 === 0;
        if (!quotesOpened && quotesEven && isValidRange(item)) {
          ranges.push(item);
        } else if (quotesOpened && !quotesEven) {
          quotesOpened = false;
          if (isValidRange(last + item)) {
            ranges.push(last + item);
          }
          last = "";
        } else {
          quotesOpened = true;
          last += `${item},`;
        }
      });
      return ranges;
    }
    module2.exports = DefinedNamesXform;
  }
});

// ../../../node_modules/exceljs/lib/xlsx/xform/book/sheet-xform.js
var require_sheet_xform = __commonJS({
  "../../../node_modules/exceljs/lib/xlsx/xform/book/sheet-xform.js"(exports2, module2) {
    var utils = require_utils2();
    var BaseXform = require_base_xform();
    var WorksheetXform = class extends BaseXform {
      render(xmlStream, model) {
        xmlStream.leafNode("sheet", {
          sheetId: model.id,
          name: model.name,
          state: model.state,
          "r:id": model.rId
        });
      }
      parseOpen(node) {
        if (node.name === "sheet") {
          this.model = {
            name: utils.xmlDecode(node.attributes.name),
            id: parseInt(node.attributes.sheetId, 10),
            state: node.attributes.state,
            rId: node.attributes["r:id"]
          };
          return true;
        }
        return false;
      }
      parseText() {
      }
      parseClose() {
        return false;
      }
    };
    module2.exports = WorksheetXform;
  }
});

// ../../../node_modules/exceljs/lib/xlsx/xform/book/workbook-view-xform.js
var require_workbook_view_xform = __commonJS({
  "../../../node_modules/exceljs/lib/xlsx/xform/book/workbook-view-xform.js"(exports2, module2) {
    var BaseXform = require_base_xform();
    var WorkbookViewXform = class extends BaseXform {
      render(xmlStream, model) {
        const attributes = {
          xWindow: model.x || 0,
          yWindow: model.y || 0,
          windowWidth: model.width || 12e3,
          windowHeight: model.height || 24e3,
          firstSheet: model.firstSheet,
          activeTab: model.activeTab
        };
        if (model.visibility && model.visibility !== "visible") {
          attributes.visibility = model.visibility;
        }
        xmlStream.leafNode("workbookView", attributes);
      }
      parseOpen(node) {
        if (node.name === "workbookView") {
          const model = this.model = {};
          const addS = function(name, value, dflt) {
            const s = value !== void 0 ? model[name] = value : dflt;
            if (s !== void 0) {
              model[name] = s;
            }
          };
          const addN = function(name, value, dflt) {
            const n = value !== void 0 ? model[name] = parseInt(value, 10) : dflt;
            if (n !== void 0) {
              model[name] = n;
            }
          };
          addN("x", node.attributes.xWindow, 0);
          addN("y", node.attributes.yWindow, 0);
          addN("width", node.attributes.windowWidth, 25e3);
          addN("height", node.attributes.windowHeight, 1e4);
          addS("visibility", node.attributes.visibility, "visible");
          addN("activeTab", node.attributes.activeTab, void 0);
          addN("firstSheet", node.attributes.firstSheet, void 0);
          return true;
        }
        return false;
      }
      parseText() {
      }
      parseClose() {
        return false;
      }
    };
    module2.exports = WorkbookViewXform;
  }
});

// ../../../node_modules/exceljs/lib/xlsx/xform/book/workbook-properties-xform.js
var require_workbook_properties_xform = __commonJS({
  "../../../node_modules/exceljs/lib/xlsx/xform/book/workbook-properties-xform.js"(exports2, module2) {
    var BaseXform = require_base_xform();
    var WorksheetPropertiesXform = class extends BaseXform {
      render(xmlStream, model) {
        xmlStream.leafNode("workbookPr", {
          date1904: model.date1904 ? 1 : void 0,
          defaultThemeVersion: 164011,
          filterPrivacy: 1
        });
      }
      parseOpen(node) {
        if (node.name === "workbookPr") {
          this.model = {
            date1904: node.attributes.date1904 === "1"
          };
          return true;
        }
        return false;
      }
      parseText() {
      }
      parseClose() {
        return false;
      }
    };
    module2.exports = WorksheetPropertiesXform;
  }
});

// ../../../node_modules/exceljs/lib/xlsx/xform/book/workbook-calc-properties-xform.js
var require_workbook_calc_properties_xform = __commonJS({
  "../../../node_modules/exceljs/lib/xlsx/xform/book/workbook-calc-properties-xform.js"(exports2, module2) {
    var BaseXform = require_base_xform();
    var WorkbookCalcPropertiesXform = class extends BaseXform {
      render(xmlStream, model) {
        xmlStream.leafNode("calcPr", {
          calcId: 171027,
          fullCalcOnLoad: model.fullCalcOnLoad ? 1 : void 0
        });
      }
      parseOpen(node) {
        if (node.name === "calcPr") {
          this.model = {};
          return true;
        }
        return false;
      }
      parseText() {
      }
      parseClose() {
        return false;
      }
    };
    module2.exports = WorkbookCalcPropertiesXform;
  }
});

// ../../../node_modules/exceljs/lib/xlsx/xform/book/workbook-xform.js
var require_workbook_xform = __commonJS({
  "../../../node_modules/exceljs/lib/xlsx/xform/book/workbook-xform.js"(exports2, module2) {
    var _2 = require_under_dash();
    var colCache = require_col_cache();
    var XmlStream = require_xml_stream();
    var BaseXform = require_base_xform();
    var StaticXform = require_static_xform();
    var ListXform = require_list_xform();
    var DefinedNameXform = require_defined_name_xform();
    var SheetXform = require_sheet_xform();
    var WorkbookViewXform = require_workbook_view_xform();
    var WorkbookPropertiesXform = require_workbook_properties_xform();
    var WorkbookCalcPropertiesXform = require_workbook_calc_properties_xform();
    var WorkbookXform = class _WorkbookXform extends BaseXform {
      constructor() {
        super();
        this.map = {
          fileVersion: _WorkbookXform.STATIC_XFORMS.fileVersion,
          workbookPr: new WorkbookPropertiesXform(),
          bookViews: new ListXform({
            tag: "bookViews",
            count: false,
            childXform: new WorkbookViewXform()
          }),
          sheets: new ListXform({ tag: "sheets", count: false, childXform: new SheetXform() }),
          definedNames: new ListXform({
            tag: "definedNames",
            count: false,
            childXform: new DefinedNameXform()
          }),
          calcPr: new WorkbookCalcPropertiesXform()
        };
      }
      prepare(model) {
        model.sheets = model.worksheets;
        const printAreas = [];
        let index = 0;
        model.sheets.forEach((sheet) => {
          if (sheet.pageSetup && sheet.pageSetup.printArea) {
            sheet.pageSetup.printArea.split("&&").forEach((printArea) => {
              const printAreaComponents = printArea.split(":");
              const definedName = {
                name: "_xlnm.Print_Area",
                ranges: [`'${sheet.name}'!$${printAreaComponents[0]}:$${printAreaComponents[1]}`],
                localSheetId: index
              };
              printAreas.push(definedName);
            });
          }
          if (sheet.pageSetup && (sheet.pageSetup.printTitlesRow || sheet.pageSetup.printTitlesColumn)) {
            const ranges = [];
            if (sheet.pageSetup.printTitlesColumn) {
              const titlesColumns = sheet.pageSetup.printTitlesColumn.split(":");
              ranges.push(`'${sheet.name}'!$${titlesColumns[0]}:$${titlesColumns[1]}`);
            }
            if (sheet.pageSetup.printTitlesRow) {
              const titlesRows = sheet.pageSetup.printTitlesRow.split(":");
              ranges.push(`'${sheet.name}'!$${titlesRows[0]}:$${titlesRows[1]}`);
            }
            const definedName = {
              name: "_xlnm.Print_Titles",
              ranges,
              localSheetId: index
            };
            printAreas.push(definedName);
          }
          index++;
        });
        if (printAreas.length) {
          model.definedNames = model.definedNames.concat(printAreas);
        }
        (model.media || []).forEach((medium, i) => {
          medium.name = medium.type + (i + 1);
        });
      }
      render(xmlStream, model) {
        xmlStream.openXml(XmlStream.StdDocAttributes);
        xmlStream.openNode("workbook", _WorkbookXform.WORKBOOK_ATTRIBUTES);
        this.map.fileVersion.render(xmlStream);
        this.map.workbookPr.render(xmlStream, model.properties);
        this.map.bookViews.render(xmlStream, model.views);
        this.map.sheets.render(xmlStream, model.sheets);
        this.map.definedNames.render(xmlStream, model.definedNames);
        this.map.calcPr.render(xmlStream, model.calcProperties);
        xmlStream.closeNode();
      }
      parseOpen(node) {
        if (this.parser) {
          this.parser.parseOpen(node);
          return true;
        }
        switch (node.name) {
          case "workbook":
            return true;
          default:
            this.parser = this.map[node.name];
            if (this.parser) {
              this.parser.parseOpen(node);
            }
            return true;
        }
      }
      parseText(text) {
        if (this.parser) {
          this.parser.parseText(text);
        }
      }
      parseClose(name) {
        if (this.parser) {
          if (!this.parser.parseClose(name)) {
            this.parser = void 0;
          }
          return true;
        }
        switch (name) {
          case "workbook":
            this.model = {
              sheets: this.map.sheets.model,
              properties: this.map.workbookPr.model || {},
              views: this.map.bookViews.model,
              calcProperties: {}
            };
            if (this.map.definedNames.model) {
              this.model.definedNames = this.map.definedNames.model;
            }
            return false;
          default:
            return true;
        }
      }
      reconcile(model) {
        const rels = (model.workbookRels || []).reduce((map, rel) => {
          map[rel.Id] = rel;
          return map;
        }, {});
        const worksheets = [];
        let worksheet;
        let index = 0;
        (model.sheets || []).forEach((sheet) => {
          const rel = rels[sheet.rId];
          if (!rel) {
            return;
          }
          worksheet = model.worksheetHash[`xl/${rel.Target.replace(/^(\s|\/xl\/)+/, "")}`];
          if (worksheet) {
            worksheet.name = sheet.name;
            worksheet.id = sheet.id;
            worksheet.state = sheet.state;
            worksheets[index++] = worksheet;
          }
        });
        const definedNames = [];
        _2.each(model.definedNames, (definedName) => {
          if (definedName.name === "_xlnm.Print_Area") {
            worksheet = worksheets[definedName.localSheetId];
            if (worksheet) {
              if (!worksheet.pageSetup) {
                worksheet.pageSetup = {};
              }
              const range = colCache.decodeEx(definedName.ranges[0]);
              worksheet.pageSetup.printArea = worksheet.pageSetup.printArea ? `${worksheet.pageSetup.printArea}&&${range.dimensions}` : range.dimensions;
            }
          } else if (definedName.name === "_xlnm.Print_Titles") {
            worksheet = worksheets[definedName.localSheetId];
            if (worksheet) {
              if (!worksheet.pageSetup) {
                worksheet.pageSetup = {};
              }
              const rangeString = definedName.ranges.join(",");
              const dollarRegex = /\$/g;
              const rowRangeRegex = /\$\d+:\$\d+/;
              const rowRangeMatches = rangeString.match(rowRangeRegex);
              if (rowRangeMatches && rowRangeMatches.length) {
                const range = rowRangeMatches[0];
                worksheet.pageSetup.printTitlesRow = range.replace(dollarRegex, "");
              }
              const columnRangeRegex = /\$[A-Z]+:\$[A-Z]+/;
              const columnRangeMatches = rangeString.match(columnRangeRegex);
              if (columnRangeMatches && columnRangeMatches.length) {
                const range = columnRangeMatches[0];
                worksheet.pageSetup.printTitlesColumn = range.replace(dollarRegex, "");
              }
            }
          } else {
            definedNames.push(definedName);
          }
        });
        model.definedNames = definedNames;
        model.media.forEach((media, i) => {
          media.index = i;
        });
      }
    };
    WorkbookXform.WORKBOOK_ATTRIBUTES = {
      xmlns: "http://schemas.openxmlformats.org/spreadsheetml/2006/main",
      "xmlns:r": "http://schemas.openxmlformats.org/officeDocument/2006/relationships",
      "xmlns:mc": "http://schemas.openxmlformats.org/markup-compatibility/2006",
      "mc:Ignorable": "x15",
      "xmlns:x15": "http://schemas.microsoft.com/office/spreadsheetml/2010/11/main"
    };
    WorkbookXform.STATIC_XFORMS = {
      fileVersion: new StaticXform({
        tag: "fileVersion",
        $: { appName: "xl", lastEdited: 5, lowestEdited: 5, rupBuild: 9303 }
      })
    };
    module2.exports = WorkbookXform;
  }
});

// ../../../node_modules/exceljs/lib/xlsx/rel-type.js
var require_rel_type = __commonJS({
  "../../../node_modules/exceljs/lib/xlsx/rel-type.js"(exports2, module2) {
    "use strict";
    module2.exports = {
      OfficeDocument: "http://schemas.openxmlformats.org/officeDocument/2006/relationships/officeDocument",
      Worksheet: "http://schemas.openxmlformats.org/officeDocument/2006/relationships/worksheet",
      CalcChain: "http://schemas.openxmlformats.org/officeDocument/2006/relationships/calcChain",
      SharedStrings: "http://schemas.openxmlformats.org/officeDocument/2006/relationships/sharedStrings",
      Styles: "http://schemas.openxmlformats.org/officeDocument/2006/relationships/styles",
      Theme: "http://schemas.openxmlformats.org/officeDocument/2006/relationships/theme",
      Hyperlink: "http://schemas.openxmlformats.org/officeDocument/2006/relationships/hyperlink",
      Image: "http://schemas.openxmlformats.org/officeDocument/2006/relationships/image",
      CoreProperties: "http://schemas.openxmlformats.org/package/2006/relationships/metadata/core-properties",
      ExtenderProperties: "http://schemas.openxmlformats.org/officeDocument/2006/relationships/extended-properties",
      Comments: "http://schemas.openxmlformats.org/officeDocument/2006/relationships/comments",
      VmlDrawing: "http://schemas.openxmlformats.org/officeDocument/2006/relationships/vmlDrawing",
      Table: "http://schemas.openxmlformats.org/officeDocument/2006/relationships/table"
    };
  }
});

// ../../../node_modules/exceljs/lib/xlsx/xform/sheet/merges.js
var require_merges = __commonJS({
  "../../../node_modules/exceljs/lib/xlsx/xform/sheet/merges.js"(exports2, module2) {
    var _2 = require_under_dash();
    var Range = require_range();
    var colCache = require_col_cache();
    var Enums = require_enums();
    var Merges = class {
      constructor() {
        this.merges = {};
      }
      add(merge) {
        if (this.merges[merge.master]) {
          this.merges[merge.master].expandToAddress(merge.address);
        } else {
          const range = `${merge.master}:${merge.address}`;
          this.merges[merge.master] = new Range(range);
        }
      }
      get mergeCells() {
        return _2.map(this.merges, (merge) => merge.range);
      }
      reconcile(mergeCells, rows) {
        _2.each(mergeCells, (merge) => {
          const dimensions = colCache.decode(merge);
          for (let i = dimensions.top; i <= dimensions.bottom; i++) {
            const row = rows[i - 1];
            for (let j = dimensions.left; j <= dimensions.right; j++) {
              const cell = row.cells[j - 1];
              if (!cell) {
                row.cells[j] = {
                  type: Enums.ValueType.Null,
                  address: colCache.encodeAddress(i, j)
                };
              } else if (cell.type === Enums.ValueType.Merge) {
                cell.master = dimensions.tl;
              }
            }
          }
        });
      }
      getMasterAddress(address) {
        const range = this.hash[address];
        return range && range.tl;
      }
    };
    module2.exports = Merges;
  }
});

// ../../../node_modules/exceljs/lib/xlsx/xform/sheet/cell-xform.js
var require_cell_xform = __commonJS({
  "../../../node_modules/exceljs/lib/xlsx/xform/sheet/cell-xform.js"(exports2, module2) {
    var utils = require_utils2();
    var BaseXform = require_base_xform();
    var Range = require_range();
    var Enums = require_enums();
    var RichTextXform = require_rich_text_xform();
    function getValueType(v) {
      if (v === null || v === void 0) {
        return Enums.ValueType.Null;
      }
      if (v instanceof String || typeof v === "string") {
        return Enums.ValueType.String;
      }
      if (typeof v === "number") {
        return Enums.ValueType.Number;
      }
      if (typeof v === "boolean") {
        return Enums.ValueType.Boolean;
      }
      if (v instanceof Date) {
        return Enums.ValueType.Date;
      }
      if (v.text && v.hyperlink) {
        return Enums.ValueType.Hyperlink;
      }
      if (v.formula) {
        return Enums.ValueType.Formula;
      }
      if (v.error) {
        return Enums.ValueType.Error;
      }
      throw new Error("I could not understand type of value");
    }
    function getEffectiveCellType(cell) {
      switch (cell.type) {
        case Enums.ValueType.Formula:
          return getValueType(cell.result);
        default:
          return cell.type;
      }
    }
    var CellXform = class extends BaseXform {
      constructor() {
        super();
        this.richTextXForm = new RichTextXform();
      }
      get tag() {
        return "c";
      }
      prepare(model, options) {
        const styleId = options.styles.addStyleModel(model.style || {}, getEffectiveCellType(model));
        if (styleId) {
          model.styleId = styleId;
        }
        if (model.comment) {
          options.comments.push({ ...model.comment, ref: model.address });
        }
        switch (model.type) {
          case Enums.ValueType.String:
          case Enums.ValueType.RichText:
            if (options.sharedStrings) {
              model.ssId = options.sharedStrings.add(model.value);
            }
            break;
          case Enums.ValueType.Date:
            if (options.date1904) {
              model.date1904 = true;
            }
            break;
          case Enums.ValueType.Hyperlink:
            if (options.sharedStrings && model.text !== void 0 && model.text !== null) {
              model.ssId = options.sharedStrings.add(model.text);
            }
            options.hyperlinks.push({
              address: model.address,
              target: model.hyperlink,
              tooltip: model.tooltip
            });
            break;
          case Enums.ValueType.Merge:
            options.merges.add(model);
            break;
          case Enums.ValueType.Formula:
            if (options.date1904) {
              model.date1904 = true;
            }
            if (model.shareType === "shared") {
              model.si = options.siFormulae++;
            }
            if (model.formula) {
              options.formulae[model.address] = model;
            } else if (model.sharedFormula) {
              const master = options.formulae[model.sharedFormula];
              if (!master) {
                throw new Error(
                  `Shared Formula master must exist above and or left of clone for cell ${model.address}`
                );
              }
              if (master.si === void 0) {
                master.shareType = "shared";
                master.si = options.siFormulae++;
                master.range = new Range(master.address, model.address);
              } else if (master.range) {
                master.range.expandToAddress(model.address);
              }
              model.si = master.si;
            }
            break;
          default:
            break;
        }
      }
      renderFormula(xmlStream, model) {
        let attrs = null;
        switch (model.shareType) {
          case "shared":
            attrs = {
              t: "shared",
              ref: model.ref || model.range.range,
              si: model.si
            };
            break;
          case "array":
            attrs = {
              t: "array",
              ref: model.ref
            };
            break;
          default:
            if (model.si !== void 0) {
              attrs = {
                t: "shared",
                si: model.si
              };
            }
            break;
        }
        switch (getValueType(model.result)) {
          case Enums.ValueType.Null:
            xmlStream.leafNode("f", attrs, model.formula);
            break;
          case Enums.ValueType.String:
            xmlStream.addAttribute("t", "str");
            xmlStream.leafNode("f", attrs, model.formula);
            xmlStream.leafNode("v", null, model.result);
            break;
          case Enums.ValueType.Number:
            xmlStream.leafNode("f", attrs, model.formula);
            xmlStream.leafNode("v", null, model.result);
            break;
          case Enums.ValueType.Boolean:
            xmlStream.addAttribute("t", "b");
            xmlStream.leafNode("f", attrs, model.formula);
            xmlStream.leafNode("v", null, model.result ? 1 : 0);
            break;
          case Enums.ValueType.Error:
            xmlStream.addAttribute("t", "e");
            xmlStream.leafNode("f", attrs, model.formula);
            xmlStream.leafNode("v", null, model.result.error);
            break;
          case Enums.ValueType.Date:
            xmlStream.leafNode("f", attrs, model.formula);
            xmlStream.leafNode("v", null, utils.dateToExcel(model.result, model.date1904));
            break;
          default:
            throw new Error("I could not understand type of value");
        }
      }
      render(xmlStream, model) {
        if (model.type === Enums.ValueType.Null && !model.styleId) {
          return;
        }
        xmlStream.openNode("c");
        xmlStream.addAttribute("r", model.address);
        if (model.styleId) {
          xmlStream.addAttribute("s", model.styleId);
        }
        switch (model.type) {
          case Enums.ValueType.Null:
            break;
          case Enums.ValueType.Number:
            xmlStream.leafNode("v", null, model.value);
            break;
          case Enums.ValueType.Boolean:
            xmlStream.addAttribute("t", "b");
            xmlStream.leafNode("v", null, model.value ? "1" : "0");
            break;
          case Enums.ValueType.Error:
            xmlStream.addAttribute("t", "e");
            xmlStream.leafNode("v", null, model.value.error);
            break;
          case Enums.ValueType.String:
          case Enums.ValueType.RichText:
            if (model.ssId !== void 0) {
              xmlStream.addAttribute("t", "s");
              xmlStream.leafNode("v", null, model.ssId);
            } else if (model.value && model.value.richText) {
              xmlStream.addAttribute("t", "inlineStr");
              xmlStream.openNode("is");
              model.value.richText.forEach((text) => {
                this.richTextXForm.render(xmlStream, text);
              });
              xmlStream.closeNode("is");
            } else {
              xmlStream.addAttribute("t", "str");
              xmlStream.leafNode("v", null, model.value);
            }
            break;
          case Enums.ValueType.Date:
            xmlStream.leafNode("v", null, utils.dateToExcel(model.value, model.date1904));
            break;
          case Enums.ValueType.Hyperlink:
            if (model.ssId !== void 0) {
              xmlStream.addAttribute("t", "s");
              xmlStream.leafNode("v", null, model.ssId);
            } else {
              xmlStream.addAttribute("t", "str");
              xmlStream.leafNode("v", null, model.text);
            }
            break;
          case Enums.ValueType.Formula:
            this.renderFormula(xmlStream, model);
            break;
          case Enums.ValueType.Merge:
            break;
          default:
            break;
        }
        xmlStream.closeNode();
      }
      parseOpen(node) {
        if (this.parser) {
          this.parser.parseOpen(node);
          return true;
        }
        switch (node.name) {
          case "c":
            this.model = {
              address: node.attributes.r
            };
            this.t = node.attributes.t;
            if (node.attributes.s) {
              this.model.styleId = parseInt(node.attributes.s, 10);
            }
            return true;
          case "f":
            this.currentNode = "f";
            this.model.si = node.attributes.si;
            this.model.shareType = node.attributes.t;
            this.model.ref = node.attributes.ref;
            return true;
          case "v":
            this.currentNode = "v";
            return true;
          case "t":
            this.currentNode = "t";
            return true;
          case "r":
            this.parser = this.richTextXForm;
            this.parser.parseOpen(node);
            return true;
          default:
            return false;
        }
      }
      parseText(text) {
        if (this.parser) {
          this.parser.parseText(text);
          return;
        }
        switch (this.currentNode) {
          case "f":
            this.model.formula = this.model.formula ? this.model.formula + text : text;
            break;
          case "v":
          case "t":
            if (this.model.value && this.model.value.richText) {
              this.model.value.richText.text = this.model.value.richText.text ? this.model.value.richText.text + text : text;
            } else {
              this.model.value = this.model.value ? this.model.value + text : text;
            }
            break;
          default:
            break;
        }
      }
      parseClose(name) {
        switch (name) {
          case "c": {
            const { model } = this;
            if (model.formula || model.shareType) {
              model.type = Enums.ValueType.Formula;
              if (model.value) {
                if (this.t === "str") {
                  model.result = utils.xmlDecode(model.value);
                } else if (this.t === "b") {
                  model.result = parseInt(model.value, 10) !== 0;
                } else if (this.t === "e") {
                  model.result = { error: model.value };
                } else {
                  model.result = parseFloat(model.value);
                }
                model.value = void 0;
              }
            } else if (model.value !== void 0) {
              switch (this.t) {
                case "s":
                  model.type = Enums.ValueType.String;
                  model.value = parseInt(model.value, 10);
                  break;
                case "str":
                  model.type = Enums.ValueType.String;
                  model.value = utils.xmlDecode(model.value);
                  break;
                case "inlineStr":
                  model.type = Enums.ValueType.String;
                  break;
                case "b":
                  model.type = Enums.ValueType.Boolean;
                  model.value = parseInt(model.value, 10) !== 0;
                  break;
                case "e":
                  model.type = Enums.ValueType.Error;
                  model.value = { error: model.value };
                  break;
                default:
                  model.type = Enums.ValueType.Number;
                  model.value = parseFloat(model.value);
                  break;
              }
            } else if (model.styleId) {
              model.type = Enums.ValueType.Null;
            } else {
              model.type = Enums.ValueType.Merge;
            }
            return false;
          }
          case "f":
          case "v":
          case "is":
            this.currentNode = void 0;
            return true;
          case "t":
            if (this.parser) {
              this.parser.parseClose(name);
              return true;
            }
            this.currentNode = void 0;
            return true;
          case "r":
            this.model.value = this.model.value || {};
            this.model.value.richText = this.model.value.richText || [];
            this.model.value.richText.push(this.parser.model);
            this.parser = void 0;
            this.currentNode = void 0;
            return true;
          default:
            if (this.parser) {
              this.parser.parseClose(name);
              return true;
            }
            return false;
        }
      }
      reconcile(model, options) {
        const style = model.styleId && options.styles && options.styles.getStyleModel(model.styleId);
        if (style) {
          model.style = style;
        }
        if (model.styleId !== void 0) {
          model.styleId = void 0;
        }
        switch (model.type) {
          case Enums.ValueType.String:
            if (typeof model.value === "number") {
              if (options.sharedStrings) {
                model.value = options.sharedStrings.getString(model.value);
              }
            }
            if (model.value.richText) {
              model.type = Enums.ValueType.RichText;
            }
            break;
          case Enums.ValueType.Number:
            if (style && utils.isDateFmt(style.numFmt)) {
              model.type = Enums.ValueType.Date;
              model.value = utils.excelToDate(model.value, options.date1904);
            }
            break;
          case Enums.ValueType.Formula:
            if (model.result !== void 0 && style && utils.isDateFmt(style.numFmt)) {
              model.result = utils.excelToDate(model.result, options.date1904);
            }
            if (model.shareType === "shared") {
              if (model.ref) {
                options.formulae[model.si] = model.address;
              } else {
                model.sharedFormula = options.formulae[model.si];
                delete model.shareType;
              }
              delete model.si;
            }
            break;
          default:
            break;
        }
        const hyperlink = options.hyperlinkMap[model.address];
        if (hyperlink) {
          if (model.type === Enums.ValueType.Formula) {
            model.text = model.result;
            model.result = void 0;
          } else {
            model.text = model.value;
            model.value = void 0;
          }
          model.type = Enums.ValueType.Hyperlink;
          model.hyperlink = hyperlink;
        }
        const comment = options.commentsMap && options.commentsMap[model.address];
        if (comment) {
          model.comment = comment;
        }
      }
    };
    module2.exports = CellXform;
  }
});

// ../../../node_modules/exceljs/lib/xlsx/xform/sheet/row-xform.js
var require_row_xform = __commonJS({
  "../../../node_modules/exceljs/lib/xlsx/xform/sheet/row-xform.js"(exports2, module2) {
    var BaseXform = require_base_xform();
    var utils = require_utils2();
    var CellXform = require_cell_xform();
    var RowXform = class extends BaseXform {
      constructor(options) {
        super();
        this.maxItems = options && options.maxItems;
        this.map = {
          c: new CellXform()
        };
      }
      get tag() {
        return "row";
      }
      prepare(model, options) {
        const styleId = options.styles.addStyleModel(model.style);
        if (styleId) {
          model.styleId = styleId;
        }
        const cellXform = this.map.c;
        model.cells.forEach((cellModel) => {
          cellXform.prepare(cellModel, options);
        });
      }
      render(xmlStream, model, options) {
        xmlStream.openNode("row");
        xmlStream.addAttribute("r", model.number);
        if (model.height) {
          xmlStream.addAttribute("ht", model.height);
          xmlStream.addAttribute("customHeight", "1");
        }
        if (model.hidden) {
          xmlStream.addAttribute("hidden", "1");
        }
        if (model.min > 0 && model.max > 0 && model.min <= model.max) {
          xmlStream.addAttribute("spans", `${model.min}:${model.max}`);
        }
        if (model.styleId) {
          xmlStream.addAttribute("s", model.styleId);
          xmlStream.addAttribute("customFormat", "1");
        }
        xmlStream.addAttribute("x14ac:dyDescent", "0.25");
        if (model.outlineLevel) {
          xmlStream.addAttribute("outlineLevel", model.outlineLevel);
        }
        if (model.collapsed) {
          xmlStream.addAttribute("collapsed", "1");
        }
        const cellXform = this.map.c;
        model.cells.forEach((cellModel) => {
          cellXform.render(xmlStream, cellModel, options);
        });
        xmlStream.closeNode();
      }
      parseOpen(node) {
        if (this.parser) {
          this.parser.parseOpen(node);
          return true;
        }
        if (node.name === "row") {
          this.numRowsSeen += 1;
          const spans = node.attributes.spans ? node.attributes.spans.split(":").map((span) => parseInt(span, 10)) : [void 0, void 0];
          const model = this.model = {
            number: parseInt(node.attributes.r, 10),
            min: spans[0],
            max: spans[1],
            cells: []
          };
          if (node.attributes.s) {
            model.styleId = parseInt(node.attributes.s, 10);
          }
          if (utils.parseBoolean(node.attributes.hidden)) {
            model.hidden = true;
          }
          if (utils.parseBoolean(node.attributes.bestFit)) {
            model.bestFit = true;
          }
          if (node.attributes.ht) {
            model.height = parseFloat(node.attributes.ht);
          }
          if (node.attributes.outlineLevel) {
            model.outlineLevel = parseInt(node.attributes.outlineLevel, 10);
          }
          if (utils.parseBoolean(node.attributes.collapsed)) {
            model.collapsed = true;
          }
          return true;
        }
        this.parser = this.map[node.name];
        if (this.parser) {
          this.parser.parseOpen(node);
          return true;
        }
        return false;
      }
      parseText(text) {
        if (this.parser) {
          this.parser.parseText(text);
        }
      }
      parseClose(name) {
        if (this.parser) {
          if (!this.parser.parseClose(name)) {
            this.model.cells.push(this.parser.model);
            if (this.maxItems && this.model.cells.length > this.maxItems) {
              throw new Error(`Max column count (${this.maxItems}) exceeded`);
            }
            this.parser = void 0;
          }
          return true;
        }
        return false;
      }
      reconcile(model, options) {
        model.style = model.styleId ? options.styles.getStyleModel(model.styleId) : {};
        if (model.styleId !== void 0) {
          model.styleId = void 0;
        }
        const cellXform = this.map.c;
        model.cells.forEach((cellModel) => {
          cellXform.reconcile(cellModel, options);
        });
      }
    };
    module2.exports = RowXform;
  }
});

// ../../../node_modules/exceljs/lib/xlsx/xform/sheet/col-xform.js
var require_col_xform = __commonJS({
  "../../../node_modules/exceljs/lib/xlsx/xform/sheet/col-xform.js"(exports2, module2) {
    var utils = require_utils2();
    var BaseXform = require_base_xform();
    var ColXform = class extends BaseXform {
      get tag() {
        return "col";
      }
      prepare(model, options) {
        const styleId = options.styles.addStyleModel(model.style || {});
        if (styleId) {
          model.styleId = styleId;
        }
      }
      render(xmlStream, model) {
        xmlStream.openNode("col");
        xmlStream.addAttribute("min", model.min);
        xmlStream.addAttribute("max", model.max);
        if (model.width) {
          xmlStream.addAttribute("width", model.width);
        }
        if (model.styleId) {
          xmlStream.addAttribute("style", model.styleId);
        }
        if (model.hidden) {
          xmlStream.addAttribute("hidden", "1");
        }
        if (model.bestFit) {
          xmlStream.addAttribute("bestFit", "1");
        }
        if (model.outlineLevel) {
          xmlStream.addAttribute("outlineLevel", model.outlineLevel);
        }
        if (model.collapsed) {
          xmlStream.addAttribute("collapsed", "1");
        }
        xmlStream.addAttribute("customWidth", "1");
        xmlStream.closeNode();
      }
      parseOpen(node) {
        if (node.name === "col") {
          const model = this.model = {
            min: parseInt(node.attributes.min || "0", 10),
            max: parseInt(node.attributes.max || "0", 10),
            width: node.attributes.width === void 0 ? void 0 : parseFloat(node.attributes.width || "0")
          };
          if (node.attributes.style) {
            model.styleId = parseInt(node.attributes.style, 10);
          }
          if (utils.parseBoolean(node.attributes.hidden)) {
            model.hidden = true;
          }
          if (utils.parseBoolean(node.attributes.bestFit)) {
            model.bestFit = true;
          }
          if (node.attributes.outlineLevel) {
            model.outlineLevel = parseInt(node.attributes.outlineLevel, 10);
          }
          if (utils.parseBoolean(node.attributes.collapsed)) {
            model.collapsed = true;
          }
          return true;
        }
        return false;
      }
      parseText() {
      }
      parseClose() {
        return false;
      }
      reconcile(model, options) {
        if (model.styleId) {
          model.style = options.styles.getStyleModel(model.styleId);
        }
      }
    };
    module2.exports = ColXform;
  }
});

// ../../../node_modules/exceljs/lib/xlsx/xform/sheet/dimension-xform.js
var require_dimension_xform = __commonJS({
  "../../../node_modules/exceljs/lib/xlsx/xform/sheet/dimension-xform.js"(exports2, module2) {
    var BaseXform = require_base_xform();
    var DimensionXform = class extends BaseXform {
      get tag() {
        return "dimension";
      }
      render(xmlStream, model) {
        if (model) {
          xmlStream.leafNode("dimension", { ref: model });
        }
      }
      parseOpen(node) {
        if (node.name === "dimension") {
          this.model = node.attributes.ref;
          return true;
        }
        return false;
      }
      parseText() {
      }
      parseClose() {
        return false;
      }
    };
    module2.exports = DimensionXform;
  }
});

// ../../../node_modules/exceljs/lib/xlsx/xform/sheet/hyperlink-xform.js
var require_hyperlink_xform = __commonJS({
  "../../../node_modules/exceljs/lib/xlsx/xform/sheet/hyperlink-xform.js"(exports2, module2) {
    var BaseXform = require_base_xform();
    var HyperlinkXform = class extends BaseXform {
      get tag() {
        return "hyperlink";
      }
      render(xmlStream, model) {
        if (this.isInternalLink(model)) {
          xmlStream.leafNode("hyperlink", {
            ref: model.address,
            "r:id": model.rId,
            tooltip: model.tooltip,
            location: model.target
          });
        } else {
          xmlStream.leafNode("hyperlink", {
            ref: model.address,
            "r:id": model.rId,
            tooltip: model.tooltip
          });
        }
      }
      parseOpen(node) {
        if (node.name === "hyperlink") {
          this.model = {
            address: node.attributes.ref,
            rId: node.attributes["r:id"],
            tooltip: node.attributes.tooltip
          };
          if (node.attributes.location) {
            this.model.target = node.attributes.location;
          }
          return true;
        }
        return false;
      }
      parseText() {
      }
      parseClose() {
        return false;
      }
      isInternalLink(model) {
        return model.target && /^[^!]+![a-zA-Z]+[\d]+$/.test(model.target);
      }
    };
    module2.exports = HyperlinkXform;
  }
});

// ../../../node_modules/exceljs/lib/xlsx/xform/sheet/merge-cell-xform.js
var require_merge_cell_xform = __commonJS({
  "../../../node_modules/exceljs/lib/xlsx/xform/sheet/merge-cell-xform.js"(exports2, module2) {
    var BaseXform = require_base_xform();
    var MergeCellXform = class extends BaseXform {
      get tag() {
        return "mergeCell";
      }
      render(xmlStream, model) {
        xmlStream.leafNode("mergeCell", { ref: model });
      }
      parseOpen(node) {
        if (node.name === "mergeCell") {
          this.model = node.attributes.ref;
          return true;
        }
        return false;
      }
      parseText() {
      }
      parseClose() {
        return false;
      }
    };
    module2.exports = MergeCellXform;
  }
});

// ../../../node_modules/exceljs/lib/xlsx/xform/sheet/data-validations-xform.js
var require_data_validations_xform = __commonJS({
  "../../../node_modules/exceljs/lib/xlsx/xform/sheet/data-validations-xform.js"(exports2, module2) {
    var _2 = require_under_dash();
    var utils = require_utils2();
    var colCache = require_col_cache();
    var BaseXform = require_base_xform();
    var Range = require_range();
    function assign(definedName, attributes, name, defaultValue) {
      const value = attributes[name];
      if (value !== void 0) {
        definedName[name] = value;
      } else if (defaultValue !== void 0) {
        definedName[name] = defaultValue;
      }
    }
    function assignBool(definedName, attributes, name, defaultValue) {
      const value = attributes[name];
      if (value !== void 0) {
        definedName[name] = utils.parseBoolean(value);
      } else if (defaultValue !== void 0) {
        definedName[name] = defaultValue;
      }
    }
    function optimiseDataValidations(model) {
      const dvList = _2.map(model, (dataValidation, address) => ({
        address,
        dataValidation,
        marked: false
      })).sort((a, b) => _2.strcmp(a.address, b.address));
      const dvMap = _2.keyBy(dvList, "address");
      const matchCol = (addr, height, col) => {
        for (let i = 0; i < height; i++) {
          const otherAddress = colCache.encodeAddress(addr.row + i, col);
          if (!model[otherAddress] || !_2.isEqual(model[addr.address], model[otherAddress])) {
            return false;
          }
        }
        return true;
      };
      return dvList.map((dv) => {
        if (!dv.marked) {
          const addr = colCache.decodeEx(dv.address);
          if (addr.dimensions) {
            dvMap[addr.dimensions].marked = true;
            return {
              ...dv.dataValidation,
              sqref: dv.address
            };
          }
          let height = 1;
          let otherAddress = colCache.encodeAddress(addr.row + height, addr.col);
          while (model[otherAddress] && _2.isEqual(dv.dataValidation, model[otherAddress])) {
            height++;
            otherAddress = colCache.encodeAddress(addr.row + height, addr.col);
          }
          let width = 1;
          while (matchCol(addr, height, addr.col + width)) {
            width++;
          }
          for (let i = 0; i < height; i++) {
            for (let j = 0; j < width; j++) {
              otherAddress = colCache.encodeAddress(addr.row + i, addr.col + j);
              dvMap[otherAddress].marked = true;
            }
          }
          if (height > 1 || width > 1) {
            const bottom = addr.row + (height - 1);
            const right = addr.col + (width - 1);
            return {
              ...dv.dataValidation,
              sqref: `${dv.address}:${colCache.encodeAddress(bottom, right)}`
            };
          }
          return {
            ...dv.dataValidation,
            sqref: dv.address
          };
        }
        return null;
      }).filter(Boolean);
    }
    var DataValidationsXform = class extends BaseXform {
      get tag() {
        return "dataValidations";
      }
      render(xmlStream, model) {
        const optimizedModel = optimiseDataValidations(model);
        if (optimizedModel.length) {
          xmlStream.openNode("dataValidations", { count: optimizedModel.length });
          optimizedModel.forEach((value) => {
            xmlStream.openNode("dataValidation");
            if (value.type !== "any") {
              xmlStream.addAttribute("type", value.type);
              if (value.operator && value.type !== "list" && value.operator !== "between") {
                xmlStream.addAttribute("operator", value.operator);
              }
              if (value.allowBlank) {
                xmlStream.addAttribute("allowBlank", "1");
              }
            }
            if (value.showInputMessage) {
              xmlStream.addAttribute("showInputMessage", "1");
            }
            if (value.promptTitle) {
              xmlStream.addAttribute("promptTitle", value.promptTitle);
            }
            if (value.prompt) {
              xmlStream.addAttribute("prompt", value.prompt);
            }
            if (value.showErrorMessage) {
              xmlStream.addAttribute("showErrorMessage", "1");
            }
            if (value.errorStyle) {
              xmlStream.addAttribute("errorStyle", value.errorStyle);
            }
            if (value.errorTitle) {
              xmlStream.addAttribute("errorTitle", value.errorTitle);
            }
            if (value.error) {
              xmlStream.addAttribute("error", value.error);
            }
            xmlStream.addAttribute("sqref", value.sqref);
            (value.formulae || []).forEach((formula, index) => {
              xmlStream.openNode(`formula${index + 1}`);
              if (value.type === "date") {
                xmlStream.writeText(utils.dateToExcel(new Date(formula)));
              } else {
                xmlStream.writeText(formula);
              }
              xmlStream.closeNode();
            });
            xmlStream.closeNode();
          });
          xmlStream.closeNode();
        }
      }
      parseOpen(node) {
        switch (node.name) {
          case "dataValidations":
            this.model = {};
            return true;
          case "dataValidation": {
            this._address = node.attributes.sqref;
            const dataValidation = { type: node.attributes.type || "any", formulae: [] };
            if (node.attributes.type) {
              assignBool(dataValidation, node.attributes, "allowBlank");
            }
            assignBool(dataValidation, node.attributes, "showInputMessage");
            assignBool(dataValidation, node.attributes, "showErrorMessage");
            switch (dataValidation.type) {
              case "any":
              case "list":
              case "custom":
                break;
              default:
                assign(dataValidation, node.attributes, "operator", "between");
                break;
            }
            assign(dataValidation, node.attributes, "promptTitle");
            assign(dataValidation, node.attributes, "prompt");
            assign(dataValidation, node.attributes, "errorStyle");
            assign(dataValidation, node.attributes, "errorTitle");
            assign(dataValidation, node.attributes, "error");
            this._dataValidation = dataValidation;
            return true;
          }
          case "formula1":
          case "formula2":
            this._formula = [];
            return true;
          default:
            return false;
        }
      }
      parseText(text) {
        if (this._formula) {
          this._formula.push(text);
        }
      }
      parseClose(name) {
        switch (name) {
          case "dataValidations":
            return false;
          case "dataValidation": {
            if (!this._dataValidation.formulae || !this._dataValidation.formulae.length) {
              delete this._dataValidation.formulae;
              delete this._dataValidation.operator;
            }
            const list = this._address.split(/\s+/g) || [];
            list.forEach((addr) => {
              if (addr.includes(":")) {
                const range = new Range(addr);
                range.forEachAddress((address) => {
                  this.model[address] = this._dataValidation;
                });
              } else {
                this.model[addr] = this._dataValidation;
              }
            });
            return true;
          }
          case "formula1":
          case "formula2": {
            let formula = this._formula.join("");
            switch (this._dataValidation.type) {
              case "whole":
              case "textLength":
                formula = parseInt(formula, 10);
                break;
              case "decimal":
                formula = parseFloat(formula);
                break;
              case "date":
                formula = utils.excelToDate(parseFloat(formula));
                break;
              default:
                break;
            }
            this._dataValidation.formulae.push(formula);
            this._formula = void 0;
            return true;
          }
          default:
            return true;
        }
      }
    };
    module2.exports = DataValidationsXform;
  }
});

// ../../../node_modules/exceljs/lib/xlsx/xform/sheet/page-setup-properties-xform.js
var require_page_setup_properties_xform = __commonJS({
  "../../../node_modules/exceljs/lib/xlsx/xform/sheet/page-setup-properties-xform.js"(exports2, module2) {
    var BaseXform = require_base_xform();
    var PageSetupPropertiesXform = class extends BaseXform {
      get tag() {
        return "pageSetUpPr";
      }
      render(xmlStream, model) {
        if (model && model.fitToPage) {
          xmlStream.leafNode(this.tag, {
            fitToPage: model.fitToPage ? "1" : void 0
          });
          return true;
        }
        return false;
      }
      parseOpen(node) {
        if (node.name === this.tag) {
          this.model = {
            fitToPage: node.attributes.fitToPage === "1"
          };
          return true;
        }
        return false;
      }
      parseText() {
      }
      parseClose() {
        return false;
      }
    };
    module2.exports = PageSetupPropertiesXform;
  }
});

// ../../../node_modules/exceljs/lib/xlsx/xform/sheet/outline-properties-xform.js
var require_outline_properties_xform = __commonJS({
  "../../../node_modules/exceljs/lib/xlsx/xform/sheet/outline-properties-xform.js"(exports2, module2) {
    var BaseXform = require_base_xform();
    var isDefined = (attr) => typeof attr !== "undefined";
    var OutlinePropertiesXform = class extends BaseXform {
      get tag() {
        return "outlinePr";
      }
      render(xmlStream, model) {
        if (model && (isDefined(model.summaryBelow) || isDefined(model.summaryRight))) {
          xmlStream.leafNode(this.tag, {
            summaryBelow: isDefined(model.summaryBelow) ? Number(model.summaryBelow) : void 0,
            summaryRight: isDefined(model.summaryRight) ? Number(model.summaryRight) : void 0
          });
          return true;
        }
        return false;
      }
      parseOpen(node) {
        if (node.name === this.tag) {
          this.model = {
            summaryBelow: isDefined(node.attributes.summaryBelow) ? Boolean(Number(node.attributes.summaryBelow)) : void 0,
            summaryRight: isDefined(node.attributes.summaryRight) ? Boolean(Number(node.attributes.summaryRight)) : void 0
          };
          return true;
        }
        return false;
      }
      parseText() {
      }
      parseClose() {
        return false;
      }
    };
    module2.exports = OutlinePropertiesXform;
  }
});

// ../../../node_modules/exceljs/lib/xlsx/xform/sheet/sheet-properties-xform.js
var require_sheet_properties_xform = __commonJS({
  "../../../node_modules/exceljs/lib/xlsx/xform/sheet/sheet-properties-xform.js"(exports2, module2) {
    var BaseXform = require_base_xform();
    var ColorXform = require_color_xform();
    var PageSetupPropertiesXform = require_page_setup_properties_xform();
    var OutlinePropertiesXform = require_outline_properties_xform();
    var SheetPropertiesXform = class extends BaseXform {
      constructor() {
        super();
        this.map = {
          tabColor: new ColorXform("tabColor"),
          pageSetUpPr: new PageSetupPropertiesXform(),
          outlinePr: new OutlinePropertiesXform()
        };
      }
      get tag() {
        return "sheetPr";
      }
      render(xmlStream, model) {
        if (model) {
          xmlStream.addRollback();
          xmlStream.openNode("sheetPr");
          let inner = false;
          inner = this.map.tabColor.render(xmlStream, model.tabColor) || inner;
          inner = this.map.pageSetUpPr.render(xmlStream, model.pageSetup) || inner;
          inner = this.map.outlinePr.render(xmlStream, model.outlineProperties) || inner;
          if (inner) {
            xmlStream.closeNode();
            xmlStream.commit();
          } else {
            xmlStream.rollback();
          }
        }
      }
      parseOpen(node) {
        if (this.parser) {
          this.parser.parseOpen(node);
          return true;
        }
        if (node.name === this.tag) {
          this.reset();
          return true;
        }
        if (this.map[node.name]) {
          this.parser = this.map[node.name];
          this.parser.parseOpen(node);
          return true;
        }
        return false;
      }
      parseText(text) {
        if (this.parser) {
          this.parser.parseText(text);
          return true;
        }
        return false;
      }
      parseClose(name) {
        if (this.parser) {
          if (!this.parser.parseClose(name)) {
            this.parser = void 0;
          }
          return true;
        }
        if (this.map.tabColor.model || this.map.pageSetUpPr.model || this.map.outlinePr.model) {
          this.model = {};
          if (this.map.tabColor.model) {
            this.model.tabColor = this.map.tabColor.model;
          }
          if (this.map.pageSetUpPr.model) {
            this.model.pageSetup = this.map.pageSetUpPr.model;
          }
          if (this.map.outlinePr.model) {
            this.model.outlineProperties = this.map.outlinePr.model;
          }
        } else {
          this.model = null;
        }
        return false;
      }
    };
    module2.exports = SheetPropertiesXform;
  }
});

// ../../../node_modules/exceljs/lib/xlsx/xform/sheet/sheet-format-properties-xform.js
var require_sheet_format_properties_xform = __commonJS({
  "../../../node_modules/exceljs/lib/xlsx/xform/sheet/sheet-format-properties-xform.js"(exports2, module2) {
    var _2 = require_under_dash();
    var BaseXform = require_base_xform();
    var SheetFormatPropertiesXform = class extends BaseXform {
      get tag() {
        return "sheetFormatPr";
      }
      render(xmlStream, model) {
        if (model) {
          const attributes = {
            defaultRowHeight: model.defaultRowHeight,
            outlineLevelRow: model.outlineLevelRow,
            outlineLevelCol: model.outlineLevelCol,
            "x14ac:dyDescent": model.dyDescent
          };
          if (model.defaultColWidth) {
            attributes.defaultColWidth = model.defaultColWidth;
          }
          if (!model.defaultRowHeight || model.defaultRowHeight !== 15) {
            attributes.customHeight = "1";
          }
          if (_2.some(attributes, (value) => value !== void 0)) {
            xmlStream.leafNode("sheetFormatPr", attributes);
          }
        }
      }
      parseOpen(node) {
        if (node.name === "sheetFormatPr") {
          this.model = {
            defaultRowHeight: parseFloat(node.attributes.defaultRowHeight || "0"),
            dyDescent: parseFloat(node.attributes["x14ac:dyDescent"] || "0"),
            outlineLevelRow: parseInt(node.attributes.outlineLevelRow || "0", 10),
            outlineLevelCol: parseInt(node.attributes.outlineLevelCol || "0", 10)
          };
          if (node.attributes.defaultColWidth) {
            this.model.defaultColWidth = parseFloat(node.attributes.defaultColWidth);
          }
          return true;
        }
        return false;
      }
      parseText() {
      }
      parseClose() {
        return false;
      }
    };
    module2.exports = SheetFormatPropertiesXform;
  }
});

// ../../../node_modules/exceljs/lib/xlsx/xform/sheet/sheet-view-xform.js
var require_sheet_view_xform = __commonJS({
  "../../../node_modules/exceljs/lib/xlsx/xform/sheet/sheet-view-xform.js"(exports2, module2) {
    var colCache = require_col_cache();
    var BaseXform = require_base_xform();
    var VIEW_STATES = {
      frozen: "frozen",
      frozenSplit: "frozen",
      split: "split"
    };
    var SheetViewXform = class extends BaseXform {
      get tag() {
        return "sheetView";
      }
      prepare(model) {
        switch (model.state) {
          case "frozen":
          case "split":
            break;
          default:
            model.state = "normal";
            break;
        }
      }
      render(xmlStream, model) {
        xmlStream.openNode("sheetView", {
          workbookViewId: model.workbookViewId || 0
        });
        const add = function(name, value, included) {
          if (included) {
            xmlStream.addAttribute(name, value);
          }
        };
        add("rightToLeft", "1", model.rightToLeft === true);
        add("tabSelected", "1", model.tabSelected);
        add("showRuler", "0", model.showRuler === false);
        add("showRowColHeaders", "0", model.showRowColHeaders === false);
        add("showGridLines", "0", model.showGridLines === false);
        add("zoomScale", model.zoomScale, model.zoomScale);
        add("zoomScaleNormal", model.zoomScaleNormal, model.zoomScaleNormal);
        add("view", model.style, model.style);
        let topLeftCell;
        let xSplit;
        let ySplit;
        let activePane;
        switch (model.state) {
          case "frozen":
            xSplit = model.xSplit || 0;
            ySplit = model.ySplit || 0;
            topLeftCell = model.topLeftCell || colCache.getAddress(ySplit + 1, xSplit + 1).address;
            activePane = model.xSplit && model.ySplit && "bottomRight" || model.xSplit && "topRight" || "bottomLeft";
            xmlStream.leafNode("pane", {
              xSplit: model.xSplit || void 0,
              ySplit: model.ySplit || void 0,
              topLeftCell,
              activePane,
              state: "frozen"
            });
            xmlStream.leafNode("selection", {
              pane: activePane,
              activeCell: model.activeCell,
              sqref: model.activeCell
            });
            break;
          case "split":
            if (model.activePane === "topLeft") {
              model.activePane = void 0;
            }
            xmlStream.leafNode("pane", {
              xSplit: model.xSplit || void 0,
              ySplit: model.ySplit || void 0,
              topLeftCell: model.topLeftCell,
              activePane: model.activePane
            });
            xmlStream.leafNode("selection", {
              pane: model.activePane,
              activeCell: model.activeCell,
              sqref: model.activeCell
            });
            break;
          case "normal":
            if (model.activeCell) {
              xmlStream.leafNode("selection", {
                activeCell: model.activeCell,
                sqref: model.activeCell
              });
            }
            break;
          default:
            break;
        }
        xmlStream.closeNode();
      }
      parseOpen(node) {
        switch (node.name) {
          case "sheetView":
            this.sheetView = {
              workbookViewId: parseInt(node.attributes.workbookViewId, 10),
              rightToLeft: node.attributes.rightToLeft === "1",
              tabSelected: node.attributes.tabSelected === "1",
              showRuler: !(node.attributes.showRuler === "0"),
              showRowColHeaders: !(node.attributes.showRowColHeaders === "0"),
              showGridLines: !(node.attributes.showGridLines === "0"),
              zoomScale: parseInt(node.attributes.zoomScale || "100", 10),
              zoomScaleNormal: parseInt(node.attributes.zoomScaleNormal || "100", 10),
              style: node.attributes.view
            };
            this.pane = void 0;
            this.selections = {};
            return true;
          case "pane":
            this.pane = {
              xSplit: parseInt(node.attributes.xSplit || "0", 10),
              ySplit: parseInt(node.attributes.ySplit || "0", 10),
              topLeftCell: node.attributes.topLeftCell,
              activePane: node.attributes.activePane || "topLeft",
              state: node.attributes.state
            };
            return true;
          case "selection": {
            const name = node.attributes.pane || "topLeft";
            this.selections[name] = {
              pane: name,
              activeCell: node.attributes.activeCell
            };
            return true;
          }
          default:
            return false;
        }
      }
      parseText() {
      }
      parseClose(name) {
        let model;
        let selection;
        switch (name) {
          case "sheetView":
            if (this.sheetView && this.pane) {
              model = this.model = {
                workbookViewId: this.sheetView.workbookViewId,
                rightToLeft: this.sheetView.rightToLeft,
                state: VIEW_STATES[this.pane.state] || "split",
                // split is default
                xSplit: this.pane.xSplit,
                ySplit: this.pane.ySplit,
                topLeftCell: this.pane.topLeftCell,
                showRuler: this.sheetView.showRuler,
                showRowColHeaders: this.sheetView.showRowColHeaders,
                showGridLines: this.sheetView.showGridLines,
                zoomScale: this.sheetView.zoomScale,
                zoomScaleNormal: this.sheetView.zoomScaleNormal
              };
              if (this.model.state === "split") {
                model.activePane = this.pane.activePane;
              }
              selection = this.selections[this.pane.activePane];
              if (selection && selection.activeCell) {
                model.activeCell = selection.activeCell;
              }
              if (this.sheetView.style) {
                model.style = this.sheetView.style;
              }
            } else {
              model = this.model = {
                workbookViewId: this.sheetView.workbookViewId,
                rightToLeft: this.sheetView.rightToLeft,
                state: "normal",
                showRuler: this.sheetView.showRuler,
                showRowColHeaders: this.sheetView.showRowColHeaders,
                showGridLines: this.sheetView.showGridLines,
                zoomScale: this.sheetView.zoomScale,
                zoomScaleNormal: this.sheetView.zoomScaleNormal
              };
              selection = this.selections.topLeft;
              if (selection && selection.activeCell) {
                model.activeCell = selection.activeCell;
              }
              if (this.sheetView.style) {
                model.style = this.sheetView.style;
              }
            }
            return false;
          default:
            return true;
        }
      }
      reconcile() {
      }
    };
    module2.exports = SheetViewXform;
  }
});

// ../../../node_modules/exceljs/lib/xlsx/xform/sheet/sheet-protection-xform.js
var require_sheet_protection_xform = __commonJS({
  "../../../node_modules/exceljs/lib/xlsx/xform/sheet/sheet-protection-xform.js"(exports2, module2) {
    var _2 = require_under_dash();
    var BaseXform = require_base_xform();
    function booleanToXml(model, value) {
      return model ? value : void 0;
    }
    function xmlToBoolean(value, equals) {
      return value === equals ? true : void 0;
    }
    var SheetProtectionXform = class extends BaseXform {
      get tag() {
        return "sheetProtection";
      }
      render(xmlStream, model) {
        if (model) {
          const attributes = {
            sheet: booleanToXml(model.sheet, "1"),
            selectLockedCells: model.selectLockedCells === false ? "1" : void 0,
            selectUnlockedCells: model.selectUnlockedCells === false ? "1" : void 0,
            formatCells: booleanToXml(model.formatCells, "0"),
            formatColumns: booleanToXml(model.formatColumns, "0"),
            formatRows: booleanToXml(model.formatRows, "0"),
            insertColumns: booleanToXml(model.insertColumns, "0"),
            insertRows: booleanToXml(model.insertRows, "0"),
            insertHyperlinks: booleanToXml(model.insertHyperlinks, "0"),
            deleteColumns: booleanToXml(model.deleteColumns, "0"),
            deleteRows: booleanToXml(model.deleteRows, "0"),
            sort: booleanToXml(model.sort, "0"),
            autoFilter: booleanToXml(model.autoFilter, "0"),
            pivotTables: booleanToXml(model.pivotTables, "0")
          };
          if (model.sheet) {
            attributes.algorithmName = model.algorithmName;
            attributes.hashValue = model.hashValue;
            attributes.saltValue = model.saltValue;
            attributes.spinCount = model.spinCount;
            attributes.objects = booleanToXml(model.objects === false, "1");
            attributes.scenarios = booleanToXml(model.scenarios === false, "1");
          }
          if (_2.some(attributes, (value) => value !== void 0)) {
            xmlStream.leafNode(this.tag, attributes);
          }
        }
      }
      parseOpen(node) {
        switch (node.name) {
          case this.tag:
            this.model = {
              sheet: xmlToBoolean(node.attributes.sheet, "1"),
              objects: node.attributes.objects === "1" ? false : void 0,
              scenarios: node.attributes.scenarios === "1" ? false : void 0,
              selectLockedCells: node.attributes.selectLockedCells === "1" ? false : void 0,
              selectUnlockedCells: node.attributes.selectUnlockedCells === "1" ? false : void 0,
              formatCells: xmlToBoolean(node.attributes.formatCells, "0"),
              formatColumns: xmlToBoolean(node.attributes.formatColumns, "0"),
              formatRows: xmlToBoolean(node.attributes.formatRows, "0"),
              insertColumns: xmlToBoolean(node.attributes.insertColumns, "0"),
              insertRows: xmlToBoolean(node.attributes.insertRows, "0"),
              insertHyperlinks: xmlToBoolean(node.attributes.insertHyperlinks, "0"),
              deleteColumns: xmlToBoolean(node.attributes.deleteColumns, "0"),
              deleteRows: xmlToBoolean(node.attributes.deleteRows, "0"),
              sort: xmlToBoolean(node.attributes.sort, "0"),
              autoFilter: xmlToBoolean(node.attributes.autoFilter, "0"),
              pivotTables: xmlToBoolean(node.attributes.pivotTables, "0")
            };
            if (node.attributes.algorithmName) {
              this.model.algorithmName = node.attributes.algorithmName;
              this.model.hashValue = node.attributes.hashValue;
              this.model.saltValue = node.attributes.saltValue;
              this.model.spinCount = parseInt(node.attributes.spinCount, 10);
            }
            return true;
          default:
            return false;
        }
      }
      parseText() {
      }
      parseClose() {
        return false;
      }
    };
    module2.exports = SheetProtectionXform;
  }
});

// ../../../node_modules/exceljs/lib/xlsx/xform/sheet/page-margins-xform.js
var require_page_margins_xform = __commonJS({
  "../../../node_modules/exceljs/lib/xlsx/xform/sheet/page-margins-xform.js"(exports2, module2) {
    var _2 = require_under_dash();
    var BaseXform = require_base_xform();
    var PageMarginsXform = class extends BaseXform {
      get tag() {
        return "pageMargins";
      }
      render(xmlStream, model) {
        if (model) {
          const attributes = {
            left: model.left,
            right: model.right,
            top: model.top,
            bottom: model.bottom,
            header: model.header,
            footer: model.footer
          };
          if (_2.some(attributes, (value) => value !== void 0)) {
            xmlStream.leafNode(this.tag, attributes);
          }
        }
      }
      parseOpen(node) {
        switch (node.name) {
          case this.tag:
            this.model = {
              left: parseFloat(node.attributes.left || 0.7),
              right: parseFloat(node.attributes.right || 0.7),
              top: parseFloat(node.attributes.top || 0.75),
              bottom: parseFloat(node.attributes.bottom || 0.75),
              header: parseFloat(node.attributes.header || 0.3),
              footer: parseFloat(node.attributes.footer || 0.3)
            };
            return true;
          default:
            return false;
        }
      }
      parseText() {
      }
      parseClose() {
        return false;
      }
    };
    module2.exports = PageMarginsXform;
  }
});

// ../../../node_modules/exceljs/lib/xlsx/xform/sheet/page-setup-xform.js
var require_page_setup_xform = __commonJS({
  "../../../node_modules/exceljs/lib/xlsx/xform/sheet/page-setup-xform.js"(exports2, module2) {
    var _2 = require_under_dash();
    var BaseXform = require_base_xform();
    function booleanToXml(model) {
      return model ? "1" : void 0;
    }
    function pageOrderToXml(model) {
      switch (model) {
        case "overThenDown":
          return model;
        default:
          return void 0;
      }
    }
    function cellCommentsToXml(model) {
      switch (model) {
        case "atEnd":
        case "asDisplyed":
          return model;
        default:
          return void 0;
      }
    }
    function errorsToXml(model) {
      switch (model) {
        case "dash":
        case "blank":
        case "NA":
          return model;
        default:
          return void 0;
      }
    }
    function pageSizeToModel(value) {
      return value !== void 0 ? parseInt(value, 10) : void 0;
    }
    var PageSetupXform = class extends BaseXform {
      get tag() {
        return "pageSetup";
      }
      render(xmlStream, model) {
        if (model) {
          const attributes = {
            paperSize: model.paperSize,
            orientation: model.orientation,
            horizontalDpi: model.horizontalDpi,
            verticalDpi: model.verticalDpi,
            pageOrder: pageOrderToXml(model.pageOrder),
            blackAndWhite: booleanToXml(model.blackAndWhite),
            draft: booleanToXml(model.draft),
            cellComments: cellCommentsToXml(model.cellComments),
            errors: errorsToXml(model.errors),
            scale: model.scale,
            fitToWidth: model.fitToWidth,
            fitToHeight: model.fitToHeight,
            firstPageNumber: model.firstPageNumber,
            useFirstPageNumber: booleanToXml(model.firstPageNumber),
            usePrinterDefaults: booleanToXml(model.usePrinterDefaults),
            copies: model.copies
          };
          if (_2.some(attributes, (value) => value !== void 0)) {
            xmlStream.leafNode(this.tag, attributes);
          }
        }
      }
      parseOpen(node) {
        switch (node.name) {
          case this.tag:
            this.model = {
              paperSize: pageSizeToModel(node.attributes.paperSize),
              orientation: node.attributes.orientation || "portrait",
              horizontalDpi: parseInt(node.attributes.horizontalDpi || "4294967295", 10),
              verticalDpi: parseInt(node.attributes.verticalDpi || "4294967295", 10),
              pageOrder: node.attributes.pageOrder || "downThenOver",
              blackAndWhite: node.attributes.blackAndWhite === "1",
              draft: node.attributes.draft === "1",
              cellComments: node.attributes.cellComments || "None",
              errors: node.attributes.errors || "displayed",
              scale: parseInt(node.attributes.scale || "100", 10),
              fitToWidth: parseInt(node.attributes.fitToWidth || "1", 10),
              fitToHeight: parseInt(node.attributes.fitToHeight || "1", 10),
              firstPageNumber: parseInt(node.attributes.firstPageNumber || "1", 10),
              useFirstPageNumber: node.attributes.useFirstPageNumber === "1",
              usePrinterDefaults: node.attributes.usePrinterDefaults === "1",
              copies: parseInt(node.attributes.copies || "1", 10)
            };
            return true;
          default:
            return false;
        }
      }
      parseText() {
      }
      parseClose() {
        return false;
      }
    };
    module2.exports = PageSetupXform;
  }
});

// ../../../node_modules/exceljs/lib/xlsx/xform/sheet/print-options-xform.js
var require_print_options_xform = __commonJS({
  "../../../node_modules/exceljs/lib/xlsx/xform/sheet/print-options-xform.js"(exports2, module2) {
    var _2 = require_under_dash();
    var BaseXform = require_base_xform();
    function booleanToXml(model) {
      return model ? "1" : void 0;
    }
    var PrintOptionsXform = class extends BaseXform {
      get tag() {
        return "printOptions";
      }
      render(xmlStream, model) {
        if (model) {
          const attributes = {
            headings: booleanToXml(model.showRowColHeaders),
            gridLines: booleanToXml(model.showGridLines),
            horizontalCentered: booleanToXml(model.horizontalCentered),
            verticalCentered: booleanToXml(model.verticalCentered)
          };
          if (_2.some(attributes, (value) => value !== void 0)) {
            xmlStream.leafNode(this.tag, attributes);
          }
        }
      }
      parseOpen(node) {
        switch (node.name) {
          case this.tag:
            this.model = {
              showRowColHeaders: node.attributes.headings === "1",
              showGridLines: node.attributes.gridLines === "1",
              horizontalCentered: node.attributes.horizontalCentered === "1",
              verticalCentered: node.attributes.verticalCentered === "1"
            };
            return true;
          default:
            return false;
        }
      }
      parseText() {
      }
      parseClose() {
        return false;
      }
    };
    module2.exports = PrintOptionsXform;
  }
});

// ../../../node_modules/exceljs/lib/xlsx/xform/sheet/auto-filter-xform.js
var require_auto_filter_xform = __commonJS({
  "../../../node_modules/exceljs/lib/xlsx/xform/sheet/auto-filter-xform.js"(exports2, module2) {
    var colCache = require_col_cache();
    var BaseXform = require_base_xform();
    var AutoFilterXform = class extends BaseXform {
      get tag() {
        return "autoFilter";
      }
      render(xmlStream, model) {
        if (model) {
          if (typeof model === "string") {
            xmlStream.leafNode("autoFilter", { ref: model });
          } else {
            const getAddress = function(addr) {
              if (typeof addr === "string") {
                return addr;
              }
              return colCache.getAddress(addr.row, addr.column).address;
            };
            const firstAddress = getAddress(model.from);
            const secondAddress = getAddress(model.to);
            if (firstAddress && secondAddress) {
              xmlStream.leafNode("autoFilter", { ref: `${firstAddress}:${secondAddress}` });
            }
          }
        }
      }
      parseOpen(node) {
        if (node.name === "autoFilter") {
          this.model = node.attributes.ref;
        }
      }
    };
    module2.exports = AutoFilterXform;
  }
});

// ../../../node_modules/exceljs/lib/xlsx/xform/sheet/picture-xform.js
var require_picture_xform = __commonJS({
  "../../../node_modules/exceljs/lib/xlsx/xform/sheet/picture-xform.js"(exports2, module2) {
    var BaseXform = require_base_xform();
    var PictureXform = class extends BaseXform {
      get tag() {
        return "picture";
      }
      render(xmlStream, model) {
        if (model) {
          xmlStream.leafNode(this.tag, { "r:id": model.rId });
        }
      }
      parseOpen(node) {
        switch (node.name) {
          case this.tag:
            this.model = {
              rId: node.attributes["r:id"]
            };
            return true;
          default:
            return false;
        }
      }
      parseText() {
      }
      parseClose() {
        return false;
      }
    };
    module2.exports = PictureXform;
  }
});

// ../../../node_modules/exceljs/lib/xlsx/xform/sheet/drawing-xform.js
var require_drawing_xform = __commonJS({
  "../../../node_modules/exceljs/lib/xlsx/xform/sheet/drawing-xform.js"(exports2, module2) {
    var BaseXform = require_base_xform();
    var DrawingXform = class extends BaseXform {
      get tag() {
        return "drawing";
      }
      render(xmlStream, model) {
        if (model) {
          xmlStream.leafNode(this.tag, { "r:id": model.rId });
        }
      }
      parseOpen(node) {
        switch (node.name) {
          case this.tag:
            this.model = {
              rId: node.attributes["r:id"]
            };
            return true;
          default:
            return false;
        }
      }
      parseText() {
      }
      parseClose() {
        return false;
      }
    };
    module2.exports = DrawingXform;
  }
});

// ../../../node_modules/exceljs/lib/xlsx/xform/sheet/table-part-xform.js
var require_table_part_xform = __commonJS({
  "../../../node_modules/exceljs/lib/xlsx/xform/sheet/table-part-xform.js"(exports2, module2) {
    var BaseXform = require_base_xform();
    var TablePartXform = class extends BaseXform {
      get tag() {
        return "tablePart";
      }
      render(xmlStream, model) {
        if (model) {
          xmlStream.leafNode(this.tag, { "r:id": model.rId });
        }
      }
      parseOpen(node) {
        switch (node.name) {
          case this.tag:
            this.model = {
              rId: node.attributes["r:id"]
            };
            return true;
          default:
            return false;
        }
      }
      parseText() {
      }
      parseClose() {
        return false;
      }
    };
    module2.exports = TablePartXform;
  }
});

// ../../../node_modules/exceljs/lib/xlsx/xform/sheet/page-breaks-xform.js
var require_page_breaks_xform = __commonJS({
  "../../../node_modules/exceljs/lib/xlsx/xform/sheet/page-breaks-xform.js"(exports2, module2) {
    var BaseXform = require_base_xform();
    var PageBreaksXform = class extends BaseXform {
      get tag() {
        return "brk";
      }
      render(xmlStream, model) {
        xmlStream.leafNode("brk", model);
      }
      parseOpen(node) {
        if (node.name === "brk") {
          this.model = node.attributes.ref;
          return true;
        }
        return false;
      }
      parseText() {
      }
      parseClose() {
        return false;
      }
    };
    module2.exports = PageBreaksXform;
  }
});

// ../../../node_modules/exceljs/lib/xlsx/xform/sheet/row-breaks-xform.js
var require_row_breaks_xform = __commonJS({
  "../../../node_modules/exceljs/lib/xlsx/xform/sheet/row-breaks-xform.js"(exports2, module2) {
    "use strict";
    var PageBreaksXform = require_page_breaks_xform();
    var ListXform = require_list_xform();
    var RowBreaksXform = class extends ListXform {
      constructor() {
        const options = {
          tag: "rowBreaks",
          count: true,
          childXform: new PageBreaksXform()
        };
        super(options);
      }
      // get tag() { return 'rowBreaks'; }
      render(xmlStream, model) {
        if (model && model.length) {
          xmlStream.openNode(this.tag, this.$);
          if (this.count) {
            xmlStream.addAttribute(this.$count, model.length);
            xmlStream.addAttribute("manualBreakCount", model.length);
          }
          const { childXform } = this;
          model.forEach((childModel) => {
            childXform.render(xmlStream, childModel);
          });
          xmlStream.closeNode();
        } else if (this.empty) {
          xmlStream.leafNode(this.tag);
        }
      }
    };
    module2.exports = RowBreaksXform;
  }
});

// ../../../node_modules/exceljs/lib/xlsx/xform/sheet/header-footer-xform.js
var require_header_footer_xform = __commonJS({
  "../../../node_modules/exceljs/lib/xlsx/xform/sheet/header-footer-xform.js"(exports2, module2) {
    var BaseXform = require_base_xform();
    var HeaderFooterXform = class extends BaseXform {
      get tag() {
        return "headerFooter";
      }
      render(xmlStream, model) {
        if (model) {
          xmlStream.addRollback();
          let createTag = false;
          xmlStream.openNode("headerFooter");
          if (model.differentFirst) {
            xmlStream.addAttribute("differentFirst", "1");
            createTag = true;
          }
          if (model.differentOddEven) {
            xmlStream.addAttribute("differentOddEven", "1");
            createTag = true;
          }
          if (model.oddHeader && typeof model.oddHeader === "string") {
            xmlStream.leafNode("oddHeader", null, model.oddHeader);
            createTag = true;
          }
          if (model.oddFooter && typeof model.oddFooter === "string") {
            xmlStream.leafNode("oddFooter", null, model.oddFooter);
            createTag = true;
          }
          if (model.evenHeader && typeof model.evenHeader === "string") {
            xmlStream.leafNode("evenHeader", null, model.evenHeader);
            createTag = true;
          }
          if (model.evenFooter && typeof model.evenFooter === "string") {
            xmlStream.leafNode("evenFooter", null, model.evenFooter);
            createTag = true;
          }
          if (model.firstHeader && typeof model.firstHeader === "string") {
            xmlStream.leafNode("firstHeader", null, model.firstHeader);
            createTag = true;
          }
          if (model.firstFooter && typeof model.firstFooter === "string") {
            xmlStream.leafNode("firstFooter", null, model.firstFooter);
            createTag = true;
          }
          if (createTag) {
            xmlStream.closeNode();
            xmlStream.commit();
          } else {
            xmlStream.rollback();
          }
        }
      }
      parseOpen(node) {
        switch (node.name) {
          case "headerFooter":
            this.model = {};
            if (node.attributes.differentFirst) {
              this.model.differentFirst = parseInt(node.attributes.differentFirst, 0) === 1;
            }
            if (node.attributes.differentOddEven) {
              this.model.differentOddEven = parseInt(node.attributes.differentOddEven, 0) === 1;
            }
            return true;
          case "oddHeader":
            this.currentNode = "oddHeader";
            return true;
          case "oddFooter":
            this.currentNode = "oddFooter";
            return true;
          case "evenHeader":
            this.currentNode = "evenHeader";
            return true;
          case "evenFooter":
            this.currentNode = "evenFooter";
            return true;
          case "firstHeader":
            this.currentNode = "firstHeader";
            return true;
          case "firstFooter":
            this.currentNode = "firstFooter";
            return true;
          default:
            return false;
        }
      }
      parseText(text) {
        switch (this.currentNode) {
          case "oddHeader":
            this.model.oddHeader = text;
            break;
          case "oddFooter":
            this.model.oddFooter = text;
            break;
          case "evenHeader":
            this.model.evenHeader = text;
            break;
          case "evenFooter":
            this.model.evenFooter = text;
            break;
          case "firstHeader":
            this.model.firstHeader = text;
            break;
          case "firstFooter":
            this.model.firstFooter = text;
            break;
          default:
            break;
        }
      }
      parseClose() {
        switch (this.currentNode) {
          case "oddHeader":
          case "oddFooter":
          case "evenHeader":
          case "evenFooter":
          case "firstHeader":
          case "firstFooter":
            this.currentNode = void 0;
            return true;
          default:
            return false;
        }
      }
    };
    module2.exports = HeaderFooterXform;
  }
});

// ../../../node_modules/exceljs/lib/xlsx/xform/composite-xform.js
var require_composite_xform = __commonJS({
  "../../../node_modules/exceljs/lib/xlsx/xform/composite-xform.js"(exports2, module2) {
    var BaseXform = require_base_xform();
    var CompositeXform = class extends BaseXform {
      createNewModel(node) {
        return {};
      }
      parseOpen(node) {
        this.parser = this.parser || this.map[node.name];
        if (this.parser) {
          this.parser.parseOpen(node);
          return true;
        }
        if (node.name === this.tag) {
          this.model = this.createNewModel(node);
          return true;
        }
        return false;
      }
      parseText(text) {
        if (this.parser) {
          this.parser.parseText(text);
        }
      }
      onParserClose(name, parser) {
        this.model[name] = parser.model;
      }
      parseClose(name) {
        if (this.parser) {
          if (!this.parser.parseClose(name)) {
            this.onParserClose(name, this.parser);
            this.parser = void 0;
          }
          return true;
        }
        return name !== this.tag;
      }
    };
    module2.exports = CompositeXform;
  }
});

// ../../../node_modules/exceljs/lib/xlsx/xform/sheet/cf/cfvo-xform.js
var require_cfvo_xform = __commonJS({
  "../../../node_modules/exceljs/lib/xlsx/xform/sheet/cf/cfvo-xform.js"(exports2, module2) {
    var BaseXform = require_base_xform();
    var CfvoXform = class extends BaseXform {
      get tag() {
        return "cfvo";
      }
      render(xmlStream, model) {
        xmlStream.leafNode(this.tag, {
          type: model.type,
          val: model.value
        });
      }
      parseOpen(node) {
        this.model = {
          type: node.attributes.type,
          value: BaseXform.toFloatValue(node.attributes.val)
        };
      }
      parseClose(name) {
        return name !== this.tag;
      }
    };
    module2.exports = CfvoXform;
  }
});

// ../../../node_modules/exceljs/lib/xlsx/xform/sheet/cf/databar-xform.js
var require_databar_xform = __commonJS({
  "../../../node_modules/exceljs/lib/xlsx/xform/sheet/cf/databar-xform.js"(exports2, module2) {
    var CompositeXform = require_composite_xform();
    var ColorXform = require_color_xform();
    var CfvoXform = require_cfvo_xform();
    var DatabarXform = class extends CompositeXform {
      constructor() {
        super();
        this.map = {
          cfvo: this.cfvoXform = new CfvoXform(),
          color: this.colorXform = new ColorXform()
        };
      }
      get tag() {
        return "dataBar";
      }
      render(xmlStream, model) {
        xmlStream.openNode(this.tag);
        model.cfvo.forEach((cfvo) => {
          this.cfvoXform.render(xmlStream, cfvo);
        });
        this.colorXform.render(xmlStream, model.color);
        xmlStream.closeNode();
      }
      createNewModel() {
        return {
          cfvo: []
        };
      }
      onParserClose(name, parser) {
        switch (name) {
          case "cfvo":
            this.model.cfvo.push(parser.model);
            break;
          case "color":
            this.model.color = parser.model;
            break;
        }
      }
    };
    module2.exports = DatabarXform;
  }
});

// ../../../node_modules/exceljs/lib/xlsx/xform/sheet/cf/ext-lst-ref-xform.js
var require_ext_lst_ref_xform = __commonJS({
  "../../../node_modules/exceljs/lib/xlsx/xform/sheet/cf/ext-lst-ref-xform.js"(exports2, module2) {
    var BaseXform = require_base_xform();
    var CompositeXform = require_composite_xform();
    var X14IdXform = class extends BaseXform {
      get tag() {
        return "x14:id";
      }
      render(xmlStream, model) {
        xmlStream.leafNode(this.tag, null, model);
      }
      parseOpen() {
        this.model = "";
      }
      parseText(text) {
        this.model += text;
      }
      parseClose(name) {
        return name !== this.tag;
      }
    };
    var ExtXform = class extends CompositeXform {
      constructor() {
        super();
        this.map = {
          "x14:id": this.idXform = new X14IdXform()
        };
      }
      get tag() {
        return "ext";
      }
      render(xmlStream, model) {
        xmlStream.openNode(this.tag, {
          uri: "{B025F937-C7B1-47D3-B67F-A62EFF666E3E}",
          "xmlns:x14": "http://schemas.microsoft.com/office/spreadsheetml/2009/9/main"
        });
        this.idXform.render(xmlStream, model.x14Id);
        xmlStream.closeNode();
      }
      createNewModel() {
        return {};
      }
      onParserClose(name, parser) {
        this.model.x14Id = parser.model;
      }
    };
    var ExtLstRefXform = class extends CompositeXform {
      constructor() {
        super();
        this.map = {
          ext: new ExtXform()
        };
      }
      get tag() {
        return "extLst";
      }
      render(xmlStream, model) {
        xmlStream.openNode(this.tag);
        this.map.ext.render(xmlStream, model);
        xmlStream.closeNode();
      }
      createNewModel() {
        return {};
      }
      onParserClose(name, parser) {
        Object.assign(this.model, parser.model);
      }
    };
    module2.exports = ExtLstRefXform;
  }
});

// ../../../node_modules/exceljs/lib/xlsx/xform/sheet/cf/formula-xform.js
var require_formula_xform = __commonJS({
  "../../../node_modules/exceljs/lib/xlsx/xform/sheet/cf/formula-xform.js"(exports2, module2) {
    var BaseXform = require_base_xform();
    var FormulaXform = class extends BaseXform {
      get tag() {
        return "formula";
      }
      render(xmlStream, model) {
        xmlStream.leafNode(this.tag, null, model);
      }
      parseOpen() {
        this.model = "";
      }
      parseText(text) {
        this.model += text;
      }
      parseClose(name) {
        return name !== this.tag;
      }
    };
    module2.exports = FormulaXform;
  }
});

// ../../../node_modules/exceljs/lib/xlsx/xform/sheet/cf/color-scale-xform.js
var require_color_scale_xform = __commonJS({
  "../../../node_modules/exceljs/lib/xlsx/xform/sheet/cf/color-scale-xform.js"(exports2, module2) {
    var CompositeXform = require_composite_xform();
    var ColorXform = require_color_xform();
    var CfvoXform = require_cfvo_xform();
    var ColorScaleXform = class extends CompositeXform {
      constructor() {
        super();
        this.map = {
          cfvo: this.cfvoXform = new CfvoXform(),
          color: this.colorXform = new ColorXform()
        };
      }
      get tag() {
        return "colorScale";
      }
      render(xmlStream, model) {
        xmlStream.openNode(this.tag);
        model.cfvo.forEach((cfvo) => {
          this.cfvoXform.render(xmlStream, cfvo);
        });
        model.color.forEach((color) => {
          this.colorXform.render(xmlStream, color);
        });
        xmlStream.closeNode();
      }
      createNewModel(node) {
        return {
          cfvo: [],
          color: []
        };
      }
      onParserClose(name, parser) {
        this.model[name].push(parser.model);
      }
    };
    module2.exports = ColorScaleXform;
  }
});

// ../../../node_modules/exceljs/lib/xlsx/xform/sheet/cf/icon-set-xform.js
var require_icon_set_xform = __commonJS({
  "../../../node_modules/exceljs/lib/xlsx/xform/sheet/cf/icon-set-xform.js"(exports2, module2) {
    var BaseXform = require_base_xform();
    var CompositeXform = require_composite_xform();
    var CfvoXform = require_cfvo_xform();
    var IconSetXform = class extends CompositeXform {
      constructor() {
        super();
        this.map = {
          cfvo: this.cfvoXform = new CfvoXform()
        };
      }
      get tag() {
        return "iconSet";
      }
      render(xmlStream, model) {
        xmlStream.openNode(this.tag, {
          iconSet: BaseXform.toStringAttribute(model.iconSet, "3TrafficLights"),
          reverse: BaseXform.toBoolAttribute(model.reverse, false),
          showValue: BaseXform.toBoolAttribute(model.showValue, true)
        });
        model.cfvo.forEach((cfvo) => {
          this.cfvoXform.render(xmlStream, cfvo);
        });
        xmlStream.closeNode();
      }
      createNewModel({ attributes }) {
        return {
          iconSet: BaseXform.toStringValue(attributes.iconSet, "3TrafficLights"),
          reverse: BaseXform.toBoolValue(attributes.reverse),
          showValue: BaseXform.toBoolValue(attributes.showValue),
          cfvo: []
        };
      }
      onParserClose(name, parser) {
        this.model[name].push(parser.model);
      }
    };
    module2.exports = IconSetXform;
  }
});

// ../../../node_modules/exceljs/lib/xlsx/xform/sheet/cf/cf-rule-xform.js
var require_cf_rule_xform = __commonJS({
  "../../../node_modules/exceljs/lib/xlsx/xform/sheet/cf/cf-rule-xform.js"(exports2, module2) {
    var BaseXform = require_base_xform();
    var CompositeXform = require_composite_xform();
    var Range = require_range();
    var DatabarXform = require_databar_xform();
    var ExtLstRefXform = require_ext_lst_ref_xform();
    var FormulaXform = require_formula_xform();
    var ColorScaleXform = require_color_scale_xform();
    var IconSetXform = require_icon_set_xform();
    var extIcons = {
      "3Triangles": true,
      "3Stars": true,
      "5Boxes": true
    };
    var getTextFormula = (model) => {
      if (model.formulae && model.formulae[0]) {
        return model.formulae[0];
      }
      const range = new Range(model.ref);
      const { tl } = range;
      switch (model.operator) {
        case "containsText":
          return `NOT(ISERROR(SEARCH("${model.text}",${tl})))`;
        case "containsBlanks":
          return `LEN(TRIM(${tl}))=0`;
        case "notContainsBlanks":
          return `LEN(TRIM(${tl}))>0`;
        case "containsErrors":
          return `ISERROR(${tl})`;
        case "notContainsErrors":
          return `NOT(ISERROR(${tl}))`;
        default:
          return void 0;
      }
    };
    var getTimePeriodFormula = (model) => {
      if (model.formulae && model.formulae[0]) {
        return model.formulae[0];
      }
      const range = new Range(model.ref);
      const { tl } = range;
      switch (model.timePeriod) {
        case "thisWeek":
          return `AND(TODAY()-ROUNDDOWN(${tl},0)<=WEEKDAY(TODAY())-1,ROUNDDOWN(${tl},0)-TODAY()<=7-WEEKDAY(TODAY()))`;
        case "lastWeek":
          return `AND(TODAY()-ROUNDDOWN(${tl},0)>=(WEEKDAY(TODAY())),TODAY()-ROUNDDOWN(${tl},0)<(WEEKDAY(TODAY())+7))`;
        case "nextWeek":
          return `AND(ROUNDDOWN(${tl},0)-TODAY()>(7-WEEKDAY(TODAY())),ROUNDDOWN(${tl},0)-TODAY()<(15-WEEKDAY(TODAY())))`;
        case "yesterday":
          return `FLOOR(${tl},1)=TODAY()-1`;
        case "today":
          return `FLOOR(${tl},1)=TODAY()`;
        case "tomorrow":
          return `FLOOR(${tl},1)=TODAY()+1`;
        case "last7Days":
          return `AND(TODAY()-FLOOR(${tl},1)<=6,FLOOR(${tl},1)<=TODAY())`;
        case "lastMonth":
          return `AND(MONTH(${tl})=MONTH(EDATE(TODAY(),0-1)),YEAR(${tl})=YEAR(EDATE(TODAY(),0-1)))`;
        case "thisMonth":
          return `AND(MONTH(${tl})=MONTH(TODAY()),YEAR(${tl})=YEAR(TODAY()))`;
        case "nextMonth":
          return `AND(MONTH(${tl})=MONTH(EDATE(TODAY(),0+1)),YEAR(${tl})=YEAR(EDATE(TODAY(),0+1)))`;
        default:
          return void 0;
      }
    };
    var opType = (attributes) => {
      const { type, operator } = attributes;
      switch (type) {
        case "containsText":
        case "containsBlanks":
        case "notContainsBlanks":
        case "containsErrors":
        case "notContainsErrors":
          return {
            type: "containsText",
            operator: type
          };
        default:
          return { type, operator };
      }
    };
    var CfRuleXform = class _CfRuleXform extends CompositeXform {
      constructor() {
        super();
        this.map = {
          dataBar: this.databarXform = new DatabarXform(),
          extLst: this.extLstRefXform = new ExtLstRefXform(),
          formula: this.formulaXform = new FormulaXform(),
          colorScale: this.colorScaleXform = new ColorScaleXform(),
          iconSet: this.iconSetXform = new IconSetXform()
        };
      }
      get tag() {
        return "cfRule";
      }
      static isPrimitive(rule) {
        if (rule.type === "iconSet") {
          if (rule.custom || extIcons[rule.iconSet]) {
            return false;
          }
        }
        return true;
      }
      render(xmlStream, model) {
        switch (model.type) {
          case "expression":
            this.renderExpression(xmlStream, model);
            break;
          case "cellIs":
            this.renderCellIs(xmlStream, model);
            break;
          case "top10":
            this.renderTop10(xmlStream, model);
            break;
          case "aboveAverage":
            this.renderAboveAverage(xmlStream, model);
            break;
          case "dataBar":
            this.renderDataBar(xmlStream, model);
            break;
          case "colorScale":
            this.renderColorScale(xmlStream, model);
            break;
          case "iconSet":
            this.renderIconSet(xmlStream, model);
            break;
          case "containsText":
            this.renderText(xmlStream, model);
            break;
          case "timePeriod":
            this.renderTimePeriod(xmlStream, model);
            break;
        }
      }
      renderExpression(xmlStream, model) {
        xmlStream.openNode(this.tag, {
          type: "expression",
          dxfId: model.dxfId,
          priority: model.priority
        });
        this.formulaXform.render(xmlStream, model.formulae[0]);
        xmlStream.closeNode();
      }
      renderCellIs(xmlStream, model) {
        xmlStream.openNode(this.tag, {
          type: "cellIs",
          dxfId: model.dxfId,
          priority: model.priority,
          operator: model.operator
        });
        model.formulae.forEach((formula) => {
          this.formulaXform.render(xmlStream, formula);
        });
        xmlStream.closeNode();
      }
      renderTop10(xmlStream, model) {
        xmlStream.leafNode(this.tag, {
          type: "top10",
          dxfId: model.dxfId,
          priority: model.priority,
          percent: BaseXform.toBoolAttribute(model.percent, false),
          bottom: BaseXform.toBoolAttribute(model.bottom, false),
          rank: BaseXform.toIntValue(model.rank, 10, true)
        });
      }
      renderAboveAverage(xmlStream, model) {
        xmlStream.leafNode(this.tag, {
          type: "aboveAverage",
          dxfId: model.dxfId,
          priority: model.priority,
          aboveAverage: BaseXform.toBoolAttribute(model.aboveAverage, true)
        });
      }
      renderDataBar(xmlStream, model) {
        xmlStream.openNode(this.tag, {
          type: "dataBar",
          priority: model.priority
        });
        this.databarXform.render(xmlStream, model);
        this.extLstRefXform.render(xmlStream, model);
        xmlStream.closeNode();
      }
      renderColorScale(xmlStream, model) {
        xmlStream.openNode(this.tag, {
          type: "colorScale",
          priority: model.priority
        });
        this.colorScaleXform.render(xmlStream, model);
        xmlStream.closeNode();
      }
      renderIconSet(xmlStream, model) {
        if (!_CfRuleXform.isPrimitive(model)) {
          return;
        }
        xmlStream.openNode(this.tag, {
          type: "iconSet",
          priority: model.priority
        });
        this.iconSetXform.render(xmlStream, model);
        xmlStream.closeNode();
      }
      renderText(xmlStream, model) {
        xmlStream.openNode(this.tag, {
          type: model.operator,
          dxfId: model.dxfId,
          priority: model.priority,
          operator: BaseXform.toStringAttribute(model.operator, "containsText")
        });
        const formula = getTextFormula(model);
        if (formula) {
          this.formulaXform.render(xmlStream, formula);
        }
        xmlStream.closeNode();
      }
      renderTimePeriod(xmlStream, model) {
        xmlStream.openNode(this.tag, {
          type: "timePeriod",
          dxfId: model.dxfId,
          priority: model.priority,
          timePeriod: model.timePeriod
        });
        const formula = getTimePeriodFormula(model);
        if (formula) {
          this.formulaXform.render(xmlStream, formula);
        }
        xmlStream.closeNode();
      }
      createNewModel({ attributes }) {
        return {
          ...opType(attributes),
          dxfId: BaseXform.toIntValue(attributes.dxfId),
          priority: BaseXform.toIntValue(attributes.priority),
          timePeriod: attributes.timePeriod,
          percent: BaseXform.toBoolValue(attributes.percent),
          bottom: BaseXform.toBoolValue(attributes.bottom),
          rank: BaseXform.toIntValue(attributes.rank),
          aboveAverage: BaseXform.toBoolValue(attributes.aboveAverage)
        };
      }
      onParserClose(name, parser) {
        switch (name) {
          case "dataBar":
          case "extLst":
          case "colorScale":
          case "iconSet":
            Object.assign(this.model, parser.model);
            break;
          case "formula":
            this.model.formulae = this.model.formulae || [];
            this.model.formulae.push(parser.model);
            break;
        }
      }
    };
    module2.exports = CfRuleXform;
  }
});

// ../../../node_modules/exceljs/lib/xlsx/xform/sheet/cf/conditional-formatting-xform.js
var require_conditional_formatting_xform = __commonJS({
  "../../../node_modules/exceljs/lib/xlsx/xform/sheet/cf/conditional-formatting-xform.js"(exports2, module2) {
    var CompositeXform = require_composite_xform();
    var CfRuleXform = require_cf_rule_xform();
    var ConditionalFormattingXform = class extends CompositeXform {
      constructor() {
        super();
        this.map = {
          cfRule: new CfRuleXform()
        };
      }
      get tag() {
        return "conditionalFormatting";
      }
      render(xmlStream, model) {
        if (!model.rules.some(CfRuleXform.isPrimitive)) {
          return;
        }
        xmlStream.openNode(this.tag, { sqref: model.ref });
        model.rules.forEach((rule) => {
          if (CfRuleXform.isPrimitive(rule)) {
            rule.ref = model.ref;
            this.map.cfRule.render(xmlStream, rule);
          }
        });
        xmlStream.closeNode();
      }
      createNewModel({ attributes }) {
        return {
          ref: attributes.sqref,
          rules: []
        };
      }
      onParserClose(name, parser) {
        this.model.rules.push(parser.model);
      }
    };
    module2.exports = ConditionalFormattingXform;
  }
});

// ../../../node_modules/exceljs/lib/xlsx/xform/sheet/cf/conditional-formattings-xform.js
var require_conditional_formattings_xform = __commonJS({
  "../../../node_modules/exceljs/lib/xlsx/xform/sheet/cf/conditional-formattings-xform.js"(exports2, module2) {
    var BaseXform = require_base_xform();
    var ConditionalFormattingXform = require_conditional_formatting_xform();
    var ConditionalFormattingsXform = class extends BaseXform {
      constructor() {
        super();
        this.cfXform = new ConditionalFormattingXform();
      }
      get tag() {
        return "conditionalFormatting";
      }
      reset() {
        this.model = [];
      }
      prepare(model, options) {
        let nextPriority = model.reduce(
          (p, cf) => Math.max(p, ...cf.rules.map((rule) => rule.priority || 0)),
          1
        );
        model.forEach((cf) => {
          cf.rules.forEach((rule) => {
            if (!rule.priority) {
              rule.priority = nextPriority++;
            }
            if (rule.style) {
              rule.dxfId = options.styles.addDxfStyle(rule.style);
            }
          });
        });
      }
      render(xmlStream, model) {
        model.forEach((cf) => {
          this.cfXform.render(xmlStream, cf);
        });
      }
      parseOpen(node) {
        if (this.parser) {
          this.parser.parseOpen(node);
          return true;
        }
        switch (node.name) {
          case "conditionalFormatting":
            this.parser = this.cfXform;
            this.parser.parseOpen(node);
            return true;
          default:
            return false;
        }
      }
      parseText(text) {
        if (this.parser) {
          this.parser.parseText(text);
        }
      }
      parseClose(name) {
        if (this.parser) {
          if (!this.parser.parseClose(name)) {
            this.model.push(this.parser.model);
            this.parser = void 0;
            return false;
          }
          return true;
        }
        return false;
      }
      reconcile(model, options) {
        model.forEach((cf) => {
          cf.rules.forEach((rule) => {
            if (rule.dxfId !== void 0) {
              rule.style = options.styles.getDxfStyle(rule.dxfId);
              delete rule.dxfId;
            }
          });
        });
      }
    };
    module2.exports = ConditionalFormattingsXform;
  }
});

// ../../../node_modules/uuid/dist/esm-node/rng.js
function rng() {
  if (poolPtr > rnds8Pool.length - 16) {
    import_crypto.default.randomFillSync(rnds8Pool);
    poolPtr = 0;
  }
  return rnds8Pool.slice(poolPtr, poolPtr += 16);
}
var import_crypto, rnds8Pool, poolPtr;
var init_rng = __esm({
  "../../../node_modules/uuid/dist/esm-node/rng.js"() {
    import_crypto = __toESM(require("crypto"));
    rnds8Pool = new Uint8Array(256);
    poolPtr = rnds8Pool.length;
  }
});

// ../../../node_modules/uuid/dist/esm-node/regex.js
var regex_default;
var init_regex = __esm({
  "../../../node_modules/uuid/dist/esm-node/regex.js"() {
    regex_default = /^(?:[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000)$/i;
  }
});

// ../../../node_modules/uuid/dist/esm-node/validate.js
function validate(uuid) {
  return typeof uuid === "string" && regex_default.test(uuid);
}
var validate_default;
var init_validate = __esm({
  "../../../node_modules/uuid/dist/esm-node/validate.js"() {
    init_regex();
    validate_default = validate;
  }
});

// ../../../node_modules/uuid/dist/esm-node/stringify.js
function stringify(arr, offset = 0) {
  const uuid = (byteToHex[arr[offset + 0]] + byteToHex[arr[offset + 1]] + byteToHex[arr[offset + 2]] + byteToHex[arr[offset + 3]] + "-" + byteToHex[arr[offset + 4]] + byteToHex[arr[offset + 5]] + "-" + byteToHex[arr[offset + 6]] + byteToHex[arr[offset + 7]] + "-" + byteToHex[arr[offset + 8]] + byteToHex[arr[offset + 9]] + "-" + byteToHex[arr[offset + 10]] + byteToHex[arr[offset + 11]] + byteToHex[arr[offset + 12]] + byteToHex[arr[offset + 13]] + byteToHex[arr[offset + 14]] + byteToHex[arr[offset + 15]]).toLowerCase();
  if (!validate_default(uuid)) {
    throw TypeError("Stringified UUID is invalid");
  }
  return uuid;
}
var byteToHex, stringify_default;
var init_stringify = __esm({
  "../../../node_modules/uuid/dist/esm-node/stringify.js"() {
    init_validate();
    byteToHex = [];
    for (let i = 0; i < 256; ++i) {
      byteToHex.push((i + 256).toString(16).substr(1));
    }
    stringify_default = stringify;
  }
});

// ../../../node_modules/uuid/dist/esm-node/v1.js
function v1(options, buf, offset) {
  let i = buf && offset || 0;
  const b = buf || new Array(16);
  options = options || {};
  let node = options.node || _nodeId;
  let clockseq = options.clockseq !== void 0 ? options.clockseq : _clockseq;
  if (node == null || clockseq == null) {
    const seedBytes = options.random || (options.rng || rng)();
    if (node == null) {
      node = _nodeId = [seedBytes[0] | 1, seedBytes[1], seedBytes[2], seedBytes[3], seedBytes[4], seedBytes[5]];
    }
    if (clockseq == null) {
      clockseq = _clockseq = (seedBytes[6] << 8 | seedBytes[7]) & 16383;
    }
  }
  let msecs = options.msecs !== void 0 ? options.msecs : Date.now();
  let nsecs = options.nsecs !== void 0 ? options.nsecs : _lastNSecs + 1;
  const dt = msecs - _lastMSecs + (nsecs - _lastNSecs) / 1e4;
  if (dt < 0 && options.clockseq === void 0) {
    clockseq = clockseq + 1 & 16383;
  }
  if ((dt < 0 || msecs > _lastMSecs) && options.nsecs === void 0) {
    nsecs = 0;
  }
  if (nsecs >= 1e4) {
    throw new Error("uuid.v1(): Can't create more than 10M uuids/sec");
  }
  _lastMSecs = msecs;
  _lastNSecs = nsecs;
  _clockseq = clockseq;
  msecs += 122192928e5;
  const tl = ((msecs & 268435455) * 1e4 + nsecs) % 4294967296;
  b[i++] = tl >>> 24 & 255;
  b[i++] = tl >>> 16 & 255;
  b[i++] = tl >>> 8 & 255;
  b[i++] = tl & 255;
  const tmh = msecs / 4294967296 * 1e4 & 268435455;
  b[i++] = tmh >>> 8 & 255;
  b[i++] = tmh & 255;
  b[i++] = tmh >>> 24 & 15 | 16;
  b[i++] = tmh >>> 16 & 255;
  b[i++] = clockseq >>> 8 | 128;
  b[i++] = clockseq & 255;
  for (let n = 0; n < 6; ++n) {
    b[i + n] = node[n];
  }
  return buf || stringify_default(b);
}
var _nodeId, _clockseq, _lastMSecs, _lastNSecs, v1_default;
var init_v1 = __esm({
  "../../../node_modules/uuid/dist/esm-node/v1.js"() {
    init_rng();
    init_stringify();
    _lastMSecs = 0;
    _lastNSecs = 0;
    v1_default = v1;
  }
});

// ../../../node_modules/uuid/dist/esm-node/parse.js
function parse(uuid) {
  if (!validate_default(uuid)) {
    throw TypeError("Invalid UUID");
  }
  let v;
  const arr = new Uint8Array(16);
  arr[0] = (v = parseInt(uuid.slice(0, 8), 16)) >>> 24;
  arr[1] = v >>> 16 & 255;
  arr[2] = v >>> 8 & 255;
  arr[3] = v & 255;
  arr[4] = (v = parseInt(uuid.slice(9, 13), 16)) >>> 8;
  arr[5] = v & 255;
  arr[6] = (v = parseInt(uuid.slice(14, 18), 16)) >>> 8;
  arr[7] = v & 255;
  arr[8] = (v = parseInt(uuid.slice(19, 23), 16)) >>> 8;
  arr[9] = v & 255;
  arr[10] = (v = parseInt(uuid.slice(24, 36), 16)) / 1099511627776 & 255;
  arr[11] = v / 4294967296 & 255;
  arr[12] = v >>> 24 & 255;
  arr[13] = v >>> 16 & 255;
  arr[14] = v >>> 8 & 255;
  arr[15] = v & 255;
  return arr;
}
var parse_default;
var init_parse = __esm({
  "../../../node_modules/uuid/dist/esm-node/parse.js"() {
    init_validate();
    parse_default = parse;
  }
});

// ../../../node_modules/uuid/dist/esm-node/v35.js
function stringToBytes(str) {
  str = unescape(encodeURIComponent(str));
  const bytes = [];
  for (let i = 0; i < str.length; ++i) {
    bytes.push(str.charCodeAt(i));
  }
  return bytes;
}
function v35_default(name, version2, hashfunc) {
  function generateUUID(value, namespace, buf, offset) {
    if (typeof value === "string") {
      value = stringToBytes(value);
    }
    if (typeof namespace === "string") {
      namespace = parse_default(namespace);
    }
    if (namespace.length !== 16) {
      throw TypeError("Namespace must be array-like (16 iterable integer values, 0-255)");
    }
    let bytes = new Uint8Array(16 + value.length);
    bytes.set(namespace);
    bytes.set(value, namespace.length);
    bytes = hashfunc(bytes);
    bytes[6] = bytes[6] & 15 | version2;
    bytes[8] = bytes[8] & 63 | 128;
    if (buf) {
      offset = offset || 0;
      for (let i = 0; i < 16; ++i) {
        buf[offset + i] = bytes[i];
      }
      return buf;
    }
    return stringify_default(bytes);
  }
  try {
    generateUUID.name = name;
  } catch (err) {
  }
  generateUUID.DNS = DNS;
  generateUUID.URL = URL2;
  return generateUUID;
}
var DNS, URL2;
var init_v35 = __esm({
  "../../../node_modules/uuid/dist/esm-node/v35.js"() {
    init_stringify();
    init_parse();
    DNS = "6ba7b810-9dad-11d1-80b4-00c04fd430c8";
    URL2 = "6ba7b811-9dad-11d1-80b4-00c04fd430c8";
  }
});

// ../../../node_modules/uuid/dist/esm-node/md5.js
function md5(bytes) {
  if (Array.isArray(bytes)) {
    bytes = Buffer.from(bytes);
  } else if (typeof bytes === "string") {
    bytes = Buffer.from(bytes, "utf8");
  }
  return import_crypto2.default.createHash("md5").update(bytes).digest();
}
var import_crypto2, md5_default;
var init_md5 = __esm({
  "../../../node_modules/uuid/dist/esm-node/md5.js"() {
    import_crypto2 = __toESM(require("crypto"));
    md5_default = md5;
  }
});

// ../../../node_modules/uuid/dist/esm-node/v3.js
var v3, v3_default;
var init_v3 = __esm({
  "../../../node_modules/uuid/dist/esm-node/v3.js"() {
    init_v35();
    init_md5();
    v3 = v35_default("v3", 48, md5_default);
    v3_default = v3;
  }
});

// ../../../node_modules/uuid/dist/esm-node/v4.js
function v4(options, buf, offset) {
  options = options || {};
  const rnds = options.random || (options.rng || rng)();
  rnds[6] = rnds[6] & 15 | 64;
  rnds[8] = rnds[8] & 63 | 128;
  if (buf) {
    offset = offset || 0;
    for (let i = 0; i < 16; ++i) {
      buf[offset + i] = rnds[i];
    }
    return buf;
  }
  return stringify_default(rnds);
}
var v4_default;
var init_v4 = __esm({
  "../../../node_modules/uuid/dist/esm-node/v4.js"() {
    init_rng();
    init_stringify();
    v4_default = v4;
  }
});

// ../../../node_modules/uuid/dist/esm-node/sha1.js
function sha1(bytes) {
  if (Array.isArray(bytes)) {
    bytes = Buffer.from(bytes);
  } else if (typeof bytes === "string") {
    bytes = Buffer.from(bytes, "utf8");
  }
  return import_crypto3.default.createHash("sha1").update(bytes).digest();
}
var import_crypto3, sha1_default;
var init_sha1 = __esm({
  "../../../node_modules/uuid/dist/esm-node/sha1.js"() {
    import_crypto3 = __toESM(require("crypto"));
    sha1_default = sha1;
  }
});

// ../../../node_modules/uuid/dist/esm-node/v5.js
var v5, v5_default;
var init_v5 = __esm({
  "../../../node_modules/uuid/dist/esm-node/v5.js"() {
    init_v35();
    init_sha1();
    v5 = v35_default("v5", 80, sha1_default);
    v5_default = v5;
  }
});

// ../../../node_modules/uuid/dist/esm-node/nil.js
var nil_default;
var init_nil = __esm({
  "../../../node_modules/uuid/dist/esm-node/nil.js"() {
    nil_default = "00000000-0000-0000-0000-000000000000";
  }
});

// ../../../node_modules/uuid/dist/esm-node/version.js
function version(uuid) {
  if (!validate_default(uuid)) {
    throw TypeError("Invalid UUID");
  }
  return parseInt(uuid.substr(14, 1), 16);
}
var version_default;
var init_version = __esm({
  "../../../node_modules/uuid/dist/esm-node/version.js"() {
    init_validate();
    version_default = version;
  }
});

// ../../../node_modules/uuid/dist/esm-node/index.js
var esm_node_exports = {};
__export(esm_node_exports, {
  NIL: () => nil_default,
  parse: () => parse_default,
  stringify: () => stringify_default,
  v1: () => v1_default,
  v3: () => v3_default,
  v4: () => v4_default,
  v5: () => v5_default,
  validate: () => validate_default,
  version: () => version_default
});
var init_esm_node = __esm({
  "../../../node_modules/uuid/dist/esm-node/index.js"() {
    init_v1();
    init_v3();
    init_v4();
    init_v5();
    init_nil();
    init_version();
    init_validate();
    init_stringify();
    init_parse();
  }
});

// ../../../node_modules/exceljs/lib/xlsx/xform/sheet/cf-ext/f-ext-xform.js
var require_f_ext_xform = __commonJS({
  "../../../node_modules/exceljs/lib/xlsx/xform/sheet/cf-ext/f-ext-xform.js"(exports2, module2) {
    var BaseXform = require_base_xform();
    var FExtXform = class extends BaseXform {
      get tag() {
        return "xm:f";
      }
      render(xmlStream, model) {
        xmlStream.leafNode(this.tag, null, model);
      }
      parseOpen() {
        this.model = "";
      }
      parseText(text) {
        this.model += text;
      }
      parseClose(name) {
        return name !== this.tag;
      }
    };
    module2.exports = FExtXform;
  }
});

// ../../../node_modules/exceljs/lib/xlsx/xform/sheet/cf-ext/cfvo-ext-xform.js
var require_cfvo_ext_xform = __commonJS({
  "../../../node_modules/exceljs/lib/xlsx/xform/sheet/cf-ext/cfvo-ext-xform.js"(exports2, module2) {
    var CompositeXform = require_composite_xform();
    var FExtXform = require_f_ext_xform();
    var CfvoExtXform = class extends CompositeXform {
      constructor() {
        super();
        this.map = {
          "xm:f": this.fExtXform = new FExtXform()
        };
      }
      get tag() {
        return "x14:cfvo";
      }
      render(xmlStream, model) {
        xmlStream.openNode(this.tag, {
          type: model.type
        });
        if (model.value !== void 0) {
          this.fExtXform.render(xmlStream, model.value);
        }
        xmlStream.closeNode();
      }
      createNewModel(node) {
        return {
          type: node.attributes.type
        };
      }
      onParserClose(name, parser) {
        switch (name) {
          case "xm:f":
            this.model.value = parser.model ? parseFloat(parser.model) : 0;
            break;
        }
      }
    };
    module2.exports = CfvoExtXform;
  }
});

// ../../../node_modules/exceljs/lib/xlsx/xform/sheet/cf-ext/databar-ext-xform.js
var require_databar_ext_xform = __commonJS({
  "../../../node_modules/exceljs/lib/xlsx/xform/sheet/cf-ext/databar-ext-xform.js"(exports2, module2) {
    var BaseXform = require_base_xform();
    var CompositeXform = require_composite_xform();
    var ColorXform = require_color_xform();
    var CfvoExtXform = require_cfvo_ext_xform();
    var DatabarExtXform = class extends CompositeXform {
      constructor() {
        super();
        this.map = {
          "x14:cfvo": this.cfvoXform = new CfvoExtXform(),
          "x14:borderColor": this.borderColorXform = new ColorXform("x14:borderColor"),
          "x14:negativeBorderColor": this.negativeBorderColorXform = new ColorXform(
            "x14:negativeBorderColor"
          ),
          "x14:negativeFillColor": this.negativeFillColorXform = new ColorXform(
            "x14:negativeFillColor"
          ),
          "x14:axisColor": this.axisColorXform = new ColorXform("x14:axisColor")
        };
      }
      static isExt(rule) {
        return !rule.gradient;
      }
      get tag() {
        return "x14:dataBar";
      }
      render(xmlStream, model) {
        xmlStream.openNode(this.tag, {
          minLength: BaseXform.toIntAttribute(model.minLength, 0, true),
          maxLength: BaseXform.toIntAttribute(model.maxLength, 100, true),
          border: BaseXform.toBoolAttribute(model.border, false),
          gradient: BaseXform.toBoolAttribute(model.gradient, true),
          negativeBarColorSameAsPositive: BaseXform.toBoolAttribute(
            model.negativeBarColorSameAsPositive,
            true
          ),
          negativeBarBorderColorSameAsPositive: BaseXform.toBoolAttribute(
            model.negativeBarBorderColorSameAsPositive,
            true
          ),
          axisPosition: BaseXform.toAttribute(model.axisPosition, "auto"),
          direction: BaseXform.toAttribute(model.direction, "leftToRight")
        });
        model.cfvo.forEach((cfvo) => {
          this.cfvoXform.render(xmlStream, cfvo);
        });
        this.borderColorXform.render(xmlStream, model.borderColor);
        this.negativeBorderColorXform.render(xmlStream, model.negativeBorderColor);
        this.negativeFillColorXform.render(xmlStream, model.negativeFillColor);
        this.axisColorXform.render(xmlStream, model.axisColor);
        xmlStream.closeNode();
      }
      createNewModel({ attributes }) {
        return {
          cfvo: [],
          minLength: BaseXform.toIntValue(attributes.minLength, 0),
          maxLength: BaseXform.toIntValue(attributes.maxLength, 100),
          border: BaseXform.toBoolValue(attributes.border, false),
          gradient: BaseXform.toBoolValue(attributes.gradient, true),
          negativeBarColorSameAsPositive: BaseXform.toBoolValue(
            attributes.negativeBarColorSameAsPositive,
            true
          ),
          negativeBarBorderColorSameAsPositive: BaseXform.toBoolValue(
            attributes.negativeBarBorderColorSameAsPositive,
            true
          ),
          axisPosition: BaseXform.toStringValue(attributes.axisPosition, "auto"),
          direction: BaseXform.toStringValue(attributes.direction, "leftToRight")
        };
      }
      onParserClose(name, parser) {
        const [, prop] = name.split(":");
        switch (prop) {
          case "cfvo":
            this.model.cfvo.push(parser.model);
            break;
          default:
            this.model[prop] = parser.model;
            break;
        }
      }
    };
    module2.exports = DatabarExtXform;
  }
});

// ../../../node_modules/exceljs/lib/xlsx/xform/sheet/cf-ext/cf-icon-ext-xform.js
var require_cf_icon_ext_xform = __commonJS({
  "../../../node_modules/exceljs/lib/xlsx/xform/sheet/cf-ext/cf-icon-ext-xform.js"(exports2, module2) {
    var BaseXform = require_base_xform();
    var CfIconExtXform = class extends BaseXform {
      get tag() {
        return "x14:cfIcon";
      }
      render(xmlStream, model) {
        xmlStream.leafNode(this.tag, {
          iconSet: model.iconSet,
          iconId: model.iconId
        });
      }
      parseOpen({ attributes }) {
        this.model = {
          iconSet: attributes.iconSet,
          iconId: BaseXform.toIntValue(attributes.iconId)
        };
      }
      parseClose(name) {
        return name !== this.tag;
      }
    };
    module2.exports = CfIconExtXform;
  }
});

// ../../../node_modules/exceljs/lib/xlsx/xform/sheet/cf-ext/icon-set-ext-xform.js
var require_icon_set_ext_xform = __commonJS({
  "../../../node_modules/exceljs/lib/xlsx/xform/sheet/cf-ext/icon-set-ext-xform.js"(exports2, module2) {
    var BaseXform = require_base_xform();
    var CompositeXform = require_composite_xform();
    var CfvoExtXform = require_cfvo_ext_xform();
    var CfIconExtXform = require_cf_icon_ext_xform();
    var IconSetExtXform = class extends CompositeXform {
      constructor() {
        super();
        this.map = {
          "x14:cfvo": this.cfvoXform = new CfvoExtXform(),
          "x14:cfIcon": this.cfIconXform = new CfIconExtXform()
        };
      }
      get tag() {
        return "x14:iconSet";
      }
      render(xmlStream, model) {
        xmlStream.openNode(this.tag, {
          iconSet: BaseXform.toStringAttribute(model.iconSet),
          reverse: BaseXform.toBoolAttribute(model.reverse, false),
          showValue: BaseXform.toBoolAttribute(model.showValue, true),
          custom: BaseXform.toBoolAttribute(model.icons, false)
        });
        model.cfvo.forEach((cfvo) => {
          this.cfvoXform.render(xmlStream, cfvo);
        });
        if (model.icons) {
          model.icons.forEach((icon, i) => {
            icon.iconId = i;
            this.cfIconXform.render(xmlStream, icon);
          });
        }
        xmlStream.closeNode();
      }
      createNewModel({ attributes }) {
        return {
          cfvo: [],
          iconSet: BaseXform.toStringValue(attributes.iconSet, "3TrafficLights"),
          reverse: BaseXform.toBoolValue(attributes.reverse, false),
          showValue: BaseXform.toBoolValue(attributes.showValue, true)
        };
      }
      onParserClose(name, parser) {
        const [, prop] = name.split(":");
        switch (prop) {
          case "cfvo":
            this.model.cfvo.push(parser.model);
            break;
          case "cfIcon":
            if (!this.model.icons) {
              this.model.icons = [];
            }
            this.model.icons.push(parser.model);
            break;
          default:
            this.model[prop] = parser.model;
            break;
        }
      }
    };
    module2.exports = IconSetExtXform;
  }
});

// ../../../node_modules/exceljs/lib/xlsx/xform/sheet/cf-ext/cf-rule-ext-xform.js
var require_cf_rule_ext_xform = __commonJS({
  "../../../node_modules/exceljs/lib/xlsx/xform/sheet/cf-ext/cf-rule-ext-xform.js"(exports2, module2) {
    var { v4: uuidv4 } = (init_esm_node(), __toCommonJS(esm_node_exports));
    var BaseXform = require_base_xform();
    var CompositeXform = require_composite_xform();
    var DatabarExtXform = require_databar_ext_xform();
    var IconSetExtXform = require_icon_set_ext_xform();
    var extIcons = {
      "3Triangles": true,
      "3Stars": true,
      "5Boxes": true
    };
    var CfRuleExtXform = class _CfRuleExtXform extends CompositeXform {
      constructor() {
        super();
        this.map = {
          "x14:dataBar": this.databarXform = new DatabarExtXform(),
          "x14:iconSet": this.iconSetXform = new IconSetExtXform()
        };
      }
      get tag() {
        return "x14:cfRule";
      }
      static isExt(rule) {
        if (rule.type === "dataBar") {
          return DatabarExtXform.isExt(rule);
        }
        if (rule.type === "iconSet") {
          if (rule.custom || extIcons[rule.iconSet]) {
            return true;
          }
        }
        return false;
      }
      prepare(model) {
        if (_CfRuleExtXform.isExt(model)) {
          model.x14Id = `{${uuidv4()}}`.toUpperCase();
        }
      }
      render(xmlStream, model) {
        if (!_CfRuleExtXform.isExt(model)) {
          return;
        }
        switch (model.type) {
          case "dataBar":
            this.renderDataBar(xmlStream, model);
            break;
          case "iconSet":
            this.renderIconSet(xmlStream, model);
            break;
        }
      }
      renderDataBar(xmlStream, model) {
        xmlStream.openNode(this.tag, {
          type: "dataBar",
          id: model.x14Id
        });
        this.databarXform.render(xmlStream, model);
        xmlStream.closeNode();
      }
      renderIconSet(xmlStream, model) {
        xmlStream.openNode(this.tag, {
          type: "iconSet",
          priority: model.priority,
          id: model.x14Id || `{${uuidv4()}}`
        });
        this.iconSetXform.render(xmlStream, model);
        xmlStream.closeNode();
      }
      createNewModel({ attributes }) {
        return {
          type: attributes.type,
          x14Id: attributes.id,
          priority: BaseXform.toIntValue(attributes.priority)
        };
      }
      onParserClose(name, parser) {
        Object.assign(this.model, parser.model);
      }
    };
    module2.exports = CfRuleExtXform;
  }
});

// ../../../node_modules/exceljs/lib/xlsx/xform/sheet/cf-ext/sqref-ext-xform.js
var require_sqref_ext_xform = __commonJS({
  "../../../node_modules/exceljs/lib/xlsx/xform/sheet/cf-ext/sqref-ext-xform.js"(exports2, module2) {
    var BaseXform = require_base_xform();
    var SqrefExtXform = class extends BaseXform {
      get tag() {
        return "xm:sqref";
      }
      render(xmlStream, model) {
        xmlStream.leafNode(this.tag, null, model);
      }
      parseOpen() {
        this.model = "";
      }
      parseText(text) {
        this.model += text;
      }
      parseClose(name) {
        return name !== this.tag;
      }
    };
    module2.exports = SqrefExtXform;
  }
});

// ../../../node_modules/exceljs/lib/xlsx/xform/sheet/cf-ext/conditional-formatting-ext-xform.js
var require_conditional_formatting_ext_xform = __commonJS({
  "../../../node_modules/exceljs/lib/xlsx/xform/sheet/cf-ext/conditional-formatting-ext-xform.js"(exports2, module2) {
    var CompositeXform = require_composite_xform();
    var SqRefExtXform = require_sqref_ext_xform();
    var CfRuleExtXform = require_cf_rule_ext_xform();
    var ConditionalFormattingExtXform = class extends CompositeXform {
      constructor() {
        super();
        this.map = {
          "xm:sqref": this.sqRef = new SqRefExtXform(),
          "x14:cfRule": this.cfRule = new CfRuleExtXform()
        };
      }
      get tag() {
        return "x14:conditionalFormatting";
      }
      prepare(model, options) {
        model.rules.forEach((rule) => {
          this.cfRule.prepare(rule, options);
        });
      }
      render(xmlStream, model) {
        if (!model.rules.some(CfRuleExtXform.isExt)) {
          return;
        }
        xmlStream.openNode(this.tag, {
          "xmlns:xm": "http://schemas.microsoft.com/office/excel/2006/main"
        });
        model.rules.filter(CfRuleExtXform.isExt).forEach((rule) => this.cfRule.render(xmlStream, rule));
        this.sqRef.render(xmlStream, model.ref);
        xmlStream.closeNode();
      }
      createNewModel() {
        return {
          rules: []
        };
      }
      onParserClose(name, parser) {
        switch (name) {
          case "xm:sqref":
            this.model.ref = parser.model;
            break;
          case "x14:cfRule":
            this.model.rules.push(parser.model);
            break;
        }
      }
    };
    module2.exports = ConditionalFormattingExtXform;
  }
});

// ../../../node_modules/exceljs/lib/xlsx/xform/sheet/cf-ext/conditional-formattings-ext-xform.js
var require_conditional_formattings_ext_xform = __commonJS({
  "../../../node_modules/exceljs/lib/xlsx/xform/sheet/cf-ext/conditional-formattings-ext-xform.js"(exports2, module2) {
    var CompositeXform = require_composite_xform();
    var CfRuleExtXform = require_cf_rule_ext_xform();
    var ConditionalFormattingExtXform = require_conditional_formatting_ext_xform();
    var ConditionalFormattingsExtXform = class extends CompositeXform {
      constructor() {
        super();
        this.map = {
          "x14:conditionalFormatting": this.cfXform = new ConditionalFormattingExtXform()
        };
      }
      get tag() {
        return "x14:conditionalFormattings";
      }
      hasContent(model) {
        if (model.hasExtContent === void 0) {
          model.hasExtContent = model.some((cf) => cf.rules.some(CfRuleExtXform.isExt));
        }
        return model.hasExtContent;
      }
      prepare(model, options) {
        model.forEach((cf) => {
          this.cfXform.prepare(cf, options);
        });
      }
      render(xmlStream, model) {
        if (this.hasContent(model)) {
          xmlStream.openNode(this.tag);
          model.forEach((cf) => this.cfXform.render(xmlStream, cf));
          xmlStream.closeNode();
        }
      }
      createNewModel() {
        return [];
      }
      onParserClose(name, parser) {
        this.model.push(parser.model);
      }
    };
    module2.exports = ConditionalFormattingsExtXform;
  }
});

// ../../../node_modules/exceljs/lib/xlsx/xform/sheet/ext-lst-xform.js
var require_ext_lst_xform = __commonJS({
  "../../../node_modules/exceljs/lib/xlsx/xform/sheet/ext-lst-xform.js"(exports2, module2) {
    var CompositeXform = require_composite_xform();
    var ConditionalFormattingsExt = require_conditional_formattings_ext_xform();
    var ExtXform = class extends CompositeXform {
      constructor() {
        super();
        this.map = {
          "x14:conditionalFormattings": this.conditionalFormattings = new ConditionalFormattingsExt()
        };
      }
      get tag() {
        return "ext";
      }
      hasContent(model) {
        return this.conditionalFormattings.hasContent(model.conditionalFormattings);
      }
      prepare(model, options) {
        this.conditionalFormattings.prepare(model.conditionalFormattings, options);
      }
      render(xmlStream, model) {
        xmlStream.openNode("ext", {
          uri: "{78C0D931-6437-407d-A8EE-F0AAD7539E65}",
          "xmlns:x14": "http://schemas.microsoft.com/office/spreadsheetml/2009/9/main"
        });
        this.conditionalFormattings.render(xmlStream, model.conditionalFormattings);
        xmlStream.closeNode();
      }
      createNewModel() {
        return {};
      }
      onParserClose(name, parser) {
        this.model[name] = parser.model;
      }
    };
    var ExtLstXform = class extends CompositeXform {
      constructor() {
        super();
        this.map = {
          ext: this.ext = new ExtXform()
        };
      }
      get tag() {
        return "extLst";
      }
      prepare(model, options) {
        this.ext.prepare(model, options);
      }
      hasContent(model) {
        return this.ext.hasContent(model);
      }
      render(xmlStream, model) {
        if (!this.hasContent(model)) {
          return;
        }
        xmlStream.openNode("extLst");
        this.ext.render(xmlStream, model);
        xmlStream.closeNode();
      }
      createNewModel() {
        return {};
      }
      onParserClose(name, parser) {
        Object.assign(this.model, parser.model);
      }
    };
    module2.exports = ExtLstXform;
  }
});

// ../../../node_modules/exceljs/lib/xlsx/xform/sheet/worksheet-xform.js
var require_worksheet_xform = __commonJS({
  "../../../node_modules/exceljs/lib/xlsx/xform/sheet/worksheet-xform.js"(exports2, module2) {
    var _2 = require_under_dash();
    var colCache = require_col_cache();
    var XmlStream = require_xml_stream();
    var RelType = require_rel_type();
    var Merges = require_merges();
    var BaseXform = require_base_xform();
    var ListXform = require_list_xform();
    var RowXform = require_row_xform();
    var ColXform = require_col_xform();
    var DimensionXform = require_dimension_xform();
    var HyperlinkXform = require_hyperlink_xform();
    var MergeCellXform = require_merge_cell_xform();
    var DataValidationsXform = require_data_validations_xform();
    var SheetPropertiesXform = require_sheet_properties_xform();
    var SheetFormatPropertiesXform = require_sheet_format_properties_xform();
    var SheetViewXform = require_sheet_view_xform();
    var SheetProtectionXform = require_sheet_protection_xform();
    var PageMarginsXform = require_page_margins_xform();
    var PageSetupXform = require_page_setup_xform();
    var PrintOptionsXform = require_print_options_xform();
    var AutoFilterXform = require_auto_filter_xform();
    var PictureXform = require_picture_xform();
    var DrawingXform = require_drawing_xform();
    var TablePartXform = require_table_part_xform();
    var RowBreaksXform = require_row_breaks_xform();
    var HeaderFooterXform = require_header_footer_xform();
    var ConditionalFormattingsXform = require_conditional_formattings_xform();
    var ExtListXform = require_ext_lst_xform();
    var mergeRule = (rule, extRule) => {
      Object.keys(extRule).forEach((key) => {
        const value = rule[key];
        const extValue = extRule[key];
        if (value === void 0 && extValue !== void 0) {
          rule[key] = extValue;
        }
      });
    };
    var mergeConditionalFormattings = (model, extModel) => {
      if (!extModel || !extModel.length) {
        return model;
      }
      if (!model || !model.length) {
        return extModel;
      }
      const cfMap = {};
      const ruleMap = {};
      model.forEach((cf) => {
        cfMap[cf.ref] = cf;
        cf.rules.forEach((rule) => {
          const { x14Id } = rule;
          if (x14Id) {
            ruleMap[x14Id] = rule;
          }
        });
      });
      extModel.forEach((extCf) => {
        extCf.rules.forEach((extRule) => {
          const rule = ruleMap[extRule.x14Id];
          if (rule) {
            mergeRule(rule, extRule);
          } else if (cfMap[extCf.ref]) {
            cfMap[extCf.ref].rules.push(extRule);
          } else {
            model.push({
              ref: extCf.ref,
              rules: [extRule]
            });
          }
        });
      });
      return model;
    };
    var WorkSheetXform = class _WorkSheetXform extends BaseXform {
      constructor(options) {
        super();
        const { maxRows, maxCols, ignoreNodes } = options || {};
        this.ignoreNodes = ignoreNodes || [];
        this.map = {
          sheetPr: new SheetPropertiesXform(),
          dimension: new DimensionXform(),
          sheetViews: new ListXform({
            tag: "sheetViews",
            count: false,
            childXform: new SheetViewXform()
          }),
          sheetFormatPr: new SheetFormatPropertiesXform(),
          cols: new ListXform({ tag: "cols", count: false, childXform: new ColXform() }),
          sheetData: new ListXform({
            tag: "sheetData",
            count: false,
            empty: true,
            childXform: new RowXform({ maxItems: maxCols }),
            maxItems: maxRows
          }),
          autoFilter: new AutoFilterXform(),
          mergeCells: new ListXform({ tag: "mergeCells", count: true, childXform: new MergeCellXform() }),
          rowBreaks: new RowBreaksXform(),
          hyperlinks: new ListXform({
            tag: "hyperlinks",
            count: false,
            childXform: new HyperlinkXform()
          }),
          pageMargins: new PageMarginsXform(),
          dataValidations: new DataValidationsXform(),
          pageSetup: new PageSetupXform(),
          headerFooter: new HeaderFooterXform(),
          printOptions: new PrintOptionsXform(),
          picture: new PictureXform(),
          drawing: new DrawingXform(),
          sheetProtection: new SheetProtectionXform(),
          tableParts: new ListXform({ tag: "tableParts", count: true, childXform: new TablePartXform() }),
          conditionalFormatting: new ConditionalFormattingsXform(),
          extLst: new ExtListXform()
        };
      }
      prepare(model, options) {
        options.merges = new Merges();
        model.hyperlinks = options.hyperlinks = [];
        model.comments = options.comments = [];
        options.formulae = {};
        options.siFormulae = 0;
        this.map.cols.prepare(model.cols, options);
        this.map.sheetData.prepare(model.rows, options);
        this.map.conditionalFormatting.prepare(model.conditionalFormattings, options);
        model.mergeCells = options.merges.mergeCells;
        const rels = model.rels = [];
        function nextRid(r) {
          return `rId${r.length + 1}`;
        }
        model.hyperlinks.forEach((hyperlink) => {
          const rId = nextRid(rels);
          hyperlink.rId = rId;
          rels.push({
            Id: rId,
            Type: RelType.Hyperlink,
            Target: hyperlink.target,
            TargetMode: "External"
          });
        });
        if (model.comments.length > 0) {
          const comment = {
            Id: nextRid(rels),
            Type: RelType.Comments,
            Target: `../comments${model.id}.xml`
          };
          rels.push(comment);
          const vmlDrawing = {
            Id: nextRid(rels),
            Type: RelType.VmlDrawing,
            Target: `../drawings/vmlDrawing${model.id}.vml`
          };
          rels.push(vmlDrawing);
          model.comments.forEach((item) => {
            item.refAddress = colCache.decodeAddress(item.ref);
          });
          options.commentRefs.push({
            commentName: `comments${model.id}`,
            vmlDrawing: `vmlDrawing${model.id}`
          });
        }
        const drawingRelsHash = [];
        let bookImage;
        model.media.forEach((medium) => {
          if (medium.type === "background") {
            const rId = nextRid(rels);
            bookImage = options.media[medium.imageId];
            rels.push({
              Id: rId,
              Type: RelType.Image,
              Target: `../media/${bookImage.name}.${bookImage.extension}`
            });
            model.background = {
              rId
            };
            model.image = options.media[medium.imageId];
          } else if (medium.type === "image") {
            let { drawing } = model;
            bookImage = options.media[medium.imageId];
            if (!drawing) {
              drawing = model.drawing = {
                rId: nextRid(rels),
                name: `drawing${++options.drawingsCount}`,
                anchors: [],
                rels: []
              };
              options.drawings.push(drawing);
              rels.push({
                Id: drawing.rId,
                Type: "http://schemas.openxmlformats.org/officeDocument/2006/relationships/drawing",
                Target: `../drawings/${drawing.name}.xml`
              });
            }
            let rIdImage = this.preImageId === medium.imageId ? drawingRelsHash[medium.imageId] : drawingRelsHash[drawing.rels.length];
            if (!rIdImage) {
              rIdImage = nextRid(drawing.rels);
              drawingRelsHash[drawing.rels.length] = rIdImage;
              drawing.rels.push({
                Id: rIdImage,
                Type: "http://schemas.openxmlformats.org/officeDocument/2006/relationships/image",
                Target: `../media/${bookImage.name}.${bookImage.extension}`
              });
            }
            const anchor = {
              picture: {
                rId: rIdImage
              },
              range: medium.range
            };
            if (medium.hyperlinks && medium.hyperlinks.hyperlink) {
              const rIdHyperLink = nextRid(drawing.rels);
              drawingRelsHash[drawing.rels.length] = rIdHyperLink;
              anchor.picture.hyperlinks = {
                tooltip: medium.hyperlinks.tooltip,
                rId: rIdHyperLink
              };
              drawing.rels.push({
                Id: rIdHyperLink,
                Type: RelType.Hyperlink,
                Target: medium.hyperlinks.hyperlink,
                TargetMode: "External"
              });
            }
            this.preImageId = medium.imageId;
            drawing.anchors.push(anchor);
          }
        });
        model.tables.forEach((table) => {
          const rId = nextRid(rels);
          table.rId = rId;
          rels.push({
            Id: rId,
            Type: RelType.Table,
            Target: `../tables/${table.target}`
          });
          table.columns.forEach((column) => {
            const { style } = column;
            if (style) {
              column.dxfId = options.styles.addDxfStyle(style);
            }
          });
        });
        this.map.extLst.prepare(model, options);
      }
      render(xmlStream, model) {
        xmlStream.openXml(XmlStream.StdDocAttributes);
        xmlStream.openNode("worksheet", _WorkSheetXform.WORKSHEET_ATTRIBUTES);
        const sheetFormatPropertiesModel = model.properties ? {
          defaultRowHeight: model.properties.defaultRowHeight,
          dyDescent: model.properties.dyDescent,
          outlineLevelCol: model.properties.outlineLevelCol,
          outlineLevelRow: model.properties.outlineLevelRow
        } : void 0;
        if (model.properties && model.properties.defaultColWidth) {
          sheetFormatPropertiesModel.defaultColWidth = model.properties.defaultColWidth;
        }
        const sheetPropertiesModel = {
          outlineProperties: model.properties && model.properties.outlineProperties,
          tabColor: model.properties && model.properties.tabColor,
          pageSetup: model.pageSetup && model.pageSetup.fitToPage ? {
            fitToPage: model.pageSetup.fitToPage
          } : void 0
        };
        const pageMarginsModel = model.pageSetup && model.pageSetup.margins;
        const printOptionsModel = {
          showRowColHeaders: model.pageSetup && model.pageSetup.showRowColHeaders,
          showGridLines: model.pageSetup && model.pageSetup.showGridLines,
          horizontalCentered: model.pageSetup && model.pageSetup.horizontalCentered,
          verticalCentered: model.pageSetup && model.pageSetup.verticalCentered
        };
        const sheetProtectionModel = model.sheetProtection;
        this.map.sheetPr.render(xmlStream, sheetPropertiesModel);
        this.map.dimension.render(xmlStream, model.dimensions);
        this.map.sheetViews.render(xmlStream, model.views);
        this.map.sheetFormatPr.render(xmlStream, sheetFormatPropertiesModel);
        this.map.cols.render(xmlStream, model.cols);
        this.map.sheetData.render(xmlStream, model.rows);
        this.map.sheetProtection.render(xmlStream, sheetProtectionModel);
        this.map.autoFilter.render(xmlStream, model.autoFilter);
        this.map.mergeCells.render(xmlStream, model.mergeCells);
        this.map.conditionalFormatting.render(xmlStream, model.conditionalFormattings);
        this.map.dataValidations.render(xmlStream, model.dataValidations);
        this.map.hyperlinks.render(xmlStream, model.hyperlinks);
        this.map.printOptions.render(xmlStream, printOptionsModel);
        this.map.pageMargins.render(xmlStream, pageMarginsModel);
        this.map.pageSetup.render(xmlStream, model.pageSetup);
        this.map.headerFooter.render(xmlStream, model.headerFooter);
        this.map.rowBreaks.render(xmlStream, model.rowBreaks);
        this.map.drawing.render(xmlStream, model.drawing);
        this.map.picture.render(xmlStream, model.background);
        this.map.tableParts.render(xmlStream, model.tables);
        this.map.extLst.render(xmlStream, model);
        if (model.rels) {
          model.rels.forEach((rel) => {
            if (rel.Type === RelType.VmlDrawing) {
              xmlStream.leafNode("legacyDrawing", { "r:id": rel.Id });
            }
          });
        }
        xmlStream.closeNode();
      }
      parseOpen(node) {
        if (this.parser) {
          this.parser.parseOpen(node);
          return true;
        }
        if (node.name === "worksheet") {
          _2.each(this.map, (xform) => {
            xform.reset();
          });
          return true;
        }
        if (this.map[node.name] && !this.ignoreNodes.includes(node.name)) {
          this.parser = this.map[node.name];
          this.parser.parseOpen(node);
        }
        return true;
      }
      parseText(text) {
        if (this.parser) {
          this.parser.parseText(text);
        }
      }
      parseClose(name) {
        if (this.parser) {
          if (!this.parser.parseClose(name)) {
            this.parser = void 0;
          }
          return true;
        }
        switch (name) {
          case "worksheet": {
            const properties = this.map.sheetFormatPr.model || {};
            if (this.map.sheetPr.model && this.map.sheetPr.model.tabColor) {
              properties.tabColor = this.map.sheetPr.model.tabColor;
            }
            if (this.map.sheetPr.model && this.map.sheetPr.model.outlineProperties) {
              properties.outlineProperties = this.map.sheetPr.model.outlineProperties;
            }
            const sheetProperties = {
              fitToPage: this.map.sheetPr.model && this.map.sheetPr.model.pageSetup && this.map.sheetPr.model.pageSetup.fitToPage || false,
              margins: this.map.pageMargins.model
            };
            const pageSetup = Object.assign(sheetProperties, this.map.pageSetup.model, this.map.printOptions.model);
            const conditionalFormattings = mergeConditionalFormattings(
              this.map.conditionalFormatting.model,
              this.map.extLst.model && this.map.extLst.model["x14:conditionalFormattings"]
            );
            this.model = {
              dimensions: this.map.dimension.model,
              cols: this.map.cols.model,
              rows: this.map.sheetData.model,
              mergeCells: this.map.mergeCells.model,
              hyperlinks: this.map.hyperlinks.model,
              dataValidations: this.map.dataValidations.model,
              properties,
              views: this.map.sheetViews.model,
              pageSetup,
              headerFooter: this.map.headerFooter.model,
              background: this.map.picture.model,
              drawing: this.map.drawing.model,
              tables: this.map.tableParts.model,
              conditionalFormattings
            };
            if (this.map.autoFilter.model) {
              this.model.autoFilter = this.map.autoFilter.model;
            }
            if (this.map.sheetProtection.model) {
              this.model.sheetProtection = this.map.sheetProtection.model;
            }
            return false;
          }
          default:
            return true;
        }
      }
      reconcile(model, options) {
        const rels = (model.relationships || []).reduce((h, rel) => {
          h[rel.Id] = rel;
          if (rel.Type === RelType.Comments) {
            model.comments = options.comments[rel.Target].comments;
          }
          if (rel.Type === RelType.VmlDrawing && model.comments && model.comments.length) {
            const vmlComment = options.vmlDrawings[rel.Target].comments;
            model.comments.forEach((comment, index) => {
              comment.note = Object.assign({}, comment.note, vmlComment[index]);
            });
          }
          return h;
        }, {});
        options.commentsMap = (model.comments || []).reduce((h, comment) => {
          if (comment.ref) {
            h[comment.ref] = comment;
          }
          return h;
        }, {});
        options.hyperlinkMap = (model.hyperlinks || []).reduce((h, hyperlink) => {
          if (hyperlink.rId) {
            h[hyperlink.address] = rels[hyperlink.rId].Target;
          }
          return h;
        }, {});
        options.formulae = {};
        model.rows = model.rows && model.rows.filter(Boolean) || [];
        model.rows.forEach((row) => {
          row.cells = row.cells && row.cells.filter(Boolean) || [];
        });
        this.map.cols.reconcile(model.cols, options);
        this.map.sheetData.reconcile(model.rows, options);
        this.map.conditionalFormatting.reconcile(model.conditionalFormattings, options);
        model.media = [];
        if (model.drawing) {
          const drawingRel = rels[model.drawing.rId];
          const match = drawingRel.Target.match(/\/drawings\/([a-zA-Z0-9]+)[.][a-zA-Z]{3,4}$/);
          if (match) {
            const drawingName = match[1];
            const drawing = options.drawings[drawingName];
            drawing.anchors.forEach((anchor) => {
              if (anchor.medium) {
                const image = {
                  type: "image",
                  imageId: anchor.medium.index,
                  range: anchor.range,
                  hyperlinks: anchor.picture.hyperlinks
                };
                model.media.push(image);
              }
            });
          }
        }
        const backgroundRel = model.background && rels[model.background.rId];
        if (backgroundRel) {
          const target = backgroundRel.Target.split("/media/")[1];
          const imageId = options.mediaIndex && options.mediaIndex[target];
          if (imageId !== void 0) {
            model.media.push({
              type: "background",
              imageId
            });
          }
        }
        model.tables = (model.tables || []).map((tablePart) => {
          const rel = rels[tablePart.rId];
          return options.tables[rel.Target];
        });
        delete model.relationships;
        delete model.hyperlinks;
        delete model.comments;
      }
    };
    WorkSheetXform.WORKSHEET_ATTRIBUTES = {
      xmlns: "http://schemas.openxmlformats.org/spreadsheetml/2006/main",
      "xmlns:r": "http://schemas.openxmlformats.org/officeDocument/2006/relationships",
      "xmlns:mc": "http://schemas.openxmlformats.org/markup-compatibility/2006",
      "mc:Ignorable": "x14ac",
      "xmlns:x14ac": "http://schemas.microsoft.com/office/spreadsheetml/2009/9/ac"
    };
    module2.exports = WorkSheetXform;
  }
});

// ../../../node_modules/exceljs/lib/xlsx/xform/drawing/base-cell-anchor-xform.js
var require_base_cell_anchor_xform = __commonJS({
  "../../../node_modules/exceljs/lib/xlsx/xform/drawing/base-cell-anchor-xform.js"(exports2, module2) {
    var BaseXform = require_base_xform();
    var BaseCellAnchorXform = class extends BaseXform {
      parseOpen(node) {
        if (this.parser) {
          this.parser.parseOpen(node);
          return true;
        }
        switch (node.name) {
          case this.tag:
            this.reset();
            this.model = {
              range: {
                editAs: node.attributes.editAs || "oneCell"
              }
            };
            break;
          default:
            this.parser = this.map[node.name];
            if (this.parser) {
              this.parser.parseOpen(node);
            }
            break;
        }
        return true;
      }
      parseText(text) {
        if (this.parser) {
          this.parser.parseText(text);
        }
      }
      reconcilePicture(model, options) {
        if (model && model.rId) {
          const rel = options.rels[model.rId];
          const match = rel.Target.match(/.*\/media\/(.+[.][a-zA-Z]{3,4})/);
          if (match) {
            const name = match[1];
            const mediaId = options.mediaIndex[name];
            return options.media[mediaId];
          }
        }
        return void 0;
      }
    };
    module2.exports = BaseCellAnchorXform;
  }
});

// ../../../node_modules/exceljs/lib/xlsx/xform/drawing/cell-position-xform.js
var require_cell_position_xform = __commonJS({
  "../../../node_modules/exceljs/lib/xlsx/xform/drawing/cell-position-xform.js"(exports2, module2) {
    var BaseXform = require_base_xform();
    var IntegerXform = require_integer_xform();
    var CellPositionXform = class extends BaseXform {
      constructor(options) {
        super();
        this.tag = options.tag;
        this.map = {
          "xdr:col": new IntegerXform({ tag: "xdr:col", zero: true }),
          "xdr:colOff": new IntegerXform({ tag: "xdr:colOff", zero: true }),
          "xdr:row": new IntegerXform({ tag: "xdr:row", zero: true }),
          "xdr:rowOff": new IntegerXform({ tag: "xdr:rowOff", zero: true })
        };
      }
      render(xmlStream, model) {
        xmlStream.openNode(this.tag);
        this.map["xdr:col"].render(xmlStream, model.nativeCol);
        this.map["xdr:colOff"].render(xmlStream, model.nativeColOff);
        this.map["xdr:row"].render(xmlStream, model.nativeRow);
        this.map["xdr:rowOff"].render(xmlStream, model.nativeRowOff);
        xmlStream.closeNode();
      }
      parseOpen(node) {
        if (this.parser) {
          this.parser.parseOpen(node);
          return true;
        }
        switch (node.name) {
          case this.tag:
            this.reset();
            break;
          default:
            this.parser = this.map[node.name];
            if (this.parser) {
              this.parser.parseOpen(node);
            }
            break;
        }
        return true;
      }
      parseText(text) {
        if (this.parser) {
          this.parser.parseText(text);
        }
      }
      parseClose(name) {
        if (this.parser) {
          if (!this.parser.parseClose(name)) {
            this.parser = void 0;
          }
          return true;
        }
        switch (name) {
          case this.tag:
            this.model = {
              nativeCol: this.map["xdr:col"].model,
              nativeColOff: this.map["xdr:colOff"].model,
              nativeRow: this.map["xdr:row"].model,
              nativeRowOff: this.map["xdr:rowOff"].model
            };
            return false;
          default:
            return true;
        }
      }
    };
    module2.exports = CellPositionXform;
  }
});

// ../../../node_modules/exceljs/lib/xlsx/xform/drawing/blip-xform.js
var require_blip_xform = __commonJS({
  "../../../node_modules/exceljs/lib/xlsx/xform/drawing/blip-xform.js"(exports2, module2) {
    var BaseXform = require_base_xform();
    var BlipXform = class extends BaseXform {
      get tag() {
        return "a:blip";
      }
      render(xmlStream, model) {
        xmlStream.leafNode(this.tag, {
          "xmlns:r": "http://schemas.openxmlformats.org/officeDocument/2006/relationships",
          "r:embed": model.rId,
          cstate: "print"
        });
      }
      parseOpen(node) {
        switch (node.name) {
          case this.tag:
            this.model = {
              rId: node.attributes["r:embed"]
            };
            return true;
          default:
            return true;
        }
      }
      parseText() {
      }
      parseClose(name) {
        switch (name) {
          case this.tag:
            return false;
          default:
            return true;
        }
      }
    };
    module2.exports = BlipXform;
  }
});

// ../../../node_modules/exceljs/lib/xlsx/xform/drawing/blip-fill-xform.js
var require_blip_fill_xform = __commonJS({
  "../../../node_modules/exceljs/lib/xlsx/xform/drawing/blip-fill-xform.js"(exports2, module2) {
    var BaseXform = require_base_xform();
    var BlipXform = require_blip_xform();
    var BlipFillXform = class extends BaseXform {
      constructor() {
        super();
        this.map = {
          "a:blip": new BlipXform()
        };
      }
      get tag() {
        return "xdr:blipFill";
      }
      render(xmlStream, model) {
        xmlStream.openNode(this.tag);
        this.map["a:blip"].render(xmlStream, model);
        xmlStream.openNode("a:stretch");
        xmlStream.leafNode("a:fillRect");
        xmlStream.closeNode();
        xmlStream.closeNode();
      }
      parseOpen(node) {
        if (this.parser) {
          this.parser.parseOpen(node);
          return true;
        }
        switch (node.name) {
          case this.tag:
            this.reset();
            break;
          default:
            this.parser = this.map[node.name];
            if (this.parser) {
              this.parser.parseOpen(node);
            }
            break;
        }
        return true;
      }
      parseText() {
      }
      parseClose(name) {
        if (this.parser) {
          if (!this.parser.parseClose(name)) {
            this.parser = void 0;
          }
          return true;
        }
        switch (name) {
          case this.tag:
            this.model = this.map["a:blip"].model;
            return false;
          default:
            return true;
        }
      }
    };
    module2.exports = BlipFillXform;
  }
});

// ../../../node_modules/exceljs/lib/xlsx/xform/drawing/hlink-click-xform.js
var require_hlink_click_xform = __commonJS({
  "../../../node_modules/exceljs/lib/xlsx/xform/drawing/hlink-click-xform.js"(exports2, module2) {
    var BaseXform = require_base_xform();
    var HLinkClickXform = class extends BaseXform {
      get tag() {
        return "a:hlinkClick";
      }
      render(xmlStream, model) {
        if (!(model.hyperlinks && model.hyperlinks.rId)) {
          return;
        }
        xmlStream.leafNode(this.tag, {
          "xmlns:r": "http://schemas.openxmlformats.org/officeDocument/2006/relationships",
          "r:id": model.hyperlinks.rId,
          tooltip: model.hyperlinks.tooltip
        });
      }
      parseOpen(node) {
        switch (node.name) {
          case this.tag:
            this.model = {
              hyperlinks: {
                rId: node.attributes["r:id"],
                tooltip: node.attributes.tooltip
              }
            };
            return true;
          default:
            return true;
        }
      }
      parseText() {
      }
      parseClose() {
        return false;
      }
    };
    module2.exports = HLinkClickXform;
  }
});

// ../../../node_modules/exceljs/lib/xlsx/xform/drawing/ext-lst-xform.js
var require_ext_lst_xform2 = __commonJS({
  "../../../node_modules/exceljs/lib/xlsx/xform/drawing/ext-lst-xform.js"(exports2, module2) {
    var BaseXform = require_base_xform();
    var ExtLstXform = class extends BaseXform {
      get tag() {
        return "a:extLst";
      }
      render(xmlStream) {
        xmlStream.openNode(this.tag);
        xmlStream.openNode("a:ext", {
          uri: "{FF2B5EF4-FFF2-40B4-BE49-F238E27FC236}"
        });
        xmlStream.leafNode("a16:creationId", {
          "xmlns:a16": "http://schemas.microsoft.com/office/drawing/2014/main",
          id: "{00000000-0008-0000-0000-000002000000}"
        });
        xmlStream.closeNode();
        xmlStream.closeNode();
      }
      parseOpen(node) {
        switch (node.name) {
          case this.tag:
            return true;
          default:
            return true;
        }
      }
      parseText() {
      }
      parseClose(name) {
        switch (name) {
          case this.tag:
            return false;
          default:
            return true;
        }
      }
    };
    module2.exports = ExtLstXform;
  }
});

// ../../../node_modules/exceljs/lib/xlsx/xform/drawing/c-nv-pr-xform.js
var require_c_nv_pr_xform = __commonJS({
  "../../../node_modules/exceljs/lib/xlsx/xform/drawing/c-nv-pr-xform.js"(exports2, module2) {
    var BaseXform = require_base_xform();
    var HlickClickXform = require_hlink_click_xform();
    var ExtLstXform = require_ext_lst_xform2();
    var CNvPrXform = class extends BaseXform {
      constructor() {
        super();
        this.map = {
          "a:hlinkClick": new HlickClickXform(),
          "a:extLst": new ExtLstXform()
        };
      }
      get tag() {
        return "xdr:cNvPr";
      }
      render(xmlStream, model) {
        xmlStream.openNode(this.tag, {
          id: model.index,
          name: `Picture ${model.index}`
        });
        this.map["a:hlinkClick"].render(xmlStream, model);
        this.map["a:extLst"].render(xmlStream, model);
        xmlStream.closeNode();
      }
      parseOpen(node) {
        if (this.parser) {
          this.parser.parseOpen(node);
          return true;
        }
        switch (node.name) {
          case this.tag:
            this.reset();
            break;
          default:
            this.parser = this.map[node.name];
            if (this.parser) {
              this.parser.parseOpen(node);
            }
            break;
        }
        return true;
      }
      parseText() {
      }
      parseClose(name) {
        if (this.parser) {
          if (!this.parser.parseClose(name)) {
            this.parser = void 0;
          }
          return true;
        }
        switch (name) {
          case this.tag:
            this.model = this.map["a:hlinkClick"].model;
            return false;
          default:
            return true;
        }
      }
    };
    module2.exports = CNvPrXform;
  }
});

// ../../../node_modules/exceljs/lib/xlsx/xform/drawing/c-nv-pic-pr-xform.js
var require_c_nv_pic_pr_xform = __commonJS({
  "../../../node_modules/exceljs/lib/xlsx/xform/drawing/c-nv-pic-pr-xform.js"(exports2, module2) {
    var BaseXform = require_base_xform();
    var CNvPicPrXform = class extends BaseXform {
      get tag() {
        return "xdr:cNvPicPr";
      }
      render(xmlStream) {
        xmlStream.openNode(this.tag);
        xmlStream.leafNode("a:picLocks", {
          noChangeAspect: "1"
        });
        xmlStream.closeNode();
      }
      parseOpen(node) {
        switch (node.name) {
          case this.tag:
            return true;
          default:
            return true;
        }
      }
      parseText() {
      }
      parseClose(name) {
        switch (name) {
          case this.tag:
            return false;
          default:
            return true;
        }
      }
    };
    module2.exports = CNvPicPrXform;
  }
});

// ../../../node_modules/exceljs/lib/xlsx/xform/drawing/nv-pic-pr-xform.js
var require_nv_pic_pr_xform = __commonJS({
  "../../../node_modules/exceljs/lib/xlsx/xform/drawing/nv-pic-pr-xform.js"(exports2, module2) {
    var BaseXform = require_base_xform();
    var CNvPrXform = require_c_nv_pr_xform();
    var CNvPicPrXform = require_c_nv_pic_pr_xform();
    var NvPicPrXform = class extends BaseXform {
      constructor() {
        super();
        this.map = {
          "xdr:cNvPr": new CNvPrXform(),
          "xdr:cNvPicPr": new CNvPicPrXform()
        };
      }
      get tag() {
        return "xdr:nvPicPr";
      }
      render(xmlStream, model) {
        xmlStream.openNode(this.tag);
        this.map["xdr:cNvPr"].render(xmlStream, model);
        this.map["xdr:cNvPicPr"].render(xmlStream, model);
        xmlStream.closeNode();
      }
      parseOpen(node) {
        if (this.parser) {
          this.parser.parseOpen(node);
          return true;
        }
        switch (node.name) {
          case this.tag:
            this.reset();
            break;
          default:
            this.parser = this.map[node.name];
            if (this.parser) {
              this.parser.parseOpen(node);
            }
            break;
        }
        return true;
      }
      parseText() {
      }
      parseClose(name) {
        if (this.parser) {
          if (!this.parser.parseClose(name)) {
            this.parser = void 0;
          }
          return true;
        }
        switch (name) {
          case this.tag:
            this.model = this.map["xdr:cNvPr"].model;
            return false;
          default:
            return true;
        }
      }
    };
    module2.exports = NvPicPrXform;
  }
});

// ../../../node_modules/exceljs/lib/xlsx/xform/drawing/sp-pr.js
var require_sp_pr = __commonJS({
  "../../../node_modules/exceljs/lib/xlsx/xform/drawing/sp-pr.js"(exports2, module2) {
    module2.exports = {
      tag: "xdr:spPr",
      c: [
        {
          tag: "a:xfrm",
          c: [
            { tag: "a:off", $: { x: "0", y: "0" } },
            { tag: "a:ext", $: { cx: "0", cy: "0" } }
          ]
        },
        {
          tag: "a:prstGeom",
          $: { prst: "rect" },
          c: [{ tag: "a:avLst" }]
        }
      ]
    };
  }
});

// ../../../node_modules/exceljs/lib/xlsx/xform/drawing/pic-xform.js
var require_pic_xform = __commonJS({
  "../../../node_modules/exceljs/lib/xlsx/xform/drawing/pic-xform.js"(exports2, module2) {
    var BaseXform = require_base_xform();
    var StaticXform = require_static_xform();
    var BlipFillXform = require_blip_fill_xform();
    var NvPicPrXform = require_nv_pic_pr_xform();
    var spPrJSON = require_sp_pr();
    var PicXform = class extends BaseXform {
      constructor() {
        super();
        this.map = {
          "xdr:nvPicPr": new NvPicPrXform(),
          "xdr:blipFill": new BlipFillXform(),
          "xdr:spPr": new StaticXform(spPrJSON)
        };
      }
      get tag() {
        return "xdr:pic";
      }
      prepare(model, options) {
        model.index = options.index + 1;
      }
      render(xmlStream, model) {
        xmlStream.openNode(this.tag);
        this.map["xdr:nvPicPr"].render(xmlStream, model);
        this.map["xdr:blipFill"].render(xmlStream, model);
        this.map["xdr:spPr"].render(xmlStream, model);
        xmlStream.closeNode();
      }
      parseOpen(node) {
        if (this.parser) {
          this.parser.parseOpen(node);
          return true;
        }
        switch (node.name) {
          case this.tag:
            this.reset();
            break;
          default:
            this.parser = this.map[node.name];
            if (this.parser) {
              this.parser.parseOpen(node);
            }
            break;
        }
        return true;
      }
      parseText() {
      }
      parseClose(name) {
        if (this.parser) {
          if (!this.parser.parseClose(name)) {
            this.mergeModel(this.parser.model);
            this.parser = void 0;
          }
          return true;
        }
        switch (name) {
          case this.tag:
            return false;
          default:
            return true;
        }
      }
    };
    module2.exports = PicXform;
  }
});

// ../../../node_modules/exceljs/lib/xlsx/xform/drawing/two-cell-anchor-xform.js
var require_two_cell_anchor_xform = __commonJS({
  "../../../node_modules/exceljs/lib/xlsx/xform/drawing/two-cell-anchor-xform.js"(exports2, module2) {
    var BaseCellAnchorXform = require_base_cell_anchor_xform();
    var StaticXform = require_static_xform();
    var CellPositionXform = require_cell_position_xform();
    var PicXform = require_pic_xform();
    var TwoCellAnchorXform = class extends BaseCellAnchorXform {
      constructor() {
        super();
        this.map = {
          "xdr:from": new CellPositionXform({ tag: "xdr:from" }),
          "xdr:to": new CellPositionXform({ tag: "xdr:to" }),
          "xdr:pic": new PicXform(),
          "xdr:clientData": new StaticXform({ tag: "xdr:clientData" })
        };
      }
      get tag() {
        return "xdr:twoCellAnchor";
      }
      prepare(model, options) {
        this.map["xdr:pic"].prepare(model.picture, options);
      }
      render(xmlStream, model) {
        xmlStream.openNode(this.tag, { editAs: model.range.editAs || "oneCell" });
        this.map["xdr:from"].render(xmlStream, model.range.tl);
        this.map["xdr:to"].render(xmlStream, model.range.br);
        this.map["xdr:pic"].render(xmlStream, model.picture);
        this.map["xdr:clientData"].render(xmlStream, {});
        xmlStream.closeNode();
      }
      parseClose(name) {
        if (this.parser) {
          if (!this.parser.parseClose(name)) {
            this.parser = void 0;
          }
          return true;
        }
        switch (name) {
          case this.tag:
            this.model.range.tl = this.map["xdr:from"].model;
            this.model.range.br = this.map["xdr:to"].model;
            this.model.picture = this.map["xdr:pic"].model;
            return false;
          default:
            return true;
        }
      }
      reconcile(model, options) {
        model.medium = this.reconcilePicture(model.picture, options);
      }
    };
    module2.exports = TwoCellAnchorXform;
  }
});

// ../../../node_modules/exceljs/lib/xlsx/xform/drawing/ext-xform.js
var require_ext_xform = __commonJS({
  "../../../node_modules/exceljs/lib/xlsx/xform/drawing/ext-xform.js"(exports2, module2) {
    var BaseXform = require_base_xform();
    var EMU_PER_PIXEL_AT_96_DPI = 9525;
    var ExtXform = class extends BaseXform {
      constructor(options) {
        super();
        this.tag = options.tag;
        this.map = {};
      }
      render(xmlStream, model) {
        xmlStream.openNode(this.tag);
        const width = Math.floor(model.width * EMU_PER_PIXEL_AT_96_DPI);
        const height = Math.floor(model.height * EMU_PER_PIXEL_AT_96_DPI);
        xmlStream.addAttribute("cx", width);
        xmlStream.addAttribute("cy", height);
        xmlStream.closeNode();
      }
      parseOpen(node) {
        if (node.name === this.tag) {
          this.model = {
            width: parseInt(node.attributes.cx || "0", 10) / EMU_PER_PIXEL_AT_96_DPI,
            height: parseInt(node.attributes.cy || "0", 10) / EMU_PER_PIXEL_AT_96_DPI
          };
          return true;
        }
        return false;
      }
      parseText() {
      }
      parseClose() {
        return false;
      }
    };
    module2.exports = ExtXform;
  }
});

// ../../../node_modules/exceljs/lib/xlsx/xform/drawing/one-cell-anchor-xform.js
var require_one_cell_anchor_xform = __commonJS({
  "../../../node_modules/exceljs/lib/xlsx/xform/drawing/one-cell-anchor-xform.js"(exports2, module2) {
    var BaseCellAnchorXform = require_base_cell_anchor_xform();
    var StaticXform = require_static_xform();
    var CellPositionXform = require_cell_position_xform();
    var ExtXform = require_ext_xform();
    var PicXform = require_pic_xform();
    var OneCellAnchorXform = class extends BaseCellAnchorXform {
      constructor() {
        super();
        this.map = {
          "xdr:from": new CellPositionXform({ tag: "xdr:from" }),
          "xdr:ext": new ExtXform({ tag: "xdr:ext" }),
          "xdr:pic": new PicXform(),
          "xdr:clientData": new StaticXform({ tag: "xdr:clientData" })
        };
      }
      get tag() {
        return "xdr:oneCellAnchor";
      }
      prepare(model, options) {
        this.map["xdr:pic"].prepare(model.picture, options);
      }
      render(xmlStream, model) {
        xmlStream.openNode(this.tag, { editAs: model.range.editAs || "oneCell" });
        this.map["xdr:from"].render(xmlStream, model.range.tl);
        this.map["xdr:ext"].render(xmlStream, model.range.ext);
        this.map["xdr:pic"].render(xmlStream, model.picture);
        this.map["xdr:clientData"].render(xmlStream, {});
        xmlStream.closeNode();
      }
      parseClose(name) {
        if (this.parser) {
          if (!this.parser.parseClose(name)) {
            this.parser = void 0;
          }
          return true;
        }
        switch (name) {
          case this.tag:
            this.model.range.tl = this.map["xdr:from"].model;
            this.model.range.ext = this.map["xdr:ext"].model;
            this.model.picture = this.map["xdr:pic"].model;
            return false;
          default:
            return true;
        }
      }
      reconcile(model, options) {
        model.medium = this.reconcilePicture(model.picture, options);
      }
    };
    module2.exports = OneCellAnchorXform;
  }
});

// ../../../node_modules/exceljs/lib/xlsx/xform/drawing/drawing-xform.js
var require_drawing_xform2 = __commonJS({
  "../../../node_modules/exceljs/lib/xlsx/xform/drawing/drawing-xform.js"(exports2, module2) {
    var colCache = require_col_cache();
    var XmlStream = require_xml_stream();
    var BaseXform = require_base_xform();
    var TwoCellAnchorXform = require_two_cell_anchor_xform();
    var OneCellAnchorXform = require_one_cell_anchor_xform();
    function getAnchorType(model) {
      const range = typeof model.range === "string" ? colCache.decode(model.range) : model.range;
      return range.br ? "xdr:twoCellAnchor" : "xdr:oneCellAnchor";
    }
    var DrawingXform = class _DrawingXform extends BaseXform {
      constructor() {
        super();
        this.map = {
          "xdr:twoCellAnchor": new TwoCellAnchorXform(),
          "xdr:oneCellAnchor": new OneCellAnchorXform()
        };
      }
      prepare(model) {
        model.anchors.forEach((item, index) => {
          item.anchorType = getAnchorType(item);
          const anchor = this.map[item.anchorType];
          anchor.prepare(item, { index });
        });
      }
      get tag() {
        return "xdr:wsDr";
      }
      render(xmlStream, model) {
        xmlStream.openXml(XmlStream.StdDocAttributes);
        xmlStream.openNode(this.tag, _DrawingXform.DRAWING_ATTRIBUTES);
        model.anchors.forEach((item) => {
          const anchor = this.map[item.anchorType];
          anchor.render(xmlStream, item);
        });
        xmlStream.closeNode();
      }
      parseOpen(node) {
        if (this.parser) {
          this.parser.parseOpen(node);
          return true;
        }
        switch (node.name) {
          case this.tag:
            this.reset();
            this.model = {
              anchors: []
            };
            break;
          default:
            this.parser = this.map[node.name];
            if (this.parser) {
              this.parser.parseOpen(node);
            }
            break;
        }
        return true;
      }
      parseText(text) {
        if (this.parser) {
          this.parser.parseText(text);
        }
      }
      parseClose(name) {
        if (this.parser) {
          if (!this.parser.parseClose(name)) {
            this.model.anchors.push(this.parser.model);
            this.parser = void 0;
          }
          return true;
        }
        switch (name) {
          case this.tag:
            return false;
          default:
            return true;
        }
      }
      reconcile(model, options) {
        model.anchors.forEach((anchor) => {
          if (anchor.br) {
            this.map["xdr:twoCellAnchor"].reconcile(anchor, options);
          } else {
            this.map["xdr:oneCellAnchor"].reconcile(anchor, options);
          }
        });
      }
    };
    DrawingXform.DRAWING_ATTRIBUTES = {
      "xmlns:xdr": "http://schemas.openxmlformats.org/drawingml/2006/spreadsheetDrawing",
      "xmlns:a": "http://schemas.openxmlformats.org/drawingml/2006/main"
    };
    module2.exports = DrawingXform;
  }
});

// ../../../node_modules/exceljs/lib/xlsx/xform/table/custom-filter-xform.js
var require_custom_filter_xform = __commonJS({
  "../../../node_modules/exceljs/lib/xlsx/xform/table/custom-filter-xform.js"(exports2, module2) {
    var BaseXform = require_base_xform();
    var CustomFilterXform = class extends BaseXform {
      get tag() {
        return "customFilter";
      }
      render(xmlStream, model) {
        xmlStream.leafNode(this.tag, {
          val: model.val,
          operator: model.operator
        });
      }
      parseOpen(node) {
        if (node.name === this.tag) {
          this.model = {
            val: node.attributes.val,
            operator: node.attributes.operator
          };
          return true;
        }
        return false;
      }
      parseText() {
      }
      parseClose() {
        return false;
      }
    };
    module2.exports = CustomFilterXform;
  }
});

// ../../../node_modules/exceljs/lib/xlsx/xform/table/filter-xform.js
var require_filter_xform = __commonJS({
  "../../../node_modules/exceljs/lib/xlsx/xform/table/filter-xform.js"(exports2, module2) {
    var BaseXform = require_base_xform();
    var FilterXform = class extends BaseXform {
      get tag() {
        return "filter";
      }
      render(xmlStream, model) {
        xmlStream.leafNode(this.tag, {
          val: model.val
        });
      }
      parseOpen(node) {
        if (node.name === this.tag) {
          this.model = {
            val: node.attributes.val
          };
          return true;
        }
        return false;
      }
      parseText() {
      }
      parseClose() {
        return false;
      }
    };
    module2.exports = FilterXform;
  }
});

// ../../../node_modules/exceljs/lib/xlsx/xform/table/filter-column-xform.js
var require_filter_column_xform = __commonJS({
  "../../../node_modules/exceljs/lib/xlsx/xform/table/filter-column-xform.js"(exports2, module2) {
    var BaseXform = require_base_xform();
    var ListXform = require_list_xform();
    var CustomFilterXform = require_custom_filter_xform();
    var FilterXform = require_filter_xform();
    var FilterColumnXform = class extends BaseXform {
      constructor() {
        super();
        this.map = {
          customFilters: new ListXform({
            tag: "customFilters",
            count: false,
            empty: true,
            childXform: new CustomFilterXform()
          }),
          filters: new ListXform({
            tag: "filters",
            count: false,
            empty: true,
            childXform: new FilterXform()
          })
        };
      }
      get tag() {
        return "filterColumn";
      }
      prepare(model, options) {
        model.colId = options.index.toString();
      }
      render(xmlStream, model) {
        if (model.customFilters) {
          xmlStream.openNode(this.tag, {
            colId: model.colId,
            hiddenButton: model.filterButton ? "0" : "1"
          });
          this.map.customFilters.render(xmlStream, model.customFilters);
          xmlStream.closeNode();
          return true;
        }
        xmlStream.leafNode(this.tag, {
          colId: model.colId,
          hiddenButton: model.filterButton ? "0" : "1"
        });
        return true;
      }
      parseOpen(node) {
        if (this.parser) {
          this.parser.parseOpen(node);
          return true;
        }
        const { attributes } = node;
        switch (node.name) {
          case this.tag:
            this.model = {
              filterButton: attributes.hiddenButton === "0"
            };
            return true;
          default:
            this.parser = this.map[node.name];
            if (this.parser) {
              this.parseOpen(node);
              return true;
            }
            throw new Error(`Unexpected xml node in parseOpen: ${JSON.stringify(node)}`);
        }
      }
      parseText() {
      }
      parseClose(name) {
        if (this.parser) {
          if (!this.parser.parseClose(name)) {
            this.parser = void 0;
          }
          return true;
        }
        switch (name) {
          case this.tag:
            this.model.customFilters = this.map.customFilters.model;
            return false;
          default:
            return true;
        }
      }
    };
    module2.exports = FilterColumnXform;
  }
});

// ../../../node_modules/exceljs/lib/xlsx/xform/table/auto-filter-xform.js
var require_auto_filter_xform2 = __commonJS({
  "../../../node_modules/exceljs/lib/xlsx/xform/table/auto-filter-xform.js"(exports2, module2) {
    var BaseXform = require_base_xform();
    var FilterColumnXform = require_filter_column_xform();
    var AutoFilterXform = class extends BaseXform {
      constructor() {
        super();
        this.map = {
          filterColumn: new FilterColumnXform()
        };
      }
      get tag() {
        return "autoFilter";
      }
      prepare(model) {
        model.columns.forEach((column, index) => {
          this.map.filterColumn.prepare(column, { index });
        });
      }
      render(xmlStream, model) {
        xmlStream.openNode(this.tag, { ref: model.autoFilterRef });
        model.columns.forEach((column) => {
          this.map.filterColumn.render(xmlStream, column);
        });
        xmlStream.closeNode();
        return true;
      }
      parseOpen(node) {
        if (this.parser) {
          this.parser.parseOpen(node);
          return true;
        }
        switch (node.name) {
          case this.tag:
            this.model = {
              autoFilterRef: node.attributes.ref,
              columns: []
            };
            return true;
          default:
            this.parser = this.map[node.name];
            if (this.parser) {
              this.parseOpen(node);
              return true;
            }
            throw new Error(`Unexpected xml node in parseOpen: ${JSON.stringify(node)}`);
        }
      }
      parseText(text) {
        if (this.parser) {
          this.parser.parseText(text);
        }
      }
      parseClose(name) {
        if (this.parser) {
          if (!this.parser.parseClose(name)) {
            this.model.columns.push(this.parser.model);
            this.parser = void 0;
          }
          return true;
        }
        switch (name) {
          case this.tag:
            return false;
          default:
            throw new Error(`Unexpected xml node in parseClose: ${name}`);
        }
      }
    };
    module2.exports = AutoFilterXform;
  }
});

// ../../../node_modules/exceljs/lib/xlsx/xform/table/table-column-xform.js
var require_table_column_xform = __commonJS({
  "../../../node_modules/exceljs/lib/xlsx/xform/table/table-column-xform.js"(exports2, module2) {
    var BaseXform = require_base_xform();
    var TableColumnXform = class extends BaseXform {
      get tag() {
        return "tableColumn";
      }
      prepare(model, options) {
        model.id = options.index + 1;
      }
      render(xmlStream, model) {
        xmlStream.leafNode(this.tag, {
          id: model.id.toString(),
          name: model.name,
          totalsRowLabel: model.totalsRowLabel,
          totalsRowFunction: model.totalsRowFunction,
          dxfId: model.dxfId
        });
        return true;
      }
      parseOpen(node) {
        if (node.name === this.tag) {
          const { attributes } = node;
          this.model = {
            name: attributes.name,
            totalsRowLabel: attributes.totalsRowLabel,
            totalsRowFunction: attributes.totalsRowFunction,
            dxfId: attributes.dxfId
          };
          return true;
        }
        return false;
      }
      parseText() {
      }
      parseClose() {
        return false;
      }
    };
    module2.exports = TableColumnXform;
  }
});

// ../../../node_modules/exceljs/lib/xlsx/xform/table/table-style-info-xform.js
var require_table_style_info_xform = __commonJS({
  "../../../node_modules/exceljs/lib/xlsx/xform/table/table-style-info-xform.js"(exports2, module2) {
    var BaseXform = require_base_xform();
    var TableStyleInfoXform = class extends BaseXform {
      get tag() {
        return "tableStyleInfo";
      }
      render(xmlStream, model) {
        xmlStream.leafNode(this.tag, {
          name: model.theme ? model.theme : void 0,
          showFirstColumn: model.showFirstColumn ? "1" : "0",
          showLastColumn: model.showLastColumn ? "1" : "0",
          showRowStripes: model.showRowStripes ? "1" : "0",
          showColumnStripes: model.showColumnStripes ? "1" : "0"
        });
        return true;
      }
      parseOpen(node) {
        if (node.name === this.tag) {
          const { attributes } = node;
          this.model = {
            theme: attributes.name ? attributes.name : null,
            showFirstColumn: attributes.showFirstColumn === "1",
            showLastColumn: attributes.showLastColumn === "1",
            showRowStripes: attributes.showRowStripes === "1",
            showColumnStripes: attributes.showColumnStripes === "1"
          };
          return true;
        }
        return false;
      }
      parseText() {
      }
      parseClose() {
        return false;
      }
    };
    module2.exports = TableStyleInfoXform;
  }
});

// ../../../node_modules/exceljs/lib/xlsx/xform/table/table-xform.js
var require_table_xform = __commonJS({
  "../../../node_modules/exceljs/lib/xlsx/xform/table/table-xform.js"(exports2, module2) {
    var XmlStream = require_xml_stream();
    var BaseXform = require_base_xform();
    var ListXform = require_list_xform();
    var AutoFilterXform = require_auto_filter_xform2();
    var TableColumnXform = require_table_column_xform();
    var TableStyleInfoXform = require_table_style_info_xform();
    var TableXform = class _TableXform extends BaseXform {
      constructor() {
        super();
        this.map = {
          autoFilter: new AutoFilterXform(),
          tableColumns: new ListXform({
            tag: "tableColumns",
            count: true,
            empty: true,
            childXform: new TableColumnXform()
          }),
          tableStyleInfo: new TableStyleInfoXform()
        };
      }
      prepare(model, options) {
        this.map.autoFilter.prepare(model);
        this.map.tableColumns.prepare(model.columns, options);
      }
      get tag() {
        return "table";
      }
      render(xmlStream, model) {
        xmlStream.openXml(XmlStream.StdDocAttributes);
        xmlStream.openNode(this.tag, {
          ..._TableXform.TABLE_ATTRIBUTES,
          id: model.id,
          name: model.name,
          displayName: model.displayName || model.name,
          ref: model.tableRef,
          totalsRowCount: model.totalsRow ? "1" : void 0,
          totalsRowShown: model.totalsRow ? void 0 : "1",
          headerRowCount: model.headerRow ? "1" : "0"
        });
        this.map.autoFilter.render(xmlStream, model);
        this.map.tableColumns.render(xmlStream, model.columns);
        this.map.tableStyleInfo.render(xmlStream, model.style);
        xmlStream.closeNode();
      }
      parseOpen(node) {
        if (this.parser) {
          this.parser.parseOpen(node);
          return true;
        }
        const { name, attributes } = node;
        switch (name) {
          case this.tag:
            this.reset();
            this.model = {
              name: attributes.name,
              displayName: attributes.displayName || attributes.name,
              tableRef: attributes.ref,
              totalsRow: attributes.totalsRowCount === "1",
              headerRow: attributes.headerRowCount === "1"
            };
            break;
          default:
            this.parser = this.map[node.name];
            if (this.parser) {
              this.parser.parseOpen(node);
            }
            break;
        }
        return true;
      }
      parseText(text) {
        if (this.parser) {
          this.parser.parseText(text);
        }
      }
      parseClose(name) {
        if (this.parser) {
          if (!this.parser.parseClose(name)) {
            this.parser = void 0;
          }
          return true;
        }
        switch (name) {
          case this.tag:
            this.model.columns = this.map.tableColumns.model;
            if (this.map.autoFilter.model) {
              this.model.autoFilterRef = this.map.autoFilter.model.autoFilterRef;
              this.map.autoFilter.model.columns.forEach((column, index) => {
                this.model.columns[index].filterButton = column.filterButton;
              });
            }
            this.model.style = this.map.tableStyleInfo.model;
            return false;
          default:
            return true;
        }
      }
      reconcile(model, options) {
        model.columns.forEach((column) => {
          if (column.dxfId !== void 0) {
            column.style = options.styles.getDxfStyle(column.dxfId);
          }
        });
      }
    };
    TableXform.TABLE_ATTRIBUTES = {
      xmlns: "http://schemas.openxmlformats.org/spreadsheetml/2006/main",
      "xmlns:mc": "http://schemas.openxmlformats.org/markup-compatibility/2006",
      "mc:Ignorable": "xr xr3",
      "xmlns:xr": "http://schemas.microsoft.com/office/spreadsheetml/2014/revision",
      "xmlns:xr3": "http://schemas.microsoft.com/office/spreadsheetml/2016/revision3"
      // 'xr:uid': '{00000000-000C-0000-FFFF-FFFF00000000}',
    };
    module2.exports = TableXform;
  }
});

// ../../../node_modules/exceljs/lib/xlsx/xform/comment/comment-xform.js
var require_comment_xform = __commonJS({
  "../../../node_modules/exceljs/lib/xlsx/xform/comment/comment-xform.js"(exports2, module2) {
    var RichTextXform = require_rich_text_xform();
    var utils = require_utils2();
    var BaseXform = require_base_xform();
    var CommentXform = module2.exports = function(model) {
      this.model = model;
    };
    utils.inherits(CommentXform, BaseXform, {
      get tag() {
        return "r";
      },
      get richTextXform() {
        if (!this._richTextXform) {
          this._richTextXform = new RichTextXform();
        }
        return this._richTextXform;
      },
      render(xmlStream, model) {
        model = model || this.model;
        xmlStream.openNode("comment", {
          ref: model.ref,
          authorId: 0
        });
        xmlStream.openNode("text");
        if (model && model.note && model.note.texts) {
          model.note.texts.forEach((text) => {
            this.richTextXform.render(xmlStream, text);
          });
        }
        xmlStream.closeNode();
        xmlStream.closeNode();
      },
      parseOpen(node) {
        if (this.parser) {
          this.parser.parseOpen(node);
          return true;
        }
        switch (node.name) {
          case "comment":
            this.model = {
              type: "note",
              note: {
                texts: []
              },
              ...node.attributes
            };
            return true;
          case "r":
            this.parser = this.richTextXform;
            this.parser.parseOpen(node);
            return true;
          default:
            return false;
        }
      },
      parseText(text) {
        if (this.parser) {
          this.parser.parseText(text);
        }
      },
      parseClose(name) {
        switch (name) {
          case "comment":
            return false;
          case "r":
            this.model.note.texts.push(this.parser.model);
            this.parser = void 0;
            return true;
          default:
            if (this.parser) {
              this.parser.parseClose(name);
            }
            return true;
        }
      }
    });
  }
});

// ../../../node_modules/exceljs/lib/xlsx/xform/comment/comments-xform.js
var require_comments_xform = __commonJS({
  "../../../node_modules/exceljs/lib/xlsx/xform/comment/comments-xform.js"(exports2, module2) {
    var XmlStream = require_xml_stream();
    var utils = require_utils2();
    var BaseXform = require_base_xform();
    var CommentXform = require_comment_xform();
    var CommentsXform = module2.exports = function() {
      this.map = {
        comment: new CommentXform()
      };
    };
    utils.inherits(
      CommentsXform,
      BaseXform,
      {
        COMMENTS_ATTRIBUTES: {
          xmlns: "http://schemas.openxmlformats.org/spreadsheetml/2006/main"
        }
      },
      {
        render(xmlStream, model) {
          model = model || this.model;
          xmlStream.openXml(XmlStream.StdDocAttributes);
          xmlStream.openNode("comments", CommentsXform.COMMENTS_ATTRIBUTES);
          xmlStream.openNode("authors");
          xmlStream.leafNode("author", null, "Author");
          xmlStream.closeNode();
          xmlStream.openNode("commentList");
          model.comments.forEach((comment) => {
            this.map.comment.render(xmlStream, comment);
          });
          xmlStream.closeNode();
          xmlStream.closeNode();
        },
        parseOpen(node) {
          if (this.parser) {
            this.parser.parseOpen(node);
            return true;
          }
          switch (node.name) {
            case "commentList":
              this.model = {
                comments: []
              };
              return true;
            case "comment":
              this.parser = this.map.comment;
              this.parser.parseOpen(node);
              return true;
            default:
              return false;
          }
        },
        parseText(text) {
          if (this.parser) {
            this.parser.parseText(text);
          }
        },
        parseClose(name) {
          switch (name) {
            case "commentList":
              return false;
            case "comment":
              this.model.comments.push(this.parser.model);
              this.parser = void 0;
              return true;
            default:
              if (this.parser) {
                this.parser.parseClose(name);
              }
              return true;
          }
        }
      }
    );
  }
});

// ../../../node_modules/exceljs/lib/xlsx/xform/comment/vml-textbox-xform.js
var require_vml_textbox_xform = __commonJS({
  "../../../node_modules/exceljs/lib/xlsx/xform/comment/vml-textbox-xform.js"(exports2, module2) {
    var BaseXform = require_base_xform();
    var VmlTextboxXform = class extends BaseXform {
      get tag() {
        return "v:textbox";
      }
      conversionUnit(value, multiple, unit) {
        return `${parseFloat(value) * multiple.toFixed(2)}${unit}`;
      }
      reverseConversionUnit(inset) {
        return (inset || "").split(",").map((margin) => {
          return Number(parseFloat(this.conversionUnit(parseFloat(margin), 0.1, "")).toFixed(2));
        });
      }
      render(xmlStream, model) {
        const attributes = {
          style: "mso-direction-alt:auto"
        };
        if (model && model.note) {
          let { inset } = model.note && model.note.margins;
          if (Array.isArray(inset)) {
            inset = inset.map((margin) => {
              return this.conversionUnit(margin, 10, "mm");
            }).join(",");
          }
          if (inset) {
            attributes.inset = inset;
          }
        }
        xmlStream.openNode("v:textbox", attributes);
        xmlStream.leafNode("div", { style: "text-align:left" });
        xmlStream.closeNode();
      }
      parseOpen(node) {
        switch (node.name) {
          case this.tag:
            this.model = {
              inset: this.reverseConversionUnit(node.attributes.inset)
            };
            return true;
          default:
            return true;
        }
      }
      parseText() {
      }
      parseClose(name) {
        switch (name) {
          case this.tag:
            return false;
          default:
            return true;
        }
      }
    };
    module2.exports = VmlTextboxXform;
  }
});

// ../../../node_modules/exceljs/lib/xlsx/xform/comment/vml-anchor-xform.js
var require_vml_anchor_xform = __commonJS({
  "../../../node_modules/exceljs/lib/xlsx/xform/comment/vml-anchor-xform.js"(exports2, module2) {
    var BaseXform = require_base_xform();
    var VmlAnchorXform = class extends BaseXform {
      get tag() {
        return "x:Anchor";
      }
      getAnchorRect(anchor) {
        const l2 = Math.floor(anchor.left);
        const lf = Math.floor((anchor.left - l2) * 68);
        const t = Math.floor(anchor.top);
        const tf = Math.floor((anchor.top - t) * 18);
        const r = Math.floor(anchor.right);
        const rf = Math.floor((anchor.right - r) * 68);
        const b = Math.floor(anchor.bottom);
        const bf = Math.floor((anchor.bottom - b) * 18);
        return [l2, lf, t, tf, r, rf, b, bf];
      }
      getDefaultRect(ref) {
        const l2 = ref.col;
        const lf = 6;
        const t = Math.max(ref.row - 2, 0);
        const tf = 14;
        const r = l2 + 2;
        const rf = 2;
        const b = t + 4;
        const bf = 16;
        return [l2, lf, t, tf, r, rf, b, bf];
      }
      render(xmlStream, model) {
        const rect = model.anchor ? this.getAnchorRect(model.anchor) : this.getDefaultRect(model.refAddress);
        xmlStream.leafNode("x:Anchor", null, rect.join(", "));
      }
      parseOpen(node) {
        switch (node.name) {
          case this.tag:
            this.text = "";
            return true;
          default:
            return false;
        }
      }
      parseText(text) {
        this.text = text;
      }
      parseClose() {
        return false;
      }
    };
    module2.exports = VmlAnchorXform;
  }
});

// ../../../node_modules/exceljs/lib/xlsx/xform/comment/style/vml-protection-xform.js
var require_vml_protection_xform = __commonJS({
  "../../../node_modules/exceljs/lib/xlsx/xform/comment/style/vml-protection-xform.js"(exports2, module2) {
    var BaseXform = require_base_xform();
    var VmlProtectionXform = class extends BaseXform {
      constructor(model) {
        super();
        this._model = model;
      }
      get tag() {
        return this._model && this._model.tag;
      }
      render(xmlStream, model) {
        xmlStream.leafNode(this.tag, null, model);
      }
      parseOpen(node) {
        switch (node.name) {
          case this.tag:
            this.text = "";
            return true;
          default:
            return false;
        }
      }
      parseText(text) {
        this.text = text;
      }
      parseClose() {
        return false;
      }
    };
    module2.exports = VmlProtectionXform;
  }
});

// ../../../node_modules/exceljs/lib/xlsx/xform/comment/style/vml-position-xform.js
var require_vml_position_xform = __commonJS({
  "../../../node_modules/exceljs/lib/xlsx/xform/comment/style/vml-position-xform.js"(exports2, module2) {
    var BaseXform = require_base_xform();
    var VmlPositionXform = class extends BaseXform {
      constructor(model) {
        super();
        this._model = model;
      }
      get tag() {
        return this._model && this._model.tag;
      }
      render(xmlStream, model, type) {
        if (model === type[2]) {
          xmlStream.leafNode(this.tag);
        } else if (this.tag === "x:SizeWithCells" && model === type[1]) {
          xmlStream.leafNode(this.tag);
        }
      }
      parseOpen(node) {
        switch (node.name) {
          case this.tag:
            this.model = {};
            this.model[this.tag] = true;
            return true;
          default:
            return false;
        }
      }
      parseText() {
      }
      parseClose() {
        return false;
      }
    };
    module2.exports = VmlPositionXform;
  }
});

// ../../../node_modules/exceljs/lib/xlsx/xform/comment/vml-client-data-xform.js
var require_vml_client_data_xform = __commonJS({
  "../../../node_modules/exceljs/lib/xlsx/xform/comment/vml-client-data-xform.js"(exports2, module2) {
    var BaseXform = require_base_xform();
    var VmlAnchorXform = require_vml_anchor_xform();
    var VmlProtectionXform = require_vml_protection_xform();
    var VmlPositionXform = require_vml_position_xform();
    var POSITION_TYPE = ["twoCells", "oneCells", "absolute"];
    var VmlClientDataXform = class extends BaseXform {
      constructor() {
        super();
        this.map = {
          "x:Anchor": new VmlAnchorXform(),
          "x:Locked": new VmlProtectionXform({ tag: "x:Locked" }),
          "x:LockText": new VmlProtectionXform({ tag: "x:LockText" }),
          "x:SizeWithCells": new VmlPositionXform({ tag: "x:SizeWithCells" }),
          "x:MoveWithCells": new VmlPositionXform({ tag: "x:MoveWithCells" })
        };
      }
      get tag() {
        return "x:ClientData";
      }
      render(xmlStream, model) {
        const { protection, editAs } = model.note;
        xmlStream.openNode(this.tag, { ObjectType: "Note" });
        this.map["x:MoveWithCells"].render(xmlStream, editAs, POSITION_TYPE);
        this.map["x:SizeWithCells"].render(xmlStream, editAs, POSITION_TYPE);
        this.map["x:Anchor"].render(xmlStream, model);
        this.map["x:Locked"].render(xmlStream, protection.locked);
        xmlStream.leafNode("x:AutoFill", null, "False");
        this.map["x:LockText"].render(xmlStream, protection.lockText);
        xmlStream.leafNode("x:Row", null, model.refAddress.row - 1);
        xmlStream.leafNode("x:Column", null, model.refAddress.col - 1);
        xmlStream.closeNode();
      }
      parseOpen(node) {
        switch (node.name) {
          case this.tag:
            this.reset();
            this.model = {
              anchor: [],
              protection: {},
              editAs: ""
            };
            break;
          default:
            this.parser = this.map[node.name];
            if (this.parser) {
              this.parser.parseOpen(node);
            }
            break;
        }
        return true;
      }
      parseText(text) {
        if (this.parser) {
          this.parser.parseText(text);
        }
      }
      parseClose(name) {
        if (this.parser) {
          if (!this.parser.parseClose(name)) {
            this.parser = void 0;
          }
          return true;
        }
        switch (name) {
          case this.tag:
            this.normalizeModel();
            return false;
          default:
            return true;
        }
      }
      normalizeModel() {
        const position = Object.assign(
          {},
          this.map["x:MoveWithCells"].model,
          this.map["x:SizeWithCells"].model
        );
        const len = Object.keys(position).length;
        this.model.editAs = POSITION_TYPE[len];
        this.model.anchor = this.map["x:Anchor"].text;
        this.model.protection.locked = this.map["x:Locked"].text;
        this.model.protection.lockText = this.map["x:LockText"].text;
      }
    };
    module2.exports = VmlClientDataXform;
  }
});

// ../../../node_modules/exceljs/lib/xlsx/xform/comment/vml-shape-xform.js
var require_vml_shape_xform = __commonJS({
  "../../../node_modules/exceljs/lib/xlsx/xform/comment/vml-shape-xform.js"(exports2, module2) {
    var BaseXform = require_base_xform();
    var VmlTextboxXform = require_vml_textbox_xform();
    var VmlClientDataXform = require_vml_client_data_xform();
    var VmlShapeXform = class _VmlShapeXform extends BaseXform {
      constructor() {
        super();
        this.map = {
          "v:textbox": new VmlTextboxXform(),
          "x:ClientData": new VmlClientDataXform()
        };
      }
      get tag() {
        return "v:shape";
      }
      render(xmlStream, model, index) {
        xmlStream.openNode("v:shape", _VmlShapeXform.V_SHAPE_ATTRIBUTES(model, index));
        xmlStream.leafNode("v:fill", { color2: "infoBackground [80]" });
        xmlStream.leafNode("v:shadow", { color: "none [81]", obscured: "t" });
        xmlStream.leafNode("v:path", { "o:connecttype": "none" });
        this.map["v:textbox"].render(xmlStream, model);
        this.map["x:ClientData"].render(xmlStream, model);
        xmlStream.closeNode();
      }
      parseOpen(node) {
        if (this.parser) {
          this.parser.parseOpen(node);
          return true;
        }
        switch (node.name) {
          case this.tag:
            this.reset();
            this.model = {
              margins: {
                insetmode: node.attributes["o:insetmode"]
              },
              anchor: "",
              editAs: "",
              protection: {}
            };
            break;
          default:
            this.parser = this.map[node.name];
            if (this.parser) {
              this.parser.parseOpen(node);
            }
            break;
        }
        return true;
      }
      parseText(text) {
        if (this.parser) {
          this.parser.parseText(text);
        }
      }
      parseClose(name) {
        if (this.parser) {
          if (!this.parser.parseClose(name)) {
            this.parser = void 0;
          }
          return true;
        }
        switch (name) {
          case this.tag:
            this.model.margins.inset = this.map["v:textbox"].model && this.map["v:textbox"].model.inset;
            this.model.protection = this.map["x:ClientData"].model && this.map["x:ClientData"].model.protection;
            this.model.anchor = this.map["x:ClientData"].model && this.map["x:ClientData"].model.anchor;
            this.model.editAs = this.map["x:ClientData"].model && this.map["x:ClientData"].model.editAs;
            return false;
          default:
            return true;
        }
      }
    };
    VmlShapeXform.V_SHAPE_ATTRIBUTES = (model, index) => ({
      id: `_x0000_s${1025 + index}`,
      type: "#_x0000_t202",
      style: "position:absolute; margin-left:105.3pt;margin-top:10.5pt;width:97.8pt;height:59.1pt;z-index:1;visibility:hidden",
      fillcolor: "infoBackground [80]",
      strokecolor: "none [81]",
      "o:insetmode": model.note.margins && model.note.margins.insetmode
    });
    module2.exports = VmlShapeXform;
  }
});

// ../../../node_modules/exceljs/lib/xlsx/xform/comment/vml-notes-xform.js
var require_vml_notes_xform = __commonJS({
  "../../../node_modules/exceljs/lib/xlsx/xform/comment/vml-notes-xform.js"(exports2, module2) {
    var XmlStream = require_xml_stream();
    var BaseXform = require_base_xform();
    var VmlShapeXform = require_vml_shape_xform();
    var VmlNotesXform = class _VmlNotesXform extends BaseXform {
      constructor() {
        super();
        this.map = {
          "v:shape": new VmlShapeXform()
        };
      }
      get tag() {
        return "xml";
      }
      render(xmlStream, model) {
        xmlStream.openXml(XmlStream.StdDocAttributes);
        xmlStream.openNode(this.tag, _VmlNotesXform.DRAWING_ATTRIBUTES);
        xmlStream.openNode("o:shapelayout", { "v:ext": "edit" });
        xmlStream.leafNode("o:idmap", { "v:ext": "edit", data: 1 });
        xmlStream.closeNode();
        xmlStream.openNode("v:shapetype", {
          id: "_x0000_t202",
          coordsize: "21600,21600",
          "o:spt": 202,
          path: "m,l,21600r21600,l21600,xe"
        });
        xmlStream.leafNode("v:stroke", { joinstyle: "miter" });
        xmlStream.leafNode("v:path", { gradientshapeok: "t", "o:connecttype": "rect" });
        xmlStream.closeNode();
        model.comments.forEach((item, index) => {
          this.map["v:shape"].render(xmlStream, item, index);
        });
        xmlStream.closeNode();
      }
      parseOpen(node) {
        if (this.parser) {
          this.parser.parseOpen(node);
          return true;
        }
        switch (node.name) {
          case this.tag:
            this.reset();
            this.model = {
              comments: []
            };
            break;
          default:
            this.parser = this.map[node.name];
            if (this.parser) {
              this.parser.parseOpen(node);
            }
            break;
        }
        return true;
      }
      parseText(text) {
        if (this.parser) {
          this.parser.parseText(text);
        }
      }
      parseClose(name) {
        if (this.parser) {
          if (!this.parser.parseClose(name)) {
            this.model.comments.push(this.parser.model);
            this.parser = void 0;
          }
          return true;
        }
        switch (name) {
          case this.tag:
            return false;
          default:
            return true;
        }
      }
      reconcile(model, options) {
        model.anchors.forEach((anchor) => {
          if (anchor.br) {
            this.map["xdr:twoCellAnchor"].reconcile(anchor, options);
          } else {
            this.map["xdr:oneCellAnchor"].reconcile(anchor, options);
          }
        });
      }
    };
    VmlNotesXform.DRAWING_ATTRIBUTES = {
      "xmlns:v": "urn:schemas-microsoft-com:vml",
      "xmlns:o": "urn:schemas-microsoft-com:office:office",
      "xmlns:x": "urn:schemas-microsoft-com:office:excel"
    };
    module2.exports = VmlNotesXform;
  }
});

// ../../../node_modules/exceljs/lib/xlsx/xml/theme1.js
var require_theme1 = __commonJS({
  "../../../node_modules/exceljs/lib/xlsx/xml/theme1.js"(exports2, module2) {
    module2.exports = '<?xml version="1.0" encoding="UTF-8" standalone="yes"?>\n<a:theme xmlns:a="http://schemas.openxmlformats.org/drawingml/2006/main" name="Office Theme"> <a:themeElements> <a:clrScheme name="Office"> <a:dk1> <a:sysClr val="windowText" lastClr="000000"/> </a:dk1> <a:lt1> <a:sysClr val="window" lastClr="FFFFFF"/> </a:lt1> <a:dk2> <a:srgbClr val="1F497D"/> </a:dk2> <a:lt2> <a:srgbClr val="EEECE1"/> </a:lt2> <a:accent1> <a:srgbClr val="4F81BD"/> </a:accent1> <a:accent2> <a:srgbClr val="C0504D"/> </a:accent2> <a:accent3> <a:srgbClr val="9BBB59"/> </a:accent3> <a:accent4> <a:srgbClr val="8064A2"/> </a:accent4> <a:accent5> <a:srgbClr val="4BACC6"/> </a:accent5> <a:accent6> <a:srgbClr val="F79646"/> </a:accent6> <a:hlink> <a:srgbClr val="0000FF"/> </a:hlink> <a:folHlink> <a:srgbClr val="800080"/> </a:folHlink> </a:clrScheme> <a:fontScheme name="Office"> <a:majorFont> <a:latin typeface="Cambria"/> <a:ea typeface=""/> <a:cs typeface=""/> <a:font script="Jpan" typeface="\uFF2D\uFF33 \uFF30\u30B4\u30B7\u30C3\u30AF"/> <a:font script="Hang" typeface="\uB9D1\uC740 \uACE0\uB515"/> <a:font script="Hans" typeface="\u5B8B\u4F53"/> <a:font script="Hant" typeface="\u65B0\u7D30\u660E\u9AD4"/> <a:font script="Arab" typeface="Times New Roman"/> <a:font script="Hebr" typeface="Times New Roman"/> <a:font script="Thai" typeface="Tahoma"/> <a:font script="Ethi" typeface="Nyala"/> <a:font script="Beng" typeface="Vrinda"/> <a:font script="Gujr" typeface="Shruti"/> <a:font script="Khmr" typeface="MoolBoran"/> <a:font script="Knda" typeface="Tunga"/> <a:font script="Guru" typeface="Raavi"/> <a:font script="Cans" typeface="Euphemia"/> <a:font script="Cher" typeface="Plantagenet Cherokee"/> <a:font script="Yiii" typeface="Microsoft Yi Baiti"/> <a:font script="Tibt" typeface="Microsoft Himalaya"/> <a:font script="Thaa" typeface="MV Boli"/> <a:font script="Deva" typeface="Mangal"/> <a:font script="Telu" typeface="Gautami"/> <a:font script="Taml" typeface="Latha"/> <a:font script="Syrc" typeface="Estrangelo Edessa"/> <a:font script="Orya" typeface="Kalinga"/> <a:font script="Mlym" typeface="Kartika"/> <a:font script="Laoo" typeface="DokChampa"/> <a:font script="Sinh" typeface="Iskoola Pota"/> <a:font script="Mong" typeface="Mongolian Baiti"/> <a:font script="Viet" typeface="Times New Roman"/> <a:font script="Uigh" typeface="Microsoft Uighur"/> <a:font script="Geor" typeface="Sylfaen"/> </a:majorFont> <a:minorFont> <a:latin typeface="Calibri"/> <a:ea typeface=""/> <a:cs typeface=""/> <a:font script="Jpan" typeface="\uFF2D\uFF33 \uFF30\u30B4\u30B7\u30C3\u30AF"/> <a:font script="Hang" typeface="\uB9D1\uC740 \uACE0\uB515"/> <a:font script="Hans" typeface="\u5B8B\u4F53"/> <a:font script="Hant" typeface="\u65B0\u7D30\u660E\u9AD4"/> <a:font script="Arab" typeface="Arial"/> <a:font script="Hebr" typeface="Arial"/> <a:font script="Thai" typeface="Tahoma"/> <a:font script="Ethi" typeface="Nyala"/> <a:font script="Beng" typeface="Vrinda"/> <a:font script="Gujr" typeface="Shruti"/> <a:font script="Khmr" typeface="DaunPenh"/> <a:font script="Knda" typeface="Tunga"/> <a:font script="Guru" typeface="Raavi"/> <a:font script="Cans" typeface="Euphemia"/> <a:font script="Cher" typeface="Plantagenet Cherokee"/> <a:font script="Yiii" typeface="Microsoft Yi Baiti"/> <a:font script="Tibt" typeface="Microsoft Himalaya"/> <a:font script="Thaa" typeface="MV Boli"/> <a:font script="Deva" typeface="Mangal"/> <a:font script="Telu" typeface="Gautami"/> <a:font script="Taml" typeface="Latha"/> <a:font script="Syrc" typeface="Estrangelo Edessa"/> <a:font script="Orya" typeface="Kalinga"/> <a:font script="Mlym" typeface="Kartika"/> <a:font script="Laoo" typeface="DokChampa"/> <a:font script="Sinh" typeface="Iskoola Pota"/> <a:font script="Mong" typeface="Mongolian Baiti"/> <a:font script="Viet" typeface="Arial"/> <a:font script="Uigh" typeface="Microsoft Uighur"/> <a:font script="Geor" typeface="Sylfaen"/> </a:minorFont> </a:fontScheme> <a:fmtScheme name="Office"> <a:fillStyleLst> <a:solidFill> <a:schemeClr val="phClr"/> </a:solidFill> <a:gradFill rotWithShape="1"> <a:gsLst> <a:gs pos="0"> <a:schemeClr val="phClr"> <a:tint val="50000"/> <a:satMod val="300000"/> </a:schemeClr> </a:gs> <a:gs pos="35000"> <a:schemeClr val="phClr"> <a:tint val="37000"/> <a:satMod val="300000"/> </a:schemeClr> </a:gs> <a:gs pos="100000"> <a:schemeClr val="phClr"> <a:tint val="15000"/> <a:satMod val="350000"/> </a:schemeClr> </a:gs> </a:gsLst> <a:lin ang="16200000" scaled="1"/> </a:gradFill> <a:gradFill rotWithShape="1"> <a:gsLst> <a:gs pos="0"> <a:schemeClr val="phClr"> <a:tint val="100000"/> <a:shade val="100000"/> <a:satMod val="130000"/> </a:schemeClr> </a:gs> <a:gs pos="100000"> <a:schemeClr val="phClr"> <a:tint val="50000"/> <a:shade val="100000"/> <a:satMod val="350000"/> </a:schemeClr> </a:gs> </a:gsLst> <a:lin ang="16200000" scaled="0"/> </a:gradFill> </a:fillStyleLst> <a:lnStyleLst> <a:ln w="9525" cap="flat" cmpd="sng" algn="ctr"> <a:solidFill> <a:schemeClr val="phClr"> <a:shade val="95000"/> <a:satMod val="105000"/> </a:schemeClr> </a:solidFill> <a:prstDash val="solid"/> </a:ln> <a:ln w="25400" cap="flat" cmpd="sng" algn="ctr"> <a:solidFill> <a:schemeClr val="phClr"/> </a:solidFill> <a:prstDash val="solid"/> </a:ln> <a:ln w="38100" cap="flat" cmpd="sng" algn="ctr"> <a:solidFill> <a:schemeClr val="phClr"/> </a:solidFill> <a:prstDash val="solid"/> </a:ln> </a:lnStyleLst> <a:effectStyleLst> <a:effectStyle> <a:effectLst> <a:outerShdw blurRad="40000" dist="20000" dir="5400000" rotWithShape="0"> <a:srgbClr val="000000"> <a:alpha val="38000"/> </a:srgbClr> </a:outerShdw> </a:effectLst> </a:effectStyle> <a:effectStyle> <a:effectLst> <a:outerShdw blurRad="40000" dist="23000" dir="5400000" rotWithShape="0"> <a:srgbClr val="000000"> <a:alpha val="35000"/> </a:srgbClr> </a:outerShdw> </a:effectLst> </a:effectStyle> <a:effectStyle> <a:effectLst> <a:outerShdw blurRad="40000" dist="23000" dir="5400000" rotWithShape="0"> <a:srgbClr val="000000"> <a:alpha val="35000"/> </a:srgbClr> </a:outerShdw> </a:effectLst> <a:scene3d> <a:camera prst="orthographicFront"> <a:rot lat="0" lon="0" rev="0"/> </a:camera> <a:lightRig rig="threePt" dir="t"> <a:rot lat="0" lon="0" rev="1200000"/> </a:lightRig> </a:scene3d> <a:sp3d> <a:bevelT w="63500" h="25400"/> </a:sp3d> </a:effectStyle> </a:effectStyleLst> <a:bgFillStyleLst> <a:solidFill> <a:schemeClr val="phClr"/> </a:solidFill> <a:gradFill rotWithShape="1"> <a:gsLst> <a:gs pos="0"> <a:schemeClr val="phClr"> <a:tint val="40000"/> <a:satMod val="350000"/> </a:schemeClr> </a:gs> <a:gs pos="40000"> <a:schemeClr val="phClr"> <a:tint val="45000"/> <a:shade val="99000"/> <a:satMod val="350000"/> </a:schemeClr> </a:gs> <a:gs pos="100000"> <a:schemeClr val="phClr"> <a:shade val="20000"/> <a:satMod val="255000"/> </a:schemeClr> </a:gs> </a:gsLst> <a:path path="circle"> <a:fillToRect l="50000" t="-80000" r="50000" b="180000"/> </a:path> </a:gradFill> <a:gradFill rotWithShape="1"> <a:gsLst> <a:gs pos="0"> <a:schemeClr val="phClr"> <a:tint val="80000"/> <a:satMod val="300000"/> </a:schemeClr> </a:gs> <a:gs pos="100000"> <a:schemeClr val="phClr"> <a:shade val="30000"/> <a:satMod val="200000"/> </a:schemeClr> </a:gs> </a:gsLst> <a:path path="circle"> <a:fillToRect l="50000" t="50000" r="50000" b="50000"/> </a:path> </a:gradFill> </a:bgFillStyleLst> </a:fmtScheme> </a:themeElements> <a:objectDefaults> <a:spDef> <a:spPr/> <a:bodyPr/> <a:lstStyle/> <a:style> <a:lnRef idx="1"> <a:schemeClr val="accent1"/> </a:lnRef> <a:fillRef idx="3"> <a:schemeClr val="accent1"/> </a:fillRef> <a:effectRef idx="2"> <a:schemeClr val="accent1"/> </a:effectRef> <a:fontRef idx="minor"> <a:schemeClr val="lt1"/> </a:fontRef> </a:style> </a:spDef> <a:lnDef> <a:spPr/> <a:bodyPr/> <a:lstStyle/> <a:style> <a:lnRef idx="2"> <a:schemeClr val="accent1"/> </a:lnRef> <a:fillRef idx="0"> <a:schemeClr val="accent1"/> </a:fillRef> <a:effectRef idx="1"> <a:schemeClr val="accent1"/> </a:effectRef> <a:fontRef idx="minor"> <a:schemeClr val="tx1"/> </a:fontRef> </a:style> </a:lnDef> </a:objectDefaults> <a:extraClrSchemeLst/> </a:theme>';
  }
});

// ../../../node_modules/exceljs/lib/xlsx/xlsx.js
var require_xlsx = __commonJS({
  "../../../node_modules/exceljs/lib/xlsx/xlsx.js"(exports2, module2) {
    var fs = require("fs");
    var JSZip = require_lib3();
    var { PassThrough } = require_readable2();
    var ZipStream = require_zip_stream();
    var StreamBuf = require_stream_buf();
    var utils = require_utils2();
    var XmlStream = require_xml_stream();
    var { bufferToString } = require_browser_buffer_decode();
    var StylesXform = require_styles_xform();
    var CoreXform = require_core_xform();
    var SharedStringsXform = require_shared_strings_xform();
    var RelationshipsXform = require_relationships_xform();
    var ContentTypesXform = require_content_types_xform();
    var AppXform = require_app_xform();
    var WorkbookXform = require_workbook_xform();
    var WorksheetXform = require_worksheet_xform();
    var DrawingXform = require_drawing_xform2();
    var TableXform = require_table_xform();
    var CommentsXform = require_comments_xform();
    var VmlNotesXform = require_vml_notes_xform();
    var theme1Xml = require_theme1();
    function fsReadFileAsync(filename, options) {
      return new Promise((resolve, reject) => {
        fs.readFile(filename, options, (error, data) => {
          if (error) {
            reject(error);
          } else {
            resolve(data);
          }
        });
      });
    }
    var XLSX = class _XLSX {
      constructor(workbook) {
        this.workbook = workbook;
      }
      // ===============================================================================
      // Workbook
      // =========================================================================
      // Read
      async readFile(filename, options) {
        if (!await utils.fs.exists(filename)) {
          throw new Error(`File not found: ${filename}`);
        }
        const stream = fs.createReadStream(filename);
        try {
          const workbook = await this.read(stream, options);
          stream.close();
          return workbook;
        } catch (error) {
          stream.close();
          throw error;
        }
      }
      parseRels(stream) {
        const xform = new RelationshipsXform();
        return xform.parseStream(stream);
      }
      parseWorkbook(stream) {
        const xform = new WorkbookXform();
        return xform.parseStream(stream);
      }
      parseSharedStrings(stream) {
        const xform = new SharedStringsXform();
        return xform.parseStream(stream);
      }
      reconcile(model, options) {
        const workbookXform = new WorkbookXform();
        const worksheetXform = new WorksheetXform(options);
        const drawingXform = new DrawingXform();
        const tableXform = new TableXform();
        workbookXform.reconcile(model);
        const drawingOptions = {
          media: model.media,
          mediaIndex: model.mediaIndex
        };
        Object.keys(model.drawings).forEach((name) => {
          const drawing = model.drawings[name];
          const drawingRel = model.drawingRels[name];
          if (drawingRel) {
            drawingOptions.rels = drawingRel.reduce((o, rel) => {
              o[rel.Id] = rel;
              return o;
            }, {});
            (drawing.anchors || []).forEach((anchor) => {
              const hyperlinks = anchor.picture && anchor.picture.hyperlinks;
              if (hyperlinks && drawingOptions.rels[hyperlinks.rId]) {
                hyperlinks.hyperlink = drawingOptions.rels[hyperlinks.rId].Target;
                delete hyperlinks.rId;
              }
            });
            drawingXform.reconcile(drawing, drawingOptions);
          }
        });
        const tableOptions = {
          styles: model.styles
        };
        Object.values(model.tables).forEach((table) => {
          tableXform.reconcile(table, tableOptions);
        });
        const sheetOptions = {
          styles: model.styles,
          sharedStrings: model.sharedStrings,
          media: model.media,
          mediaIndex: model.mediaIndex,
          date1904: model.properties && model.properties.date1904,
          drawings: model.drawings,
          comments: model.comments,
          tables: model.tables,
          vmlDrawings: model.vmlDrawings
        };
        model.worksheets.forEach((worksheet) => {
          worksheet.relationships = model.worksheetRels[worksheet.sheetNo];
          worksheetXform.reconcile(worksheet, sheetOptions);
        });
        delete model.worksheetHash;
        delete model.worksheetRels;
        delete model.globalRels;
        delete model.sharedStrings;
        delete model.workbookRels;
        delete model.sheetDefs;
        delete model.styles;
        delete model.mediaIndex;
        delete model.drawings;
        delete model.drawingRels;
        delete model.vmlDrawings;
      }
      async _processWorksheetEntry(stream, model, sheetNo, options, path) {
        const xform = new WorksheetXform(options);
        const worksheet = await xform.parseStream(stream);
        worksheet.sheetNo = sheetNo;
        model.worksheetHash[path] = worksheet;
        model.worksheets.push(worksheet);
      }
      async _processCommentEntry(stream, model, name) {
        const xform = new CommentsXform();
        const comments = await xform.parseStream(stream);
        model.comments[`../${name}.xml`] = comments;
      }
      async _processTableEntry(stream, model, name) {
        const xform = new TableXform();
        const table = await xform.parseStream(stream);
        model.tables[`../tables/${name}.xml`] = table;
      }
      async _processWorksheetRelsEntry(stream, model, sheetNo) {
        const xform = new RelationshipsXform();
        const relationships = await xform.parseStream(stream);
        model.worksheetRels[sheetNo] = relationships;
      }
      async _processMediaEntry(entry, model, filename) {
        const lastDot = filename.lastIndexOf(".");
        if (lastDot >= 1) {
          const extension = filename.substr(lastDot + 1);
          const name = filename.substr(0, lastDot);
          await new Promise((resolve, reject) => {
            const streamBuf = new StreamBuf();
            streamBuf.on("finish", () => {
              model.mediaIndex[filename] = model.media.length;
              model.mediaIndex[name] = model.media.length;
              const medium = {
                type: "image",
                name,
                extension,
                buffer: streamBuf.toBuffer()
              };
              model.media.push(medium);
              resolve();
            });
            entry.on("error", (error) => {
              reject(error);
            });
            entry.pipe(streamBuf);
          });
        }
      }
      async _processDrawingEntry(entry, model, name) {
        const xform = new DrawingXform();
        const drawing = await xform.parseStream(entry);
        model.drawings[name] = drawing;
      }
      async _processDrawingRelsEntry(entry, model, name) {
        const xform = new RelationshipsXform();
        const relationships = await xform.parseStream(entry);
        model.drawingRels[name] = relationships;
      }
      async _processVmlDrawingEntry(entry, model, name) {
        const xform = new VmlNotesXform();
        const vmlDrawing = await xform.parseStream(entry);
        model.vmlDrawings[`../drawings/${name}.vml`] = vmlDrawing;
      }
      async _processThemeEntry(entry, model, name) {
        await new Promise((resolve, reject) => {
          const stream = new StreamBuf();
          entry.on("error", reject);
          stream.on("error", reject);
          stream.on("finish", () => {
            model.themes[name] = stream.read().toString();
            resolve();
          });
          entry.pipe(stream);
        });
      }
      /**
       * @deprecated since version 4.0. You should use `#read` instead. Please follow upgrade instruction: https://github.com/exceljs/exceljs/blob/master/UPGRADE-4.0.md
       */
      createInputStream() {
        throw new Error(
          "`XLSX#createInputStream` is deprecated. You should use `XLSX#read` instead. This method will be removed in version 5.0. Please follow upgrade instruction: https://github.com/exceljs/exceljs/blob/master/UPGRADE-4.0.md"
        );
      }
      async read(stream, options) {
        if (!stream[Symbol.asyncIterator] && stream.pipe) {
          stream = stream.pipe(new PassThrough());
        }
        const chunks = [];
        for await (const chunk of stream) {
          chunks.push(chunk);
        }
        return this.load(Buffer.concat(chunks), options);
      }
      async load(data, options) {
        let buffer;
        if (options && options.base64) {
          buffer = Buffer.from(data.toString(), "base64");
        } else {
          buffer = data;
        }
        const model = {
          worksheets: [],
          worksheetHash: {},
          worksheetRels: [],
          themes: {},
          media: [],
          mediaIndex: {},
          drawings: {},
          drawingRels: {},
          comments: {},
          tables: {},
          vmlDrawings: {}
        };
        const zip = await JSZip.loadAsync(buffer);
        for (const entry of Object.values(zip.files)) {
          if (!entry.dir) {
            let entryName = entry.name;
            if (entryName[0] === "/") {
              entryName = entryName.substr(1);
            }
            let stream;
            if (entryName.match(/xl\/media\//) || // themes are not parsed as stream
            entryName.match(/xl\/theme\/([a-zA-Z0-9]+)[.]xml/)) {
              stream = new PassThrough();
              stream.write(await entry.async("nodebuffer"));
            } else {
              stream = new PassThrough({
                writableObjectMode: true,
                readableObjectMode: true
              });
              let content;
              if (process.browser) {
                content = bufferToString(await entry.async("nodebuffer"));
              } else {
                content = await entry.async("string");
              }
              const chunkSize = 16 * 1024;
              for (let i = 0; i < content.length; i += chunkSize) {
                stream.write(content.substring(i, i + chunkSize));
              }
            }
            stream.end();
            switch (entryName) {
              case "_rels/.rels":
                model.globalRels = await this.parseRels(stream);
                break;
              case "xl/workbook.xml": {
                const workbook = await this.parseWorkbook(stream);
                model.sheets = workbook.sheets;
                model.definedNames = workbook.definedNames;
                model.views = workbook.views;
                model.properties = workbook.properties;
                model.calcProperties = workbook.calcProperties;
                break;
              }
              case "xl/_rels/workbook.xml.rels":
                model.workbookRels = await this.parseRels(stream);
                break;
              case "xl/sharedStrings.xml":
                model.sharedStrings = new SharedStringsXform();
                await model.sharedStrings.parseStream(stream);
                break;
              case "xl/styles.xml":
                model.styles = new StylesXform();
                await model.styles.parseStream(stream);
                break;
              case "docProps/app.xml": {
                const appXform = new AppXform();
                const appProperties = await appXform.parseStream(stream);
                model.company = appProperties.company;
                model.manager = appProperties.manager;
                break;
              }
              case "docProps/core.xml": {
                const coreXform = new CoreXform();
                const coreProperties = await coreXform.parseStream(stream);
                Object.assign(model, coreProperties);
                break;
              }
              default: {
                let match = entryName.match(/xl\/worksheets\/sheet(\d+)[.]xml/);
                if (match) {
                  await this._processWorksheetEntry(stream, model, match[1], options, entryName);
                  break;
                }
                match = entryName.match(/xl\/worksheets\/_rels\/sheet(\d+)[.]xml.rels/);
                if (match) {
                  await this._processWorksheetRelsEntry(stream, model, match[1]);
                  break;
                }
                match = entryName.match(/xl\/theme\/([a-zA-Z0-9]+)[.]xml/);
                if (match) {
                  await this._processThemeEntry(stream, model, match[1]);
                  break;
                }
                match = entryName.match(/xl\/media\/([a-zA-Z0-9]+[.][a-zA-Z0-9]{3,4})$/);
                if (match) {
                  await this._processMediaEntry(stream, model, match[1]);
                  break;
                }
                match = entryName.match(/xl\/drawings\/([a-zA-Z0-9]+)[.]xml/);
                if (match) {
                  await this._processDrawingEntry(stream, model, match[1]);
                  break;
                }
                match = entryName.match(/xl\/(comments\d+)[.]xml/);
                if (match) {
                  await this._processCommentEntry(stream, model, match[1]);
                  break;
                }
                match = entryName.match(/xl\/tables\/(table\d+)[.]xml/);
                if (match) {
                  await this._processTableEntry(stream, model, match[1]);
                  break;
                }
                match = entryName.match(/xl\/drawings\/_rels\/([a-zA-Z0-9]+)[.]xml[.]rels/);
                if (match) {
                  await this._processDrawingRelsEntry(stream, model, match[1]);
                  break;
                }
                match = entryName.match(/xl\/drawings\/(vmlDrawing\d+)[.]vml/);
                if (match) {
                  await this._processVmlDrawingEntry(stream, model, match[1]);
                  break;
                }
              }
            }
          }
        }
        this.reconcile(model, options);
        this.workbook.model = model;
        return this.workbook;
      }
      // =========================================================================
      // Write
      async addMedia(zip, model) {
        await Promise.all(
          model.media.map(async (medium) => {
            if (medium.type === "image") {
              const filename = `xl/media/${medium.name}.${medium.extension}`;
              if (medium.filename) {
                const data = await fsReadFileAsync(medium.filename);
                return zip.append(data, { name: filename });
              }
              if (medium.buffer) {
                return zip.append(medium.buffer, { name: filename });
              }
              if (medium.base64) {
                const dataimg64 = medium.base64;
                const content = dataimg64.substring(dataimg64.indexOf(",") + 1);
                return zip.append(content, { name: filename, base64: true });
              }
            }
            throw new Error("Unsupported media");
          })
        );
      }
      addDrawings(zip, model) {
        const drawingXform = new DrawingXform();
        const relsXform = new RelationshipsXform();
        model.worksheets.forEach((worksheet) => {
          const { drawing } = worksheet;
          if (drawing) {
            drawingXform.prepare(drawing, {});
            let xml = drawingXform.toXml(drawing);
            zip.append(xml, { name: `xl/drawings/${drawing.name}.xml` });
            xml = relsXform.toXml(drawing.rels);
            zip.append(xml, { name: `xl/drawings/_rels/${drawing.name}.xml.rels` });
          }
        });
      }
      addTables(zip, model) {
        const tableXform = new TableXform();
        model.worksheets.forEach((worksheet) => {
          const { tables } = worksheet;
          tables.forEach((table) => {
            tableXform.prepare(table, {});
            const tableXml = tableXform.toXml(table);
            zip.append(tableXml, { name: `xl/tables/${table.target}` });
          });
        });
      }
      async addContentTypes(zip, model) {
        const xform = new ContentTypesXform();
        const xml = xform.toXml(model);
        zip.append(xml, { name: "[Content_Types].xml" });
      }
      async addApp(zip, model) {
        const xform = new AppXform();
        const xml = xform.toXml(model);
        zip.append(xml, { name: "docProps/app.xml" });
      }
      async addCore(zip, model) {
        const coreXform = new CoreXform();
        zip.append(coreXform.toXml(model), { name: "docProps/core.xml" });
      }
      async addThemes(zip, model) {
        const themes = model.themes || { theme1: theme1Xml };
        Object.keys(themes).forEach((name) => {
          const xml = themes[name];
          const path = `xl/theme/${name}.xml`;
          zip.append(xml, { name: path });
        });
      }
      async addOfficeRels(zip) {
        const xform = new RelationshipsXform();
        const xml = xform.toXml([
          { Id: "rId1", Type: _XLSX.RelType.OfficeDocument, Target: "xl/workbook.xml" },
          { Id: "rId2", Type: _XLSX.RelType.CoreProperties, Target: "docProps/core.xml" },
          { Id: "rId3", Type: _XLSX.RelType.ExtenderProperties, Target: "docProps/app.xml" }
        ]);
        zip.append(xml, { name: "_rels/.rels" });
      }
      async addWorkbookRels(zip, model) {
        let count = 1;
        const relationships = [
          { Id: `rId${count++}`, Type: _XLSX.RelType.Styles, Target: "styles.xml" },
          { Id: `rId${count++}`, Type: _XLSX.RelType.Theme, Target: "theme/theme1.xml" }
        ];
        if (model.sharedStrings.count) {
          relationships.push({
            Id: `rId${count++}`,
            Type: _XLSX.RelType.SharedStrings,
            Target: "sharedStrings.xml"
          });
        }
        model.worksheets.forEach((worksheet) => {
          worksheet.rId = `rId${count++}`;
          relationships.push({
            Id: worksheet.rId,
            Type: _XLSX.RelType.Worksheet,
            Target: `worksheets/sheet${worksheet.id}.xml`
          });
        });
        const xform = new RelationshipsXform();
        const xml = xform.toXml(relationships);
        zip.append(xml, { name: "xl/_rels/workbook.xml.rels" });
      }
      async addSharedStrings(zip, model) {
        if (model.sharedStrings && model.sharedStrings.count) {
          zip.append(model.sharedStrings.xml, { name: "xl/sharedStrings.xml" });
        }
      }
      async addStyles(zip, model) {
        const { xml } = model.styles;
        if (xml) {
          zip.append(xml, { name: "xl/styles.xml" });
        }
      }
      async addWorkbook(zip, model) {
        const xform = new WorkbookXform();
        zip.append(xform.toXml(model), { name: "xl/workbook.xml" });
      }
      async addWorksheets(zip, model) {
        const worksheetXform = new WorksheetXform();
        const relationshipsXform = new RelationshipsXform();
        const commentsXform = new CommentsXform();
        const vmlNotesXform = new VmlNotesXform();
        model.worksheets.forEach((worksheet) => {
          let xmlStream = new XmlStream();
          worksheetXform.render(xmlStream, worksheet);
          zip.append(xmlStream.xml, { name: `xl/worksheets/sheet${worksheet.id}.xml` });
          if (worksheet.rels && worksheet.rels.length) {
            xmlStream = new XmlStream();
            relationshipsXform.render(xmlStream, worksheet.rels);
            zip.append(xmlStream.xml, { name: `xl/worksheets/_rels/sheet${worksheet.id}.xml.rels` });
          }
          if (worksheet.comments.length > 0) {
            xmlStream = new XmlStream();
            commentsXform.render(xmlStream, worksheet);
            zip.append(xmlStream.xml, { name: `xl/comments${worksheet.id}.xml` });
            xmlStream = new XmlStream();
            vmlNotesXform.render(xmlStream, worksheet);
            zip.append(xmlStream.xml, { name: `xl/drawings/vmlDrawing${worksheet.id}.vml` });
          }
        });
      }
      _finalize(zip) {
        return new Promise((resolve, reject) => {
          zip.on("finish", () => {
            resolve(this);
          });
          zip.on("error", reject);
          zip.finalize();
        });
      }
      prepareModel(model, options) {
        model.creator = model.creator || "ExcelJS";
        model.lastModifiedBy = model.lastModifiedBy || "ExcelJS";
        model.created = model.created || /* @__PURE__ */ new Date();
        model.modified = model.modified || /* @__PURE__ */ new Date();
        model.useSharedStrings = options.useSharedStrings !== void 0 ? options.useSharedStrings : true;
        model.useStyles = options.useStyles !== void 0 ? options.useStyles : true;
        model.sharedStrings = new SharedStringsXform();
        model.styles = model.useStyles ? new StylesXform(true) : new StylesXform.Mock();
        const workbookXform = new WorkbookXform();
        const worksheetXform = new WorksheetXform();
        workbookXform.prepare(model);
        const worksheetOptions = {
          sharedStrings: model.sharedStrings,
          styles: model.styles,
          date1904: model.properties.date1904,
          drawingsCount: 0,
          media: model.media
        };
        worksheetOptions.drawings = model.drawings = [];
        worksheetOptions.commentRefs = model.commentRefs = [];
        let tableCount = 0;
        model.tables = [];
        model.worksheets.forEach((worksheet) => {
          worksheet.tables.forEach((table) => {
            tableCount++;
            table.target = `table${tableCount}.xml`;
            table.id = tableCount;
            model.tables.push(table);
          });
          worksheetXform.prepare(worksheet, worksheetOptions);
        });
      }
      async write(stream, options) {
        options = options || {};
        const { model } = this.workbook;
        const zip = new ZipStream.ZipWriter(options.zip);
        zip.pipe(stream);
        this.prepareModel(model, options);
        await this.addContentTypes(zip, model);
        await this.addOfficeRels(zip, model);
        await this.addWorkbookRels(zip, model);
        await this.addWorksheets(zip, model);
        await this.addSharedStrings(zip, model);
        await this.addDrawings(zip, model);
        await this.addTables(zip, model);
        await Promise.all([this.addThemes(zip, model), this.addStyles(zip, model)]);
        await this.addMedia(zip, model);
        await Promise.all([this.addApp(zip, model), this.addCore(zip, model)]);
        await this.addWorkbook(zip, model);
        return this._finalize(zip);
      }
      writeFile(filename, options) {
        const stream = fs.createWriteStream(filename);
        return new Promise((resolve, reject) => {
          stream.on("finish", () => {
            resolve();
          });
          stream.on("error", (error) => {
            reject(error);
          });
          this.write(stream, options).then(() => {
            stream.end();
          }).catch((err) => {
            reject(err);
          });
        });
      }
      async writeBuffer(options) {
        const stream = new StreamBuf();
        await this.write(stream, options);
        return stream.read();
      }
    };
    XLSX.RelType = require_rel_type();
    module2.exports = XLSX;
  }
});

// ../../../node_modules/@fast-csv/format/build/src/FormatterOptions.js
var require_FormatterOptions = __commonJS({
  "../../../node_modules/@fast-csv/format/build/src/FormatterOptions.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.FormatterOptions = void 0;
    var FormatterOptions = class {
      constructor(opts = {}) {
        var _a;
        this.objectMode = true;
        this.delimiter = ",";
        this.rowDelimiter = "\n";
        this.quote = '"';
        this.escape = this.quote;
        this.quoteColumns = false;
        this.quoteHeaders = this.quoteColumns;
        this.headers = null;
        this.includeEndRowDelimiter = false;
        this.writeBOM = false;
        this.BOM = "\uFEFF";
        this.alwaysWriteHeaders = false;
        Object.assign(this, opts || {});
        if (typeof (opts === null || opts === void 0 ? void 0 : opts.quoteHeaders) === "undefined") {
          this.quoteHeaders = this.quoteColumns;
        }
        if ((opts === null || opts === void 0 ? void 0 : opts.quote) === true) {
          this.quote = '"';
        } else if ((opts === null || opts === void 0 ? void 0 : opts.quote) === false) {
          this.quote = "";
        }
        if (typeof (opts === null || opts === void 0 ? void 0 : opts.escape) !== "string") {
          this.escape = this.quote;
        }
        this.shouldWriteHeaders = !!this.headers && ((_a = opts.writeHeaders) !== null && _a !== void 0 ? _a : true);
        this.headers = Array.isArray(this.headers) ? this.headers : null;
        this.escapedQuote = `${this.escape}${this.quote}`;
      }
    };
    exports2.FormatterOptions = FormatterOptions;
  }
});

// ../../../node_modules/lodash.isfunction/index.js
var require_lodash = __commonJS({
  "../../../node_modules/lodash.isfunction/index.js"(exports2, module2) {
    var asyncTag = "[object AsyncFunction]";
    var funcTag = "[object Function]";
    var genTag = "[object GeneratorFunction]";
    var nullTag = "[object Null]";
    var proxyTag = "[object Proxy]";
    var undefinedTag = "[object Undefined]";
    var freeGlobal = typeof global == "object" && global && global.Object === Object && global;
    var freeSelf = typeof self == "object" && self && self.Object === Object && self;
    var root = freeGlobal || freeSelf || Function("return this")();
    var objectProto = Object.prototype;
    var hasOwnProperty = objectProto.hasOwnProperty;
    var nativeObjectToString = objectProto.toString;
    var Symbol2 = root.Symbol;
    var symToStringTag = Symbol2 ? Symbol2.toStringTag : void 0;
    function baseGetTag(value) {
      if (value == null) {
        return value === void 0 ? undefinedTag : nullTag;
      }
      return symToStringTag && symToStringTag in Object(value) ? getRawTag(value) : objectToString(value);
    }
    function getRawTag(value) {
      var isOwn = hasOwnProperty.call(value, symToStringTag), tag = value[symToStringTag];
      try {
        value[symToStringTag] = void 0;
        var unmasked = true;
      } catch (e) {
      }
      var result = nativeObjectToString.call(value);
      if (unmasked) {
        if (isOwn) {
          value[symToStringTag] = tag;
        } else {
          delete value[symToStringTag];
        }
      }
      return result;
    }
    function objectToString(value) {
      return nativeObjectToString.call(value);
    }
    function isFunction(value) {
      if (!isObject2(value)) {
        return false;
      }
      var tag = baseGetTag(value);
      return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;
    }
    function isObject2(value) {
      var type = typeof value;
      return value != null && (type == "object" || type == "function");
    }
    module2.exports = isFunction;
  }
});

// ../../../node_modules/lodash.isequal/index.js
var require_lodash2 = __commonJS({
  "../../../node_modules/lodash.isequal/index.js"(exports2, module2) {
    var LARGE_ARRAY_SIZE = 200;
    var HASH_UNDEFINED = "__lodash_hash_undefined__";
    var COMPARE_PARTIAL_FLAG = 1;
    var COMPARE_UNORDERED_FLAG = 2;
    var MAX_SAFE_INTEGER = 9007199254740991;
    var argsTag = "[object Arguments]";
    var arrayTag = "[object Array]";
    var asyncTag = "[object AsyncFunction]";
    var boolTag = "[object Boolean]";
    var dateTag = "[object Date]";
    var errorTag = "[object Error]";
    var funcTag = "[object Function]";
    var genTag = "[object GeneratorFunction]";
    var mapTag = "[object Map]";
    var numberTag = "[object Number]";
    var nullTag = "[object Null]";
    var objectTag = "[object Object]";
    var promiseTag = "[object Promise]";
    var proxyTag = "[object Proxy]";
    var regexpTag = "[object RegExp]";
    var setTag = "[object Set]";
    var stringTag = "[object String]";
    var symbolTag = "[object Symbol]";
    var undefinedTag = "[object Undefined]";
    var weakMapTag = "[object WeakMap]";
    var arrayBufferTag = "[object ArrayBuffer]";
    var dataViewTag = "[object DataView]";
    var float32Tag = "[object Float32Array]";
    var float64Tag = "[object Float64Array]";
    var int8Tag = "[object Int8Array]";
    var int16Tag = "[object Int16Array]";
    var int32Tag = "[object Int32Array]";
    var uint8Tag = "[object Uint8Array]";
    var uint8ClampedTag = "[object Uint8ClampedArray]";
    var uint16Tag = "[object Uint16Array]";
    var uint32Tag = "[object Uint32Array]";
    var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;
    var reIsHostCtor = /^\[object .+?Constructor\]$/;
    var reIsUint = /^(?:0|[1-9]\d*)$/;
    var typedArrayTags = {};
    typedArrayTags[float32Tag] = typedArrayTags[float64Tag] = typedArrayTags[int8Tag] = typedArrayTags[int16Tag] = typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] = typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] = typedArrayTags[uint32Tag] = true;
    typedArrayTags[argsTag] = typedArrayTags[arrayTag] = typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] = typedArrayTags[dataViewTag] = typedArrayTags[dateTag] = typedArrayTags[errorTag] = typedArrayTags[funcTag] = typedArrayTags[mapTag] = typedArrayTags[numberTag] = typedArrayTags[objectTag] = typedArrayTags[regexpTag] = typedArrayTags[setTag] = typedArrayTags[stringTag] = typedArrayTags[weakMapTag] = false;
    var freeGlobal = typeof global == "object" && global && global.Object === Object && global;
    var freeSelf = typeof self == "object" && self && self.Object === Object && self;
    var root = freeGlobal || freeSelf || Function("return this")();
    var freeExports = typeof exports2 == "object" && exports2 && !exports2.nodeType && exports2;
    var freeModule = freeExports && typeof module2 == "object" && module2 && !module2.nodeType && module2;
    var moduleExports = freeModule && freeModule.exports === freeExports;
    var freeProcess = moduleExports && freeGlobal.process;
    var nodeUtil = function() {
      try {
        return freeProcess && freeProcess.binding && freeProcess.binding("util");
      } catch (e) {
      }
    }();
    var nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;
    function arrayFilter(array, predicate) {
      var index = -1, length = array == null ? 0 : array.length, resIndex = 0, result = [];
      while (++index < length) {
        var value = array[index];
        if (predicate(value, index, array)) {
          result[resIndex++] = value;
        }
      }
      return result;
    }
    function arrayPush(array, values) {
      var index = -1, length = values.length, offset = array.length;
      while (++index < length) {
        array[offset + index] = values[index];
      }
      return array;
    }
    function arraySome(array, predicate) {
      var index = -1, length = array == null ? 0 : array.length;
      while (++index < length) {
        if (predicate(array[index], index, array)) {
          return true;
        }
      }
      return false;
    }
    function baseTimes(n, iteratee) {
      var index = -1, result = Array(n);
      while (++index < n) {
        result[index] = iteratee(index);
      }
      return result;
    }
    function baseUnary(func) {
      return function(value) {
        return func(value);
      };
    }
    function cacheHas(cache, key) {
      return cache.has(key);
    }
    function getValue(object, key) {
      return object == null ? void 0 : object[key];
    }
    function mapToArray(map) {
      var index = -1, result = Array(map.size);
      map.forEach(function(value, key) {
        result[++index] = [key, value];
      });
      return result;
    }
    function overArg(func, transform) {
      return function(arg) {
        return func(transform(arg));
      };
    }
    function setToArray(set) {
      var index = -1, result = Array(set.size);
      set.forEach(function(value) {
        result[++index] = value;
      });
      return result;
    }
    var arrayProto = Array.prototype;
    var funcProto = Function.prototype;
    var objectProto = Object.prototype;
    var coreJsData = root["__core-js_shared__"];
    var funcToString = funcProto.toString;
    var hasOwnProperty = objectProto.hasOwnProperty;
    var maskSrcKey = function() {
      var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || "");
      return uid ? "Symbol(src)_1." + uid : "";
    }();
    var nativeObjectToString = objectProto.toString;
    var reIsNative = RegExp(
      "^" + funcToString.call(hasOwnProperty).replace(reRegExpChar, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"
    );
    var Buffer2 = moduleExports ? root.Buffer : void 0;
    var Symbol2 = root.Symbol;
    var Uint8Array2 = root.Uint8Array;
    var propertyIsEnumerable = objectProto.propertyIsEnumerable;
    var splice = arrayProto.splice;
    var symToStringTag = Symbol2 ? Symbol2.toStringTag : void 0;
    var nativeGetSymbols = Object.getOwnPropertySymbols;
    var nativeIsBuffer = Buffer2 ? Buffer2.isBuffer : void 0;
    var nativeKeys = overArg(Object.keys, Object);
    var DataView2 = getNative(root, "DataView");
    var Map2 = getNative(root, "Map");
    var Promise2 = getNative(root, "Promise");
    var Set2 = getNative(root, "Set");
    var WeakMap2 = getNative(root, "WeakMap");
    var nativeCreate = getNative(Object, "create");
    var dataViewCtorString = toSource(DataView2);
    var mapCtorString = toSource(Map2);
    var promiseCtorString = toSource(Promise2);
    var setCtorString = toSource(Set2);
    var weakMapCtorString = toSource(WeakMap2);
    var symbolProto = Symbol2 ? Symbol2.prototype : void 0;
    var symbolValueOf = symbolProto ? symbolProto.valueOf : void 0;
    function Hash(entries) {
      var index = -1, length = entries == null ? 0 : entries.length;
      this.clear();
      while (++index < length) {
        var entry = entries[index];
        this.set(entry[0], entry[1]);
      }
    }
    function hashClear() {
      this.__data__ = nativeCreate ? nativeCreate(null) : {};
      this.size = 0;
    }
    function hashDelete(key) {
      var result = this.has(key) && delete this.__data__[key];
      this.size -= result ? 1 : 0;
      return result;
    }
    function hashGet(key) {
      var data = this.__data__;
      if (nativeCreate) {
        var result = data[key];
        return result === HASH_UNDEFINED ? void 0 : result;
      }
      return hasOwnProperty.call(data, key) ? data[key] : void 0;
    }
    function hashHas(key) {
      var data = this.__data__;
      return nativeCreate ? data[key] !== void 0 : hasOwnProperty.call(data, key);
    }
    function hashSet(key, value) {
      var data = this.__data__;
      this.size += this.has(key) ? 0 : 1;
      data[key] = nativeCreate && value === void 0 ? HASH_UNDEFINED : value;
      return this;
    }
    Hash.prototype.clear = hashClear;
    Hash.prototype["delete"] = hashDelete;
    Hash.prototype.get = hashGet;
    Hash.prototype.has = hashHas;
    Hash.prototype.set = hashSet;
    function ListCache(entries) {
      var index = -1, length = entries == null ? 0 : entries.length;
      this.clear();
      while (++index < length) {
        var entry = entries[index];
        this.set(entry[0], entry[1]);
      }
    }
    function listCacheClear() {
      this.__data__ = [];
      this.size = 0;
    }
    function listCacheDelete(key) {
      var data = this.__data__, index = assocIndexOf(data, key);
      if (index < 0) {
        return false;
      }
      var lastIndex = data.length - 1;
      if (index == lastIndex) {
        data.pop();
      } else {
        splice.call(data, index, 1);
      }
      --this.size;
      return true;
    }
    function listCacheGet(key) {
      var data = this.__data__, index = assocIndexOf(data, key);
      return index < 0 ? void 0 : data[index][1];
    }
    function listCacheHas(key) {
      return assocIndexOf(this.__data__, key) > -1;
    }
    function listCacheSet(key, value) {
      var data = this.__data__, index = assocIndexOf(data, key);
      if (index < 0) {
        ++this.size;
        data.push([key, value]);
      } else {
        data[index][1] = value;
      }
      return this;
    }
    ListCache.prototype.clear = listCacheClear;
    ListCache.prototype["delete"] = listCacheDelete;
    ListCache.prototype.get = listCacheGet;
    ListCache.prototype.has = listCacheHas;
    ListCache.prototype.set = listCacheSet;
    function MapCache(entries) {
      var index = -1, length = entries == null ? 0 : entries.length;
      this.clear();
      while (++index < length) {
        var entry = entries[index];
        this.set(entry[0], entry[1]);
      }
    }
    function mapCacheClear() {
      this.size = 0;
      this.__data__ = {
        "hash": new Hash(),
        "map": new (Map2 || ListCache)(),
        "string": new Hash()
      };
    }
    function mapCacheDelete(key) {
      var result = getMapData(this, key)["delete"](key);
      this.size -= result ? 1 : 0;
      return result;
    }
    function mapCacheGet(key) {
      return getMapData(this, key).get(key);
    }
    function mapCacheHas(key) {
      return getMapData(this, key).has(key);
    }
    function mapCacheSet(key, value) {
      var data = getMapData(this, key), size = data.size;
      data.set(key, value);
      this.size += data.size == size ? 0 : 1;
      return this;
    }
    MapCache.prototype.clear = mapCacheClear;
    MapCache.prototype["delete"] = mapCacheDelete;
    MapCache.prototype.get = mapCacheGet;
    MapCache.prototype.has = mapCacheHas;
    MapCache.prototype.set = mapCacheSet;
    function SetCache(values) {
      var index = -1, length = values == null ? 0 : values.length;
      this.__data__ = new MapCache();
      while (++index < length) {
        this.add(values[index]);
      }
    }
    function setCacheAdd(value) {
      this.__data__.set(value, HASH_UNDEFINED);
      return this;
    }
    function setCacheHas(value) {
      return this.__data__.has(value);
    }
    SetCache.prototype.add = SetCache.prototype.push = setCacheAdd;
    SetCache.prototype.has = setCacheHas;
    function Stack(entries) {
      var data = this.__data__ = new ListCache(entries);
      this.size = data.size;
    }
    function stackClear() {
      this.__data__ = new ListCache();
      this.size = 0;
    }
    function stackDelete(key) {
      var data = this.__data__, result = data["delete"](key);
      this.size = data.size;
      return result;
    }
    function stackGet(key) {
      return this.__data__.get(key);
    }
    function stackHas(key) {
      return this.__data__.has(key);
    }
    function stackSet(key, value) {
      var data = this.__data__;
      if (data instanceof ListCache) {
        var pairs = data.__data__;
        if (!Map2 || pairs.length < LARGE_ARRAY_SIZE - 1) {
          pairs.push([key, value]);
          this.size = ++data.size;
          return this;
        }
        data = this.__data__ = new MapCache(pairs);
      }
      data.set(key, value);
      this.size = data.size;
      return this;
    }
    Stack.prototype.clear = stackClear;
    Stack.prototype["delete"] = stackDelete;
    Stack.prototype.get = stackGet;
    Stack.prototype.has = stackHas;
    Stack.prototype.set = stackSet;
    function arrayLikeKeys(value, inherited) {
      var isArr = isArray(value), isArg = !isArr && isArguments(value), isBuff = !isArr && !isArg && isBuffer(value), isType = !isArr && !isArg && !isBuff && isTypedArray(value), skipIndexes = isArr || isArg || isBuff || isType, result = skipIndexes ? baseTimes(value.length, String) : [], length = result.length;
      for (var key in value) {
        if ((inherited || hasOwnProperty.call(value, key)) && !(skipIndexes && // Safari 9 has enumerable `arguments.length` in strict mode.
        (key == "length" || // Node.js 0.10 has enumerable non-index properties on buffers.
        isBuff && (key == "offset" || key == "parent") || // PhantomJS 2 has enumerable non-index properties on typed arrays.
        isType && (key == "buffer" || key == "byteLength" || key == "byteOffset") || // Skip index properties.
        isIndex(key, length)))) {
          result.push(key);
        }
      }
      return result;
    }
    function assocIndexOf(array, key) {
      var length = array.length;
      while (length--) {
        if (eq(array[length][0], key)) {
          return length;
        }
      }
      return -1;
    }
    function baseGetAllKeys(object, keysFunc, symbolsFunc) {
      var result = keysFunc(object);
      return isArray(object) ? result : arrayPush(result, symbolsFunc(object));
    }
    function baseGetTag(value) {
      if (value == null) {
        return value === void 0 ? undefinedTag : nullTag;
      }
      return symToStringTag && symToStringTag in Object(value) ? getRawTag(value) : objectToString(value);
    }
    function baseIsArguments(value) {
      return isObjectLike(value) && baseGetTag(value) == argsTag;
    }
    function baseIsEqual(value, other, bitmask, customizer, stack) {
      if (value === other) {
        return true;
      }
      if (value == null || other == null || !isObjectLike(value) && !isObjectLike(other)) {
        return value !== value && other !== other;
      }
      return baseIsEqualDeep(value, other, bitmask, customizer, baseIsEqual, stack);
    }
    function baseIsEqualDeep(object, other, bitmask, customizer, equalFunc, stack) {
      var objIsArr = isArray(object), othIsArr = isArray(other), objTag = objIsArr ? arrayTag : getTag(object), othTag = othIsArr ? arrayTag : getTag(other);
      objTag = objTag == argsTag ? objectTag : objTag;
      othTag = othTag == argsTag ? objectTag : othTag;
      var objIsObj = objTag == objectTag, othIsObj = othTag == objectTag, isSameTag = objTag == othTag;
      if (isSameTag && isBuffer(object)) {
        if (!isBuffer(other)) {
          return false;
        }
        objIsArr = true;
        objIsObj = false;
      }
      if (isSameTag && !objIsObj) {
        stack || (stack = new Stack());
        return objIsArr || isTypedArray(object) ? equalArrays(object, other, bitmask, customizer, equalFunc, stack) : equalByTag(object, other, objTag, bitmask, customizer, equalFunc, stack);
      }
      if (!(bitmask & COMPARE_PARTIAL_FLAG)) {
        var objIsWrapped = objIsObj && hasOwnProperty.call(object, "__wrapped__"), othIsWrapped = othIsObj && hasOwnProperty.call(other, "__wrapped__");
        if (objIsWrapped || othIsWrapped) {
          var objUnwrapped = objIsWrapped ? object.value() : object, othUnwrapped = othIsWrapped ? other.value() : other;
          stack || (stack = new Stack());
          return equalFunc(objUnwrapped, othUnwrapped, bitmask, customizer, stack);
        }
      }
      if (!isSameTag) {
        return false;
      }
      stack || (stack = new Stack());
      return equalObjects(object, other, bitmask, customizer, equalFunc, stack);
    }
    function baseIsNative(value) {
      if (!isObject2(value) || isMasked(value)) {
        return false;
      }
      var pattern = isFunction(value) ? reIsNative : reIsHostCtor;
      return pattern.test(toSource(value));
    }
    function baseIsTypedArray(value) {
      return isObjectLike(value) && isLength(value.length) && !!typedArrayTags[baseGetTag(value)];
    }
    function baseKeys(object) {
      if (!isPrototype(object)) {
        return nativeKeys(object);
      }
      var result = [];
      for (var key in Object(object)) {
        if (hasOwnProperty.call(object, key) && key != "constructor") {
          result.push(key);
        }
      }
      return result;
    }
    function equalArrays(array, other, bitmask, customizer, equalFunc, stack) {
      var isPartial = bitmask & COMPARE_PARTIAL_FLAG, arrLength = array.length, othLength = other.length;
      if (arrLength != othLength && !(isPartial && othLength > arrLength)) {
        return false;
      }
      var stacked = stack.get(array);
      if (stacked && stack.get(other)) {
        return stacked == other;
      }
      var index = -1, result = true, seen = bitmask & COMPARE_UNORDERED_FLAG ? new SetCache() : void 0;
      stack.set(array, other);
      stack.set(other, array);
      while (++index < arrLength) {
        var arrValue = array[index], othValue = other[index];
        if (customizer) {
          var compared = isPartial ? customizer(othValue, arrValue, index, other, array, stack) : customizer(arrValue, othValue, index, array, other, stack);
        }
        if (compared !== void 0) {
          if (compared) {
            continue;
          }
          result = false;
          break;
        }
        if (seen) {
          if (!arraySome(other, function(othValue2, othIndex) {
            if (!cacheHas(seen, othIndex) && (arrValue === othValue2 || equalFunc(arrValue, othValue2, bitmask, customizer, stack))) {
              return seen.push(othIndex);
            }
          })) {
            result = false;
            break;
          }
        } else if (!(arrValue === othValue || equalFunc(arrValue, othValue, bitmask, customizer, stack))) {
          result = false;
          break;
        }
      }
      stack["delete"](array);
      stack["delete"](other);
      return result;
    }
    function equalByTag(object, other, tag, bitmask, customizer, equalFunc, stack) {
      switch (tag) {
        case dataViewTag:
          if (object.byteLength != other.byteLength || object.byteOffset != other.byteOffset) {
            return false;
          }
          object = object.buffer;
          other = other.buffer;
        case arrayBufferTag:
          if (object.byteLength != other.byteLength || !equalFunc(new Uint8Array2(object), new Uint8Array2(other))) {
            return false;
          }
          return true;
        case boolTag:
        case dateTag:
        case numberTag:
          return eq(+object, +other);
        case errorTag:
          return object.name == other.name && object.message == other.message;
        case regexpTag:
        case stringTag:
          return object == other + "";
        case mapTag:
          var convert = mapToArray;
        case setTag:
          var isPartial = bitmask & COMPARE_PARTIAL_FLAG;
          convert || (convert = setToArray);
          if (object.size != other.size && !isPartial) {
            return false;
          }
          var stacked = stack.get(object);
          if (stacked) {
            return stacked == other;
          }
          bitmask |= COMPARE_UNORDERED_FLAG;
          stack.set(object, other);
          var result = equalArrays(convert(object), convert(other), bitmask, customizer, equalFunc, stack);
          stack["delete"](object);
          return result;
        case symbolTag:
          if (symbolValueOf) {
            return symbolValueOf.call(object) == symbolValueOf.call(other);
          }
      }
      return false;
    }
    function equalObjects(object, other, bitmask, customizer, equalFunc, stack) {
      var isPartial = bitmask & COMPARE_PARTIAL_FLAG, objProps = getAllKeys(object), objLength = objProps.length, othProps = getAllKeys(other), othLength = othProps.length;
      if (objLength != othLength && !isPartial) {
        return false;
      }
      var index = objLength;
      while (index--) {
        var key = objProps[index];
        if (!(isPartial ? key in other : hasOwnProperty.call(other, key))) {
          return false;
        }
      }
      var stacked = stack.get(object);
      if (stacked && stack.get(other)) {
        return stacked == other;
      }
      var result = true;
      stack.set(object, other);
      stack.set(other, object);
      var skipCtor = isPartial;
      while (++index < objLength) {
        key = objProps[index];
        var objValue = object[key], othValue = other[key];
        if (customizer) {
          var compared = isPartial ? customizer(othValue, objValue, key, other, object, stack) : customizer(objValue, othValue, key, object, other, stack);
        }
        if (!(compared === void 0 ? objValue === othValue || equalFunc(objValue, othValue, bitmask, customizer, stack) : compared)) {
          result = false;
          break;
        }
        skipCtor || (skipCtor = key == "constructor");
      }
      if (result && !skipCtor) {
        var objCtor = object.constructor, othCtor = other.constructor;
        if (objCtor != othCtor && ("constructor" in object && "constructor" in other) && !(typeof objCtor == "function" && objCtor instanceof objCtor && typeof othCtor == "function" && othCtor instanceof othCtor)) {
          result = false;
        }
      }
      stack["delete"](object);
      stack["delete"](other);
      return result;
    }
    function getAllKeys(object) {
      return baseGetAllKeys(object, keys, getSymbols);
    }
    function getMapData(map, key) {
      var data = map.__data__;
      return isKeyable(key) ? data[typeof key == "string" ? "string" : "hash"] : data.map;
    }
    function getNative(object, key) {
      var value = getValue(object, key);
      return baseIsNative(value) ? value : void 0;
    }
    function getRawTag(value) {
      var isOwn = hasOwnProperty.call(value, symToStringTag), tag = value[symToStringTag];
      try {
        value[symToStringTag] = void 0;
        var unmasked = true;
      } catch (e) {
      }
      var result = nativeObjectToString.call(value);
      if (unmasked) {
        if (isOwn) {
          value[symToStringTag] = tag;
        } else {
          delete value[symToStringTag];
        }
      }
      return result;
    }
    var getSymbols = !nativeGetSymbols ? stubArray : function(object) {
      if (object == null) {
        return [];
      }
      object = Object(object);
      return arrayFilter(nativeGetSymbols(object), function(symbol) {
        return propertyIsEnumerable.call(object, symbol);
      });
    };
    var getTag = baseGetTag;
    if (DataView2 && getTag(new DataView2(new ArrayBuffer(1))) != dataViewTag || Map2 && getTag(new Map2()) != mapTag || Promise2 && getTag(Promise2.resolve()) != promiseTag || Set2 && getTag(new Set2()) != setTag || WeakMap2 && getTag(new WeakMap2()) != weakMapTag) {
      getTag = function(value) {
        var result = baseGetTag(value), Ctor = result == objectTag ? value.constructor : void 0, ctorString = Ctor ? toSource(Ctor) : "";
        if (ctorString) {
          switch (ctorString) {
            case dataViewCtorString:
              return dataViewTag;
            case mapCtorString:
              return mapTag;
            case promiseCtorString:
              return promiseTag;
            case setCtorString:
              return setTag;
            case weakMapCtorString:
              return weakMapTag;
          }
        }
        return result;
      };
    }
    function isIndex(value, length) {
      length = length == null ? MAX_SAFE_INTEGER : length;
      return !!length && (typeof value == "number" || reIsUint.test(value)) && (value > -1 && value % 1 == 0 && value < length);
    }
    function isKeyable(value) {
      var type = typeof value;
      return type == "string" || type == "number" || type == "symbol" || type == "boolean" ? value !== "__proto__" : value === null;
    }
    function isMasked(func) {
      return !!maskSrcKey && maskSrcKey in func;
    }
    function isPrototype(value) {
      var Ctor = value && value.constructor, proto = typeof Ctor == "function" && Ctor.prototype || objectProto;
      return value === proto;
    }
    function objectToString(value) {
      return nativeObjectToString.call(value);
    }
    function toSource(func) {
      if (func != null) {
        try {
          return funcToString.call(func);
        } catch (e) {
        }
        try {
          return func + "";
        } catch (e) {
        }
      }
      return "";
    }
    function eq(value, other) {
      return value === other || value !== value && other !== other;
    }
    var isArguments = baseIsArguments(/* @__PURE__ */ function() {
      return arguments;
    }()) ? baseIsArguments : function(value) {
      return isObjectLike(value) && hasOwnProperty.call(value, "callee") && !propertyIsEnumerable.call(value, "callee");
    };
    var isArray = Array.isArray;
    function isArrayLike(value) {
      return value != null && isLength(value.length) && !isFunction(value);
    }
    var isBuffer = nativeIsBuffer || stubFalse;
    function isEqual(value, other) {
      return baseIsEqual(value, other);
    }
    function isFunction(value) {
      if (!isObject2(value)) {
        return false;
      }
      var tag = baseGetTag(value);
      return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;
    }
    function isLength(value) {
      return typeof value == "number" && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
    }
    function isObject2(value) {
      var type = typeof value;
      return value != null && (type == "object" || type == "function");
    }
    function isObjectLike(value) {
      return value != null && typeof value == "object";
    }
    var isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;
    function keys(object) {
      return isArrayLike(object) ? arrayLikeKeys(object) : baseKeys(object);
    }
    function stubArray() {
      return [];
    }
    function stubFalse() {
      return false;
    }
    module2.exports = isEqual;
  }
});

// ../../../node_modules/lodash.isboolean/index.js
var require_lodash3 = __commonJS({
  "../../../node_modules/lodash.isboolean/index.js"(exports2, module2) {
    var boolTag = "[object Boolean]";
    var objectProto = Object.prototype;
    var objectToString = objectProto.toString;
    function isBoolean(value) {
      return value === true || value === false || isObjectLike(value) && objectToString.call(value) == boolTag;
    }
    function isObjectLike(value) {
      return !!value && typeof value == "object";
    }
    module2.exports = isBoolean;
  }
});

// ../../../node_modules/lodash.isnil/index.js
var require_lodash4 = __commonJS({
  "../../../node_modules/lodash.isnil/index.js"(exports2, module2) {
    function isNil(value) {
      return value == null;
    }
    module2.exports = isNil;
  }
});

// ../../../node_modules/lodash.escaperegexp/index.js
var require_lodash5 = __commonJS({
  "../../../node_modules/lodash.escaperegexp/index.js"(exports2, module2) {
    var INFINITY = 1 / 0;
    var symbolTag = "[object Symbol]";
    var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;
    var reHasRegExpChar = RegExp(reRegExpChar.source);
    var freeGlobal = typeof global == "object" && global && global.Object === Object && global;
    var freeSelf = typeof self == "object" && self && self.Object === Object && self;
    var root = freeGlobal || freeSelf || Function("return this")();
    var objectProto = Object.prototype;
    var objectToString = objectProto.toString;
    var Symbol2 = root.Symbol;
    var symbolProto = Symbol2 ? Symbol2.prototype : void 0;
    var symbolToString = symbolProto ? symbolProto.toString : void 0;
    function baseToString(value) {
      if (typeof value == "string") {
        return value;
      }
      if (isSymbol(value)) {
        return symbolToString ? symbolToString.call(value) : "";
      }
      var result = value + "";
      return result == "0" && 1 / value == -INFINITY ? "-0" : result;
    }
    function isObjectLike(value) {
      return !!value && typeof value == "object";
    }
    function isSymbol(value) {
      return typeof value == "symbol" || isObjectLike(value) && objectToString.call(value) == symbolTag;
    }
    function toString(value) {
      return value == null ? "" : baseToString(value);
    }
    function escapeRegExp(string) {
      string = toString(string);
      return string && reHasRegExpChar.test(string) ? string.replace(reRegExpChar, "\\$&") : string;
    }
    module2.exports = escapeRegExp;
  }
});

// ../../../node_modules/@fast-csv/format/build/src/formatter/FieldFormatter.js
var require_FieldFormatter = __commonJS({
  "../../../node_modules/@fast-csv/format/build/src/formatter/FieldFormatter.js"(exports2) {
    "use strict";
    var __importDefault = exports2 && exports2.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.FieldFormatter = void 0;
    var lodash_isboolean_1 = __importDefault(require_lodash3());
    var lodash_isnil_1 = __importDefault(require_lodash4());
    var lodash_escaperegexp_1 = __importDefault(require_lodash5());
    var FieldFormatter = class {
      constructor(formatterOptions) {
        this._headers = null;
        this.formatterOptions = formatterOptions;
        if (formatterOptions.headers !== null) {
          this.headers = formatterOptions.headers;
        }
        this.REPLACE_REGEXP = new RegExp(formatterOptions.quote, "g");
        const escapePattern = `[${formatterOptions.delimiter}${lodash_escaperegexp_1.default(formatterOptions.rowDelimiter)}|\r|
]`;
        this.ESCAPE_REGEXP = new RegExp(escapePattern);
      }
      set headers(headers) {
        this._headers = headers;
      }
      shouldQuote(fieldIndex, isHeader) {
        const quoteConfig = isHeader ? this.formatterOptions.quoteHeaders : this.formatterOptions.quoteColumns;
        if (lodash_isboolean_1.default(quoteConfig)) {
          return quoteConfig;
        }
        if (Array.isArray(quoteConfig)) {
          return quoteConfig[fieldIndex];
        }
        if (this._headers !== null) {
          return quoteConfig[this._headers[fieldIndex]];
        }
        return false;
      }
      format(field, fieldIndex, isHeader) {
        const preparedField = `${lodash_isnil_1.default(field) ? "" : field}`.replace(/\0/g, "");
        const { formatterOptions } = this;
        if (formatterOptions.quote !== "") {
          const shouldEscape = preparedField.indexOf(formatterOptions.quote) !== -1;
          if (shouldEscape) {
            return this.quoteField(preparedField.replace(this.REPLACE_REGEXP, formatterOptions.escapedQuote));
          }
        }
        const hasEscapeCharacters = preparedField.search(this.ESCAPE_REGEXP) !== -1;
        if (hasEscapeCharacters || this.shouldQuote(fieldIndex, isHeader)) {
          return this.quoteField(preparedField);
        }
        return preparedField;
      }
      quoteField(field) {
        const { quote } = this.formatterOptions;
        return `${quote}${field}${quote}`;
      }
    };
    exports2.FieldFormatter = FieldFormatter;
  }
});

// ../../../node_modules/@fast-csv/format/build/src/types.js
var require_types = __commonJS({
  "../../../node_modules/@fast-csv/format/build/src/types.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.isSyncTransform = void 0;
    exports2.isSyncTransform = (transform) => transform.length === 1;
  }
});

// ../../../node_modules/@fast-csv/format/build/src/formatter/RowFormatter.js
var require_RowFormatter = __commonJS({
  "../../../node_modules/@fast-csv/format/build/src/formatter/RowFormatter.js"(exports2) {
    "use strict";
    var __importDefault = exports2 && exports2.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.RowFormatter = void 0;
    var lodash_isfunction_1 = __importDefault(require_lodash());
    var lodash_isequal_1 = __importDefault(require_lodash2());
    var FieldFormatter_1 = require_FieldFormatter();
    var types_1 = require_types();
    var RowFormatter = class _RowFormatter {
      constructor(formatterOptions) {
        this.rowCount = 0;
        this.formatterOptions = formatterOptions;
        this.fieldFormatter = new FieldFormatter_1.FieldFormatter(formatterOptions);
        this.headers = formatterOptions.headers;
        this.shouldWriteHeaders = formatterOptions.shouldWriteHeaders;
        this.hasWrittenHeaders = false;
        if (this.headers !== null) {
          this.fieldFormatter.headers = this.headers;
        }
        if (formatterOptions.transform) {
          this.rowTransform = formatterOptions.transform;
        }
      }
      static isRowHashArray(row) {
        if (Array.isArray(row)) {
          return Array.isArray(row[0]) && row[0].length === 2;
        }
        return false;
      }
      static isRowArray(row) {
        return Array.isArray(row) && !this.isRowHashArray(row);
      }
      // get headers from a row item
      static gatherHeaders(row) {
        if (_RowFormatter.isRowHashArray(row)) {
          return row.map((it) => it[0]);
        }
        if (Array.isArray(row)) {
          return row;
        }
        return Object.keys(row);
      }
      // eslint-disable-next-line @typescript-eslint/no-shadow
      static createTransform(transformFunction) {
        if (types_1.isSyncTransform(transformFunction)) {
          return (row, cb) => {
            let transformedRow = null;
            try {
              transformedRow = transformFunction(row);
            } catch (e) {
              return cb(e);
            }
            return cb(null, transformedRow);
          };
        }
        return (row, cb) => {
          transformFunction(row, cb);
        };
      }
      set rowTransform(transformFunction) {
        if (!lodash_isfunction_1.default(transformFunction)) {
          throw new TypeError("The transform should be a function");
        }
        this._rowTransform = _RowFormatter.createTransform(transformFunction);
      }
      format(row, cb) {
        this.callTransformer(row, (err, transformedRow) => {
          if (err) {
            return cb(err);
          }
          if (!row) {
            return cb(null);
          }
          const rows = [];
          if (transformedRow) {
            const { shouldFormatColumns, headers } = this.checkHeaders(transformedRow);
            if (this.shouldWriteHeaders && headers && !this.hasWrittenHeaders) {
              rows.push(this.formatColumns(headers, true));
              this.hasWrittenHeaders = true;
            }
            if (shouldFormatColumns) {
              const columns = this.gatherColumns(transformedRow);
              rows.push(this.formatColumns(columns, false));
            }
          }
          return cb(null, rows);
        });
      }
      finish(cb) {
        const rows = [];
        if (this.formatterOptions.alwaysWriteHeaders && this.rowCount === 0) {
          if (!this.headers) {
            return cb(new Error("`alwaysWriteHeaders` option is set to true but `headers` option not provided."));
          }
          rows.push(this.formatColumns(this.headers, true));
        }
        if (this.formatterOptions.includeEndRowDelimiter) {
          rows.push(this.formatterOptions.rowDelimiter);
        }
        return cb(null, rows);
      }
      // check if we need to write header return true if we should also write a row
      // could be false if headers is true and the header row(first item) is passed in
      checkHeaders(row) {
        if (this.headers) {
          return { shouldFormatColumns: true, headers: this.headers };
        }
        const headers = _RowFormatter.gatherHeaders(row);
        this.headers = headers;
        this.fieldFormatter.headers = headers;
        if (!this.shouldWriteHeaders) {
          return { shouldFormatColumns: true, headers: null };
        }
        return { shouldFormatColumns: !lodash_isequal_1.default(headers, row), headers };
      }
      // todo change this method to unknown[]
      gatherColumns(row) {
        if (this.headers === null) {
          throw new Error("Headers is currently null");
        }
        if (!Array.isArray(row)) {
          return this.headers.map((header) => row[header]);
        }
        if (_RowFormatter.isRowHashArray(row)) {
          return this.headers.map((header, i) => {
            const col = row[i];
            if (col) {
              return col[1];
            }
            return "";
          });
        }
        if (_RowFormatter.isRowArray(row) && !this.shouldWriteHeaders) {
          return row;
        }
        return this.headers.map((header, i) => row[i]);
      }
      callTransformer(row, cb) {
        if (!this._rowTransform) {
          return cb(null, row);
        }
        return this._rowTransform(row, cb);
      }
      formatColumns(columns, isHeadersRow) {
        const formattedCols = columns.map((field, i) => this.fieldFormatter.format(field, i, isHeadersRow)).join(this.formatterOptions.delimiter);
        const { rowCount } = this;
        this.rowCount += 1;
        if (rowCount) {
          return [this.formatterOptions.rowDelimiter, formattedCols].join("");
        }
        return formattedCols;
      }
    };
    exports2.RowFormatter = RowFormatter;
  }
});

// ../../../node_modules/@fast-csv/format/build/src/formatter/index.js
var require_formatter = __commonJS({
  "../../../node_modules/@fast-csv/format/build/src/formatter/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.FieldFormatter = exports2.RowFormatter = void 0;
    var RowFormatter_1 = require_RowFormatter();
    Object.defineProperty(exports2, "RowFormatter", { enumerable: true, get: function() {
      return RowFormatter_1.RowFormatter;
    } });
    var FieldFormatter_1 = require_FieldFormatter();
    Object.defineProperty(exports2, "FieldFormatter", { enumerable: true, get: function() {
      return FieldFormatter_1.FieldFormatter;
    } });
  }
});

// ../../../node_modules/@fast-csv/format/build/src/CsvFormatterStream.js
var require_CsvFormatterStream = __commonJS({
  "../../../node_modules/@fast-csv/format/build/src/CsvFormatterStream.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.CsvFormatterStream = void 0;
    var stream_1 = require("stream");
    var formatter_1 = require_formatter();
    var CsvFormatterStream = class extends stream_1.Transform {
      constructor(formatterOptions) {
        super({ writableObjectMode: formatterOptions.objectMode });
        this.hasWrittenBOM = false;
        this.formatterOptions = formatterOptions;
        this.rowFormatter = new formatter_1.RowFormatter(formatterOptions);
        this.hasWrittenBOM = !formatterOptions.writeBOM;
      }
      transform(transformFunction) {
        this.rowFormatter.rowTransform = transformFunction;
        return this;
      }
      _transform(row, encoding, cb) {
        let cbCalled = false;
        try {
          if (!this.hasWrittenBOM) {
            this.push(this.formatterOptions.BOM);
            this.hasWrittenBOM = true;
          }
          this.rowFormatter.format(row, (err, rows) => {
            if (err) {
              cbCalled = true;
              return cb(err);
            }
            if (rows) {
              rows.forEach((r) => {
                this.push(Buffer.from(r, "utf8"));
              });
            }
            cbCalled = true;
            return cb();
          });
        } catch (e) {
          if (cbCalled) {
            throw e;
          }
          cb(e);
        }
      }
      _flush(cb) {
        this.rowFormatter.finish((err, rows) => {
          if (err) {
            return cb(err);
          }
          if (rows) {
            rows.forEach((r) => {
              this.push(Buffer.from(r, "utf8"));
            });
          }
          return cb();
        });
      }
    };
    exports2.CsvFormatterStream = CsvFormatterStream;
  }
});

// ../../../node_modules/@fast-csv/format/build/src/index.js
var require_src = __commonJS({
  "../../../node_modules/@fast-csv/format/build/src/index.js"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      Object.defineProperty(o, k2, { enumerable: true, get: function() {
        return m[k];
      } });
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports2 && exports2.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports2 && exports2.__importStar || function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod)
          if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
            __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    var __exportStar = exports2 && exports2.__exportStar || function(m, exports3) {
      for (var p in m)
        if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p))
          __createBinding(exports3, m, p);
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.writeToPath = exports2.writeToString = exports2.writeToBuffer = exports2.writeToStream = exports2.write = exports2.format = exports2.FormatterOptions = exports2.CsvFormatterStream = void 0;
    var util_1 = require("util");
    var stream_1 = require("stream");
    var fs = __importStar(require("fs"));
    var FormatterOptions_1 = require_FormatterOptions();
    var CsvFormatterStream_1 = require_CsvFormatterStream();
    __exportStar(require_types(), exports2);
    var CsvFormatterStream_2 = require_CsvFormatterStream();
    Object.defineProperty(exports2, "CsvFormatterStream", { enumerable: true, get: function() {
      return CsvFormatterStream_2.CsvFormatterStream;
    } });
    var FormatterOptions_2 = require_FormatterOptions();
    Object.defineProperty(exports2, "FormatterOptions", { enumerable: true, get: function() {
      return FormatterOptions_2.FormatterOptions;
    } });
    exports2.format = (options) => new CsvFormatterStream_1.CsvFormatterStream(new FormatterOptions_1.FormatterOptions(options));
    exports2.write = (rows, options) => {
      const csvStream = exports2.format(options);
      const promiseWrite = util_1.promisify((row, cb) => {
        csvStream.write(row, void 0, cb);
      });
      rows.reduce((prev, row) => prev.then(() => promiseWrite(row)), Promise.resolve()).then(() => csvStream.end()).catch((err) => {
        csvStream.emit("error", err);
      });
      return csvStream;
    };
    exports2.writeToStream = (ws, rows, options) => exports2.write(rows, options).pipe(ws);
    exports2.writeToBuffer = (rows, opts = {}) => {
      const buffers = [];
      const ws = new stream_1.Writable({
        write(data, enc, writeCb) {
          buffers.push(data);
          writeCb();
        }
      });
      return new Promise((res, rej) => {
        ws.on("error", rej).on("finish", () => res(Buffer.concat(buffers)));
        exports2.write(rows, opts).pipe(ws);
      });
    };
    exports2.writeToString = (rows, options) => exports2.writeToBuffer(rows, options).then((buffer) => buffer.toString());
    exports2.writeToPath = (path, rows, options) => {
      const stream = fs.createWriteStream(path, { encoding: "utf8" });
      return exports2.write(rows, options).pipe(stream);
    };
  }
});

// ../../../node_modules/@fast-csv/parse/build/src/ParserOptions.js
var require_ParserOptions = __commonJS({
  "../../../node_modules/@fast-csv/parse/build/src/ParserOptions.js"(exports2) {
    "use strict";
    var __importDefault = exports2 && exports2.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ParserOptions = void 0;
    var lodash_escaperegexp_1 = __importDefault(require_lodash5());
    var lodash_isnil_1 = __importDefault(require_lodash4());
    var ParserOptions = class {
      constructor(opts) {
        var _a;
        this.objectMode = true;
        this.delimiter = ",";
        this.ignoreEmpty = false;
        this.quote = '"';
        this.escape = null;
        this.escapeChar = this.quote;
        this.comment = null;
        this.supportsComments = false;
        this.ltrim = false;
        this.rtrim = false;
        this.trim = false;
        this.headers = null;
        this.renameHeaders = false;
        this.strictColumnHandling = false;
        this.discardUnmappedColumns = false;
        this.carriageReturn = "\r";
        this.encoding = "utf8";
        this.limitRows = false;
        this.maxRows = 0;
        this.skipLines = 0;
        this.skipRows = 0;
        Object.assign(this, opts || {});
        if (this.delimiter.length > 1) {
          throw new Error("delimiter option must be one character long");
        }
        this.escapedDelimiter = lodash_escaperegexp_1.default(this.delimiter);
        this.escapeChar = (_a = this.escape) !== null && _a !== void 0 ? _a : this.quote;
        this.supportsComments = !lodash_isnil_1.default(this.comment);
        this.NEXT_TOKEN_REGEXP = new RegExp(`([^\\s]|\\r\\n|\\n|\\r|${this.escapedDelimiter})`);
        if (this.maxRows > 0) {
          this.limitRows = true;
        }
      }
    };
    exports2.ParserOptions = ParserOptions;
  }
});

// ../../../node_modules/@fast-csv/parse/build/src/types.js
var require_types2 = __commonJS({
  "../../../node_modules/@fast-csv/parse/build/src/types.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.isSyncValidate = exports2.isSyncTransform = void 0;
    exports2.isSyncTransform = (transform) => transform.length === 1;
    exports2.isSyncValidate = (validate2) => validate2.length === 1;
  }
});

// ../../../node_modules/@fast-csv/parse/build/src/transforms/RowTransformerValidator.js
var require_RowTransformerValidator = __commonJS({
  "../../../node_modules/@fast-csv/parse/build/src/transforms/RowTransformerValidator.js"(exports2) {
    "use strict";
    var __importDefault = exports2 && exports2.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.RowTransformerValidator = void 0;
    var lodash_isfunction_1 = __importDefault(require_lodash());
    var types_1 = require_types2();
    var RowTransformerValidator = class _RowTransformerValidator {
      constructor() {
        this._rowTransform = null;
        this._rowValidator = null;
      }
      // eslint-disable-next-line @typescript-eslint/no-shadow
      static createTransform(transformFunction) {
        if (types_1.isSyncTransform(transformFunction)) {
          return (row, cb) => {
            let transformed = null;
            try {
              transformed = transformFunction(row);
            } catch (e) {
              return cb(e);
            }
            return cb(null, transformed);
          };
        }
        return transformFunction;
      }
      static createValidator(validateFunction) {
        if (types_1.isSyncValidate(validateFunction)) {
          return (row, cb) => {
            cb(null, { row, isValid: validateFunction(row) });
          };
        }
        return (row, cb) => {
          validateFunction(row, (err, isValid, reason) => {
            if (err) {
              return cb(err);
            }
            if (isValid) {
              return cb(null, { row, isValid, reason });
            }
            return cb(null, { row, isValid: false, reason });
          });
        };
      }
      set rowTransform(transformFunction) {
        if (!lodash_isfunction_1.default(transformFunction)) {
          throw new TypeError("The transform should be a function");
        }
        this._rowTransform = _RowTransformerValidator.createTransform(transformFunction);
      }
      set rowValidator(validateFunction) {
        if (!lodash_isfunction_1.default(validateFunction)) {
          throw new TypeError("The validate should be a function");
        }
        this._rowValidator = _RowTransformerValidator.createValidator(validateFunction);
      }
      transformAndValidate(row, cb) {
        return this.callTransformer(row, (transformErr, transformedRow) => {
          if (transformErr) {
            return cb(transformErr);
          }
          if (!transformedRow) {
            return cb(null, { row: null, isValid: true });
          }
          return this.callValidator(transformedRow, (validateErr, validationResult) => {
            if (validateErr) {
              return cb(validateErr);
            }
            if (validationResult && !validationResult.isValid) {
              return cb(null, { row: transformedRow, isValid: false, reason: validationResult.reason });
            }
            return cb(null, { row: transformedRow, isValid: true });
          });
        });
      }
      callTransformer(row, cb) {
        if (!this._rowTransform) {
          return cb(null, row);
        }
        return this._rowTransform(row, cb);
      }
      callValidator(row, cb) {
        if (!this._rowValidator) {
          return cb(null, { row, isValid: true });
        }
        return this._rowValidator(row, cb);
      }
    };
    exports2.RowTransformerValidator = RowTransformerValidator;
  }
});

// ../../../node_modules/lodash.isundefined/index.js
var require_lodash6 = __commonJS({
  "../../../node_modules/lodash.isundefined/index.js"(exports2, module2) {
    function isUndefined(value) {
      return value === void 0;
    }
    module2.exports = isUndefined;
  }
});

// ../../../node_modules/lodash.uniq/index.js
var require_lodash7 = __commonJS({
  "../../../node_modules/lodash.uniq/index.js"(exports2, module2) {
    var LARGE_ARRAY_SIZE = 200;
    var HASH_UNDEFINED = "__lodash_hash_undefined__";
    var INFINITY = 1 / 0;
    var funcTag = "[object Function]";
    var genTag = "[object GeneratorFunction]";
    var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;
    var reIsHostCtor = /^\[object .+?Constructor\]$/;
    var freeGlobal = typeof global == "object" && global && global.Object === Object && global;
    var freeSelf = typeof self == "object" && self && self.Object === Object && self;
    var root = freeGlobal || freeSelf || Function("return this")();
    function arrayIncludes(array, value) {
      var length = array ? array.length : 0;
      return !!length && baseIndexOf(array, value, 0) > -1;
    }
    function arrayIncludesWith(array, value, comparator) {
      var index = -1, length = array ? array.length : 0;
      while (++index < length) {
        if (comparator(value, array[index])) {
          return true;
        }
      }
      return false;
    }
    function baseFindIndex(array, predicate, fromIndex, fromRight) {
      var length = array.length, index = fromIndex + (fromRight ? 1 : -1);
      while (fromRight ? index-- : ++index < length) {
        if (predicate(array[index], index, array)) {
          return index;
        }
      }
      return -1;
    }
    function baseIndexOf(array, value, fromIndex) {
      if (value !== value) {
        return baseFindIndex(array, baseIsNaN, fromIndex);
      }
      var index = fromIndex - 1, length = array.length;
      while (++index < length) {
        if (array[index] === value) {
          return index;
        }
      }
      return -1;
    }
    function baseIsNaN(value) {
      return value !== value;
    }
    function cacheHas(cache, key) {
      return cache.has(key);
    }
    function getValue(object, key) {
      return object == null ? void 0 : object[key];
    }
    function isHostObject(value) {
      var result = false;
      if (value != null && typeof value.toString != "function") {
        try {
          result = !!(value + "");
        } catch (e) {
        }
      }
      return result;
    }
    function setToArray(set) {
      var index = -1, result = Array(set.size);
      set.forEach(function(value) {
        result[++index] = value;
      });
      return result;
    }
    var arrayProto = Array.prototype;
    var funcProto = Function.prototype;
    var objectProto = Object.prototype;
    var coreJsData = root["__core-js_shared__"];
    var maskSrcKey = function() {
      var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || "");
      return uid ? "Symbol(src)_1." + uid : "";
    }();
    var funcToString = funcProto.toString;
    var hasOwnProperty = objectProto.hasOwnProperty;
    var objectToString = objectProto.toString;
    var reIsNative = RegExp(
      "^" + funcToString.call(hasOwnProperty).replace(reRegExpChar, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"
    );
    var splice = arrayProto.splice;
    var Map2 = getNative(root, "Map");
    var Set2 = getNative(root, "Set");
    var nativeCreate = getNative(Object, "create");
    function Hash(entries) {
      var index = -1, length = entries ? entries.length : 0;
      this.clear();
      while (++index < length) {
        var entry = entries[index];
        this.set(entry[0], entry[1]);
      }
    }
    function hashClear() {
      this.__data__ = nativeCreate ? nativeCreate(null) : {};
    }
    function hashDelete(key) {
      return this.has(key) && delete this.__data__[key];
    }
    function hashGet(key) {
      var data = this.__data__;
      if (nativeCreate) {
        var result = data[key];
        return result === HASH_UNDEFINED ? void 0 : result;
      }
      return hasOwnProperty.call(data, key) ? data[key] : void 0;
    }
    function hashHas(key) {
      var data = this.__data__;
      return nativeCreate ? data[key] !== void 0 : hasOwnProperty.call(data, key);
    }
    function hashSet(key, value) {
      var data = this.__data__;
      data[key] = nativeCreate && value === void 0 ? HASH_UNDEFINED : value;
      return this;
    }
    Hash.prototype.clear = hashClear;
    Hash.prototype["delete"] = hashDelete;
    Hash.prototype.get = hashGet;
    Hash.prototype.has = hashHas;
    Hash.prototype.set = hashSet;
    function ListCache(entries) {
      var index = -1, length = entries ? entries.length : 0;
      this.clear();
      while (++index < length) {
        var entry = entries[index];
        this.set(entry[0], entry[1]);
      }
    }
    function listCacheClear() {
      this.__data__ = [];
    }
    function listCacheDelete(key) {
      var data = this.__data__, index = assocIndexOf(data, key);
      if (index < 0) {
        return false;
      }
      var lastIndex = data.length - 1;
      if (index == lastIndex) {
        data.pop();
      } else {
        splice.call(data, index, 1);
      }
      return true;
    }
    function listCacheGet(key) {
      var data = this.__data__, index = assocIndexOf(data, key);
      return index < 0 ? void 0 : data[index][1];
    }
    function listCacheHas(key) {
      return assocIndexOf(this.__data__, key) > -1;
    }
    function listCacheSet(key, value) {
      var data = this.__data__, index = assocIndexOf(data, key);
      if (index < 0) {
        data.push([key, value]);
      } else {
        data[index][1] = value;
      }
      return this;
    }
    ListCache.prototype.clear = listCacheClear;
    ListCache.prototype["delete"] = listCacheDelete;
    ListCache.prototype.get = listCacheGet;
    ListCache.prototype.has = listCacheHas;
    ListCache.prototype.set = listCacheSet;
    function MapCache(entries) {
      var index = -1, length = entries ? entries.length : 0;
      this.clear();
      while (++index < length) {
        var entry = entries[index];
        this.set(entry[0], entry[1]);
      }
    }
    function mapCacheClear() {
      this.__data__ = {
        "hash": new Hash(),
        "map": new (Map2 || ListCache)(),
        "string": new Hash()
      };
    }
    function mapCacheDelete(key) {
      return getMapData(this, key)["delete"](key);
    }
    function mapCacheGet(key) {
      return getMapData(this, key).get(key);
    }
    function mapCacheHas(key) {
      return getMapData(this, key).has(key);
    }
    function mapCacheSet(key, value) {
      getMapData(this, key).set(key, value);
      return this;
    }
    MapCache.prototype.clear = mapCacheClear;
    MapCache.prototype["delete"] = mapCacheDelete;
    MapCache.prototype.get = mapCacheGet;
    MapCache.prototype.has = mapCacheHas;
    MapCache.prototype.set = mapCacheSet;
    function SetCache(values) {
      var index = -1, length = values ? values.length : 0;
      this.__data__ = new MapCache();
      while (++index < length) {
        this.add(values[index]);
      }
    }
    function setCacheAdd(value) {
      this.__data__.set(value, HASH_UNDEFINED);
      return this;
    }
    function setCacheHas(value) {
      return this.__data__.has(value);
    }
    SetCache.prototype.add = SetCache.prototype.push = setCacheAdd;
    SetCache.prototype.has = setCacheHas;
    function assocIndexOf(array, key) {
      var length = array.length;
      while (length--) {
        if (eq(array[length][0], key)) {
          return length;
        }
      }
      return -1;
    }
    function baseIsNative(value) {
      if (!isObject2(value) || isMasked(value)) {
        return false;
      }
      var pattern = isFunction(value) || isHostObject(value) ? reIsNative : reIsHostCtor;
      return pattern.test(toSource(value));
    }
    function baseUniq(array, iteratee, comparator) {
      var index = -1, includes = arrayIncludes, length = array.length, isCommon = true, result = [], seen = result;
      if (comparator) {
        isCommon = false;
        includes = arrayIncludesWith;
      } else if (length >= LARGE_ARRAY_SIZE) {
        var set = iteratee ? null : createSet(array);
        if (set) {
          return setToArray(set);
        }
        isCommon = false;
        includes = cacheHas;
        seen = new SetCache();
      } else {
        seen = iteratee ? [] : result;
      }
      outer:
        while (++index < length) {
          var value = array[index], computed = iteratee ? iteratee(value) : value;
          value = comparator || value !== 0 ? value : 0;
          if (isCommon && computed === computed) {
            var seenIndex = seen.length;
            while (seenIndex--) {
              if (seen[seenIndex] === computed) {
                continue outer;
              }
            }
            if (iteratee) {
              seen.push(computed);
            }
            result.push(value);
          } else if (!includes(seen, computed, comparator)) {
            if (seen !== result) {
              seen.push(computed);
            }
            result.push(value);
          }
        }
      return result;
    }
    var createSet = !(Set2 && 1 / setToArray(new Set2([, -0]))[1] == INFINITY) ? noop : function(values) {
      return new Set2(values);
    };
    function getMapData(map, key) {
      var data = map.__data__;
      return isKeyable(key) ? data[typeof key == "string" ? "string" : "hash"] : data.map;
    }
    function getNative(object, key) {
      var value = getValue(object, key);
      return baseIsNative(value) ? value : void 0;
    }
    function isKeyable(value) {
      var type = typeof value;
      return type == "string" || type == "number" || type == "symbol" || type == "boolean" ? value !== "__proto__" : value === null;
    }
    function isMasked(func) {
      return !!maskSrcKey && maskSrcKey in func;
    }
    function toSource(func) {
      if (func != null) {
        try {
          return funcToString.call(func);
        } catch (e) {
        }
        try {
          return func + "";
        } catch (e) {
        }
      }
      return "";
    }
    function uniq(array) {
      return array && array.length ? baseUniq(array) : [];
    }
    function eq(value, other) {
      return value === other || value !== value && other !== other;
    }
    function isFunction(value) {
      var tag = isObject2(value) ? objectToString.call(value) : "";
      return tag == funcTag || tag == genTag;
    }
    function isObject2(value) {
      var type = typeof value;
      return !!value && (type == "object" || type == "function");
    }
    function noop() {
    }
    module2.exports = uniq;
  }
});

// ../../../node_modules/lodash.groupby/index.js
var require_lodash8 = __commonJS({
  "../../../node_modules/lodash.groupby/index.js"(exports2, module2) {
    var LARGE_ARRAY_SIZE = 200;
    var FUNC_ERROR_TEXT = "Expected a function";
    var HASH_UNDEFINED = "__lodash_hash_undefined__";
    var UNORDERED_COMPARE_FLAG = 1;
    var PARTIAL_COMPARE_FLAG = 2;
    var INFINITY = 1 / 0;
    var MAX_SAFE_INTEGER = 9007199254740991;
    var argsTag = "[object Arguments]";
    var arrayTag = "[object Array]";
    var boolTag = "[object Boolean]";
    var dateTag = "[object Date]";
    var errorTag = "[object Error]";
    var funcTag = "[object Function]";
    var genTag = "[object GeneratorFunction]";
    var mapTag = "[object Map]";
    var numberTag = "[object Number]";
    var objectTag = "[object Object]";
    var promiseTag = "[object Promise]";
    var regexpTag = "[object RegExp]";
    var setTag = "[object Set]";
    var stringTag = "[object String]";
    var symbolTag = "[object Symbol]";
    var weakMapTag = "[object WeakMap]";
    var arrayBufferTag = "[object ArrayBuffer]";
    var dataViewTag = "[object DataView]";
    var float32Tag = "[object Float32Array]";
    var float64Tag = "[object Float64Array]";
    var int8Tag = "[object Int8Array]";
    var int16Tag = "[object Int16Array]";
    var int32Tag = "[object Int32Array]";
    var uint8Tag = "[object Uint8Array]";
    var uint8ClampedTag = "[object Uint8ClampedArray]";
    var uint16Tag = "[object Uint16Array]";
    var uint32Tag = "[object Uint32Array]";
    var reIsDeepProp = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/;
    var reIsPlainProp = /^\w*$/;
    var reLeadingDot = /^\./;
    var rePropName = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g;
    var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;
    var reEscapeChar = /\\(\\)?/g;
    var reIsHostCtor = /^\[object .+?Constructor\]$/;
    var reIsUint = /^(?:0|[1-9]\d*)$/;
    var typedArrayTags = {};
    typedArrayTags[float32Tag] = typedArrayTags[float64Tag] = typedArrayTags[int8Tag] = typedArrayTags[int16Tag] = typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] = typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] = typedArrayTags[uint32Tag] = true;
    typedArrayTags[argsTag] = typedArrayTags[arrayTag] = typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] = typedArrayTags[dataViewTag] = typedArrayTags[dateTag] = typedArrayTags[errorTag] = typedArrayTags[funcTag] = typedArrayTags[mapTag] = typedArrayTags[numberTag] = typedArrayTags[objectTag] = typedArrayTags[regexpTag] = typedArrayTags[setTag] = typedArrayTags[stringTag] = typedArrayTags[weakMapTag] = false;
    var freeGlobal = typeof global == "object" && global && global.Object === Object && global;
    var freeSelf = typeof self == "object" && self && self.Object === Object && self;
    var root = freeGlobal || freeSelf || Function("return this")();
    var freeExports = typeof exports2 == "object" && exports2 && !exports2.nodeType && exports2;
    var freeModule = freeExports && typeof module2 == "object" && module2 && !module2.nodeType && module2;
    var moduleExports = freeModule && freeModule.exports === freeExports;
    var freeProcess = moduleExports && freeGlobal.process;
    var nodeUtil = function() {
      try {
        return freeProcess && freeProcess.binding("util");
      } catch (e) {
      }
    }();
    var nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;
    function arrayAggregator(array, setter, iteratee, accumulator) {
      var index = -1, length = array ? array.length : 0;
      while (++index < length) {
        var value = array[index];
        setter(accumulator, value, iteratee(value), array);
      }
      return accumulator;
    }
    function arraySome(array, predicate) {
      var index = -1, length = array ? array.length : 0;
      while (++index < length) {
        if (predicate(array[index], index, array)) {
          return true;
        }
      }
      return false;
    }
    function baseProperty(key) {
      return function(object) {
        return object == null ? void 0 : object[key];
      };
    }
    function baseTimes(n, iteratee) {
      var index = -1, result = Array(n);
      while (++index < n) {
        result[index] = iteratee(index);
      }
      return result;
    }
    function baseUnary(func) {
      return function(value) {
        return func(value);
      };
    }
    function getValue(object, key) {
      return object == null ? void 0 : object[key];
    }
    function isHostObject(value) {
      var result = false;
      if (value != null && typeof value.toString != "function") {
        try {
          result = !!(value + "");
        } catch (e) {
        }
      }
      return result;
    }
    function mapToArray(map) {
      var index = -1, result = Array(map.size);
      map.forEach(function(value, key) {
        result[++index] = [key, value];
      });
      return result;
    }
    function overArg(func, transform) {
      return function(arg) {
        return func(transform(arg));
      };
    }
    function setToArray(set) {
      var index = -1, result = Array(set.size);
      set.forEach(function(value) {
        result[++index] = value;
      });
      return result;
    }
    var arrayProto = Array.prototype;
    var funcProto = Function.prototype;
    var objectProto = Object.prototype;
    var coreJsData = root["__core-js_shared__"];
    var maskSrcKey = function() {
      var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || "");
      return uid ? "Symbol(src)_1." + uid : "";
    }();
    var funcToString = funcProto.toString;
    var hasOwnProperty = objectProto.hasOwnProperty;
    var objectToString = objectProto.toString;
    var reIsNative = RegExp(
      "^" + funcToString.call(hasOwnProperty).replace(reRegExpChar, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"
    );
    var Symbol2 = root.Symbol;
    var Uint8Array2 = root.Uint8Array;
    var propertyIsEnumerable = objectProto.propertyIsEnumerable;
    var splice = arrayProto.splice;
    var nativeKeys = overArg(Object.keys, Object);
    var DataView2 = getNative(root, "DataView");
    var Map2 = getNative(root, "Map");
    var Promise2 = getNative(root, "Promise");
    var Set2 = getNative(root, "Set");
    var WeakMap2 = getNative(root, "WeakMap");
    var nativeCreate = getNative(Object, "create");
    var dataViewCtorString = toSource(DataView2);
    var mapCtorString = toSource(Map2);
    var promiseCtorString = toSource(Promise2);
    var setCtorString = toSource(Set2);
    var weakMapCtorString = toSource(WeakMap2);
    var symbolProto = Symbol2 ? Symbol2.prototype : void 0;
    var symbolValueOf = symbolProto ? symbolProto.valueOf : void 0;
    var symbolToString = symbolProto ? symbolProto.toString : void 0;
    function Hash(entries) {
      var index = -1, length = entries ? entries.length : 0;
      this.clear();
      while (++index < length) {
        var entry = entries[index];
        this.set(entry[0], entry[1]);
      }
    }
    function hashClear() {
      this.__data__ = nativeCreate ? nativeCreate(null) : {};
    }
    function hashDelete(key) {
      return this.has(key) && delete this.__data__[key];
    }
    function hashGet(key) {
      var data = this.__data__;
      if (nativeCreate) {
        var result = data[key];
        return result === HASH_UNDEFINED ? void 0 : result;
      }
      return hasOwnProperty.call(data, key) ? data[key] : void 0;
    }
    function hashHas(key) {
      var data = this.__data__;
      return nativeCreate ? data[key] !== void 0 : hasOwnProperty.call(data, key);
    }
    function hashSet(key, value) {
      var data = this.__data__;
      data[key] = nativeCreate && value === void 0 ? HASH_UNDEFINED : value;
      return this;
    }
    Hash.prototype.clear = hashClear;
    Hash.prototype["delete"] = hashDelete;
    Hash.prototype.get = hashGet;
    Hash.prototype.has = hashHas;
    Hash.prototype.set = hashSet;
    function ListCache(entries) {
      var index = -1, length = entries ? entries.length : 0;
      this.clear();
      while (++index < length) {
        var entry = entries[index];
        this.set(entry[0], entry[1]);
      }
    }
    function listCacheClear() {
      this.__data__ = [];
    }
    function listCacheDelete(key) {
      var data = this.__data__, index = assocIndexOf(data, key);
      if (index < 0) {
        return false;
      }
      var lastIndex = data.length - 1;
      if (index == lastIndex) {
        data.pop();
      } else {
        splice.call(data, index, 1);
      }
      return true;
    }
    function listCacheGet(key) {
      var data = this.__data__, index = assocIndexOf(data, key);
      return index < 0 ? void 0 : data[index][1];
    }
    function listCacheHas(key) {
      return assocIndexOf(this.__data__, key) > -1;
    }
    function listCacheSet(key, value) {
      var data = this.__data__, index = assocIndexOf(data, key);
      if (index < 0) {
        data.push([key, value]);
      } else {
        data[index][1] = value;
      }
      return this;
    }
    ListCache.prototype.clear = listCacheClear;
    ListCache.prototype["delete"] = listCacheDelete;
    ListCache.prototype.get = listCacheGet;
    ListCache.prototype.has = listCacheHas;
    ListCache.prototype.set = listCacheSet;
    function MapCache(entries) {
      var index = -1, length = entries ? entries.length : 0;
      this.clear();
      while (++index < length) {
        var entry = entries[index];
        this.set(entry[0], entry[1]);
      }
    }
    function mapCacheClear() {
      this.__data__ = {
        "hash": new Hash(),
        "map": new (Map2 || ListCache)(),
        "string": new Hash()
      };
    }
    function mapCacheDelete(key) {
      return getMapData(this, key)["delete"](key);
    }
    function mapCacheGet(key) {
      return getMapData(this, key).get(key);
    }
    function mapCacheHas(key) {
      return getMapData(this, key).has(key);
    }
    function mapCacheSet(key, value) {
      getMapData(this, key).set(key, value);
      return this;
    }
    MapCache.prototype.clear = mapCacheClear;
    MapCache.prototype["delete"] = mapCacheDelete;
    MapCache.prototype.get = mapCacheGet;
    MapCache.prototype.has = mapCacheHas;
    MapCache.prototype.set = mapCacheSet;
    function SetCache(values) {
      var index = -1, length = values ? values.length : 0;
      this.__data__ = new MapCache();
      while (++index < length) {
        this.add(values[index]);
      }
    }
    function setCacheAdd(value) {
      this.__data__.set(value, HASH_UNDEFINED);
      return this;
    }
    function setCacheHas(value) {
      return this.__data__.has(value);
    }
    SetCache.prototype.add = SetCache.prototype.push = setCacheAdd;
    SetCache.prototype.has = setCacheHas;
    function Stack(entries) {
      this.__data__ = new ListCache(entries);
    }
    function stackClear() {
      this.__data__ = new ListCache();
    }
    function stackDelete(key) {
      return this.__data__["delete"](key);
    }
    function stackGet(key) {
      return this.__data__.get(key);
    }
    function stackHas(key) {
      return this.__data__.has(key);
    }
    function stackSet(key, value) {
      var cache = this.__data__;
      if (cache instanceof ListCache) {
        var pairs = cache.__data__;
        if (!Map2 || pairs.length < LARGE_ARRAY_SIZE - 1) {
          pairs.push([key, value]);
          return this;
        }
        cache = this.__data__ = new MapCache(pairs);
      }
      cache.set(key, value);
      return this;
    }
    Stack.prototype.clear = stackClear;
    Stack.prototype["delete"] = stackDelete;
    Stack.prototype.get = stackGet;
    Stack.prototype.has = stackHas;
    Stack.prototype.set = stackSet;
    function arrayLikeKeys(value, inherited) {
      var result = isArray(value) || isArguments(value) ? baseTimes(value.length, String) : [];
      var length = result.length, skipIndexes = !!length;
      for (var key in value) {
        if ((inherited || hasOwnProperty.call(value, key)) && !(skipIndexes && (key == "length" || isIndex(key, length)))) {
          result.push(key);
        }
      }
      return result;
    }
    function assocIndexOf(array, key) {
      var length = array.length;
      while (length--) {
        if (eq(array[length][0], key)) {
          return length;
        }
      }
      return -1;
    }
    function baseAggregator(collection, setter, iteratee, accumulator) {
      baseEach(collection, function(value, key, collection2) {
        setter(accumulator, value, iteratee(value), collection2);
      });
      return accumulator;
    }
    var baseEach = createBaseEach(baseForOwn);
    var baseFor = createBaseFor();
    function baseForOwn(object, iteratee) {
      return object && baseFor(object, iteratee, keys);
    }
    function baseGet(object, path) {
      path = isKey(path, object) ? [path] : castPath(path);
      var index = 0, length = path.length;
      while (object != null && index < length) {
        object = object[toKey(path[index++])];
      }
      return index && index == length ? object : void 0;
    }
    function baseGetTag(value) {
      return objectToString.call(value);
    }
    function baseHasIn(object, key) {
      return object != null && key in Object(object);
    }
    function baseIsEqual(value, other, customizer, bitmask, stack) {
      if (value === other) {
        return true;
      }
      if (value == null || other == null || !isObject2(value) && !isObjectLike(other)) {
        return value !== value && other !== other;
      }
      return baseIsEqualDeep(value, other, baseIsEqual, customizer, bitmask, stack);
    }
    function baseIsEqualDeep(object, other, equalFunc, customizer, bitmask, stack) {
      var objIsArr = isArray(object), othIsArr = isArray(other), objTag = arrayTag, othTag = arrayTag;
      if (!objIsArr) {
        objTag = getTag(object);
        objTag = objTag == argsTag ? objectTag : objTag;
      }
      if (!othIsArr) {
        othTag = getTag(other);
        othTag = othTag == argsTag ? objectTag : othTag;
      }
      var objIsObj = objTag == objectTag && !isHostObject(object), othIsObj = othTag == objectTag && !isHostObject(other), isSameTag = objTag == othTag;
      if (isSameTag && !objIsObj) {
        stack || (stack = new Stack());
        return objIsArr || isTypedArray(object) ? equalArrays(object, other, equalFunc, customizer, bitmask, stack) : equalByTag(object, other, objTag, equalFunc, customizer, bitmask, stack);
      }
      if (!(bitmask & PARTIAL_COMPARE_FLAG)) {
        var objIsWrapped = objIsObj && hasOwnProperty.call(object, "__wrapped__"), othIsWrapped = othIsObj && hasOwnProperty.call(other, "__wrapped__");
        if (objIsWrapped || othIsWrapped) {
          var objUnwrapped = objIsWrapped ? object.value() : object, othUnwrapped = othIsWrapped ? other.value() : other;
          stack || (stack = new Stack());
          return equalFunc(objUnwrapped, othUnwrapped, customizer, bitmask, stack);
        }
      }
      if (!isSameTag) {
        return false;
      }
      stack || (stack = new Stack());
      return equalObjects(object, other, equalFunc, customizer, bitmask, stack);
    }
    function baseIsMatch(object, source, matchData, customizer) {
      var index = matchData.length, length = index, noCustomizer = !customizer;
      if (object == null) {
        return !length;
      }
      object = Object(object);
      while (index--) {
        var data = matchData[index];
        if (noCustomizer && data[2] ? data[1] !== object[data[0]] : !(data[0] in object)) {
          return false;
        }
      }
      while (++index < length) {
        data = matchData[index];
        var key = data[0], objValue = object[key], srcValue = data[1];
        if (noCustomizer && data[2]) {
          if (objValue === void 0 && !(key in object)) {
            return false;
          }
        } else {
          var stack = new Stack();
          if (customizer) {
            var result = customizer(objValue, srcValue, key, object, source, stack);
          }
          if (!(result === void 0 ? baseIsEqual(srcValue, objValue, customizer, UNORDERED_COMPARE_FLAG | PARTIAL_COMPARE_FLAG, stack) : result)) {
            return false;
          }
        }
      }
      return true;
    }
    function baseIsNative(value) {
      if (!isObject2(value) || isMasked(value)) {
        return false;
      }
      var pattern = isFunction(value) || isHostObject(value) ? reIsNative : reIsHostCtor;
      return pattern.test(toSource(value));
    }
    function baseIsTypedArray(value) {
      return isObjectLike(value) && isLength(value.length) && !!typedArrayTags[objectToString.call(value)];
    }
    function baseIteratee(value) {
      if (typeof value == "function") {
        return value;
      }
      if (value == null) {
        return identity;
      }
      if (typeof value == "object") {
        return isArray(value) ? baseMatchesProperty(value[0], value[1]) : baseMatches(value);
      }
      return property(value);
    }
    function baseKeys(object) {
      if (!isPrototype(object)) {
        return nativeKeys(object);
      }
      var result = [];
      for (var key in Object(object)) {
        if (hasOwnProperty.call(object, key) && key != "constructor") {
          result.push(key);
        }
      }
      return result;
    }
    function baseMatches(source) {
      var matchData = getMatchData(source);
      if (matchData.length == 1 && matchData[0][2]) {
        return matchesStrictComparable(matchData[0][0], matchData[0][1]);
      }
      return function(object) {
        return object === source || baseIsMatch(object, source, matchData);
      };
    }
    function baseMatchesProperty(path, srcValue) {
      if (isKey(path) && isStrictComparable(srcValue)) {
        return matchesStrictComparable(toKey(path), srcValue);
      }
      return function(object) {
        var objValue = get(object, path);
        return objValue === void 0 && objValue === srcValue ? hasIn(object, path) : baseIsEqual(srcValue, objValue, void 0, UNORDERED_COMPARE_FLAG | PARTIAL_COMPARE_FLAG);
      };
    }
    function basePropertyDeep(path) {
      return function(object) {
        return baseGet(object, path);
      };
    }
    function baseToString(value) {
      if (typeof value == "string") {
        return value;
      }
      if (isSymbol(value)) {
        return symbolToString ? symbolToString.call(value) : "";
      }
      var result = value + "";
      return result == "0" && 1 / value == -INFINITY ? "-0" : result;
    }
    function castPath(value) {
      return isArray(value) ? value : stringToPath(value);
    }
    function createAggregator(setter, initializer) {
      return function(collection, iteratee) {
        var func = isArray(collection) ? arrayAggregator : baseAggregator, accumulator = initializer ? initializer() : {};
        return func(collection, setter, baseIteratee(iteratee, 2), accumulator);
      };
    }
    function createBaseEach(eachFunc, fromRight) {
      return function(collection, iteratee) {
        if (collection == null) {
          return collection;
        }
        if (!isArrayLike(collection)) {
          return eachFunc(collection, iteratee);
        }
        var length = collection.length, index = fromRight ? length : -1, iterable = Object(collection);
        while (fromRight ? index-- : ++index < length) {
          if (iteratee(iterable[index], index, iterable) === false) {
            break;
          }
        }
        return collection;
      };
    }
    function createBaseFor(fromRight) {
      return function(object, iteratee, keysFunc) {
        var index = -1, iterable = Object(object), props = keysFunc(object), length = props.length;
        while (length--) {
          var key = props[fromRight ? length : ++index];
          if (iteratee(iterable[key], key, iterable) === false) {
            break;
          }
        }
        return object;
      };
    }
    function equalArrays(array, other, equalFunc, customizer, bitmask, stack) {
      var isPartial = bitmask & PARTIAL_COMPARE_FLAG, arrLength = array.length, othLength = other.length;
      if (arrLength != othLength && !(isPartial && othLength > arrLength)) {
        return false;
      }
      var stacked = stack.get(array);
      if (stacked && stack.get(other)) {
        return stacked == other;
      }
      var index = -1, result = true, seen = bitmask & UNORDERED_COMPARE_FLAG ? new SetCache() : void 0;
      stack.set(array, other);
      stack.set(other, array);
      while (++index < arrLength) {
        var arrValue = array[index], othValue = other[index];
        if (customizer) {
          var compared = isPartial ? customizer(othValue, arrValue, index, other, array, stack) : customizer(arrValue, othValue, index, array, other, stack);
        }
        if (compared !== void 0) {
          if (compared) {
            continue;
          }
          result = false;
          break;
        }
        if (seen) {
          if (!arraySome(other, function(othValue2, othIndex) {
            if (!seen.has(othIndex) && (arrValue === othValue2 || equalFunc(arrValue, othValue2, customizer, bitmask, stack))) {
              return seen.add(othIndex);
            }
          })) {
            result = false;
            break;
          }
        } else if (!(arrValue === othValue || equalFunc(arrValue, othValue, customizer, bitmask, stack))) {
          result = false;
          break;
        }
      }
      stack["delete"](array);
      stack["delete"](other);
      return result;
    }
    function equalByTag(object, other, tag, equalFunc, customizer, bitmask, stack) {
      switch (tag) {
        case dataViewTag:
          if (object.byteLength != other.byteLength || object.byteOffset != other.byteOffset) {
            return false;
          }
          object = object.buffer;
          other = other.buffer;
        case arrayBufferTag:
          if (object.byteLength != other.byteLength || !equalFunc(new Uint8Array2(object), new Uint8Array2(other))) {
            return false;
          }
          return true;
        case boolTag:
        case dateTag:
        case numberTag:
          return eq(+object, +other);
        case errorTag:
          return object.name == other.name && object.message == other.message;
        case regexpTag:
        case stringTag:
          return object == other + "";
        case mapTag:
          var convert = mapToArray;
        case setTag:
          var isPartial = bitmask & PARTIAL_COMPARE_FLAG;
          convert || (convert = setToArray);
          if (object.size != other.size && !isPartial) {
            return false;
          }
          var stacked = stack.get(object);
          if (stacked) {
            return stacked == other;
          }
          bitmask |= UNORDERED_COMPARE_FLAG;
          stack.set(object, other);
          var result = equalArrays(convert(object), convert(other), equalFunc, customizer, bitmask, stack);
          stack["delete"](object);
          return result;
        case symbolTag:
          if (symbolValueOf) {
            return symbolValueOf.call(object) == symbolValueOf.call(other);
          }
      }
      return false;
    }
    function equalObjects(object, other, equalFunc, customizer, bitmask, stack) {
      var isPartial = bitmask & PARTIAL_COMPARE_FLAG, objProps = keys(object), objLength = objProps.length, othProps = keys(other), othLength = othProps.length;
      if (objLength != othLength && !isPartial) {
        return false;
      }
      var index = objLength;
      while (index--) {
        var key = objProps[index];
        if (!(isPartial ? key in other : hasOwnProperty.call(other, key))) {
          return false;
        }
      }
      var stacked = stack.get(object);
      if (stacked && stack.get(other)) {
        return stacked == other;
      }
      var result = true;
      stack.set(object, other);
      stack.set(other, object);
      var skipCtor = isPartial;
      while (++index < objLength) {
        key = objProps[index];
        var objValue = object[key], othValue = other[key];
        if (customizer) {
          var compared = isPartial ? customizer(othValue, objValue, key, other, object, stack) : customizer(objValue, othValue, key, object, other, stack);
        }
        if (!(compared === void 0 ? objValue === othValue || equalFunc(objValue, othValue, customizer, bitmask, stack) : compared)) {
          result = false;
          break;
        }
        skipCtor || (skipCtor = key == "constructor");
      }
      if (result && !skipCtor) {
        var objCtor = object.constructor, othCtor = other.constructor;
        if (objCtor != othCtor && ("constructor" in object && "constructor" in other) && !(typeof objCtor == "function" && objCtor instanceof objCtor && typeof othCtor == "function" && othCtor instanceof othCtor)) {
          result = false;
        }
      }
      stack["delete"](object);
      stack["delete"](other);
      return result;
    }
    function getMapData(map, key) {
      var data = map.__data__;
      return isKeyable(key) ? data[typeof key == "string" ? "string" : "hash"] : data.map;
    }
    function getMatchData(object) {
      var result = keys(object), length = result.length;
      while (length--) {
        var key = result[length], value = object[key];
        result[length] = [key, value, isStrictComparable(value)];
      }
      return result;
    }
    function getNative(object, key) {
      var value = getValue(object, key);
      return baseIsNative(value) ? value : void 0;
    }
    var getTag = baseGetTag;
    if (DataView2 && getTag(new DataView2(new ArrayBuffer(1))) != dataViewTag || Map2 && getTag(new Map2()) != mapTag || Promise2 && getTag(Promise2.resolve()) != promiseTag || Set2 && getTag(new Set2()) != setTag || WeakMap2 && getTag(new WeakMap2()) != weakMapTag) {
      getTag = function(value) {
        var result = objectToString.call(value), Ctor = result == objectTag ? value.constructor : void 0, ctorString = Ctor ? toSource(Ctor) : void 0;
        if (ctorString) {
          switch (ctorString) {
            case dataViewCtorString:
              return dataViewTag;
            case mapCtorString:
              return mapTag;
            case promiseCtorString:
              return promiseTag;
            case setCtorString:
              return setTag;
            case weakMapCtorString:
              return weakMapTag;
          }
        }
        return result;
      };
    }
    function hasPath(object, path, hasFunc) {
      path = isKey(path, object) ? [path] : castPath(path);
      var result, index = -1, length = path.length;
      while (++index < length) {
        var key = toKey(path[index]);
        if (!(result = object != null && hasFunc(object, key))) {
          break;
        }
        object = object[key];
      }
      if (result) {
        return result;
      }
      var length = object ? object.length : 0;
      return !!length && isLength(length) && isIndex(key, length) && (isArray(object) || isArguments(object));
    }
    function isIndex(value, length) {
      length = length == null ? MAX_SAFE_INTEGER : length;
      return !!length && (typeof value == "number" || reIsUint.test(value)) && (value > -1 && value % 1 == 0 && value < length);
    }
    function isKey(value, object) {
      if (isArray(value)) {
        return false;
      }
      var type = typeof value;
      if (type == "number" || type == "symbol" || type == "boolean" || value == null || isSymbol(value)) {
        return true;
      }
      return reIsPlainProp.test(value) || !reIsDeepProp.test(value) || object != null && value in Object(object);
    }
    function isKeyable(value) {
      var type = typeof value;
      return type == "string" || type == "number" || type == "symbol" || type == "boolean" ? value !== "__proto__" : value === null;
    }
    function isMasked(func) {
      return !!maskSrcKey && maskSrcKey in func;
    }
    function isPrototype(value) {
      var Ctor = value && value.constructor, proto = typeof Ctor == "function" && Ctor.prototype || objectProto;
      return value === proto;
    }
    function isStrictComparable(value) {
      return value === value && !isObject2(value);
    }
    function matchesStrictComparable(key, srcValue) {
      return function(object) {
        if (object == null) {
          return false;
        }
        return object[key] === srcValue && (srcValue !== void 0 || key in Object(object));
      };
    }
    var stringToPath = memoize(function(string) {
      string = toString(string);
      var result = [];
      if (reLeadingDot.test(string)) {
        result.push("");
      }
      string.replace(rePropName, function(match, number, quote, string2) {
        result.push(quote ? string2.replace(reEscapeChar, "$1") : number || match);
      });
      return result;
    });
    function toKey(value) {
      if (typeof value == "string" || isSymbol(value)) {
        return value;
      }
      var result = value + "";
      return result == "0" && 1 / value == -INFINITY ? "-0" : result;
    }
    function toSource(func) {
      if (func != null) {
        try {
          return funcToString.call(func);
        } catch (e) {
        }
        try {
          return func + "";
        } catch (e) {
        }
      }
      return "";
    }
    var groupBy = createAggregator(function(result, value, key) {
      if (hasOwnProperty.call(result, key)) {
        result[key].push(value);
      } else {
        result[key] = [value];
      }
    });
    function memoize(func, resolver) {
      if (typeof func != "function" || resolver && typeof resolver != "function") {
        throw new TypeError(FUNC_ERROR_TEXT);
      }
      var memoized = function() {
        var args = arguments, key = resolver ? resolver.apply(this, args) : args[0], cache = memoized.cache;
        if (cache.has(key)) {
          return cache.get(key);
        }
        var result = func.apply(this, args);
        memoized.cache = cache.set(key, result);
        return result;
      };
      memoized.cache = new (memoize.Cache || MapCache)();
      return memoized;
    }
    memoize.Cache = MapCache;
    function eq(value, other) {
      return value === other || value !== value && other !== other;
    }
    function isArguments(value) {
      return isArrayLikeObject(value) && hasOwnProperty.call(value, "callee") && (!propertyIsEnumerable.call(value, "callee") || objectToString.call(value) == argsTag);
    }
    var isArray = Array.isArray;
    function isArrayLike(value) {
      return value != null && isLength(value.length) && !isFunction(value);
    }
    function isArrayLikeObject(value) {
      return isObjectLike(value) && isArrayLike(value);
    }
    function isFunction(value) {
      var tag = isObject2(value) ? objectToString.call(value) : "";
      return tag == funcTag || tag == genTag;
    }
    function isLength(value) {
      return typeof value == "number" && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
    }
    function isObject2(value) {
      var type = typeof value;
      return !!value && (type == "object" || type == "function");
    }
    function isObjectLike(value) {
      return !!value && typeof value == "object";
    }
    function isSymbol(value) {
      return typeof value == "symbol" || isObjectLike(value) && objectToString.call(value) == symbolTag;
    }
    var isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;
    function toString(value) {
      return value == null ? "" : baseToString(value);
    }
    function get(object, path, defaultValue) {
      var result = object == null ? void 0 : baseGet(object, path);
      return result === void 0 ? defaultValue : result;
    }
    function hasIn(object, path) {
      return object != null && hasPath(object, path, baseHasIn);
    }
    function keys(object) {
      return isArrayLike(object) ? arrayLikeKeys(object) : baseKeys(object);
    }
    function identity(value) {
      return value;
    }
    function property(path) {
      return isKey(path) ? baseProperty(toKey(path)) : basePropertyDeep(path);
    }
    module2.exports = groupBy;
  }
});

// ../../../node_modules/@fast-csv/parse/build/src/transforms/HeaderTransformer.js
var require_HeaderTransformer = __commonJS({
  "../../../node_modules/@fast-csv/parse/build/src/transforms/HeaderTransformer.js"(exports2) {
    "use strict";
    var __importDefault = exports2 && exports2.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.HeaderTransformer = void 0;
    var lodash_isundefined_1 = __importDefault(require_lodash6());
    var lodash_isfunction_1 = __importDefault(require_lodash());
    var lodash_uniq_1 = __importDefault(require_lodash7());
    var lodash_groupby_1 = __importDefault(require_lodash8());
    var HeaderTransformer = class {
      constructor(parserOptions) {
        this.headers = null;
        this.receivedHeaders = false;
        this.shouldUseFirstRow = false;
        this.processedFirstRow = false;
        this.headersLength = 0;
        this.parserOptions = parserOptions;
        if (parserOptions.headers === true) {
          this.shouldUseFirstRow = true;
        } else if (Array.isArray(parserOptions.headers)) {
          this.setHeaders(parserOptions.headers);
        } else if (lodash_isfunction_1.default(parserOptions.headers)) {
          this.headersTransform = parserOptions.headers;
        }
      }
      transform(row, cb) {
        if (!this.shouldMapRow(row)) {
          return cb(null, { row: null, isValid: true });
        }
        return cb(null, this.processRow(row));
      }
      shouldMapRow(row) {
        const { parserOptions } = this;
        if (!this.headersTransform && parserOptions.renameHeaders && !this.processedFirstRow) {
          if (!this.receivedHeaders) {
            throw new Error("Error renaming headers: new headers must be provided in an array");
          }
          this.processedFirstRow = true;
          return false;
        }
        if (!this.receivedHeaders && Array.isArray(row)) {
          if (this.headersTransform) {
            this.setHeaders(this.headersTransform(row));
          } else if (this.shouldUseFirstRow) {
            this.setHeaders(row);
          } else {
            return true;
          }
          return false;
        }
        return true;
      }
      processRow(row) {
        if (!this.headers) {
          return { row, isValid: true };
        }
        const { parserOptions } = this;
        if (!parserOptions.discardUnmappedColumns && row.length > this.headersLength) {
          if (!parserOptions.strictColumnHandling) {
            throw new Error(`Unexpected Error: column header mismatch expected: ${this.headersLength} columns got: ${row.length}`);
          }
          return {
            row,
            isValid: false,
            reason: `Column header mismatch expected: ${this.headersLength} columns got: ${row.length}`
          };
        }
        if (parserOptions.strictColumnHandling && row.length < this.headersLength) {
          return {
            row,
            isValid: false,
            reason: `Column header mismatch expected: ${this.headersLength} columns got: ${row.length}`
          };
        }
        return { row: this.mapHeaders(row), isValid: true };
      }
      mapHeaders(row) {
        const rowMap = {};
        const { headers, headersLength } = this;
        for (let i = 0; i < headersLength; i += 1) {
          const header = headers[i];
          if (!lodash_isundefined_1.default(header)) {
            const val = row[i];
            if (lodash_isundefined_1.default(val)) {
              rowMap[header] = "";
            } else {
              rowMap[header] = val;
            }
          }
        }
        return rowMap;
      }
      setHeaders(headers) {
        var _a;
        const filteredHeaders = headers.filter((h) => !!h);
        if (lodash_uniq_1.default(filteredHeaders).length !== filteredHeaders.length) {
          const grouped = lodash_groupby_1.default(filteredHeaders);
          const duplicates = Object.keys(grouped).filter((dup) => grouped[dup].length > 1);
          throw new Error(`Duplicate headers found ${JSON.stringify(duplicates)}`);
        }
        this.headers = headers;
        this.receivedHeaders = true;
        this.headersLength = ((_a = this.headers) === null || _a === void 0 ? void 0 : _a.length) || 0;
      }
    };
    exports2.HeaderTransformer = HeaderTransformer;
  }
});

// ../../../node_modules/@fast-csv/parse/build/src/transforms/index.js
var require_transforms = __commonJS({
  "../../../node_modules/@fast-csv/parse/build/src/transforms/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.HeaderTransformer = exports2.RowTransformerValidator = void 0;
    var RowTransformerValidator_1 = require_RowTransformerValidator();
    Object.defineProperty(exports2, "RowTransformerValidator", { enumerable: true, get: function() {
      return RowTransformerValidator_1.RowTransformerValidator;
    } });
    var HeaderTransformer_1 = require_HeaderTransformer();
    Object.defineProperty(exports2, "HeaderTransformer", { enumerable: true, get: function() {
      return HeaderTransformer_1.HeaderTransformer;
    } });
  }
});

// ../../../node_modules/@fast-csv/parse/build/src/parser/Token.js
var require_Token = __commonJS({
  "../../../node_modules/@fast-csv/parse/build/src/parser/Token.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.Token = void 0;
    var Token = class {
      constructor(tokenArgs) {
        this.token = tokenArgs.token;
        this.startCursor = tokenArgs.startCursor;
        this.endCursor = tokenArgs.endCursor;
      }
      static isTokenRowDelimiter(token) {
        const content = token.token;
        return content === "\r" || content === "\n" || content === "\r\n";
      }
      static isTokenCarriageReturn(token, parserOptions) {
        return token.token === parserOptions.carriageReturn;
      }
      static isTokenComment(token, parserOptions) {
        return parserOptions.supportsComments && !!token && token.token === parserOptions.comment;
      }
      static isTokenEscapeCharacter(token, parserOptions) {
        return token.token === parserOptions.escapeChar;
      }
      static isTokenQuote(token, parserOptions) {
        return token.token === parserOptions.quote;
      }
      static isTokenDelimiter(token, parserOptions) {
        return token.token === parserOptions.delimiter;
      }
    };
    exports2.Token = Token;
  }
});

// ../../../node_modules/@fast-csv/parse/build/src/parser/Scanner.js
var require_Scanner = __commonJS({
  "../../../node_modules/@fast-csv/parse/build/src/parser/Scanner.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.Scanner = void 0;
    var Token_1 = require_Token();
    var ROW_DELIMITER = /((?:\r\n)|\n|\r)/;
    var Scanner = class {
      constructor(args) {
        this.cursor = 0;
        this.line = args.line;
        this.lineLength = this.line.length;
        this.parserOptions = args.parserOptions;
        this.hasMoreData = args.hasMoreData;
        this.cursor = args.cursor || 0;
      }
      get hasMoreCharacters() {
        return this.lineLength > this.cursor;
      }
      get nextNonSpaceToken() {
        const { lineFromCursor } = this;
        const regex = this.parserOptions.NEXT_TOKEN_REGEXP;
        if (lineFromCursor.search(regex) === -1) {
          return null;
        }
        const match = regex.exec(lineFromCursor);
        if (match == null) {
          return null;
        }
        const token = match[1];
        const startCursor = this.cursor + (match.index || 0);
        return new Token_1.Token({
          token,
          startCursor,
          endCursor: startCursor + token.length - 1
        });
      }
      get nextCharacterToken() {
        const { cursor, lineLength } = this;
        if (lineLength <= cursor) {
          return null;
        }
        return new Token_1.Token({
          token: this.line[cursor],
          startCursor: cursor,
          endCursor: cursor
        });
      }
      get lineFromCursor() {
        return this.line.substr(this.cursor);
      }
      advancePastLine() {
        const match = ROW_DELIMITER.exec(this.lineFromCursor);
        if (!match) {
          if (this.hasMoreData) {
            return null;
          }
          this.cursor = this.lineLength;
          return this;
        }
        this.cursor += (match.index || 0) + match[0].length;
        return this;
      }
      advanceTo(cursor) {
        this.cursor = cursor;
        return this;
      }
      advanceToToken(token) {
        this.cursor = token.startCursor;
        return this;
      }
      advancePastToken(token) {
        this.cursor = token.endCursor + 1;
        return this;
      }
      truncateToCursor() {
        this.line = this.lineFromCursor;
        this.lineLength = this.line.length;
        this.cursor = 0;
        return this;
      }
    };
    exports2.Scanner = Scanner;
  }
});

// ../../../node_modules/@fast-csv/parse/build/src/parser/column/ColumnFormatter.js
var require_ColumnFormatter = __commonJS({
  "../../../node_modules/@fast-csv/parse/build/src/parser/column/ColumnFormatter.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ColumnFormatter = void 0;
    var ColumnFormatter = class {
      constructor(parserOptions) {
        if (parserOptions.trim) {
          this.format = (col) => col.trim();
        } else if (parserOptions.ltrim) {
          this.format = (col) => col.trimLeft();
        } else if (parserOptions.rtrim) {
          this.format = (col) => col.trimRight();
        } else {
          this.format = (col) => col;
        }
      }
    };
    exports2.ColumnFormatter = ColumnFormatter;
  }
});

// ../../../node_modules/@fast-csv/parse/build/src/parser/column/NonQuotedColumnParser.js
var require_NonQuotedColumnParser = __commonJS({
  "../../../node_modules/@fast-csv/parse/build/src/parser/column/NonQuotedColumnParser.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.NonQuotedColumnParser = void 0;
    var ColumnFormatter_1 = require_ColumnFormatter();
    var Token_1 = require_Token();
    var NonQuotedColumnParser = class {
      constructor(parserOptions) {
        this.parserOptions = parserOptions;
        this.columnFormatter = new ColumnFormatter_1.ColumnFormatter(parserOptions);
      }
      parse(scanner) {
        if (!scanner.hasMoreCharacters) {
          return null;
        }
        const { parserOptions } = this;
        const characters = [];
        let nextToken = scanner.nextCharacterToken;
        for (; nextToken; nextToken = scanner.nextCharacterToken) {
          if (Token_1.Token.isTokenDelimiter(nextToken, parserOptions) || Token_1.Token.isTokenRowDelimiter(nextToken)) {
            break;
          }
          characters.push(nextToken.token);
          scanner.advancePastToken(nextToken);
        }
        return this.columnFormatter.format(characters.join(""));
      }
    };
    exports2.NonQuotedColumnParser = NonQuotedColumnParser;
  }
});

// ../../../node_modules/@fast-csv/parse/build/src/parser/column/QuotedColumnParser.js
var require_QuotedColumnParser = __commonJS({
  "../../../node_modules/@fast-csv/parse/build/src/parser/column/QuotedColumnParser.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.QuotedColumnParser = void 0;
    var ColumnFormatter_1 = require_ColumnFormatter();
    var Token_1 = require_Token();
    var QuotedColumnParser = class {
      constructor(parserOptions) {
        this.parserOptions = parserOptions;
        this.columnFormatter = new ColumnFormatter_1.ColumnFormatter(parserOptions);
      }
      parse(scanner) {
        if (!scanner.hasMoreCharacters) {
          return null;
        }
        const originalCursor = scanner.cursor;
        const { foundClosingQuote, col } = this.gatherDataBetweenQuotes(scanner);
        if (!foundClosingQuote) {
          scanner.advanceTo(originalCursor);
          if (!scanner.hasMoreData) {
            throw new Error(`Parse Error: missing closing: '${this.parserOptions.quote || ""}' in line: at '${scanner.lineFromCursor.replace(/[\r\n]/g, "\\n'")}'`);
          }
          return null;
        }
        this.checkForMalformedColumn(scanner);
        return col;
      }
      gatherDataBetweenQuotes(scanner) {
        const { parserOptions } = this;
        let foundStartingQuote = false;
        let foundClosingQuote = false;
        const characters = [];
        let nextToken = scanner.nextCharacterToken;
        for (; !foundClosingQuote && nextToken !== null; nextToken = scanner.nextCharacterToken) {
          const isQuote = Token_1.Token.isTokenQuote(nextToken, parserOptions);
          if (!foundStartingQuote && isQuote) {
            foundStartingQuote = true;
          } else if (foundStartingQuote) {
            if (Token_1.Token.isTokenEscapeCharacter(nextToken, parserOptions)) {
              scanner.advancePastToken(nextToken);
              const tokenFollowingEscape = scanner.nextCharacterToken;
              if (tokenFollowingEscape !== null && (Token_1.Token.isTokenQuote(tokenFollowingEscape, parserOptions) || Token_1.Token.isTokenEscapeCharacter(tokenFollowingEscape, parserOptions))) {
                characters.push(tokenFollowingEscape.token);
                nextToken = tokenFollowingEscape;
              } else if (isQuote) {
                foundClosingQuote = true;
              } else {
                characters.push(nextToken.token);
              }
            } else if (isQuote) {
              foundClosingQuote = true;
            } else {
              characters.push(nextToken.token);
            }
          }
          scanner.advancePastToken(nextToken);
        }
        return { col: this.columnFormatter.format(characters.join("")), foundClosingQuote };
      }
      checkForMalformedColumn(scanner) {
        const { parserOptions } = this;
        const { nextNonSpaceToken } = scanner;
        if (nextNonSpaceToken) {
          const isNextTokenADelimiter = Token_1.Token.isTokenDelimiter(nextNonSpaceToken, parserOptions);
          const isNextTokenARowDelimiter = Token_1.Token.isTokenRowDelimiter(nextNonSpaceToken);
          if (!(isNextTokenADelimiter || isNextTokenARowDelimiter)) {
            const linePreview = scanner.lineFromCursor.substr(0, 10).replace(/[\r\n]/g, "\\n'");
            throw new Error(`Parse Error: expected: '${parserOptions.escapedDelimiter}' OR new line got: '${nextNonSpaceToken.token}'. at '${linePreview}`);
          }
          scanner.advanceToToken(nextNonSpaceToken);
        } else if (!scanner.hasMoreData) {
          scanner.advancePastLine();
        }
      }
    };
    exports2.QuotedColumnParser = QuotedColumnParser;
  }
});

// ../../../node_modules/@fast-csv/parse/build/src/parser/column/ColumnParser.js
var require_ColumnParser = __commonJS({
  "../../../node_modules/@fast-csv/parse/build/src/parser/column/ColumnParser.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ColumnParser = void 0;
    var NonQuotedColumnParser_1 = require_NonQuotedColumnParser();
    var QuotedColumnParser_1 = require_QuotedColumnParser();
    var Token_1 = require_Token();
    var ColumnParser = class {
      constructor(parserOptions) {
        this.parserOptions = parserOptions;
        this.quotedColumnParser = new QuotedColumnParser_1.QuotedColumnParser(parserOptions);
        this.nonQuotedColumnParser = new NonQuotedColumnParser_1.NonQuotedColumnParser(parserOptions);
      }
      parse(scanner) {
        const { nextNonSpaceToken } = scanner;
        if (nextNonSpaceToken !== null && Token_1.Token.isTokenQuote(nextNonSpaceToken, this.parserOptions)) {
          scanner.advanceToToken(nextNonSpaceToken);
          return this.quotedColumnParser.parse(scanner);
        }
        return this.nonQuotedColumnParser.parse(scanner);
      }
    };
    exports2.ColumnParser = ColumnParser;
  }
});

// ../../../node_modules/@fast-csv/parse/build/src/parser/column/index.js
var require_column2 = __commonJS({
  "../../../node_modules/@fast-csv/parse/build/src/parser/column/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ColumnFormatter = exports2.QuotedColumnParser = exports2.NonQuotedColumnParser = exports2.ColumnParser = void 0;
    var ColumnParser_1 = require_ColumnParser();
    Object.defineProperty(exports2, "ColumnParser", { enumerable: true, get: function() {
      return ColumnParser_1.ColumnParser;
    } });
    var NonQuotedColumnParser_1 = require_NonQuotedColumnParser();
    Object.defineProperty(exports2, "NonQuotedColumnParser", { enumerable: true, get: function() {
      return NonQuotedColumnParser_1.NonQuotedColumnParser;
    } });
    var QuotedColumnParser_1 = require_QuotedColumnParser();
    Object.defineProperty(exports2, "QuotedColumnParser", { enumerable: true, get: function() {
      return QuotedColumnParser_1.QuotedColumnParser;
    } });
    var ColumnFormatter_1 = require_ColumnFormatter();
    Object.defineProperty(exports2, "ColumnFormatter", { enumerable: true, get: function() {
      return ColumnFormatter_1.ColumnFormatter;
    } });
  }
});

// ../../../node_modules/@fast-csv/parse/build/src/parser/RowParser.js
var require_RowParser = __commonJS({
  "../../../node_modules/@fast-csv/parse/build/src/parser/RowParser.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.RowParser = void 0;
    var column_1 = require_column2();
    var Token_1 = require_Token();
    var EMPTY_STRING = "";
    var RowParser = class {
      constructor(parserOptions) {
        this.parserOptions = parserOptions;
        this.columnParser = new column_1.ColumnParser(parserOptions);
      }
      static isEmptyRow(row) {
        return row.join(EMPTY_STRING).replace(/\s+/g, EMPTY_STRING) === EMPTY_STRING;
      }
      parse(scanner) {
        const { parserOptions } = this;
        const { hasMoreData } = scanner;
        const currentScanner = scanner;
        const columns = [];
        let currentToken = this.getStartToken(currentScanner, columns);
        while (currentToken) {
          if (Token_1.Token.isTokenRowDelimiter(currentToken)) {
            currentScanner.advancePastToken(currentToken);
            if (!currentScanner.hasMoreCharacters && Token_1.Token.isTokenCarriageReturn(currentToken, parserOptions) && hasMoreData) {
              return null;
            }
            currentScanner.truncateToCursor();
            return columns;
          }
          if (!this.shouldSkipColumnParse(currentScanner, currentToken, columns)) {
            const item = this.columnParser.parse(currentScanner);
            if (item === null) {
              return null;
            }
            columns.push(item);
          }
          currentToken = currentScanner.nextNonSpaceToken;
        }
        if (!hasMoreData) {
          currentScanner.truncateToCursor();
          return columns;
        }
        return null;
      }
      getStartToken(scanner, columns) {
        const currentToken = scanner.nextNonSpaceToken;
        if (currentToken !== null && Token_1.Token.isTokenDelimiter(currentToken, this.parserOptions)) {
          columns.push("");
          return scanner.nextNonSpaceToken;
        }
        return currentToken;
      }
      shouldSkipColumnParse(scanner, currentToken, columns) {
        const { parserOptions } = this;
        if (Token_1.Token.isTokenDelimiter(currentToken, parserOptions)) {
          scanner.advancePastToken(currentToken);
          const nextToken = scanner.nextCharacterToken;
          if (!scanner.hasMoreCharacters || nextToken !== null && Token_1.Token.isTokenRowDelimiter(nextToken)) {
            columns.push("");
            return true;
          }
          if (nextToken !== null && Token_1.Token.isTokenDelimiter(nextToken, parserOptions)) {
            columns.push("");
            return true;
          }
        }
        return false;
      }
    };
    exports2.RowParser = RowParser;
  }
});

// ../../../node_modules/@fast-csv/parse/build/src/parser/Parser.js
var require_Parser = __commonJS({
  "../../../node_modules/@fast-csv/parse/build/src/parser/Parser.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.Parser = void 0;
    var Scanner_1 = require_Scanner();
    var RowParser_1 = require_RowParser();
    var Token_1 = require_Token();
    var Parser = class _Parser {
      constructor(parserOptions) {
        this.parserOptions = parserOptions;
        this.rowParser = new RowParser_1.RowParser(this.parserOptions);
      }
      static removeBOM(line) {
        if (line && line.charCodeAt(0) === 65279) {
          return line.slice(1);
        }
        return line;
      }
      parse(line, hasMoreData) {
        const scanner = new Scanner_1.Scanner({
          line: _Parser.removeBOM(line),
          parserOptions: this.parserOptions,
          hasMoreData
        });
        if (this.parserOptions.supportsComments) {
          return this.parseWithComments(scanner);
        }
        return this.parseWithoutComments(scanner);
      }
      parseWithoutComments(scanner) {
        const rows = [];
        let shouldContinue = true;
        while (shouldContinue) {
          shouldContinue = this.parseRow(scanner, rows);
        }
        return { line: scanner.line, rows };
      }
      parseWithComments(scanner) {
        const { parserOptions } = this;
        const rows = [];
        for (let nextToken = scanner.nextCharacterToken; nextToken !== null; nextToken = scanner.nextCharacterToken) {
          if (Token_1.Token.isTokenComment(nextToken, parserOptions)) {
            const cursor = scanner.advancePastLine();
            if (cursor === null) {
              return { line: scanner.lineFromCursor, rows };
            }
            if (!scanner.hasMoreCharacters) {
              return { line: scanner.lineFromCursor, rows };
            }
            scanner.truncateToCursor();
          } else if (!this.parseRow(scanner, rows)) {
            break;
          }
        }
        return { line: scanner.line, rows };
      }
      parseRow(scanner, rows) {
        const nextToken = scanner.nextNonSpaceToken;
        if (!nextToken) {
          return false;
        }
        const row = this.rowParser.parse(scanner);
        if (row === null) {
          return false;
        }
        if (this.parserOptions.ignoreEmpty && RowParser_1.RowParser.isEmptyRow(row)) {
          return true;
        }
        rows.push(row);
        return true;
      }
    };
    exports2.Parser = Parser;
  }
});

// ../../../node_modules/@fast-csv/parse/build/src/parser/index.js
var require_parser = __commonJS({
  "../../../node_modules/@fast-csv/parse/build/src/parser/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.QuotedColumnParser = exports2.NonQuotedColumnParser = exports2.ColumnParser = exports2.Token = exports2.Scanner = exports2.RowParser = exports2.Parser = void 0;
    var Parser_1 = require_Parser();
    Object.defineProperty(exports2, "Parser", { enumerable: true, get: function() {
      return Parser_1.Parser;
    } });
    var RowParser_1 = require_RowParser();
    Object.defineProperty(exports2, "RowParser", { enumerable: true, get: function() {
      return RowParser_1.RowParser;
    } });
    var Scanner_1 = require_Scanner();
    Object.defineProperty(exports2, "Scanner", { enumerable: true, get: function() {
      return Scanner_1.Scanner;
    } });
    var Token_1 = require_Token();
    Object.defineProperty(exports2, "Token", { enumerable: true, get: function() {
      return Token_1.Token;
    } });
    var column_1 = require_column2();
    Object.defineProperty(exports2, "ColumnParser", { enumerable: true, get: function() {
      return column_1.ColumnParser;
    } });
    Object.defineProperty(exports2, "NonQuotedColumnParser", { enumerable: true, get: function() {
      return column_1.NonQuotedColumnParser;
    } });
    Object.defineProperty(exports2, "QuotedColumnParser", { enumerable: true, get: function() {
      return column_1.QuotedColumnParser;
    } });
  }
});

// ../../../node_modules/@fast-csv/parse/build/src/CsvParserStream.js
var require_CsvParserStream = __commonJS({
  "../../../node_modules/@fast-csv/parse/build/src/CsvParserStream.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.CsvParserStream = void 0;
    var string_decoder_1 = require("string_decoder");
    var stream_1 = require("stream");
    var transforms_1 = require_transforms();
    var parser_1 = require_parser();
    var CsvParserStream = class _CsvParserStream extends stream_1.Transform {
      constructor(parserOptions) {
        super({ objectMode: parserOptions.objectMode });
        this.lines = "";
        this.rowCount = 0;
        this.parsedRowCount = 0;
        this.parsedLineCount = 0;
        this.endEmitted = false;
        this.headersEmitted = false;
        this.parserOptions = parserOptions;
        this.parser = new parser_1.Parser(parserOptions);
        this.headerTransformer = new transforms_1.HeaderTransformer(parserOptions);
        this.decoder = new string_decoder_1.StringDecoder(parserOptions.encoding);
        this.rowTransformerValidator = new transforms_1.RowTransformerValidator();
      }
      get hasHitRowLimit() {
        return this.parserOptions.limitRows && this.rowCount >= this.parserOptions.maxRows;
      }
      get shouldEmitRows() {
        return this.parsedRowCount > this.parserOptions.skipRows;
      }
      get shouldSkipLine() {
        return this.parsedLineCount <= this.parserOptions.skipLines;
      }
      transform(transformFunction) {
        this.rowTransformerValidator.rowTransform = transformFunction;
        return this;
      }
      validate(validateFunction) {
        this.rowTransformerValidator.rowValidator = validateFunction;
        return this;
      }
      // eslint-disable-next-line @typescript-eslint/no-explicit-any
      emit(event, ...rest) {
        if (event === "end") {
          if (!this.endEmitted) {
            this.endEmitted = true;
            super.emit("end", this.rowCount);
          }
          return false;
        }
        return super.emit(event, ...rest);
      }
      _transform(data, encoding, done) {
        if (this.hasHitRowLimit) {
          return done();
        }
        const wrappedCallback = _CsvParserStream.wrapDoneCallback(done);
        try {
          const { lines } = this;
          const newLine = lines + this.decoder.write(data);
          const rows = this.parse(newLine, true);
          return this.processRows(rows, wrappedCallback);
        } catch (e) {
          return wrappedCallback(e);
        }
      }
      _flush(done) {
        const wrappedCallback = _CsvParserStream.wrapDoneCallback(done);
        if (this.hasHitRowLimit) {
          return wrappedCallback();
        }
        try {
          const newLine = this.lines + this.decoder.end();
          const rows = this.parse(newLine, false);
          return this.processRows(rows, wrappedCallback);
        } catch (e) {
          return wrappedCallback(e);
        }
      }
      parse(data, hasMoreData) {
        if (!data) {
          return [];
        }
        const { line, rows } = this.parser.parse(data, hasMoreData);
        this.lines = line;
        return rows;
      }
      processRows(rows, cb) {
        const rowsLength = rows.length;
        const iterate = (i) => {
          const callNext = (err) => {
            if (err) {
              return cb(err);
            }
            if (i % 100 === 0) {
              setImmediate(() => iterate(i + 1));
              return void 0;
            }
            return iterate(i + 1);
          };
          this.checkAndEmitHeaders();
          if (i >= rowsLength || this.hasHitRowLimit) {
            return cb();
          }
          this.parsedLineCount += 1;
          if (this.shouldSkipLine) {
            return callNext();
          }
          const row = rows[i];
          this.rowCount += 1;
          this.parsedRowCount += 1;
          const nextRowCount = this.rowCount;
          return this.transformRow(row, (err, transformResult) => {
            if (err) {
              this.rowCount -= 1;
              return callNext(err);
            }
            if (!transformResult) {
              return callNext(new Error("expected transform result"));
            }
            if (!transformResult.isValid) {
              this.emit("data-invalid", transformResult.row, nextRowCount, transformResult.reason);
            } else if (transformResult.row) {
              return this.pushRow(transformResult.row, callNext);
            }
            return callNext();
          });
        };
        iterate(0);
      }
      transformRow(parsedRow, cb) {
        try {
          this.headerTransformer.transform(parsedRow, (err, withHeaders) => {
            if (err) {
              return cb(err);
            }
            if (!withHeaders) {
              return cb(new Error("Expected result from header transform"));
            }
            if (!withHeaders.isValid) {
              if (this.shouldEmitRows) {
                return cb(null, { isValid: false, row: parsedRow });
              }
              return this.skipRow(cb);
            }
            if (withHeaders.row) {
              if (this.shouldEmitRows) {
                return this.rowTransformerValidator.transformAndValidate(withHeaders.row, cb);
              }
              return this.skipRow(cb);
            }
            this.rowCount -= 1;
            this.parsedRowCount -= 1;
            return cb(null, { row: null, isValid: true });
          });
        } catch (e) {
          cb(e);
        }
      }
      checkAndEmitHeaders() {
        if (!this.headersEmitted && this.headerTransformer.headers) {
          this.headersEmitted = true;
          this.emit("headers", this.headerTransformer.headers);
        }
      }
      skipRow(cb) {
        this.rowCount -= 1;
        return cb(null, { row: null, isValid: true });
      }
      pushRow(row, cb) {
        try {
          if (!this.parserOptions.objectMode) {
            this.push(JSON.stringify(row));
          } else {
            this.push(row);
          }
          cb();
        } catch (e) {
          cb(e);
        }
      }
      static wrapDoneCallback(done) {
        let errorCalled = false;
        return (err, ...args) => {
          if (err) {
            if (errorCalled) {
              throw err;
            }
            errorCalled = true;
            done(err);
            return;
          }
          done(...args);
        };
      }
    };
    exports2.CsvParserStream = CsvParserStream;
  }
});

// ../../../node_modules/@fast-csv/parse/build/src/index.js
var require_src2 = __commonJS({
  "../../../node_modules/@fast-csv/parse/build/src/index.js"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      Object.defineProperty(o, k2, { enumerable: true, get: function() {
        return m[k];
      } });
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports2 && exports2.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports2 && exports2.__importStar || function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod)
          if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
            __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    var __exportStar = exports2 && exports2.__exportStar || function(m, exports3) {
      for (var p in m)
        if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p))
          __createBinding(exports3, m, p);
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.parseString = exports2.parseFile = exports2.parseStream = exports2.parse = exports2.ParserOptions = exports2.CsvParserStream = void 0;
    var fs = __importStar(require("fs"));
    var stream_1 = require("stream");
    var ParserOptions_1 = require_ParserOptions();
    var CsvParserStream_1 = require_CsvParserStream();
    __exportStar(require_types2(), exports2);
    var CsvParserStream_2 = require_CsvParserStream();
    Object.defineProperty(exports2, "CsvParserStream", { enumerable: true, get: function() {
      return CsvParserStream_2.CsvParserStream;
    } });
    var ParserOptions_2 = require_ParserOptions();
    Object.defineProperty(exports2, "ParserOptions", { enumerable: true, get: function() {
      return ParserOptions_2.ParserOptions;
    } });
    exports2.parse = (args) => new CsvParserStream_1.CsvParserStream(new ParserOptions_1.ParserOptions(args));
    exports2.parseStream = (stream, options) => stream.pipe(new CsvParserStream_1.CsvParserStream(new ParserOptions_1.ParserOptions(options)));
    exports2.parseFile = (location, options = {}) => fs.createReadStream(location).pipe(new CsvParserStream_1.CsvParserStream(new ParserOptions_1.ParserOptions(options)));
    exports2.parseString = (string, options) => {
      const rs = new stream_1.Readable();
      rs.push(string);
      rs.push(null);
      return rs.pipe(new CsvParserStream_1.CsvParserStream(new ParserOptions_1.ParserOptions(options)));
    };
  }
});

// ../../../node_modules/fast-csv/build/src/index.js
var require_src3 = __commonJS({
  "../../../node_modules/fast-csv/build/src/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.CsvParserStream = exports2.ParserOptions = exports2.parseFile = exports2.parseStream = exports2.parseString = exports2.parse = exports2.FormatterOptions = exports2.CsvFormatterStream = exports2.writeToPath = exports2.writeToString = exports2.writeToBuffer = exports2.writeToStream = exports2.write = exports2.format = void 0;
    var format_1 = require_src();
    Object.defineProperty(exports2, "format", { enumerable: true, get: function() {
      return format_1.format;
    } });
    Object.defineProperty(exports2, "write", { enumerable: true, get: function() {
      return format_1.write;
    } });
    Object.defineProperty(exports2, "writeToStream", { enumerable: true, get: function() {
      return format_1.writeToStream;
    } });
    Object.defineProperty(exports2, "writeToBuffer", { enumerable: true, get: function() {
      return format_1.writeToBuffer;
    } });
    Object.defineProperty(exports2, "writeToString", { enumerable: true, get: function() {
      return format_1.writeToString;
    } });
    Object.defineProperty(exports2, "writeToPath", { enumerable: true, get: function() {
      return format_1.writeToPath;
    } });
    Object.defineProperty(exports2, "CsvFormatterStream", { enumerable: true, get: function() {
      return format_1.CsvFormatterStream;
    } });
    Object.defineProperty(exports2, "FormatterOptions", { enumerable: true, get: function() {
      return format_1.FormatterOptions;
    } });
    var parse_1 = require_src2();
    Object.defineProperty(exports2, "parse", { enumerable: true, get: function() {
      return parse_1.parse;
    } });
    Object.defineProperty(exports2, "parseString", { enumerable: true, get: function() {
      return parse_1.parseString;
    } });
    Object.defineProperty(exports2, "parseStream", { enumerable: true, get: function() {
      return parse_1.parseStream;
    } });
    Object.defineProperty(exports2, "parseFile", { enumerable: true, get: function() {
      return parse_1.parseFile;
    } });
    Object.defineProperty(exports2, "ParserOptions", { enumerable: true, get: function() {
      return parse_1.ParserOptions;
    } });
    Object.defineProperty(exports2, "CsvParserStream", { enumerable: true, get: function() {
      return parse_1.CsvParserStream;
    } });
  }
});

// ../../../node_modules/dayjs/plugin/customParseFormat.js
var require_customParseFormat = __commonJS({
  "../../../node_modules/dayjs/plugin/customParseFormat.js"(exports2, module2) {
    !function(e, t) {
      "object" == typeof exports2 && "undefined" != typeof module2 ? module2.exports = t() : "function" == typeof define && define.amd ? define(t) : (e = "undefined" != typeof globalThis ? globalThis : e || self).dayjs_plugin_customParseFormat = t();
    }(exports2, function() {
      "use strict";
      var e = { LTS: "h:mm:ss A", LT: "h:mm A", L: "MM/DD/YYYY", LL: "MMMM D, YYYY", LLL: "MMMM D, YYYY h:mm A", LLLL: "dddd, MMMM D, YYYY h:mm A" }, t = /(\[[^[]*\])|([-_:/.,()\s]+)|(A|a|Q|YYYY|YY?|ww?|MM?M?M?|Do|DD?|hh?|HH?|mm?|ss?|S{1,3}|z|ZZ?)/g, n = /\d/, r = /\d\d/, i = /\d\d?/, o = /\d*[^-_:/,()\s\d]+/, s = {}, a = function(e2) {
        return (e2 = +e2) + (e2 > 68 ? 1900 : 2e3);
      };
      var f = function(e2) {
        return function(t2) {
          this[e2] = +t2;
        };
      }, h = [/[+-]\d\d:?(\d\d)?|Z/, function(e2) {
        (this.zone || (this.zone = {})).offset = function(e3) {
          if (!e3)
            return 0;
          if ("Z" === e3)
            return 0;
          var t2 = e3.match(/([+-]|\d\d)/g), n2 = 60 * t2[1] + (+t2[2] || 0);
          return 0 === n2 ? 0 : "+" === t2[0] ? -n2 : n2;
        }(e2);
      }], u = function(e2) {
        var t2 = s[e2];
        return t2 && (t2.indexOf ? t2 : t2.s.concat(t2.f));
      }, d = function(e2, t2) {
        var n2, r2 = s.meridiem;
        if (r2) {
          for (var i2 = 1; i2 <= 24; i2 += 1)
            if (e2.indexOf(r2(i2, 0, t2)) > -1) {
              n2 = i2 > 12;
              break;
            }
        } else
          n2 = e2 === (t2 ? "pm" : "PM");
        return n2;
      }, c = { A: [o, function(e2) {
        this.afternoon = d(e2, false);
      }], a: [o, function(e2) {
        this.afternoon = d(e2, true);
      }], Q: [n, function(e2) {
        this.month = 3 * (e2 - 1) + 1;
      }], S: [n, function(e2) {
        this.milliseconds = 100 * +e2;
      }], SS: [r, function(e2) {
        this.milliseconds = 10 * +e2;
      }], SSS: [/\d{3}/, function(e2) {
        this.milliseconds = +e2;
      }], s: [i, f("seconds")], ss: [i, f("seconds")], m: [i, f("minutes")], mm: [i, f("minutes")], H: [i, f("hours")], h: [i, f("hours")], HH: [i, f("hours")], hh: [i, f("hours")], D: [i, f("day")], DD: [r, f("day")], Do: [o, function(e2) {
        var t2 = s.ordinal, n2 = e2.match(/\d+/);
        if (this.day = n2[0], t2)
          for (var r2 = 1; r2 <= 31; r2 += 1)
            t2(r2).replace(/\[|\]/g, "") === e2 && (this.day = r2);
      }], w: [i, f("week")], ww: [r, f("week")], M: [i, f("month")], MM: [r, f("month")], MMM: [o, function(e2) {
        var t2 = u("months"), n2 = (u("monthsShort") || t2.map(function(e3) {
          return e3.slice(0, 3);
        })).indexOf(e2) + 1;
        if (n2 < 1)
          throw new Error();
        this.month = n2 % 12 || n2;
      }], MMMM: [o, function(e2) {
        var t2 = u("months").indexOf(e2) + 1;
        if (t2 < 1)
          throw new Error();
        this.month = t2 % 12 || t2;
      }], Y: [/[+-]?\d+/, f("year")], YY: [r, function(e2) {
        this.year = a(e2);
      }], YYYY: [/\d{4}/, f("year")], Z: h, ZZ: h };
      function l2(n2) {
        var r2, i2;
        r2 = n2, i2 = s && s.formats;
        for (var o2 = (n2 = r2.replace(/(\[[^\]]+])|(LTS?|l{1,4}|L{1,4})/g, function(t2, n3, r3) {
          var o3 = r3 && r3.toUpperCase();
          return n3 || i2[r3] || e[r3] || i2[o3].replace(/(\[[^\]]+])|(MMMM|MM|DD|dddd)/g, function(e2, t3, n4) {
            return t3 || n4.slice(1);
          });
        })).match(t), a2 = o2.length, f2 = 0; f2 < a2; f2 += 1) {
          var h2 = o2[f2], u2 = c[h2], d2 = u2 && u2[0], l3 = u2 && u2[1];
          o2[f2] = l3 ? { regex: d2, parser: l3 } : h2.replace(/^\[|\]$/g, "");
        }
        return function(e2) {
          for (var t2 = {}, n3 = 0, r3 = 0; n3 < a2; n3 += 1) {
            var i3 = o2[n3];
            if ("string" == typeof i3)
              r3 += i3.length;
            else {
              var s2 = i3.regex, f3 = i3.parser, h3 = e2.slice(r3), u3 = s2.exec(h3)[0];
              f3.call(t2, u3), e2 = e2.replace(u3, "");
            }
          }
          return function(e3) {
            var t3 = e3.afternoon;
            if (void 0 !== t3) {
              var n4 = e3.hours;
              t3 ? n4 < 12 && (e3.hours += 12) : 12 === n4 && (e3.hours = 0), delete e3.afternoon;
            }
          }(t2), t2;
        };
      }
      return function(e2, t2, n2) {
        n2.p.customParseFormat = true, e2 && e2.parseTwoDigitYear && (a = e2.parseTwoDigitYear);
        var r2 = t2.prototype, i2 = r2.parse;
        r2.parse = function(e3) {
          var t3 = e3.date, r3 = e3.utc, o2 = e3.args;
          this.$u = r3;
          var a2 = o2[1];
          if ("string" == typeof a2) {
            var f2 = true === o2[2], h2 = true === o2[3], u2 = f2 || h2, d2 = o2[2];
            h2 && (d2 = o2[2]), s = this.$locale(), !f2 && d2 && (s = n2.Ls[d2]), this.$d = function(e4, t4, n3, r4) {
              try {
                if (["x", "X"].indexOf(t4) > -1)
                  return new Date(("X" === t4 ? 1e3 : 1) * e4);
                var i3 = l2(t4)(e4), o3 = i3.year, s2 = i3.month, a3 = i3.day, f3 = i3.hours, h3 = i3.minutes, u3 = i3.seconds, d3 = i3.milliseconds, c3 = i3.zone, m2 = i3.week, M2 = /* @__PURE__ */ new Date(), Y = a3 || (o3 || s2 ? 1 : M2.getDate()), p = o3 || M2.getFullYear(), v = 0;
                o3 && !s2 || (v = s2 > 0 ? s2 - 1 : M2.getMonth());
                var D, w = f3 || 0, g = h3 || 0, y = u3 || 0, L = d3 || 0;
                return c3 ? new Date(Date.UTC(p, v, Y, w, g, y, L + 60 * c3.offset * 1e3)) : n3 ? new Date(Date.UTC(p, v, Y, w, g, y, L)) : (D = new Date(p, v, Y, w, g, y, L), m2 && (D = r4(D).week(m2).toDate()), D);
              } catch (e5) {
                return /* @__PURE__ */ new Date("");
              }
            }(t3, a2, r3, n2), this.init(), d2 && true !== d2 && (this.$L = this.locale(d2).$L), u2 && t3 != this.format(a2) && (this.$d = /* @__PURE__ */ new Date("")), s = {};
          } else if (a2 instanceof Array)
            for (var c2 = a2.length, m = 1; m <= c2; m += 1) {
              o2[1] = a2[m - 1];
              var M = n2.apply(this, o2);
              if (M.isValid()) {
                this.$d = M.$d, this.$L = M.$L, this.init();
                break;
              }
              m === c2 && (this.$d = /* @__PURE__ */ new Date(""));
            }
          else
            i2.call(this, e3);
        };
      };
    });
  }
});

// ../../../node_modules/dayjs/plugin/utc.js
var require_utc = __commonJS({
  "../../../node_modules/dayjs/plugin/utc.js"(exports2, module2) {
    !function(t, i) {
      "object" == typeof exports2 && "undefined" != typeof module2 ? module2.exports = i() : "function" == typeof define && define.amd ? define(i) : (t = "undefined" != typeof globalThis ? globalThis : t || self).dayjs_plugin_utc = i();
    }(exports2, function() {
      "use strict";
      var t = "minute", i = /[+-]\d\d(?::?\d\d)?/g, e = /([+-]|\d\d)/g;
      return function(s, f, n) {
        var u = f.prototype;
        n.utc = function(t2) {
          var i2 = { date: t2, utc: true, args: arguments };
          return new f(i2);
        }, u.utc = function(i2) {
          var e2 = n(this.toDate(), { locale: this.$L, utc: true });
          return i2 ? e2.add(this.utcOffset(), t) : e2;
        }, u.local = function() {
          return n(this.toDate(), { locale: this.$L, utc: false });
        };
        var o = u.parse;
        u.parse = function(t2) {
          t2.utc && (this.$u = true), this.$utils().u(t2.$offset) || (this.$offset = t2.$offset), o.call(this, t2);
        };
        var r = u.init;
        u.init = function() {
          if (this.$u) {
            var t2 = this.$d;
            this.$y = t2.getUTCFullYear(), this.$M = t2.getUTCMonth(), this.$D = t2.getUTCDate(), this.$W = t2.getUTCDay(), this.$H = t2.getUTCHours(), this.$m = t2.getUTCMinutes(), this.$s = t2.getUTCSeconds(), this.$ms = t2.getUTCMilliseconds();
          } else
            r.call(this);
        };
        var a = u.utcOffset;
        u.utcOffset = function(s2, f2) {
          var n2 = this.$utils().u;
          if (n2(s2))
            return this.$u ? 0 : n2(this.$offset) ? a.call(this) : this.$offset;
          if ("string" == typeof s2 && (s2 = function(t2) {
            void 0 === t2 && (t2 = "");
            var s3 = t2.match(i);
            if (!s3)
              return null;
            var f3 = ("" + s3[0]).match(e) || ["-", 0, 0], n3 = f3[0], u3 = 60 * +f3[1] + +f3[2];
            return 0 === u3 ? 0 : "+" === n3 ? u3 : -u3;
          }(s2), null === s2))
            return this;
          var u2 = Math.abs(s2) <= 16 ? 60 * s2 : s2, o2 = this;
          if (f2)
            return o2.$offset = u2, o2.$u = 0 === s2, o2;
          if (0 !== s2) {
            var r2 = this.$u ? this.toDate().getTimezoneOffset() : -1 * this.utcOffset();
            (o2 = this.local().add(u2 + r2, t)).$offset = u2, o2.$x.$localOffset = r2;
          } else
            o2 = this.utc();
          return o2;
        };
        var h = u.format;
        u.format = function(t2) {
          var i2 = t2 || (this.$u ? "YYYY-MM-DDTHH:mm:ss[Z]" : "");
          return h.call(this, i2);
        }, u.valueOf = function() {
          var t2 = this.$utils().u(this.$offset) ? 0 : this.$offset + (this.$x.$localOffset || this.$d.getTimezoneOffset());
          return this.$d.valueOf() - 6e4 * t2;
        }, u.isUTC = function() {
          return !!this.$u;
        }, u.toISOString = function() {
          return this.toDate().toISOString();
        }, u.toString = function() {
          return this.toDate().toUTCString();
        };
        var l2 = u.toDate;
        u.toDate = function(t2) {
          return "s" === t2 && this.$offset ? n(this.format("YYYY-MM-DD HH:mm:ss:SSS")).toDate() : l2.call(this);
        };
        var c = u.diff;
        u.diff = function(t2, i2, e2) {
          if (t2 && this.$u === t2.$u)
            return c.call(this, t2, i2, e2);
          var s2 = this.local(), f2 = n(t2).local();
          return c.call(s2, f2, i2, e2);
        };
      };
    });
  }
});

// ../../../node_modules/dayjs/dayjs.min.js
var require_dayjs_min = __commonJS({
  "../../../node_modules/dayjs/dayjs.min.js"(exports2, module2) {
    !function(t, e) {
      "object" == typeof exports2 && "undefined" != typeof module2 ? module2.exports = e() : "function" == typeof define && define.amd ? define(e) : (t = "undefined" != typeof globalThis ? globalThis : t || self).dayjs = e();
    }(exports2, function() {
      "use strict";
      var t = 1e3, e = 6e4, n = 36e5, r = "millisecond", i = "second", s = "minute", u = "hour", a = "day", o = "week", c = "month", f = "quarter", h = "year", d = "date", l2 = "Invalid Date", $2 = /^(\d{4})[-/]?(\d{1,2})?[-/]?(\d{0,2})[Tt\s]*(\d{1,2})?:?(\d{1,2})?:?(\d{1,2})?[.:]?(\d+)?$/, y = /\[([^\]]+)]|Y{1,4}|M{1,4}|D{1,2}|d{1,4}|H{1,2}|h{1,2}|a|A|m{1,2}|s{1,2}|Z{1,2}|SSS/g, M = { name: "en", weekdays: "Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday".split("_"), months: "January_February_March_April_May_June_July_August_September_October_November_December".split("_"), ordinal: function(t2) {
        var e2 = ["th", "st", "nd", "rd"], n2 = t2 % 100;
        return "[" + t2 + (e2[(n2 - 20) % 10] || e2[n2] || e2[0]) + "]";
      } }, m = function(t2, e2, n2) {
        var r2 = String(t2);
        return !r2 || r2.length >= e2 ? t2 : "" + Array(e2 + 1 - r2.length).join(n2) + t2;
      }, v = { s: m, z: function(t2) {
        var e2 = -t2.utcOffset(), n2 = Math.abs(e2), r2 = Math.floor(n2 / 60), i2 = n2 % 60;
        return (e2 <= 0 ? "+" : "-") + m(r2, 2, "0") + ":" + m(i2, 2, "0");
      }, m: function t2(e2, n2) {
        if (e2.date() < n2.date())
          return -t2(n2, e2);
        var r2 = 12 * (n2.year() - e2.year()) + (n2.month() - e2.month()), i2 = e2.clone().add(r2, c), s2 = n2 - i2 < 0, u2 = e2.clone().add(r2 + (s2 ? -1 : 1), c);
        return +(-(r2 + (n2 - i2) / (s2 ? i2 - u2 : u2 - i2)) || 0);
      }, a: function(t2) {
        return t2 < 0 ? Math.ceil(t2) || 0 : Math.floor(t2);
      }, p: function(t2) {
        return { M: c, y: h, w: o, d: a, D: d, h: u, m: s, s: i, ms: r, Q: f }[t2] || String(t2 || "").toLowerCase().replace(/s$/, "");
      }, u: function(t2) {
        return void 0 === t2;
      } }, g = "en", D = {};
      D[g] = M;
      var p = "$isDayjsObject", S = function(t2) {
        return t2 instanceof _2 || !(!t2 || !t2[p]);
      }, w = function t2(e2, n2, r2) {
        var i2;
        if (!e2)
          return g;
        if ("string" == typeof e2) {
          var s2 = e2.toLowerCase();
          D[s2] && (i2 = s2), n2 && (D[s2] = n2, i2 = s2);
          var u2 = e2.split("-");
          if (!i2 && u2.length > 1)
            return t2(u2[0]);
        } else {
          var a2 = e2.name;
          D[a2] = e2, i2 = a2;
        }
        return !r2 && i2 && (g = i2), i2 || !r2 && g;
      }, O = function(t2, e2) {
        if (S(t2))
          return t2.clone();
        var n2 = "object" == typeof e2 ? e2 : {};
        return n2.date = t2, n2.args = arguments, new _2(n2);
      }, b = v;
      b.l = w, b.i = S, b.w = function(t2, e2) {
        return O(t2, { locale: e2.$L, utc: e2.$u, x: e2.$x, $offset: e2.$offset });
      };
      var _2 = function() {
        function M2(t2) {
          this.$L = w(t2.locale, null, true), this.parse(t2), this.$x = this.$x || t2.x || {}, this[p] = true;
        }
        var m2 = M2.prototype;
        return m2.parse = function(t2) {
          this.$d = function(t3) {
            var e2 = t3.date, n2 = t3.utc;
            if (null === e2)
              return /* @__PURE__ */ new Date(NaN);
            if (b.u(e2))
              return /* @__PURE__ */ new Date();
            if (e2 instanceof Date)
              return new Date(e2);
            if ("string" == typeof e2 && !/Z$/i.test(e2)) {
              var r2 = e2.match($2);
              if (r2) {
                var i2 = r2[2] - 1 || 0, s2 = (r2[7] || "0").substring(0, 3);
                return n2 ? new Date(Date.UTC(r2[1], i2, r2[3] || 1, r2[4] || 0, r2[5] || 0, r2[6] || 0, s2)) : new Date(r2[1], i2, r2[3] || 1, r2[4] || 0, r2[5] || 0, r2[6] || 0, s2);
              }
            }
            return new Date(e2);
          }(t2), this.init();
        }, m2.init = function() {
          var t2 = this.$d;
          this.$y = t2.getFullYear(), this.$M = t2.getMonth(), this.$D = t2.getDate(), this.$W = t2.getDay(), this.$H = t2.getHours(), this.$m = t2.getMinutes(), this.$s = t2.getSeconds(), this.$ms = t2.getMilliseconds();
        }, m2.$utils = function() {
          return b;
        }, m2.isValid = function() {
          return !(this.$d.toString() === l2);
        }, m2.isSame = function(t2, e2) {
          var n2 = O(t2);
          return this.startOf(e2) <= n2 && n2 <= this.endOf(e2);
        }, m2.isAfter = function(t2, e2) {
          return O(t2) < this.startOf(e2);
        }, m2.isBefore = function(t2, e2) {
          return this.endOf(e2) < O(t2);
        }, m2.$g = function(t2, e2, n2) {
          return b.u(t2) ? this[e2] : this.set(n2, t2);
        }, m2.unix = function() {
          return Math.floor(this.valueOf() / 1e3);
        }, m2.valueOf = function() {
          return this.$d.getTime();
        }, m2.startOf = function(t2, e2) {
          var n2 = this, r2 = !!b.u(e2) || e2, f2 = b.p(t2), l3 = function(t3, e3) {
            var i2 = b.w(n2.$u ? Date.UTC(n2.$y, e3, t3) : new Date(n2.$y, e3, t3), n2);
            return r2 ? i2 : i2.endOf(a);
          }, $3 = function(t3, e3) {
            return b.w(n2.toDate()[t3].apply(n2.toDate("s"), (r2 ? [0, 0, 0, 0] : [23, 59, 59, 999]).slice(e3)), n2);
          }, y2 = this.$W, M3 = this.$M, m3 = this.$D, v2 = "set" + (this.$u ? "UTC" : "");
          switch (f2) {
            case h:
              return r2 ? l3(1, 0) : l3(31, 11);
            case c:
              return r2 ? l3(1, M3) : l3(0, M3 + 1);
            case o:
              var g2 = this.$locale().weekStart || 0, D2 = (y2 < g2 ? y2 + 7 : y2) - g2;
              return l3(r2 ? m3 - D2 : m3 + (6 - D2), M3);
            case a:
            case d:
              return $3(v2 + "Hours", 0);
            case u:
              return $3(v2 + "Minutes", 1);
            case s:
              return $3(v2 + "Seconds", 2);
            case i:
              return $3(v2 + "Milliseconds", 3);
            default:
              return this.clone();
          }
        }, m2.endOf = function(t2) {
          return this.startOf(t2, false);
        }, m2.$set = function(t2, e2) {
          var n2, o2 = b.p(t2), f2 = "set" + (this.$u ? "UTC" : ""), l3 = (n2 = {}, n2[a] = f2 + "Date", n2[d] = f2 + "Date", n2[c] = f2 + "Month", n2[h] = f2 + "FullYear", n2[u] = f2 + "Hours", n2[s] = f2 + "Minutes", n2[i] = f2 + "Seconds", n2[r] = f2 + "Milliseconds", n2)[o2], $3 = o2 === a ? this.$D + (e2 - this.$W) : e2;
          if (o2 === c || o2 === h) {
            var y2 = this.clone().set(d, 1);
            y2.$d[l3]($3), y2.init(), this.$d = y2.set(d, Math.min(this.$D, y2.daysInMonth())).$d;
          } else
            l3 && this.$d[l3]($3);
          return this.init(), this;
        }, m2.set = function(t2, e2) {
          return this.clone().$set(t2, e2);
        }, m2.get = function(t2) {
          return this[b.p(t2)]();
        }, m2.add = function(r2, f2) {
          var d2, l3 = this;
          r2 = Number(r2);
          var $3 = b.p(f2), y2 = function(t2) {
            var e2 = O(l3);
            return b.w(e2.date(e2.date() + Math.round(t2 * r2)), l3);
          };
          if ($3 === c)
            return this.set(c, this.$M + r2);
          if ($3 === h)
            return this.set(h, this.$y + r2);
          if ($3 === a)
            return y2(1);
          if ($3 === o)
            return y2(7);
          var M3 = (d2 = {}, d2[s] = e, d2[u] = n, d2[i] = t, d2)[$3] || 1, m3 = this.$d.getTime() + r2 * M3;
          return b.w(m3, this);
        }, m2.subtract = function(t2, e2) {
          return this.add(-1 * t2, e2);
        }, m2.format = function(t2) {
          var e2 = this, n2 = this.$locale();
          if (!this.isValid())
            return n2.invalidDate || l2;
          var r2 = t2 || "YYYY-MM-DDTHH:mm:ssZ", i2 = b.z(this), s2 = this.$H, u2 = this.$m, a2 = this.$M, o2 = n2.weekdays, c2 = n2.months, f2 = n2.meridiem, h2 = function(t3, n3, i3, s3) {
            return t3 && (t3[n3] || t3(e2, r2)) || i3[n3].slice(0, s3);
          }, d2 = function(t3) {
            return b.s(s2 % 12 || 12, t3, "0");
          }, $3 = f2 || function(t3, e3, n3) {
            var r3 = t3 < 12 ? "AM" : "PM";
            return n3 ? r3.toLowerCase() : r3;
          };
          return r2.replace(y, function(t3, r3) {
            return r3 || function(t4) {
              switch (t4) {
                case "YY":
                  return String(e2.$y).slice(-2);
                case "YYYY":
                  return b.s(e2.$y, 4, "0");
                case "M":
                  return a2 + 1;
                case "MM":
                  return b.s(a2 + 1, 2, "0");
                case "MMM":
                  return h2(n2.monthsShort, a2, c2, 3);
                case "MMMM":
                  return h2(c2, a2);
                case "D":
                  return e2.$D;
                case "DD":
                  return b.s(e2.$D, 2, "0");
                case "d":
                  return String(e2.$W);
                case "dd":
                  return h2(n2.weekdaysMin, e2.$W, o2, 2);
                case "ddd":
                  return h2(n2.weekdaysShort, e2.$W, o2, 3);
                case "dddd":
                  return o2[e2.$W];
                case "H":
                  return String(s2);
                case "HH":
                  return b.s(s2, 2, "0");
                case "h":
                  return d2(1);
                case "hh":
                  return d2(2);
                case "a":
                  return $3(s2, u2, true);
                case "A":
                  return $3(s2, u2, false);
                case "m":
                  return String(u2);
                case "mm":
                  return b.s(u2, 2, "0");
                case "s":
                  return String(e2.$s);
                case "ss":
                  return b.s(e2.$s, 2, "0");
                case "SSS":
                  return b.s(e2.$ms, 3, "0");
                case "Z":
                  return i2;
              }
              return null;
            }(t3) || i2.replace(":", "");
          });
        }, m2.utcOffset = function() {
          return 15 * -Math.round(this.$d.getTimezoneOffset() / 15);
        }, m2.diff = function(r2, d2, l3) {
          var $3, y2 = this, M3 = b.p(d2), m3 = O(r2), v2 = (m3.utcOffset() - this.utcOffset()) * e, g2 = this - m3, D2 = function() {
            return b.m(y2, m3);
          };
          switch (M3) {
            case h:
              $3 = D2() / 12;
              break;
            case c:
              $3 = D2();
              break;
            case f:
              $3 = D2() / 3;
              break;
            case o:
              $3 = (g2 - v2) / 6048e5;
              break;
            case a:
              $3 = (g2 - v2) / 864e5;
              break;
            case u:
              $3 = g2 / n;
              break;
            case s:
              $3 = g2 / e;
              break;
            case i:
              $3 = g2 / t;
              break;
            default:
              $3 = g2;
          }
          return l3 ? $3 : b.a($3);
        }, m2.daysInMonth = function() {
          return this.endOf(c).$D;
        }, m2.$locale = function() {
          return D[this.$L];
        }, m2.locale = function(t2, e2) {
          if (!t2)
            return this.$L;
          var n2 = this.clone(), r2 = w(t2, e2, true);
          return r2 && (n2.$L = r2), n2;
        }, m2.clone = function() {
          return b.w(this.$d, this);
        }, m2.toDate = function() {
          return new Date(this.valueOf());
        }, m2.toJSON = function() {
          return this.isValid() ? this.toISOString() : null;
        }, m2.toISOString = function() {
          return this.$d.toISOString();
        }, m2.toString = function() {
          return this.$d.toUTCString();
        }, M2;
      }(), k = _2.prototype;
      return O.prototype = k, [["$ms", r], ["$s", i], ["$m", s], ["$H", u], ["$W", a], ["$M", c], ["$y", h], ["$D", d]].forEach(function(t2) {
        k[t2[1]] = function(e2) {
          return this.$g(e2, t2[0], t2[1]);
        };
      }), O.extend = function(t2, e2) {
        return t2.$i || (t2(e2, _2, O), t2.$i = true), O;
      }, O.locale = w, O.isDayjs = S, O.unix = function(t2) {
        return O(1e3 * t2);
      }, O.en = D[g], O.Ls = D, O.p = {}, O;
    });
  }
});

// ../../../node_modules/exceljs/lib/csv/csv.js
var require_csv = __commonJS({
  "../../../node_modules/exceljs/lib/csv/csv.js"(exports2, module2) {
    var fs = require("fs");
    var fastCsv = require_src3();
    var customParseFormat = require_customParseFormat();
    var utc = require_utc();
    var dayjs = require_dayjs_min().extend(customParseFormat).extend(utc);
    var StreamBuf = require_stream_buf();
    var {
      fs: { exists }
    } = require_utils2();
    var SpecialValues = {
      true: true,
      false: false,
      "#N/A": { error: "#N/A" },
      "#REF!": { error: "#REF!" },
      "#NAME?": { error: "#NAME?" },
      "#DIV/0!": { error: "#DIV/0!" },
      "#NULL!": { error: "#NULL!" },
      "#VALUE!": { error: "#VALUE!" },
      "#NUM!": { error: "#NUM!" }
    };
    var CSV = class {
      constructor(workbook) {
        this.workbook = workbook;
        this.worksheet = null;
      }
      async readFile(filename, options) {
        options = options || {};
        if (!await exists(filename)) {
          throw new Error(`File not found: ${filename}`);
        }
        const stream = fs.createReadStream(filename);
        const worksheet = await this.read(stream, options);
        stream.close();
        return worksheet;
      }
      read(stream, options) {
        options = options || {};
        return new Promise((resolve, reject) => {
          const worksheet = this.workbook.addWorksheet(options.sheetName);
          const dateFormats = options.dateFormats || [
            "YYYY-MM-DD[T]HH:mm:ssZ",
            "YYYY-MM-DD[T]HH:mm:ss",
            "MM-DD-YYYY",
            "YYYY-MM-DD"
          ];
          const map = options.map || function(datum) {
            if (datum === "") {
              return null;
            }
            const datumNumber = Number(datum);
            if (!Number.isNaN(datumNumber) && datumNumber !== Infinity) {
              return datumNumber;
            }
            const dt = dateFormats.reduce((matchingDate, currentDateFormat) => {
              if (matchingDate) {
                return matchingDate;
              }
              const dayjsObj = dayjs(datum, currentDateFormat, true);
              if (dayjsObj.isValid()) {
                return dayjsObj;
              }
              return null;
            }, null);
            if (dt) {
              return new Date(dt.valueOf());
            }
            const special = SpecialValues[datum];
            if (special !== void 0) {
              return special;
            }
            return datum;
          };
          const csvStream = fastCsv.parse(options.parserOptions).on("data", (data) => {
            worksheet.addRow(data.map(map));
          }).on("end", () => {
            csvStream.emit("worksheet", worksheet);
          });
          csvStream.on("worksheet", resolve).on("error", reject);
          stream.pipe(csvStream);
        });
      }
      /**
       * @deprecated since version 4.0. You should use `CSV#read` instead. Please follow upgrade instruction: https://github.com/exceljs/exceljs/blob/master/UPGRADE-4.0.md
       */
      createInputStream() {
        throw new Error(
          "`CSV#createInputStream` is deprecated. You should use `CSV#read` instead. This method will be removed in version 5.0. Please follow upgrade instruction: https://github.com/exceljs/exceljs/blob/master/UPGRADE-4.0.md"
        );
      }
      write(stream, options) {
        return new Promise((resolve, reject) => {
          options = options || {};
          const worksheet = this.workbook.getWorksheet(options.sheetName || options.sheetId);
          const csvStream = fastCsv.format(options.formatterOptions);
          stream.on("finish", () => {
            resolve();
          });
          csvStream.on("error", reject);
          csvStream.pipe(stream);
          const { dateFormat, dateUTC } = options;
          const map = options.map || ((value) => {
            if (value) {
              if (value.text || value.hyperlink) {
                return value.hyperlink || value.text || "";
              }
              if (value.formula || value.result) {
                return value.result || "";
              }
              if (value instanceof Date) {
                if (dateFormat) {
                  return dateUTC ? dayjs.utc(value).format(dateFormat) : dayjs(value).format(dateFormat);
                }
                return dateUTC ? dayjs.utc(value).format() : dayjs(value).format();
              }
              if (value.error) {
                return value.error;
              }
              if (typeof value === "object") {
                return JSON.stringify(value);
              }
            }
            return value;
          });
          const includeEmptyRows = options.includeEmptyRows === void 0 || options.includeEmptyRows;
          let lastRow = 1;
          if (worksheet) {
            worksheet.eachRow((row, rowNumber) => {
              if (includeEmptyRows) {
                while (lastRow++ < rowNumber - 1) {
                  csvStream.write([]);
                }
              }
              const { values } = row;
              values.shift();
              csvStream.write(values.map(map));
              lastRow = rowNumber;
            });
          }
          csvStream.end();
        });
      }
      writeFile(filename, options) {
        options = options || {};
        const streamOptions = {
          encoding: options.encoding || "utf8"
        };
        const stream = fs.createWriteStream(filename, streamOptions);
        return this.write(stream, options);
      }
      async writeBuffer(options) {
        const stream = new StreamBuf();
        await this.write(stream, options);
        return stream.read();
      }
    };
    module2.exports = CSV;
  }
});

// ../../../node_modules/exceljs/lib/doc/workbook.js
var require_workbook = __commonJS({
  "../../../node_modules/exceljs/lib/doc/workbook.js"(exports2, module2) {
    "use strict";
    var Worksheet = require_worksheet();
    var DefinedNames = require_defined_names();
    var XLSX = require_xlsx();
    var CSV = require_csv();
    var Workbook = class {
      constructor() {
        this.category = "";
        this.company = "";
        this.created = /* @__PURE__ */ new Date();
        this.description = "";
        this.keywords = "";
        this.manager = "";
        this.modified = this.created;
        this.properties = {};
        this.calcProperties = {};
        this._worksheets = [];
        this.subject = "";
        this.title = "";
        this.views = [];
        this.media = [];
        this._definedNames = new DefinedNames();
      }
      get xlsx() {
        if (!this._xlsx)
          this._xlsx = new XLSX(this);
        return this._xlsx;
      }
      get csv() {
        if (!this._csv)
          this._csv = new CSV(this);
        return this._csv;
      }
      get nextId() {
        for (let i = 1; i < this._worksheets.length; i++) {
          if (!this._worksheets[i]) {
            return i;
          }
        }
        return this._worksheets.length || 1;
      }
      addWorksheet(name, options) {
        const id = this.nextId;
        if (options) {
          if (typeof options === "string") {
            console.trace(
              'tabColor argument is now deprecated. Please use workbook.addWorksheet(name, {properties: { tabColor: { argb: "rbg value" } }'
            );
            options = {
              properties: {
                tabColor: { argb: options }
              }
            };
          } else if (options.argb || options.theme || options.indexed) {
            console.trace(
              "tabColor argument is now deprecated. Please use workbook.addWorksheet(name, {properties: { tabColor: { ... } }"
            );
            options = {
              properties: {
                tabColor: options
              }
            };
          }
        }
        const lastOrderNo = this._worksheets.reduce((acc, ws) => (ws && ws.orderNo) > acc ? ws.orderNo : acc, 0);
        const worksheetOptions = Object.assign({}, options, {
          id,
          name,
          orderNo: lastOrderNo + 1,
          workbook: this
        });
        const worksheet = new Worksheet(worksheetOptions);
        this._worksheets[id] = worksheet;
        return worksheet;
      }
      removeWorksheetEx(worksheet) {
        delete this._worksheets[worksheet.id];
      }
      removeWorksheet(id) {
        const worksheet = this.getWorksheet(id);
        if (worksheet) {
          worksheet.destroy();
        }
      }
      getWorksheet(id) {
        if (id === void 0) {
          return this._worksheets.find(Boolean);
        }
        if (typeof id === "number") {
          return this._worksheets[id];
        }
        if (typeof id === "string") {
          return this._worksheets.find((worksheet) => worksheet && worksheet.name === id);
        }
        return void 0;
      }
      get worksheets() {
        return this._worksheets.slice(1).sort((a, b) => a.orderNo - b.orderNo).filter(Boolean);
      }
      eachSheet(iteratee) {
        this.worksheets.forEach((sheet) => {
          iteratee(sheet, sheet.id);
        });
      }
      get definedNames() {
        return this._definedNames;
      }
      clearThemes() {
        this._themes = void 0;
      }
      addImage(image) {
        const id = this.media.length;
        this.media.push(Object.assign({}, image, { type: "image" }));
        return id;
      }
      getImage(id) {
        return this.media[id];
      }
      get model() {
        return {
          creator: this.creator || "Unknown",
          lastModifiedBy: this.lastModifiedBy || "Unknown",
          lastPrinted: this.lastPrinted,
          created: this.created,
          modified: this.modified,
          properties: this.properties,
          worksheets: this.worksheets.map((worksheet) => worksheet.model),
          sheets: this.worksheets.map((ws) => ws.model).filter(Boolean),
          definedNames: this._definedNames.model,
          views: this.views,
          company: this.company,
          manager: this.manager,
          title: this.title,
          subject: this.subject,
          keywords: this.keywords,
          category: this.category,
          description: this.description,
          language: this.language,
          revision: this.revision,
          contentStatus: this.contentStatus,
          themes: this._themes,
          media: this.media,
          calcProperties: this.calcProperties
        };
      }
      set model(value) {
        this.creator = value.creator;
        this.lastModifiedBy = value.lastModifiedBy;
        this.lastPrinted = value.lastPrinted;
        this.created = value.created;
        this.modified = value.modified;
        this.company = value.company;
        this.manager = value.manager;
        this.title = value.title;
        this.subject = value.subject;
        this.keywords = value.keywords;
        this.category = value.category;
        this.description = value.description;
        this.language = value.language;
        this.revision = value.revision;
        this.contentStatus = value.contentStatus;
        this.properties = value.properties;
        this.calcProperties = value.calcProperties;
        this._worksheets = [];
        value.worksheets.forEach((worksheetModel) => {
          const { id, name, state } = worksheetModel;
          const orderNo = value.sheets && value.sheets.findIndex((ws) => ws.id === id);
          const worksheet = this._worksheets[id] = new Worksheet({
            id,
            name,
            orderNo,
            state,
            workbook: this
          });
          worksheet.model = worksheetModel;
        });
        this._definedNames.model = value.definedNames;
        this.views = value.views;
        this._themes = value.themes;
        this.media = value.media || [];
      }
    };
    module2.exports = Workbook;
  }
});

// ../../../node_modules/exceljs/lib/doc/modelcontainer.js
var require_modelcontainer = __commonJS({
  "../../../node_modules/exceljs/lib/doc/modelcontainer.js"(exports2, module2) {
    "use strict";
    var XLSX = require_xlsx();
    var ModelContainer = class {
      constructor(model) {
        this.model = model;
      }
      get xlsx() {
        if (!this._xlsx) {
          this._xlsx = new XLSX(this);
        }
        return this._xlsx;
      }
    };
    module2.exports = ModelContainer;
  }
});

// ../../../node_modules/readdir-glob/node_modules/minimatch/lib/path.js
var require_path = __commonJS({
  "../../../node_modules/readdir-glob/node_modules/minimatch/lib/path.js"(exports2, module2) {
    var isWindows = typeof process === "object" && process && process.platform === "win32";
    module2.exports = isWindows ? { sep: "\\" } : { sep: "/" };
  }
});

// ../../../node_modules/balanced-match/index.js
var require_balanced_match = __commonJS({
  "../../../node_modules/balanced-match/index.js"(exports2, module2) {
    "use strict";
    module2.exports = balanced;
    function balanced(a, b, str) {
      if (a instanceof RegExp)
        a = maybeMatch(a, str);
      if (b instanceof RegExp)
        b = maybeMatch(b, str);
      var r = range(a, b, str);
      return r && {
        start: r[0],
        end: r[1],
        pre: str.slice(0, r[0]),
        body: str.slice(r[0] + a.length, r[1]),
        post: str.slice(r[1] + b.length)
      };
    }
    function maybeMatch(reg, str) {
      var m = str.match(reg);
      return m ? m[0] : null;
    }
    balanced.range = range;
    function range(a, b, str) {
      var begs, beg, left, right, result;
      var ai = str.indexOf(a);
      var bi = str.indexOf(b, ai + 1);
      var i = ai;
      if (ai >= 0 && bi > 0) {
        if (a === b) {
          return [ai, bi];
        }
        begs = [];
        left = str.length;
        while (i >= 0 && !result) {
          if (i == ai) {
            begs.push(i);
            ai = str.indexOf(a, i + 1);
          } else if (begs.length == 1) {
            result = [begs.pop(), bi];
          } else {
            beg = begs.pop();
            if (beg < left) {
              left = beg;
              right = bi;
            }
            bi = str.indexOf(b, i + 1);
          }
          i = ai < bi && ai >= 0 ? ai : bi;
        }
        if (begs.length) {
          result = [left, right];
        }
      }
      return result;
    }
  }
});

// ../../../node_modules/brace-expansion/index.js
var require_brace_expansion = __commonJS({
  "../../../node_modules/brace-expansion/index.js"(exports2, module2) {
    var balanced = require_balanced_match();
    module2.exports = expandTop;
    var escSlash = "\0SLASH" + Math.random() + "\0";
    var escOpen = "\0OPEN" + Math.random() + "\0";
    var escClose = "\0CLOSE" + Math.random() + "\0";
    var escComma = "\0COMMA" + Math.random() + "\0";
    var escPeriod = "\0PERIOD" + Math.random() + "\0";
    function numeric(str) {
      return parseInt(str, 10) == str ? parseInt(str, 10) : str.charCodeAt(0);
    }
    function escapeBraces(str) {
      return str.split("\\\\").join(escSlash).split("\\{").join(escOpen).split("\\}").join(escClose).split("\\,").join(escComma).split("\\.").join(escPeriod);
    }
    function unescapeBraces(str) {
      return str.split(escSlash).join("\\").split(escOpen).join("{").split(escClose).join("}").split(escComma).join(",").split(escPeriod).join(".");
    }
    function parseCommaParts(str) {
      if (!str)
        return [""];
      var parts = [];
      var m = balanced("{", "}", str);
      if (!m)
        return str.split(",");
      var pre = m.pre;
      var body = m.body;
      var post = m.post;
      var p = pre.split(",");
      p[p.length - 1] += "{" + body + "}";
      var postParts = parseCommaParts(post);
      if (post.length) {
        p[p.length - 1] += postParts.shift();
        p.push.apply(p, postParts);
      }
      parts.push.apply(parts, p);
      return parts;
    }
    function expandTop(str) {
      if (!str)
        return [];
      if (str.substr(0, 2) === "{}") {
        str = "\\{\\}" + str.substr(2);
      }
      return expand(escapeBraces(str), true).map(unescapeBraces);
    }
    function embrace(str) {
      return "{" + str + "}";
    }
    function isPadded(el) {
      return /^-?0\d/.test(el);
    }
    function lte(i, y) {
      return i <= y;
    }
    function gte(i, y) {
      return i >= y;
    }
    function expand(str, isTop) {
      var expansions = [];
      var m = balanced("{", "}", str);
      if (!m)
        return [str];
      var pre = m.pre;
      var post = m.post.length ? expand(m.post, false) : [""];
      if (/\$$/.test(m.pre)) {
        for (var k = 0; k < post.length; k++) {
          var expansion = pre + "{" + m.body + "}" + post[k];
          expansions.push(expansion);
        }
      } else {
        var isNumericSequence = /^-?\d+\.\.-?\d+(?:\.\.-?\d+)?$/.test(m.body);
        var isAlphaSequence = /^[a-zA-Z]\.\.[a-zA-Z](?:\.\.-?\d+)?$/.test(m.body);
        var isSequence = isNumericSequence || isAlphaSequence;
        var isOptions = m.body.indexOf(",") >= 0;
        if (!isSequence && !isOptions) {
          if (m.post.match(/,.*\}/)) {
            str = m.pre + "{" + m.body + escClose + m.post;
            return expand(str);
          }
          return [str];
        }
        var n;
        if (isSequence) {
          n = m.body.split(/\.\./);
        } else {
          n = parseCommaParts(m.body);
          if (n.length === 1) {
            n = expand(n[0], false).map(embrace);
            if (n.length === 1) {
              return post.map(function(p) {
                return m.pre + n[0] + p;
              });
            }
          }
        }
        var N;
        if (isSequence) {
          var x = numeric(n[0]);
          var y = numeric(n[1]);
          var width = Math.max(n[0].length, n[1].length);
          var incr = n.length == 3 ? Math.abs(numeric(n[2])) : 1;
          var test = lte;
          var reverse = y < x;
          if (reverse) {
            incr *= -1;
            test = gte;
          }
          var pad = n.some(isPadded);
          N = [];
          for (var i = x; test(i, y); i += incr) {
            var c;
            if (isAlphaSequence) {
              c = String.fromCharCode(i);
              if (c === "\\")
                c = "";
            } else {
              c = String(i);
              if (pad) {
                var need = width - c.length;
                if (need > 0) {
                  var z = new Array(need + 1).join("0");
                  if (i < 0)
                    c = "-" + z + c.slice(1);
                  else
                    c = z + c;
                }
              }
            }
            N.push(c);
          }
        } else {
          N = [];
          for (var j = 0; j < n.length; j++) {
            N.push.apply(N, expand(n[j], false));
          }
        }
        for (var j = 0; j < N.length; j++) {
          for (var k = 0; k < post.length; k++) {
            var expansion = pre + N[j] + post[k];
            if (!isTop || isSequence || expansion)
              expansions.push(expansion);
          }
        }
      }
      return expansions;
    }
  }
});

// ../../../node_modules/readdir-glob/node_modules/minimatch/minimatch.js
var require_minimatch = __commonJS({
  "../../../node_modules/readdir-glob/node_modules/minimatch/minimatch.js"(exports2, module2) {
    var minimatch = module2.exports = (p, pattern, options = {}) => {
      assertValidPattern(pattern);
      if (!options.nocomment && pattern.charAt(0) === "#") {
        return false;
      }
      return new Minimatch(pattern, options).match(p);
    };
    module2.exports = minimatch;
    var path = require_path();
    minimatch.sep = path.sep;
    var GLOBSTAR = Symbol("globstar **");
    minimatch.GLOBSTAR = GLOBSTAR;
    var expand = require_brace_expansion();
    var plTypes = {
      "!": { open: "(?:(?!(?:", close: "))[^/]*?)" },
      "?": { open: "(?:", close: ")?" },
      "+": { open: "(?:", close: ")+" },
      "*": { open: "(?:", close: ")*" },
      "@": { open: "(?:", close: ")" }
    };
    var qmark = "[^/]";
    var star = qmark + "*?";
    var twoStarDot = "(?:(?!(?:\\/|^)(?:\\.{1,2})($|\\/)).)*?";
    var twoStarNoDot = "(?:(?!(?:\\/|^)\\.).)*?";
    var charSet = (s) => s.split("").reduce((set, c) => {
      set[c] = true;
      return set;
    }, {});
    var reSpecials = charSet("().*{}+?[]^$\\!");
    var addPatternStartSet = charSet("[.(");
    var slashSplit = /\/+/;
    minimatch.filter = (pattern, options = {}) => (p, i, list) => minimatch(p, pattern, options);
    var ext = (a, b = {}) => {
      const t = {};
      Object.keys(a).forEach((k) => t[k] = a[k]);
      Object.keys(b).forEach((k) => t[k] = b[k]);
      return t;
    };
    minimatch.defaults = (def) => {
      if (!def || typeof def !== "object" || !Object.keys(def).length) {
        return minimatch;
      }
      const orig = minimatch;
      const m = (p, pattern, options) => orig(p, pattern, ext(def, options));
      m.Minimatch = class Minimatch extends orig.Minimatch {
        constructor(pattern, options) {
          super(pattern, ext(def, options));
        }
      };
      m.Minimatch.defaults = (options) => orig.defaults(ext(def, options)).Minimatch;
      m.filter = (pattern, options) => orig.filter(pattern, ext(def, options));
      m.defaults = (options) => orig.defaults(ext(def, options));
      m.makeRe = (pattern, options) => orig.makeRe(pattern, ext(def, options));
      m.braceExpand = (pattern, options) => orig.braceExpand(pattern, ext(def, options));
      m.match = (list, pattern, options) => orig.match(list, pattern, ext(def, options));
      return m;
    };
    minimatch.braceExpand = (pattern, options) => braceExpand(pattern, options);
    var braceExpand = (pattern, options = {}) => {
      assertValidPattern(pattern);
      if (options.nobrace || !/\{(?:(?!\{).)*\}/.test(pattern)) {
        return [pattern];
      }
      return expand(pattern);
    };
    var MAX_PATTERN_LENGTH = 1024 * 64;
    var assertValidPattern = (pattern) => {
      if (typeof pattern !== "string") {
        throw new TypeError("invalid pattern");
      }
      if (pattern.length > MAX_PATTERN_LENGTH) {
        throw new TypeError("pattern is too long");
      }
    };
    var SUBPARSE = Symbol("subparse");
    minimatch.makeRe = (pattern, options) => new Minimatch(pattern, options || {}).makeRe();
    minimatch.match = (list, pattern, options = {}) => {
      const mm = new Minimatch(pattern, options);
      list = list.filter((f) => mm.match(f));
      if (mm.options.nonull && !list.length) {
        list.push(pattern);
      }
      return list;
    };
    var globUnescape = (s) => s.replace(/\\(.)/g, "$1");
    var charUnescape = (s) => s.replace(/\\([^-\]])/g, "$1");
    var regExpEscape = (s) => s.replace(/[-[\]{}()*+?.,\\^$|#\s]/g, "\\$&");
    var braExpEscape = (s) => s.replace(/[[\]\\]/g, "\\$&");
    var Minimatch = class {
      constructor(pattern, options) {
        assertValidPattern(pattern);
        if (!options)
          options = {};
        this.options = options;
        this.set = [];
        this.pattern = pattern;
        this.windowsPathsNoEscape = !!options.windowsPathsNoEscape || options.allowWindowsEscape === false;
        if (this.windowsPathsNoEscape) {
          this.pattern = this.pattern.replace(/\\/g, "/");
        }
        this.regexp = null;
        this.negate = false;
        this.comment = false;
        this.empty = false;
        this.partial = !!options.partial;
        this.make();
      }
      debug() {
      }
      make() {
        const pattern = this.pattern;
        const options = this.options;
        if (!options.nocomment && pattern.charAt(0) === "#") {
          this.comment = true;
          return;
        }
        if (!pattern) {
          this.empty = true;
          return;
        }
        this.parseNegate();
        let set = this.globSet = this.braceExpand();
        if (options.debug)
          this.debug = (...args) => console.error(...args);
        this.debug(this.pattern, set);
        set = this.globParts = set.map((s) => s.split(slashSplit));
        this.debug(this.pattern, set);
        set = set.map((s, si, set2) => s.map(this.parse, this));
        this.debug(this.pattern, set);
        set = set.filter((s) => s.indexOf(false) === -1);
        this.debug(this.pattern, set);
        this.set = set;
      }
      parseNegate() {
        if (this.options.nonegate)
          return;
        const pattern = this.pattern;
        let negate = false;
        let negateOffset = 0;
        for (let i = 0; i < pattern.length && pattern.charAt(i) === "!"; i++) {
          negate = !negate;
          negateOffset++;
        }
        if (negateOffset)
          this.pattern = pattern.slice(negateOffset);
        this.negate = negate;
      }
      // set partial to true to test if, for example,
      // "/a/b" matches the start of "/*/b/*/d"
      // Partial means, if you run out of file before you run
      // out of pattern, then that's fine, as long as all
      // the parts match.
      matchOne(file, pattern, partial) {
        var options = this.options;
        this.debug(
          "matchOne",
          { "this": this, file, pattern }
        );
        this.debug("matchOne", file.length, pattern.length);
        for (var fi = 0, pi = 0, fl = file.length, pl = pattern.length; fi < fl && pi < pl; fi++, pi++) {
          this.debug("matchOne loop");
          var p = pattern[pi];
          var f = file[fi];
          this.debug(pattern, p, f);
          if (p === false)
            return false;
          if (p === GLOBSTAR) {
            this.debug("GLOBSTAR", [pattern, p, f]);
            var fr = fi;
            var pr = pi + 1;
            if (pr === pl) {
              this.debug("** at the end");
              for (; fi < fl; fi++) {
                if (file[fi] === "." || file[fi] === ".." || !options.dot && file[fi].charAt(0) === ".")
                  return false;
              }
              return true;
            }
            while (fr < fl) {
              var swallowee = file[fr];
              this.debug("\nglobstar while", file, fr, pattern, pr, swallowee);
              if (this.matchOne(file.slice(fr), pattern.slice(pr), partial)) {
                this.debug("globstar found match!", fr, fl, swallowee);
                return true;
              } else {
                if (swallowee === "." || swallowee === ".." || !options.dot && swallowee.charAt(0) === ".") {
                  this.debug("dot detected!", file, fr, pattern, pr);
                  break;
                }
                this.debug("globstar swallow a segment, and continue");
                fr++;
              }
            }
            if (partial) {
              this.debug("\n>>> no match, partial?", file, fr, pattern, pr);
              if (fr === fl)
                return true;
            }
            return false;
          }
          var hit;
          if (typeof p === "string") {
            hit = f === p;
            this.debug("string match", p, f, hit);
          } else {
            hit = f.match(p);
            this.debug("pattern match", p, f, hit);
          }
          if (!hit)
            return false;
        }
        if (fi === fl && pi === pl) {
          return true;
        } else if (fi === fl) {
          return partial;
        } else if (pi === pl) {
          return fi === fl - 1 && file[fi] === "";
        }
        throw new Error("wtf?");
      }
      braceExpand() {
        return braceExpand(this.pattern, this.options);
      }
      parse(pattern, isSub) {
        assertValidPattern(pattern);
        const options = this.options;
        if (pattern === "**") {
          if (!options.noglobstar)
            return GLOBSTAR;
          else
            pattern = "*";
        }
        if (pattern === "")
          return "";
        let re = "";
        let hasMagic = false;
        let escaping = false;
        const patternListStack = [];
        const negativeLists = [];
        let stateChar;
        let inClass = false;
        let reClassStart = -1;
        let classStart = -1;
        let cs;
        let pl;
        let sp;
        let dotTravAllowed = pattern.charAt(0) === ".";
        let dotFileAllowed = options.dot || dotTravAllowed;
        const patternStart = () => dotTravAllowed ? "" : dotFileAllowed ? "(?!(?:^|\\/)\\.{1,2}(?:$|\\/))" : "(?!\\.)";
        const subPatternStart = (p) => p.charAt(0) === "." ? "" : options.dot ? "(?!(?:^|\\/)\\.{1,2}(?:$|\\/))" : "(?!\\.)";
        const clearStateChar = () => {
          if (stateChar) {
            switch (stateChar) {
              case "*":
                re += star;
                hasMagic = true;
                break;
              case "?":
                re += qmark;
                hasMagic = true;
                break;
              default:
                re += "\\" + stateChar;
                break;
            }
            this.debug("clearStateChar %j %j", stateChar, re);
            stateChar = false;
          }
        };
        for (let i = 0, c; i < pattern.length && (c = pattern.charAt(i)); i++) {
          this.debug("%s	%s %s %j", pattern, i, re, c);
          if (escaping) {
            if (c === "/") {
              return false;
            }
            if (reSpecials[c]) {
              re += "\\";
            }
            re += c;
            escaping = false;
            continue;
          }
          switch (c) {
            case "/": {
              return false;
            }
            case "\\":
              if (inClass && pattern.charAt(i + 1) === "-") {
                re += c;
                continue;
              }
              clearStateChar();
              escaping = true;
              continue;
            case "?":
            case "*":
            case "+":
            case "@":
            case "!":
              this.debug("%s	%s %s %j <-- stateChar", pattern, i, re, c);
              if (inClass) {
                this.debug("  in class");
                if (c === "!" && i === classStart + 1)
                  c = "^";
                re += c;
                continue;
              }
              this.debug("call clearStateChar %j", stateChar);
              clearStateChar();
              stateChar = c;
              if (options.noext)
                clearStateChar();
              continue;
            case "(": {
              if (inClass) {
                re += "(";
                continue;
              }
              if (!stateChar) {
                re += "\\(";
                continue;
              }
              const plEntry = {
                type: stateChar,
                start: i - 1,
                reStart: re.length,
                open: plTypes[stateChar].open,
                close: plTypes[stateChar].close
              };
              this.debug(this.pattern, "	", plEntry);
              patternListStack.push(plEntry);
              re += plEntry.open;
              if (plEntry.start === 0 && plEntry.type !== "!") {
                dotTravAllowed = true;
                re += subPatternStart(pattern.slice(i + 1));
              }
              this.debug("plType %j %j", stateChar, re);
              stateChar = false;
              continue;
            }
            case ")": {
              const plEntry = patternListStack[patternListStack.length - 1];
              if (inClass || !plEntry) {
                re += "\\)";
                continue;
              }
              patternListStack.pop();
              clearStateChar();
              hasMagic = true;
              pl = plEntry;
              re += pl.close;
              if (pl.type === "!") {
                negativeLists.push(Object.assign(pl, { reEnd: re.length }));
              }
              continue;
            }
            case "|": {
              const plEntry = patternListStack[patternListStack.length - 1];
              if (inClass || !plEntry) {
                re += "\\|";
                continue;
              }
              clearStateChar();
              re += "|";
              if (plEntry.start === 0 && plEntry.type !== "!") {
                dotTravAllowed = true;
                re += subPatternStart(pattern.slice(i + 1));
              }
              continue;
            }
            case "[":
              clearStateChar();
              if (inClass) {
                re += "\\" + c;
                continue;
              }
              inClass = true;
              classStart = i;
              reClassStart = re.length;
              re += c;
              continue;
            case "]":
              if (i === classStart + 1 || !inClass) {
                re += "\\" + c;
                continue;
              }
              cs = pattern.substring(classStart + 1, i);
              try {
                RegExp("[" + braExpEscape(charUnescape(cs)) + "]");
                re += c;
              } catch (er) {
                re = re.substring(0, reClassStart) + "(?:$.)";
              }
              hasMagic = true;
              inClass = false;
              continue;
            default:
              clearStateChar();
              if (reSpecials[c] && !(c === "^" && inClass)) {
                re += "\\";
              }
              re += c;
              break;
          }
        }
        if (inClass) {
          cs = pattern.slice(classStart + 1);
          sp = this.parse(cs, SUBPARSE);
          re = re.substring(0, reClassStart) + "\\[" + sp[0];
          hasMagic = hasMagic || sp[1];
        }
        for (pl = patternListStack.pop(); pl; pl = patternListStack.pop()) {
          let tail;
          tail = re.slice(pl.reStart + pl.open.length);
          this.debug("setting tail", re, pl);
          tail = tail.replace(/((?:\\{2}){0,64})(\\?)\|/g, (_2, $1, $2) => {
            if (!$2) {
              $2 = "\\";
            }
            return $1 + $1 + $2 + "|";
          });
          this.debug("tail=%j\n   %s", tail, tail, pl, re);
          const t = pl.type === "*" ? star : pl.type === "?" ? qmark : "\\" + pl.type;
          hasMagic = true;
          re = re.slice(0, pl.reStart) + t + "\\(" + tail;
        }
        clearStateChar();
        if (escaping) {
          re += "\\\\";
        }
        const addPatternStart = addPatternStartSet[re.charAt(0)];
        for (let n = negativeLists.length - 1; n > -1; n--) {
          const nl = negativeLists[n];
          const nlBefore = re.slice(0, nl.reStart);
          const nlFirst = re.slice(nl.reStart, nl.reEnd - 8);
          let nlAfter = re.slice(nl.reEnd);
          const nlLast = re.slice(nl.reEnd - 8, nl.reEnd) + nlAfter;
          const closeParensBefore = nlBefore.split(")").length;
          const openParensBefore = nlBefore.split("(").length - closeParensBefore;
          let cleanAfter = nlAfter;
          for (let i = 0; i < openParensBefore; i++) {
            cleanAfter = cleanAfter.replace(/\)[+*?]?/, "");
          }
          nlAfter = cleanAfter;
          const dollar = nlAfter === "" && isSub !== SUBPARSE ? "(?:$|\\/)" : "";
          re = nlBefore + nlFirst + nlAfter + dollar + nlLast;
        }
        if (re !== "" && hasMagic) {
          re = "(?=.)" + re;
        }
        if (addPatternStart) {
          re = patternStart() + re;
        }
        if (isSub === SUBPARSE) {
          return [re, hasMagic];
        }
        if (options.nocase && !hasMagic) {
          hasMagic = pattern.toUpperCase() !== pattern.toLowerCase();
        }
        if (!hasMagic) {
          return globUnescape(pattern);
        }
        const flags = options.nocase ? "i" : "";
        try {
          return Object.assign(new RegExp("^" + re + "$", flags), {
            _glob: pattern,
            _src: re
          });
        } catch (er) {
          return new RegExp("$.");
        }
      }
      makeRe() {
        if (this.regexp || this.regexp === false)
          return this.regexp;
        const set = this.set;
        if (!set.length) {
          this.regexp = false;
          return this.regexp;
        }
        const options = this.options;
        const twoStar = options.noglobstar ? star : options.dot ? twoStarDot : twoStarNoDot;
        const flags = options.nocase ? "i" : "";
        let re = set.map((pattern) => {
          pattern = pattern.map(
            (p) => typeof p === "string" ? regExpEscape(p) : p === GLOBSTAR ? GLOBSTAR : p._src
          ).reduce((set2, p) => {
            if (!(set2[set2.length - 1] === GLOBSTAR && p === GLOBSTAR)) {
              set2.push(p);
            }
            return set2;
          }, []);
          pattern.forEach((p, i) => {
            if (p !== GLOBSTAR || pattern[i - 1] === GLOBSTAR) {
              return;
            }
            if (i === 0) {
              if (pattern.length > 1) {
                pattern[i + 1] = "(?:\\/|" + twoStar + "\\/)?" + pattern[i + 1];
              } else {
                pattern[i] = twoStar;
              }
            } else if (i === pattern.length - 1) {
              pattern[i - 1] += "(?:\\/|" + twoStar + ")?";
            } else {
              pattern[i - 1] += "(?:\\/|\\/" + twoStar + "\\/)" + pattern[i + 1];
              pattern[i + 1] = GLOBSTAR;
            }
          });
          return pattern.filter((p) => p !== GLOBSTAR).join("/");
        }).join("|");
        re = "^(?:" + re + ")$";
        if (this.negate)
          re = "^(?!" + re + ").*$";
        try {
          this.regexp = new RegExp(re, flags);
        } catch (ex) {
          this.regexp = false;
        }
        return this.regexp;
      }
      match(f, partial = this.partial) {
        this.debug("match", f, this.pattern);
        if (this.comment)
          return false;
        if (this.empty)
          return f === "";
        if (f === "/" && partial)
          return true;
        const options = this.options;
        if (path.sep !== "/") {
          f = f.split(path.sep).join("/");
        }
        f = f.split(slashSplit);
        this.debug(this.pattern, "split", f);
        const set = this.set;
        this.debug(this.pattern, "set", set);
        let filename;
        for (let i = f.length - 1; i >= 0; i--) {
          filename = f[i];
          if (filename)
            break;
        }
        for (let i = 0; i < set.length; i++) {
          const pattern = set[i];
          let file = f;
          if (options.matchBase && pattern.length === 1) {
            file = [filename];
          }
          const hit = this.matchOne(file, pattern, partial);
          if (hit) {
            if (options.flipNegate)
              return true;
            return !this.negate;
          }
        }
        if (options.flipNegate)
          return false;
        return this.negate;
      }
      static defaults(def) {
        return minimatch.defaults(def).Minimatch;
      }
    };
    minimatch.Minimatch = Minimatch;
  }
});

// ../../../node_modules/readdir-glob/index.js
var require_readdir_glob = __commonJS({
  "../../../node_modules/readdir-glob/index.js"(exports2, module2) {
    module2.exports = readdirGlob;
    var fs = require("fs");
    var { EventEmitter } = require("events");
    var { Minimatch } = require_minimatch();
    var { resolve } = require("path");
    function readdir(dir, strict) {
      return new Promise((resolve2, reject) => {
        fs.readdir(dir, { withFileTypes: true }, (err, files) => {
          if (err) {
            switch (err.code) {
              case "ENOTDIR":
                if (strict) {
                  reject(err);
                } else {
                  resolve2([]);
                }
                break;
              case "ENOTSUP":
              case "ENOENT":
              case "ENAMETOOLONG":
              case "UNKNOWN":
                resolve2([]);
                break;
              case "ELOOP":
              default:
                reject(err);
                break;
            }
          } else {
            resolve2(files);
          }
        });
      });
    }
    function stat(file, followSymlinks) {
      return new Promise((resolve2, reject) => {
        const statFunc = followSymlinks ? fs.stat : fs.lstat;
        statFunc(file, (err, stats) => {
          if (err) {
            switch (err.code) {
              case "ENOENT":
                if (followSymlinks) {
                  resolve2(stat(file, false));
                } else {
                  resolve2(null);
                }
                break;
              default:
                resolve2(null);
                break;
            }
          } else {
            resolve2(stats);
          }
        });
      });
    }
    async function* exploreWalkAsync(dir, path, followSymlinks, useStat, shouldSkip, strict) {
      let files = await readdir(path + dir, strict);
      for (const file of files) {
        let name = file.name;
        if (name === void 0) {
          name = file;
          useStat = true;
        }
        const filename = dir + "/" + name;
        const relative = filename.slice(1);
        const absolute = path + "/" + relative;
        let stats = null;
        if (useStat || followSymlinks) {
          stats = await stat(absolute, followSymlinks);
        }
        if (!stats && file.name !== void 0) {
          stats = file;
        }
        if (stats === null) {
          stats = { isDirectory: () => false };
        }
        if (stats.isDirectory()) {
          if (!shouldSkip(relative)) {
            yield { relative, absolute, stats };
            yield* exploreWalkAsync(filename, path, followSymlinks, useStat, shouldSkip, false);
          }
        } else {
          yield { relative, absolute, stats };
        }
      }
    }
    async function* explore(path, followSymlinks, useStat, shouldSkip) {
      yield* exploreWalkAsync("", path, followSymlinks, useStat, shouldSkip, true);
    }
    function readOptions(options) {
      return {
        pattern: options.pattern,
        dot: !!options.dot,
        noglobstar: !!options.noglobstar,
        matchBase: !!options.matchBase,
        nocase: !!options.nocase,
        ignore: options.ignore,
        skip: options.skip,
        follow: !!options.follow,
        stat: !!options.stat,
        nodir: !!options.nodir,
        mark: !!options.mark,
        silent: !!options.silent,
        absolute: !!options.absolute
      };
    }
    var ReaddirGlob = class extends EventEmitter {
      constructor(cwd, options, cb) {
        super();
        if (typeof options === "function") {
          cb = options;
          options = null;
        }
        this.options = readOptions(options || {});
        this.matchers = [];
        if (this.options.pattern) {
          const matchers = Array.isArray(this.options.pattern) ? this.options.pattern : [this.options.pattern];
          this.matchers = matchers.map(
            (m) => new Minimatch(m, {
              dot: this.options.dot,
              noglobstar: this.options.noglobstar,
              matchBase: this.options.matchBase,
              nocase: this.options.nocase
            })
          );
        }
        this.ignoreMatchers = [];
        if (this.options.ignore) {
          const ignorePatterns = Array.isArray(this.options.ignore) ? this.options.ignore : [this.options.ignore];
          this.ignoreMatchers = ignorePatterns.map(
            (ignore) => new Minimatch(ignore, { dot: true })
          );
        }
        this.skipMatchers = [];
        if (this.options.skip) {
          const skipPatterns = Array.isArray(this.options.skip) ? this.options.skip : [this.options.skip];
          this.skipMatchers = skipPatterns.map(
            (skip) => new Minimatch(skip, { dot: true })
          );
        }
        this.iterator = explore(resolve(cwd || "."), this.options.follow, this.options.stat, this._shouldSkipDirectory.bind(this));
        this.paused = false;
        this.inactive = false;
        this.aborted = false;
        if (cb) {
          this._matches = [];
          this.on("match", (match) => this._matches.push(this.options.absolute ? match.absolute : match.relative));
          this.on("error", (err) => cb(err));
          this.on("end", () => cb(null, this._matches));
        }
        setTimeout(() => this._next(), 0);
      }
      _shouldSkipDirectory(relative) {
        return this.skipMatchers.some((m) => m.match(relative));
      }
      _fileMatches(relative, isDirectory) {
        const file = relative + (isDirectory ? "/" : "");
        return (this.matchers.length === 0 || this.matchers.some((m) => m.match(file))) && !this.ignoreMatchers.some((m) => m.match(file)) && (!this.options.nodir || !isDirectory);
      }
      _next() {
        if (!this.paused && !this.aborted) {
          this.iterator.next().then((obj2) => {
            if (!obj2.done) {
              const isDirectory = obj2.value.stats.isDirectory();
              if (this._fileMatches(obj2.value.relative, isDirectory)) {
                let relative = obj2.value.relative;
                let absolute = obj2.value.absolute;
                if (this.options.mark && isDirectory) {
                  relative += "/";
                  absolute += "/";
                }
                if (this.options.stat) {
                  this.emit("match", { relative, absolute, stat: obj2.value.stats });
                } else {
                  this.emit("match", { relative, absolute });
                }
              }
              this._next(this.iterator);
            } else {
              this.emit("end");
            }
          }).catch((err) => {
            this.abort();
            this.emit("error", err);
            if (!err.code && !this.options.silent) {
              console.error(err);
            }
          });
        } else {
          this.inactive = true;
        }
      }
      abort() {
        this.aborted = true;
      }
      pause() {
        this.paused = true;
      }
      resume() {
        this.paused = false;
        if (this.inactive) {
          this.inactive = false;
          this._next();
        }
      }
    };
    function readdirGlob(pattern, options, cb) {
      return new ReaddirGlob(pattern, options, cb);
    }
    readdirGlob.ReaddirGlob = ReaddirGlob;
  }
});

// ../../../node_modules/async/dist/async.js
var require_async = __commonJS({
  "../../../node_modules/async/dist/async.js"(exports2, module2) {
    (function(global2, factory) {
      typeof exports2 === "object" && typeof module2 !== "undefined" ? factory(exports2) : typeof define === "function" && define.amd ? define(["exports"], factory) : (global2 = typeof globalThis !== "undefined" ? globalThis : global2 || self, factory(global2.async = {}));
    })(exports2, function(exports3) {
      "use strict";
      function apply(fn, ...args) {
        return (...callArgs) => fn(...args, ...callArgs);
      }
      function initialParams(fn) {
        return function(...args) {
          var callback = args.pop();
          return fn.call(this, args, callback);
        };
      }
      var hasQueueMicrotask = typeof queueMicrotask === "function" && queueMicrotask;
      var hasSetImmediate = typeof setImmediate === "function" && setImmediate;
      var hasNextTick = typeof process === "object" && typeof process.nextTick === "function";
      function fallback(fn) {
        setTimeout(fn, 0);
      }
      function wrap(defer) {
        return (fn, ...args) => defer(() => fn(...args));
      }
      var _defer$1;
      if (hasQueueMicrotask) {
        _defer$1 = queueMicrotask;
      } else if (hasSetImmediate) {
        _defer$1 = setImmediate;
      } else if (hasNextTick) {
        _defer$1 = process.nextTick;
      } else {
        _defer$1 = fallback;
      }
      var setImmediate$1 = wrap(_defer$1);
      function asyncify(func) {
        if (isAsync(func)) {
          return function(...args) {
            const callback = args.pop();
            const promise = func.apply(this, args);
            return handlePromise(promise, callback);
          };
        }
        return initialParams(function(args, callback) {
          var result;
          try {
            result = func.apply(this, args);
          } catch (e) {
            return callback(e);
          }
          if (result && typeof result.then === "function") {
            return handlePromise(result, callback);
          } else {
            callback(null, result);
          }
        });
      }
      function handlePromise(promise, callback) {
        return promise.then((value) => {
          invokeCallback(callback, null, value);
        }, (err) => {
          invokeCallback(callback, err && (err instanceof Error || err.message) ? err : new Error(err));
        });
      }
      function invokeCallback(callback, error, value) {
        try {
          callback(error, value);
        } catch (err) {
          setImmediate$1((e) => {
            throw e;
          }, err);
        }
      }
      function isAsync(fn) {
        return fn[Symbol.toStringTag] === "AsyncFunction";
      }
      function isAsyncGenerator(fn) {
        return fn[Symbol.toStringTag] === "AsyncGenerator";
      }
      function isAsyncIterable(obj2) {
        return typeof obj2[Symbol.asyncIterator] === "function";
      }
      function wrapAsync(asyncFn) {
        if (typeof asyncFn !== "function")
          throw new Error("expected a function");
        return isAsync(asyncFn) ? asyncify(asyncFn) : asyncFn;
      }
      function awaitify(asyncFn, arity) {
        if (!arity)
          arity = asyncFn.length;
        if (!arity)
          throw new Error("arity is undefined");
        function awaitable(...args) {
          if (typeof args[arity - 1] === "function") {
            return asyncFn.apply(this, args);
          }
          return new Promise((resolve, reject2) => {
            args[arity - 1] = (err, ...cbArgs) => {
              if (err)
                return reject2(err);
              resolve(cbArgs.length > 1 ? cbArgs : cbArgs[0]);
            };
            asyncFn.apply(this, args);
          });
        }
        return awaitable;
      }
      function applyEach$1(eachfn) {
        return function applyEach2(fns, ...callArgs) {
          const go = awaitify(function(callback) {
            var that = this;
            return eachfn(fns, (fn, cb) => {
              wrapAsync(fn).apply(that, callArgs.concat(cb));
            }, callback);
          });
          return go;
        };
      }
      function _asyncMap(eachfn, arr, iteratee, callback) {
        arr = arr || [];
        var results = [];
        var counter = 0;
        var _iteratee = wrapAsync(iteratee);
        return eachfn(arr, (value, _2, iterCb) => {
          var index2 = counter++;
          _iteratee(value, (err, v) => {
            results[index2] = v;
            iterCb(err);
          });
        }, (err) => {
          callback(err, results);
        });
      }
      function isArrayLike(value) {
        return value && typeof value.length === "number" && value.length >= 0 && value.length % 1 === 0;
      }
      const breakLoop = {};
      function once(fn) {
        function wrapper(...args) {
          if (fn === null)
            return;
          var callFn = fn;
          fn = null;
          callFn.apply(this, args);
        }
        Object.assign(wrapper, fn);
        return wrapper;
      }
      function getIterator(coll) {
        return coll[Symbol.iterator] && coll[Symbol.iterator]();
      }
      function createArrayIterator(coll) {
        var i = -1;
        var len = coll.length;
        return function next() {
          return ++i < len ? { value: coll[i], key: i } : null;
        };
      }
      function createES2015Iterator(iterator) {
        var i = -1;
        return function next() {
          var item = iterator.next();
          if (item.done)
            return null;
          i++;
          return { value: item.value, key: i };
        };
      }
      function createObjectIterator(obj2) {
        var okeys = obj2 ? Object.keys(obj2) : [];
        var i = -1;
        var len = okeys.length;
        return function next() {
          var key = okeys[++i];
          if (key === "__proto__") {
            return next();
          }
          return i < len ? { value: obj2[key], key } : null;
        };
      }
      function createIterator(coll) {
        if (isArrayLike(coll)) {
          return createArrayIterator(coll);
        }
        var iterator = getIterator(coll);
        return iterator ? createES2015Iterator(iterator) : createObjectIterator(coll);
      }
      function onlyOnce(fn) {
        return function(...args) {
          if (fn === null)
            throw new Error("Callback was already called.");
          var callFn = fn;
          fn = null;
          callFn.apply(this, args);
        };
      }
      function asyncEachOfLimit(generator, limit, iteratee, callback) {
        let done = false;
        let canceled = false;
        let awaiting = false;
        let running = 0;
        let idx = 0;
        function replenish() {
          if (running >= limit || awaiting || done)
            return;
          awaiting = true;
          generator.next().then(({ value, done: iterDone }) => {
            if (canceled || done)
              return;
            awaiting = false;
            if (iterDone) {
              done = true;
              if (running <= 0) {
                callback(null);
              }
              return;
            }
            running++;
            iteratee(value, idx, iterateeCallback);
            idx++;
            replenish();
          }).catch(handleError);
        }
        function iterateeCallback(err, result) {
          running -= 1;
          if (canceled)
            return;
          if (err)
            return handleError(err);
          if (err === false) {
            done = true;
            canceled = true;
            return;
          }
          if (result === breakLoop || done && running <= 0) {
            done = true;
            return callback(null);
          }
          replenish();
        }
        function handleError(err) {
          if (canceled)
            return;
          awaiting = false;
          done = true;
          callback(err);
        }
        replenish();
      }
      var eachOfLimit$2 = (limit) => {
        return (obj2, iteratee, callback) => {
          callback = once(callback);
          if (limit <= 0) {
            throw new RangeError("concurrency limit cannot be less than 1");
          }
          if (!obj2) {
            return callback(null);
          }
          if (isAsyncGenerator(obj2)) {
            return asyncEachOfLimit(obj2, limit, iteratee, callback);
          }
          if (isAsyncIterable(obj2)) {
            return asyncEachOfLimit(obj2[Symbol.asyncIterator](), limit, iteratee, callback);
          }
          var nextElem = createIterator(obj2);
          var done = false;
          var canceled = false;
          var running = 0;
          var looping = false;
          function iterateeCallback(err, value) {
            if (canceled)
              return;
            running -= 1;
            if (err) {
              done = true;
              callback(err);
            } else if (err === false) {
              done = true;
              canceled = true;
            } else if (value === breakLoop || done && running <= 0) {
              done = true;
              return callback(null);
            } else if (!looping) {
              replenish();
            }
          }
          function replenish() {
            looping = true;
            while (running < limit && !done) {
              var elem = nextElem();
              if (elem === null) {
                done = true;
                if (running <= 0) {
                  callback(null);
                }
                return;
              }
              running += 1;
              iteratee(elem.value, elem.key, onlyOnce(iterateeCallback));
            }
            looping = false;
          }
          replenish();
        };
      };
      function eachOfLimit(coll, limit, iteratee, callback) {
        return eachOfLimit$2(limit)(coll, wrapAsync(iteratee), callback);
      }
      var eachOfLimit$1 = awaitify(eachOfLimit, 4);
      function eachOfArrayLike(coll, iteratee, callback) {
        callback = once(callback);
        var index2 = 0, completed = 0, { length } = coll, canceled = false;
        if (length === 0) {
          callback(null);
        }
        function iteratorCallback(err, value) {
          if (err === false) {
            canceled = true;
          }
          if (canceled === true)
            return;
          if (err) {
            callback(err);
          } else if (++completed === length || value === breakLoop) {
            callback(null);
          }
        }
        for (; index2 < length; index2++) {
          iteratee(coll[index2], index2, onlyOnce(iteratorCallback));
        }
      }
      function eachOfGeneric(coll, iteratee, callback) {
        return eachOfLimit$1(coll, Infinity, iteratee, callback);
      }
      function eachOf(coll, iteratee, callback) {
        var eachOfImplementation = isArrayLike(coll) ? eachOfArrayLike : eachOfGeneric;
        return eachOfImplementation(coll, wrapAsync(iteratee), callback);
      }
      var eachOf$1 = awaitify(eachOf, 3);
      function map(coll, iteratee, callback) {
        return _asyncMap(eachOf$1, coll, iteratee, callback);
      }
      var map$1 = awaitify(map, 3);
      var applyEach = applyEach$1(map$1);
      function eachOfSeries(coll, iteratee, callback) {
        return eachOfLimit$1(coll, 1, iteratee, callback);
      }
      var eachOfSeries$1 = awaitify(eachOfSeries, 3);
      function mapSeries(coll, iteratee, callback) {
        return _asyncMap(eachOfSeries$1, coll, iteratee, callback);
      }
      var mapSeries$1 = awaitify(mapSeries, 3);
      var applyEachSeries = applyEach$1(mapSeries$1);
      const PROMISE_SYMBOL = Symbol("promiseCallback");
      function promiseCallback() {
        let resolve, reject2;
        function callback(err, ...args) {
          if (err)
            return reject2(err);
          resolve(args.length > 1 ? args : args[0]);
        }
        callback[PROMISE_SYMBOL] = new Promise((res, rej) => {
          resolve = res, reject2 = rej;
        });
        return callback;
      }
      function auto(tasks, concurrency, callback) {
        if (typeof concurrency !== "number") {
          callback = concurrency;
          concurrency = null;
        }
        callback = once(callback || promiseCallback());
        var numTasks = Object.keys(tasks).length;
        if (!numTasks) {
          return callback(null);
        }
        if (!concurrency) {
          concurrency = numTasks;
        }
        var results = {};
        var runningTasks = 0;
        var canceled = false;
        var hasError = false;
        var listeners = /* @__PURE__ */ Object.create(null);
        var readyTasks = [];
        var readyToCheck = [];
        var uncheckedDependencies = {};
        Object.keys(tasks).forEach((key) => {
          var task = tasks[key];
          if (!Array.isArray(task)) {
            enqueueTask(key, [task]);
            readyToCheck.push(key);
            return;
          }
          var dependencies = task.slice(0, task.length - 1);
          var remainingDependencies = dependencies.length;
          if (remainingDependencies === 0) {
            enqueueTask(key, task);
            readyToCheck.push(key);
            return;
          }
          uncheckedDependencies[key] = remainingDependencies;
          dependencies.forEach((dependencyName) => {
            if (!tasks[dependencyName]) {
              throw new Error("async.auto task `" + key + "` has a non-existent dependency `" + dependencyName + "` in " + dependencies.join(", "));
            }
            addListener(dependencyName, () => {
              remainingDependencies--;
              if (remainingDependencies === 0) {
                enqueueTask(key, task);
              }
            });
          });
        });
        checkForDeadlocks();
        processQueue();
        function enqueueTask(key, task) {
          readyTasks.push(() => runTask(key, task));
        }
        function processQueue() {
          if (canceled)
            return;
          if (readyTasks.length === 0 && runningTasks === 0) {
            return callback(null, results);
          }
          while (readyTasks.length && runningTasks < concurrency) {
            var run = readyTasks.shift();
            run();
          }
        }
        function addListener(taskName, fn) {
          var taskListeners = listeners[taskName];
          if (!taskListeners) {
            taskListeners = listeners[taskName] = [];
          }
          taskListeners.push(fn);
        }
        function taskComplete(taskName) {
          var taskListeners = listeners[taskName] || [];
          taskListeners.forEach((fn) => fn());
          processQueue();
        }
        function runTask(key, task) {
          if (hasError)
            return;
          var taskCallback = onlyOnce((err, ...result) => {
            runningTasks--;
            if (err === false) {
              canceled = true;
              return;
            }
            if (result.length < 2) {
              [result] = result;
            }
            if (err) {
              var safeResults = {};
              Object.keys(results).forEach((rkey) => {
                safeResults[rkey] = results[rkey];
              });
              safeResults[key] = result;
              hasError = true;
              listeners = /* @__PURE__ */ Object.create(null);
              if (canceled)
                return;
              callback(err, safeResults);
            } else {
              results[key] = result;
              taskComplete(key);
            }
          });
          runningTasks++;
          var taskFn = wrapAsync(task[task.length - 1]);
          if (task.length > 1) {
            taskFn(results, taskCallback);
          } else {
            taskFn(taskCallback);
          }
        }
        function checkForDeadlocks() {
          var currentTask;
          var counter = 0;
          while (readyToCheck.length) {
            currentTask = readyToCheck.pop();
            counter++;
            getDependents(currentTask).forEach((dependent) => {
              if (--uncheckedDependencies[dependent] === 0) {
                readyToCheck.push(dependent);
              }
            });
          }
          if (counter !== numTasks) {
            throw new Error(
              "async.auto cannot execute tasks due to a recursive dependency"
            );
          }
        }
        function getDependents(taskName) {
          var result = [];
          Object.keys(tasks).forEach((key) => {
            const task = tasks[key];
            if (Array.isArray(task) && task.indexOf(taskName) >= 0) {
              result.push(key);
            }
          });
          return result;
        }
        return callback[PROMISE_SYMBOL];
      }
      var FN_ARGS = /^(?:async\s)?(?:function)?\s*(?:\w+\s*)?\(([^)]+)\)(?:\s*{)/;
      var ARROW_FN_ARGS = /^(?:async\s)?\s*(?:\(\s*)?((?:[^)=\s]\s*)*)(?:\)\s*)?=>/;
      var FN_ARG_SPLIT = /,/;
      var FN_ARG = /(=.+)?(\s*)$/;
      function stripComments(string) {
        let stripped = "";
        let index2 = 0;
        let endBlockComment = string.indexOf("*/");
        while (index2 < string.length) {
          if (string[index2] === "/" && string[index2 + 1] === "/") {
            let endIndex = string.indexOf("\n", index2);
            index2 = endIndex === -1 ? string.length : endIndex;
          } else if (endBlockComment !== -1 && string[index2] === "/" && string[index2 + 1] === "*") {
            let endIndex = string.indexOf("*/", index2);
            if (endIndex !== -1) {
              index2 = endIndex + 2;
              endBlockComment = string.indexOf("*/", index2);
            } else {
              stripped += string[index2];
              index2++;
            }
          } else {
            stripped += string[index2];
            index2++;
          }
        }
        return stripped;
      }
      function parseParams(func) {
        const src = stripComments(func.toString());
        let match = src.match(FN_ARGS);
        if (!match) {
          match = src.match(ARROW_FN_ARGS);
        }
        if (!match)
          throw new Error("could not parse args in autoInject\nSource:\n" + src);
        let [, args] = match;
        return args.replace(/\s/g, "").split(FN_ARG_SPLIT).map((arg) => arg.replace(FN_ARG, "").trim());
      }
      function autoInject(tasks, callback) {
        var newTasks = {};
        Object.keys(tasks).forEach((key) => {
          var taskFn = tasks[key];
          var params;
          var fnIsAsync = isAsync(taskFn);
          var hasNoDeps = !fnIsAsync && taskFn.length === 1 || fnIsAsync && taskFn.length === 0;
          if (Array.isArray(taskFn)) {
            params = [...taskFn];
            taskFn = params.pop();
            newTasks[key] = params.concat(params.length > 0 ? newTask : taskFn);
          } else if (hasNoDeps) {
            newTasks[key] = taskFn;
          } else {
            params = parseParams(taskFn);
            if (taskFn.length === 0 && !fnIsAsync && params.length === 0) {
              throw new Error("autoInject task functions require explicit parameters.");
            }
            if (!fnIsAsync)
              params.pop();
            newTasks[key] = params.concat(newTask);
          }
          function newTask(results, taskCb) {
            var newArgs = params.map((name) => results[name]);
            newArgs.push(taskCb);
            wrapAsync(taskFn)(...newArgs);
          }
        });
        return auto(newTasks, callback);
      }
      class DLL {
        constructor() {
          this.head = this.tail = null;
          this.length = 0;
        }
        removeLink(node) {
          if (node.prev)
            node.prev.next = node.next;
          else
            this.head = node.next;
          if (node.next)
            node.next.prev = node.prev;
          else
            this.tail = node.prev;
          node.prev = node.next = null;
          this.length -= 1;
          return node;
        }
        empty() {
          while (this.head)
            this.shift();
          return this;
        }
        insertAfter(node, newNode) {
          newNode.prev = node;
          newNode.next = node.next;
          if (node.next)
            node.next.prev = newNode;
          else
            this.tail = newNode;
          node.next = newNode;
          this.length += 1;
        }
        insertBefore(node, newNode) {
          newNode.prev = node.prev;
          newNode.next = node;
          if (node.prev)
            node.prev.next = newNode;
          else
            this.head = newNode;
          node.prev = newNode;
          this.length += 1;
        }
        unshift(node) {
          if (this.head)
            this.insertBefore(this.head, node);
          else
            setInitial(this, node);
        }
        push(node) {
          if (this.tail)
            this.insertAfter(this.tail, node);
          else
            setInitial(this, node);
        }
        shift() {
          return this.head && this.removeLink(this.head);
        }
        pop() {
          return this.tail && this.removeLink(this.tail);
        }
        toArray() {
          return [...this];
        }
        *[Symbol.iterator]() {
          var cur = this.head;
          while (cur) {
            yield cur.data;
            cur = cur.next;
          }
        }
        remove(testFn) {
          var curr = this.head;
          while (curr) {
            var { next } = curr;
            if (testFn(curr)) {
              this.removeLink(curr);
            }
            curr = next;
          }
          return this;
        }
      }
      function setInitial(dll, node) {
        dll.length = 1;
        dll.head = dll.tail = node;
      }
      function queue$1(worker, concurrency, payload) {
        if (concurrency == null) {
          concurrency = 1;
        } else if (concurrency === 0) {
          throw new RangeError("Concurrency must not be zero");
        }
        var _worker = wrapAsync(worker);
        var numRunning = 0;
        var workersList = [];
        const events = {
          error: [],
          drain: [],
          saturated: [],
          unsaturated: [],
          empty: []
        };
        function on(event, handler) {
          events[event].push(handler);
        }
        function once2(event, handler) {
          const handleAndRemove = (...args) => {
            off(event, handleAndRemove);
            handler(...args);
          };
          events[event].push(handleAndRemove);
        }
        function off(event, handler) {
          if (!event)
            return Object.keys(events).forEach((ev) => events[ev] = []);
          if (!handler)
            return events[event] = [];
          events[event] = events[event].filter((ev) => ev !== handler);
        }
        function trigger(event, ...args) {
          events[event].forEach((handler) => handler(...args));
        }
        var processingScheduled = false;
        function _insert(data, insertAtFront, rejectOnError, callback) {
          if (callback != null && typeof callback !== "function") {
            throw new Error("task callback must be a function");
          }
          q.started = true;
          var res, rej;
          function promiseCallback2(err, ...args) {
            if (err)
              return rejectOnError ? rej(err) : res();
            if (args.length <= 1)
              return res(args[0]);
            res(args);
          }
          var item = q._createTaskItem(
            data,
            rejectOnError ? promiseCallback2 : callback || promiseCallback2
          );
          if (insertAtFront) {
            q._tasks.unshift(item);
          } else {
            q._tasks.push(item);
          }
          if (!processingScheduled) {
            processingScheduled = true;
            setImmediate$1(() => {
              processingScheduled = false;
              q.process();
            });
          }
          if (rejectOnError || !callback) {
            return new Promise((resolve, reject2) => {
              res = resolve;
              rej = reject2;
            });
          }
        }
        function _createCB(tasks) {
          return function(err, ...args) {
            numRunning -= 1;
            for (var i = 0, l2 = tasks.length; i < l2; i++) {
              var task = tasks[i];
              var index2 = workersList.indexOf(task);
              if (index2 === 0) {
                workersList.shift();
              } else if (index2 > 0) {
                workersList.splice(index2, 1);
              }
              task.callback(err, ...args);
              if (err != null) {
                trigger("error", err, task.data);
              }
            }
            if (numRunning <= q.concurrency - q.buffer) {
              trigger("unsaturated");
            }
            if (q.idle()) {
              trigger("drain");
            }
            q.process();
          };
        }
        function _maybeDrain(data) {
          if (data.length === 0 && q.idle()) {
            setImmediate$1(() => trigger("drain"));
            return true;
          }
          return false;
        }
        const eventMethod = (name) => (handler) => {
          if (!handler) {
            return new Promise((resolve, reject2) => {
              once2(name, (err, data) => {
                if (err)
                  return reject2(err);
                resolve(data);
              });
            });
          }
          off(name);
          on(name, handler);
        };
        var isProcessing = false;
        var q = {
          _tasks: new DLL(),
          _createTaskItem(data, callback) {
            return {
              data,
              callback
            };
          },
          *[Symbol.iterator]() {
            yield* q._tasks[Symbol.iterator]();
          },
          concurrency,
          payload,
          buffer: concurrency / 4,
          started: false,
          paused: false,
          push(data, callback) {
            if (Array.isArray(data)) {
              if (_maybeDrain(data))
                return;
              return data.map((datum) => _insert(datum, false, false, callback));
            }
            return _insert(data, false, false, callback);
          },
          pushAsync(data, callback) {
            if (Array.isArray(data)) {
              if (_maybeDrain(data))
                return;
              return data.map((datum) => _insert(datum, false, true, callback));
            }
            return _insert(data, false, true, callback);
          },
          kill() {
            off();
            q._tasks.empty();
          },
          unshift(data, callback) {
            if (Array.isArray(data)) {
              if (_maybeDrain(data))
                return;
              return data.map((datum) => _insert(datum, true, false, callback));
            }
            return _insert(data, true, false, callback);
          },
          unshiftAsync(data, callback) {
            if (Array.isArray(data)) {
              if (_maybeDrain(data))
                return;
              return data.map((datum) => _insert(datum, true, true, callback));
            }
            return _insert(data, true, true, callback);
          },
          remove(testFn) {
            q._tasks.remove(testFn);
          },
          process() {
            if (isProcessing) {
              return;
            }
            isProcessing = true;
            while (!q.paused && numRunning < q.concurrency && q._tasks.length) {
              var tasks = [], data = [];
              var l2 = q._tasks.length;
              if (q.payload)
                l2 = Math.min(l2, q.payload);
              for (var i = 0; i < l2; i++) {
                var node = q._tasks.shift();
                tasks.push(node);
                workersList.push(node);
                data.push(node.data);
              }
              numRunning += 1;
              if (q._tasks.length === 0) {
                trigger("empty");
              }
              if (numRunning === q.concurrency) {
                trigger("saturated");
              }
              var cb = onlyOnce(_createCB(tasks));
              _worker(data, cb);
            }
            isProcessing = false;
          },
          length() {
            return q._tasks.length;
          },
          running() {
            return numRunning;
          },
          workersList() {
            return workersList;
          },
          idle() {
            return q._tasks.length + numRunning === 0;
          },
          pause() {
            q.paused = true;
          },
          resume() {
            if (q.paused === false) {
              return;
            }
            q.paused = false;
            setImmediate$1(q.process);
          }
        };
        Object.defineProperties(q, {
          saturated: {
            writable: false,
            value: eventMethod("saturated")
          },
          unsaturated: {
            writable: false,
            value: eventMethod("unsaturated")
          },
          empty: {
            writable: false,
            value: eventMethod("empty")
          },
          drain: {
            writable: false,
            value: eventMethod("drain")
          },
          error: {
            writable: false,
            value: eventMethod("error")
          }
        });
        return q;
      }
      function cargo$1(worker, payload) {
        return queue$1(worker, 1, payload);
      }
      function cargo(worker, concurrency, payload) {
        return queue$1(worker, concurrency, payload);
      }
      function reduce(coll, memo, iteratee, callback) {
        callback = once(callback);
        var _iteratee = wrapAsync(iteratee);
        return eachOfSeries$1(coll, (x, i, iterCb) => {
          _iteratee(memo, x, (err, v) => {
            memo = v;
            iterCb(err);
          });
        }, (err) => callback(err, memo));
      }
      var reduce$1 = awaitify(reduce, 4);
      function seq(...functions) {
        var _functions = functions.map(wrapAsync);
        return function(...args) {
          var that = this;
          var cb = args[args.length - 1];
          if (typeof cb == "function") {
            args.pop();
          } else {
            cb = promiseCallback();
          }
          reduce$1(
            _functions,
            args,
            (newargs, fn, iterCb) => {
              fn.apply(that, newargs.concat((err, ...nextargs) => {
                iterCb(err, nextargs);
              }));
            },
            (err, results) => cb(err, ...results)
          );
          return cb[PROMISE_SYMBOL];
        };
      }
      function compose(...args) {
        return seq(...args.reverse());
      }
      function mapLimit(coll, limit, iteratee, callback) {
        return _asyncMap(eachOfLimit$2(limit), coll, iteratee, callback);
      }
      var mapLimit$1 = awaitify(mapLimit, 4);
      function concatLimit(coll, limit, iteratee, callback) {
        var _iteratee = wrapAsync(iteratee);
        return mapLimit$1(coll, limit, (val, iterCb) => {
          _iteratee(val, (err, ...args) => {
            if (err)
              return iterCb(err);
            return iterCb(err, args);
          });
        }, (err, mapResults) => {
          var result = [];
          for (var i = 0; i < mapResults.length; i++) {
            if (mapResults[i]) {
              result = result.concat(...mapResults[i]);
            }
          }
          return callback(err, result);
        });
      }
      var concatLimit$1 = awaitify(concatLimit, 4);
      function concat(coll, iteratee, callback) {
        return concatLimit$1(coll, Infinity, iteratee, callback);
      }
      var concat$1 = awaitify(concat, 3);
      function concatSeries(coll, iteratee, callback) {
        return concatLimit$1(coll, 1, iteratee, callback);
      }
      var concatSeries$1 = awaitify(concatSeries, 3);
      function constant$1(...args) {
        return function(...ignoredArgs) {
          var callback = ignoredArgs.pop();
          return callback(null, ...args);
        };
      }
      function _createTester(check, getResult) {
        return (eachfn, arr, _iteratee, cb) => {
          var testPassed = false;
          var testResult;
          const iteratee = wrapAsync(_iteratee);
          eachfn(arr, (value, _2, callback) => {
            iteratee(value, (err, result) => {
              if (err || err === false)
                return callback(err);
              if (check(result) && !testResult) {
                testPassed = true;
                testResult = getResult(true, value);
                return callback(null, breakLoop);
              }
              callback();
            });
          }, (err) => {
            if (err)
              return cb(err);
            cb(null, testPassed ? testResult : getResult(false));
          });
        };
      }
      function detect(coll, iteratee, callback) {
        return _createTester((bool) => bool, (res, item) => item)(eachOf$1, coll, iteratee, callback);
      }
      var detect$1 = awaitify(detect, 3);
      function detectLimit(coll, limit, iteratee, callback) {
        return _createTester((bool) => bool, (res, item) => item)(eachOfLimit$2(limit), coll, iteratee, callback);
      }
      var detectLimit$1 = awaitify(detectLimit, 4);
      function detectSeries(coll, iteratee, callback) {
        return _createTester((bool) => bool, (res, item) => item)(eachOfLimit$2(1), coll, iteratee, callback);
      }
      var detectSeries$1 = awaitify(detectSeries, 3);
      function consoleFunc(name) {
        return (fn, ...args) => wrapAsync(fn)(...args, (err, ...resultArgs) => {
          if (typeof console === "object") {
            if (err) {
              if (console.error) {
                console.error(err);
              }
            } else if (console[name]) {
              resultArgs.forEach((x) => console[name](x));
            }
          }
        });
      }
      var dir = consoleFunc("dir");
      function doWhilst(iteratee, test, callback) {
        callback = onlyOnce(callback);
        var _fn = wrapAsync(iteratee);
        var _test = wrapAsync(test);
        var results;
        function next(err, ...args) {
          if (err)
            return callback(err);
          if (err === false)
            return;
          results = args;
          _test(...args, check);
        }
        function check(err, truth) {
          if (err)
            return callback(err);
          if (err === false)
            return;
          if (!truth)
            return callback(null, ...results);
          _fn(next);
        }
        return check(null, true);
      }
      var doWhilst$1 = awaitify(doWhilst, 3);
      function doUntil(iteratee, test, callback) {
        const _test = wrapAsync(test);
        return doWhilst$1(iteratee, (...args) => {
          const cb = args.pop();
          _test(...args, (err, truth) => cb(err, !truth));
        }, callback);
      }
      function _withoutIndex(iteratee) {
        return (value, index2, callback) => iteratee(value, callback);
      }
      function eachLimit$2(coll, iteratee, callback) {
        return eachOf$1(coll, _withoutIndex(wrapAsync(iteratee)), callback);
      }
      var each = awaitify(eachLimit$2, 3);
      function eachLimit(coll, limit, iteratee, callback) {
        return eachOfLimit$2(limit)(coll, _withoutIndex(wrapAsync(iteratee)), callback);
      }
      var eachLimit$1 = awaitify(eachLimit, 4);
      function eachSeries(coll, iteratee, callback) {
        return eachLimit$1(coll, 1, iteratee, callback);
      }
      var eachSeries$1 = awaitify(eachSeries, 3);
      function ensureAsync(fn) {
        if (isAsync(fn))
          return fn;
        return function(...args) {
          var callback = args.pop();
          var sync = true;
          args.push((...innerArgs) => {
            if (sync) {
              setImmediate$1(() => callback(...innerArgs));
            } else {
              callback(...innerArgs);
            }
          });
          fn.apply(this, args);
          sync = false;
        };
      }
      function every(coll, iteratee, callback) {
        return _createTester((bool) => !bool, (res) => !res)(eachOf$1, coll, iteratee, callback);
      }
      var every$1 = awaitify(every, 3);
      function everyLimit(coll, limit, iteratee, callback) {
        return _createTester((bool) => !bool, (res) => !res)(eachOfLimit$2(limit), coll, iteratee, callback);
      }
      var everyLimit$1 = awaitify(everyLimit, 4);
      function everySeries(coll, iteratee, callback) {
        return _createTester((bool) => !bool, (res) => !res)(eachOfSeries$1, coll, iteratee, callback);
      }
      var everySeries$1 = awaitify(everySeries, 3);
      function filterArray(eachfn, arr, iteratee, callback) {
        var truthValues = new Array(arr.length);
        eachfn(arr, (x, index2, iterCb) => {
          iteratee(x, (err, v) => {
            truthValues[index2] = !!v;
            iterCb(err);
          });
        }, (err) => {
          if (err)
            return callback(err);
          var results = [];
          for (var i = 0; i < arr.length; i++) {
            if (truthValues[i])
              results.push(arr[i]);
          }
          callback(null, results);
        });
      }
      function filterGeneric(eachfn, coll, iteratee, callback) {
        var results = [];
        eachfn(coll, (x, index2, iterCb) => {
          iteratee(x, (err, v) => {
            if (err)
              return iterCb(err);
            if (v) {
              results.push({ index: index2, value: x });
            }
            iterCb(err);
          });
        }, (err) => {
          if (err)
            return callback(err);
          callback(null, results.sort((a, b) => a.index - b.index).map((v) => v.value));
        });
      }
      function _filter(eachfn, coll, iteratee, callback) {
        var filter2 = isArrayLike(coll) ? filterArray : filterGeneric;
        return filter2(eachfn, coll, wrapAsync(iteratee), callback);
      }
      function filter(coll, iteratee, callback) {
        return _filter(eachOf$1, coll, iteratee, callback);
      }
      var filter$1 = awaitify(filter, 3);
      function filterLimit(coll, limit, iteratee, callback) {
        return _filter(eachOfLimit$2(limit), coll, iteratee, callback);
      }
      var filterLimit$1 = awaitify(filterLimit, 4);
      function filterSeries(coll, iteratee, callback) {
        return _filter(eachOfSeries$1, coll, iteratee, callback);
      }
      var filterSeries$1 = awaitify(filterSeries, 3);
      function forever(fn, errback) {
        var done = onlyOnce(errback);
        var task = wrapAsync(ensureAsync(fn));
        function next(err) {
          if (err)
            return done(err);
          if (err === false)
            return;
          task(next);
        }
        return next();
      }
      var forever$1 = awaitify(forever, 2);
      function groupByLimit(coll, limit, iteratee, callback) {
        var _iteratee = wrapAsync(iteratee);
        return mapLimit$1(coll, limit, (val, iterCb) => {
          _iteratee(val, (err, key) => {
            if (err)
              return iterCb(err);
            return iterCb(err, { key, val });
          });
        }, (err, mapResults) => {
          var result = {};
          var { hasOwnProperty } = Object.prototype;
          for (var i = 0; i < mapResults.length; i++) {
            if (mapResults[i]) {
              var { key } = mapResults[i];
              var { val } = mapResults[i];
              if (hasOwnProperty.call(result, key)) {
                result[key].push(val);
              } else {
                result[key] = [val];
              }
            }
          }
          return callback(err, result);
        });
      }
      var groupByLimit$1 = awaitify(groupByLimit, 4);
      function groupBy(coll, iteratee, callback) {
        return groupByLimit$1(coll, Infinity, iteratee, callback);
      }
      function groupBySeries(coll, iteratee, callback) {
        return groupByLimit$1(coll, 1, iteratee, callback);
      }
      var log = consoleFunc("log");
      function mapValuesLimit(obj2, limit, iteratee, callback) {
        callback = once(callback);
        var newObj = {};
        var _iteratee = wrapAsync(iteratee);
        return eachOfLimit$2(limit)(obj2, (val, key, next) => {
          _iteratee(val, key, (err, result) => {
            if (err)
              return next(err);
            newObj[key] = result;
            next(err);
          });
        }, (err) => callback(err, newObj));
      }
      var mapValuesLimit$1 = awaitify(mapValuesLimit, 4);
      function mapValues(obj2, iteratee, callback) {
        return mapValuesLimit$1(obj2, Infinity, iteratee, callback);
      }
      function mapValuesSeries(obj2, iteratee, callback) {
        return mapValuesLimit$1(obj2, 1, iteratee, callback);
      }
      function memoize(fn, hasher = (v) => v) {
        var memo = /* @__PURE__ */ Object.create(null);
        var queues = /* @__PURE__ */ Object.create(null);
        var _fn = wrapAsync(fn);
        var memoized = initialParams((args, callback) => {
          var key = hasher(...args);
          if (key in memo) {
            setImmediate$1(() => callback(null, ...memo[key]));
          } else if (key in queues) {
            queues[key].push(callback);
          } else {
            queues[key] = [callback];
            _fn(...args, (err, ...resultArgs) => {
              if (!err) {
                memo[key] = resultArgs;
              }
              var q = queues[key];
              delete queues[key];
              for (var i = 0, l2 = q.length; i < l2; i++) {
                q[i](err, ...resultArgs);
              }
            });
          }
        });
        memoized.memo = memo;
        memoized.unmemoized = fn;
        return memoized;
      }
      var _defer;
      if (hasNextTick) {
        _defer = process.nextTick;
      } else if (hasSetImmediate) {
        _defer = setImmediate;
      } else {
        _defer = fallback;
      }
      var nextTick = wrap(_defer);
      var _parallel = awaitify((eachfn, tasks, callback) => {
        var results = isArrayLike(tasks) ? [] : {};
        eachfn(tasks, (task, key, taskCb) => {
          wrapAsync(task)((err, ...result) => {
            if (result.length < 2) {
              [result] = result;
            }
            results[key] = result;
            taskCb(err);
          });
        }, (err) => callback(err, results));
      }, 3);
      function parallel(tasks, callback) {
        return _parallel(eachOf$1, tasks, callback);
      }
      function parallelLimit(tasks, limit, callback) {
        return _parallel(eachOfLimit$2(limit), tasks, callback);
      }
      function queue(worker, concurrency) {
        var _worker = wrapAsync(worker);
        return queue$1((items, cb) => {
          _worker(items[0], cb);
        }, concurrency, 1);
      }
      class Heap {
        constructor() {
          this.heap = [];
          this.pushCount = Number.MIN_SAFE_INTEGER;
        }
        get length() {
          return this.heap.length;
        }
        empty() {
          this.heap = [];
          return this;
        }
        percUp(index2) {
          let p;
          while (index2 > 0 && smaller(this.heap[index2], this.heap[p = parent(index2)])) {
            let t = this.heap[index2];
            this.heap[index2] = this.heap[p];
            this.heap[p] = t;
            index2 = p;
          }
        }
        percDown(index2) {
          let l2;
          while ((l2 = leftChi(index2)) < this.heap.length) {
            if (l2 + 1 < this.heap.length && smaller(this.heap[l2 + 1], this.heap[l2])) {
              l2 = l2 + 1;
            }
            if (smaller(this.heap[index2], this.heap[l2])) {
              break;
            }
            let t = this.heap[index2];
            this.heap[index2] = this.heap[l2];
            this.heap[l2] = t;
            index2 = l2;
          }
        }
        push(node) {
          node.pushCount = ++this.pushCount;
          this.heap.push(node);
          this.percUp(this.heap.length - 1);
        }
        unshift(node) {
          return this.heap.push(node);
        }
        shift() {
          let [top] = this.heap;
          this.heap[0] = this.heap[this.heap.length - 1];
          this.heap.pop();
          this.percDown(0);
          return top;
        }
        toArray() {
          return [...this];
        }
        *[Symbol.iterator]() {
          for (let i = 0; i < this.heap.length; i++) {
            yield this.heap[i].data;
          }
        }
        remove(testFn) {
          let j = 0;
          for (let i = 0; i < this.heap.length; i++) {
            if (!testFn(this.heap[i])) {
              this.heap[j] = this.heap[i];
              j++;
            }
          }
          this.heap.splice(j);
          for (let i = parent(this.heap.length - 1); i >= 0; i--) {
            this.percDown(i);
          }
          return this;
        }
      }
      function leftChi(i) {
        return (i << 1) + 1;
      }
      function parent(i) {
        return (i + 1 >> 1) - 1;
      }
      function smaller(x, y) {
        if (x.priority !== y.priority) {
          return x.priority < y.priority;
        } else {
          return x.pushCount < y.pushCount;
        }
      }
      function priorityQueue(worker, concurrency) {
        var q = queue(worker, concurrency);
        var {
          push,
          pushAsync
        } = q;
        q._tasks = new Heap();
        q._createTaskItem = ({ data, priority }, callback) => {
          return {
            data,
            priority,
            callback
          };
        };
        function createDataItems(tasks, priority) {
          if (!Array.isArray(tasks)) {
            return { data: tasks, priority };
          }
          return tasks.map((data) => {
            return { data, priority };
          });
        }
        q.push = function(data, priority = 0, callback) {
          return push(createDataItems(data, priority), callback);
        };
        q.pushAsync = function(data, priority = 0, callback) {
          return pushAsync(createDataItems(data, priority), callback);
        };
        delete q.unshift;
        delete q.unshiftAsync;
        return q;
      }
      function race(tasks, callback) {
        callback = once(callback);
        if (!Array.isArray(tasks))
          return callback(new TypeError("First argument to race must be an array of functions"));
        if (!tasks.length)
          return callback();
        for (var i = 0, l2 = tasks.length; i < l2; i++) {
          wrapAsync(tasks[i])(callback);
        }
      }
      var race$1 = awaitify(race, 2);
      function reduceRight(array, memo, iteratee, callback) {
        var reversed = [...array].reverse();
        return reduce$1(reversed, memo, iteratee, callback);
      }
      function reflect(fn) {
        var _fn = wrapAsync(fn);
        return initialParams(function reflectOn(args, reflectCallback) {
          args.push((error, ...cbArgs) => {
            let retVal = {};
            if (error) {
              retVal.error = error;
            }
            if (cbArgs.length > 0) {
              var value = cbArgs;
              if (cbArgs.length <= 1) {
                [value] = cbArgs;
              }
              retVal.value = value;
            }
            reflectCallback(null, retVal);
          });
          return _fn.apply(this, args);
        });
      }
      function reflectAll(tasks) {
        var results;
        if (Array.isArray(tasks)) {
          results = tasks.map(reflect);
        } else {
          results = {};
          Object.keys(tasks).forEach((key) => {
            results[key] = reflect.call(this, tasks[key]);
          });
        }
        return results;
      }
      function reject$2(eachfn, arr, _iteratee, callback) {
        const iteratee = wrapAsync(_iteratee);
        return _filter(eachfn, arr, (value, cb) => {
          iteratee(value, (err, v) => {
            cb(err, !v);
          });
        }, callback);
      }
      function reject(coll, iteratee, callback) {
        return reject$2(eachOf$1, coll, iteratee, callback);
      }
      var reject$1 = awaitify(reject, 3);
      function rejectLimit(coll, limit, iteratee, callback) {
        return reject$2(eachOfLimit$2(limit), coll, iteratee, callback);
      }
      var rejectLimit$1 = awaitify(rejectLimit, 4);
      function rejectSeries(coll, iteratee, callback) {
        return reject$2(eachOfSeries$1, coll, iteratee, callback);
      }
      var rejectSeries$1 = awaitify(rejectSeries, 3);
      function constant(value) {
        return function() {
          return value;
        };
      }
      const DEFAULT_TIMES = 5;
      const DEFAULT_INTERVAL = 0;
      function retry(opts, task, callback) {
        var options = {
          times: DEFAULT_TIMES,
          intervalFunc: constant(DEFAULT_INTERVAL)
        };
        if (arguments.length < 3 && typeof opts === "function") {
          callback = task || promiseCallback();
          task = opts;
        } else {
          parseTimes(options, opts);
          callback = callback || promiseCallback();
        }
        if (typeof task !== "function") {
          throw new Error("Invalid arguments for async.retry");
        }
        var _task = wrapAsync(task);
        var attempt = 1;
        function retryAttempt() {
          _task((err, ...args) => {
            if (err === false)
              return;
            if (err && attempt++ < options.times && (typeof options.errorFilter != "function" || options.errorFilter(err))) {
              setTimeout(retryAttempt, options.intervalFunc(attempt - 1));
            } else {
              callback(err, ...args);
            }
          });
        }
        retryAttempt();
        return callback[PROMISE_SYMBOL];
      }
      function parseTimes(acc, t) {
        if (typeof t === "object") {
          acc.times = +t.times || DEFAULT_TIMES;
          acc.intervalFunc = typeof t.interval === "function" ? t.interval : constant(+t.interval || DEFAULT_INTERVAL);
          acc.errorFilter = t.errorFilter;
        } else if (typeof t === "number" || typeof t === "string") {
          acc.times = +t || DEFAULT_TIMES;
        } else {
          throw new Error("Invalid arguments for async.retry");
        }
      }
      function retryable(opts, task) {
        if (!task) {
          task = opts;
          opts = null;
        }
        let arity = opts && opts.arity || task.length;
        if (isAsync(task)) {
          arity += 1;
        }
        var _task = wrapAsync(task);
        return initialParams((args, callback) => {
          if (args.length < arity - 1 || callback == null) {
            args.push(callback);
            callback = promiseCallback();
          }
          function taskFn(cb) {
            _task(...args, cb);
          }
          if (opts)
            retry(opts, taskFn, callback);
          else
            retry(taskFn, callback);
          return callback[PROMISE_SYMBOL];
        });
      }
      function series(tasks, callback) {
        return _parallel(eachOfSeries$1, tasks, callback);
      }
      function some(coll, iteratee, callback) {
        return _createTester(Boolean, (res) => res)(eachOf$1, coll, iteratee, callback);
      }
      var some$1 = awaitify(some, 3);
      function someLimit(coll, limit, iteratee, callback) {
        return _createTester(Boolean, (res) => res)(eachOfLimit$2(limit), coll, iteratee, callback);
      }
      var someLimit$1 = awaitify(someLimit, 4);
      function someSeries(coll, iteratee, callback) {
        return _createTester(Boolean, (res) => res)(eachOfSeries$1, coll, iteratee, callback);
      }
      var someSeries$1 = awaitify(someSeries, 3);
      function sortBy(coll, iteratee, callback) {
        var _iteratee = wrapAsync(iteratee);
        return map$1(coll, (x, iterCb) => {
          _iteratee(x, (err, criteria) => {
            if (err)
              return iterCb(err);
            iterCb(err, { value: x, criteria });
          });
        }, (err, results) => {
          if (err)
            return callback(err);
          callback(null, results.sort(comparator).map((v) => v.value));
        });
        function comparator(left, right) {
          var a = left.criteria, b = right.criteria;
          return a < b ? -1 : a > b ? 1 : 0;
        }
      }
      var sortBy$1 = awaitify(sortBy, 3);
      function timeout(asyncFn, milliseconds, info) {
        var fn = wrapAsync(asyncFn);
        return initialParams((args, callback) => {
          var timedOut = false;
          var timer;
          function timeoutCallback() {
            var name = asyncFn.name || "anonymous";
            var error = new Error('Callback function "' + name + '" timed out.');
            error.code = "ETIMEDOUT";
            if (info) {
              error.info = info;
            }
            timedOut = true;
            callback(error);
          }
          args.push((...cbArgs) => {
            if (!timedOut) {
              callback(...cbArgs);
              clearTimeout(timer);
            }
          });
          timer = setTimeout(timeoutCallback, milliseconds);
          fn(...args);
        });
      }
      function range(size) {
        var result = Array(size);
        while (size--) {
          result[size] = size;
        }
        return result;
      }
      function timesLimit(count, limit, iteratee, callback) {
        var _iteratee = wrapAsync(iteratee);
        return mapLimit$1(range(count), limit, _iteratee, callback);
      }
      function times(n, iteratee, callback) {
        return timesLimit(n, Infinity, iteratee, callback);
      }
      function timesSeries(n, iteratee, callback) {
        return timesLimit(n, 1, iteratee, callback);
      }
      function transform(coll, accumulator, iteratee, callback) {
        if (arguments.length <= 3 && typeof accumulator === "function") {
          callback = iteratee;
          iteratee = accumulator;
          accumulator = Array.isArray(coll) ? [] : {};
        }
        callback = once(callback || promiseCallback());
        var _iteratee = wrapAsync(iteratee);
        eachOf$1(coll, (v, k, cb) => {
          _iteratee(accumulator, v, k, cb);
        }, (err) => callback(err, accumulator));
        return callback[PROMISE_SYMBOL];
      }
      function tryEach(tasks, callback) {
        var error = null;
        var result;
        return eachSeries$1(tasks, (task, taskCb) => {
          wrapAsync(task)((err, ...args) => {
            if (err === false)
              return taskCb(err);
            if (args.length < 2) {
              [result] = args;
            } else {
              result = args;
            }
            error = err;
            taskCb(err ? null : {});
          });
        }, () => callback(error, result));
      }
      var tryEach$1 = awaitify(tryEach);
      function unmemoize(fn) {
        return (...args) => {
          return (fn.unmemoized || fn)(...args);
        };
      }
      function whilst(test, iteratee, callback) {
        callback = onlyOnce(callback);
        var _fn = wrapAsync(iteratee);
        var _test = wrapAsync(test);
        var results = [];
        function next(err, ...rest) {
          if (err)
            return callback(err);
          results = rest;
          if (err === false)
            return;
          _test(check);
        }
        function check(err, truth) {
          if (err)
            return callback(err);
          if (err === false)
            return;
          if (!truth)
            return callback(null, ...results);
          _fn(next);
        }
        return _test(check);
      }
      var whilst$1 = awaitify(whilst, 3);
      function until(test, iteratee, callback) {
        const _test = wrapAsync(test);
        return whilst$1((cb) => _test((err, truth) => cb(err, !truth)), iteratee, callback);
      }
      function waterfall(tasks, callback) {
        callback = once(callback);
        if (!Array.isArray(tasks))
          return callback(new Error("First argument to waterfall must be an array of functions"));
        if (!tasks.length)
          return callback();
        var taskIndex = 0;
        function nextTask(args) {
          var task = wrapAsync(tasks[taskIndex++]);
          task(...args, onlyOnce(next));
        }
        function next(err, ...args) {
          if (err === false)
            return;
          if (err || taskIndex === tasks.length) {
            return callback(err, ...args);
          }
          nextTask(args);
        }
        nextTask([]);
      }
      var waterfall$1 = awaitify(waterfall);
      var index = {
        apply,
        applyEach,
        applyEachSeries,
        asyncify,
        auto,
        autoInject,
        cargo: cargo$1,
        cargoQueue: cargo,
        compose,
        concat: concat$1,
        concatLimit: concatLimit$1,
        concatSeries: concatSeries$1,
        constant: constant$1,
        detect: detect$1,
        detectLimit: detectLimit$1,
        detectSeries: detectSeries$1,
        dir,
        doUntil,
        doWhilst: doWhilst$1,
        each,
        eachLimit: eachLimit$1,
        eachOf: eachOf$1,
        eachOfLimit: eachOfLimit$1,
        eachOfSeries: eachOfSeries$1,
        eachSeries: eachSeries$1,
        ensureAsync,
        every: every$1,
        everyLimit: everyLimit$1,
        everySeries: everySeries$1,
        filter: filter$1,
        filterLimit: filterLimit$1,
        filterSeries: filterSeries$1,
        forever: forever$1,
        groupBy,
        groupByLimit: groupByLimit$1,
        groupBySeries,
        log,
        map: map$1,
        mapLimit: mapLimit$1,
        mapSeries: mapSeries$1,
        mapValues,
        mapValuesLimit: mapValuesLimit$1,
        mapValuesSeries,
        memoize,
        nextTick,
        parallel,
        parallelLimit,
        priorityQueue,
        queue,
        race: race$1,
        reduce: reduce$1,
        reduceRight,
        reflect,
        reflectAll,
        reject: reject$1,
        rejectLimit: rejectLimit$1,
        rejectSeries: rejectSeries$1,
        retry,
        retryable,
        seq,
        series,
        setImmediate: setImmediate$1,
        some: some$1,
        someLimit: someLimit$1,
        someSeries: someSeries$1,
        sortBy: sortBy$1,
        timeout,
        times,
        timesLimit,
        timesSeries,
        transform,
        tryEach: tryEach$1,
        unmemoize,
        until,
        waterfall: waterfall$1,
        whilst: whilst$1,
        // aliases
        all: every$1,
        allLimit: everyLimit$1,
        allSeries: everySeries$1,
        any: some$1,
        anyLimit: someLimit$1,
        anySeries: someSeries$1,
        find: detect$1,
        findLimit: detectLimit$1,
        findSeries: detectSeries$1,
        flatMap: concat$1,
        flatMapLimit: concatLimit$1,
        flatMapSeries: concatSeries$1,
        forEach: each,
        forEachSeries: eachSeries$1,
        forEachLimit: eachLimit$1,
        forEachOf: eachOf$1,
        forEachOfSeries: eachOfSeries$1,
        forEachOfLimit: eachOfLimit$1,
        inject: reduce$1,
        foldl: reduce$1,
        foldr: reduceRight,
        select: filter$1,
        selectLimit: filterLimit$1,
        selectSeries: filterSeries$1,
        wrapSync: asyncify,
        during: whilst$1,
        doDuring: doWhilst$1
      };
      exports3.all = every$1;
      exports3.allLimit = everyLimit$1;
      exports3.allSeries = everySeries$1;
      exports3.any = some$1;
      exports3.anyLimit = someLimit$1;
      exports3.anySeries = someSeries$1;
      exports3.apply = apply;
      exports3.applyEach = applyEach;
      exports3.applyEachSeries = applyEachSeries;
      exports3.asyncify = asyncify;
      exports3.auto = auto;
      exports3.autoInject = autoInject;
      exports3.cargo = cargo$1;
      exports3.cargoQueue = cargo;
      exports3.compose = compose;
      exports3.concat = concat$1;
      exports3.concatLimit = concatLimit$1;
      exports3.concatSeries = concatSeries$1;
      exports3.constant = constant$1;
      exports3.default = index;
      exports3.detect = detect$1;
      exports3.detectLimit = detectLimit$1;
      exports3.detectSeries = detectSeries$1;
      exports3.dir = dir;
      exports3.doDuring = doWhilst$1;
      exports3.doUntil = doUntil;
      exports3.doWhilst = doWhilst$1;
      exports3.during = whilst$1;
      exports3.each = each;
      exports3.eachLimit = eachLimit$1;
      exports3.eachOf = eachOf$1;
      exports3.eachOfLimit = eachOfLimit$1;
      exports3.eachOfSeries = eachOfSeries$1;
      exports3.eachSeries = eachSeries$1;
      exports3.ensureAsync = ensureAsync;
      exports3.every = every$1;
      exports3.everyLimit = everyLimit$1;
      exports3.everySeries = everySeries$1;
      exports3.filter = filter$1;
      exports3.filterLimit = filterLimit$1;
      exports3.filterSeries = filterSeries$1;
      exports3.find = detect$1;
      exports3.findLimit = detectLimit$1;
      exports3.findSeries = detectSeries$1;
      exports3.flatMap = concat$1;
      exports3.flatMapLimit = concatLimit$1;
      exports3.flatMapSeries = concatSeries$1;
      exports3.foldl = reduce$1;
      exports3.foldr = reduceRight;
      exports3.forEach = each;
      exports3.forEachLimit = eachLimit$1;
      exports3.forEachOf = eachOf$1;
      exports3.forEachOfLimit = eachOfLimit$1;
      exports3.forEachOfSeries = eachOfSeries$1;
      exports3.forEachSeries = eachSeries$1;
      exports3.forever = forever$1;
      exports3.groupBy = groupBy;
      exports3.groupByLimit = groupByLimit$1;
      exports3.groupBySeries = groupBySeries;
      exports3.inject = reduce$1;
      exports3.log = log;
      exports3.map = map$1;
      exports3.mapLimit = mapLimit$1;
      exports3.mapSeries = mapSeries$1;
      exports3.mapValues = mapValues;
      exports3.mapValuesLimit = mapValuesLimit$1;
      exports3.mapValuesSeries = mapValuesSeries;
      exports3.memoize = memoize;
      exports3.nextTick = nextTick;
      exports3.parallel = parallel;
      exports3.parallelLimit = parallelLimit;
      exports3.priorityQueue = priorityQueue;
      exports3.queue = queue;
      exports3.race = race$1;
      exports3.reduce = reduce$1;
      exports3.reduceRight = reduceRight;
      exports3.reflect = reflect;
      exports3.reflectAll = reflectAll;
      exports3.reject = reject$1;
      exports3.rejectLimit = rejectLimit$1;
      exports3.rejectSeries = rejectSeries$1;
      exports3.retry = retry;
      exports3.retryable = retryable;
      exports3.select = filter$1;
      exports3.selectLimit = filterLimit$1;
      exports3.selectSeries = filterSeries$1;
      exports3.seq = seq;
      exports3.series = series;
      exports3.setImmediate = setImmediate$1;
      exports3.some = some$1;
      exports3.someLimit = someLimit$1;
      exports3.someSeries = someSeries$1;
      exports3.sortBy = sortBy$1;
      exports3.timeout = timeout;
      exports3.times = times;
      exports3.timesLimit = timesLimit;
      exports3.timesSeries = timesSeries;
      exports3.transform = transform;
      exports3.tryEach = tryEach$1;
      exports3.unmemoize = unmemoize;
      exports3.until = until;
      exports3.waterfall = waterfall$1;
      exports3.whilst = whilst$1;
      exports3.wrapSync = asyncify;
      Object.defineProperty(exports3, "__esModule", { value: true });
    });
  }
});

// ../../../node_modules/graceful-fs/polyfills.js
var require_polyfills = __commonJS({
  "../../../node_modules/graceful-fs/polyfills.js"(exports2, module2) {
    var constants = require("constants");
    var origCwd = process.cwd;
    var cwd = null;
    var platform = process.env.GRACEFUL_FS_PLATFORM || process.platform;
    process.cwd = function() {
      if (!cwd)
        cwd = origCwd.call(process);
      return cwd;
    };
    try {
      process.cwd();
    } catch (er) {
    }
    if (typeof process.chdir === "function") {
      chdir = process.chdir;
      process.chdir = function(d) {
        cwd = null;
        chdir.call(process, d);
      };
      if (Object.setPrototypeOf)
        Object.setPrototypeOf(process.chdir, chdir);
    }
    var chdir;
    module2.exports = patch;
    function patch(fs) {
      if (constants.hasOwnProperty("O_SYMLINK") && process.version.match(/^v0\.6\.[0-2]|^v0\.5\./)) {
        patchLchmod(fs);
      }
      if (!fs.lutimes) {
        patchLutimes(fs);
      }
      fs.chown = chownFix(fs.chown);
      fs.fchown = chownFix(fs.fchown);
      fs.lchown = chownFix(fs.lchown);
      fs.chmod = chmodFix(fs.chmod);
      fs.fchmod = chmodFix(fs.fchmod);
      fs.lchmod = chmodFix(fs.lchmod);
      fs.chownSync = chownFixSync(fs.chownSync);
      fs.fchownSync = chownFixSync(fs.fchownSync);
      fs.lchownSync = chownFixSync(fs.lchownSync);
      fs.chmodSync = chmodFixSync(fs.chmodSync);
      fs.fchmodSync = chmodFixSync(fs.fchmodSync);
      fs.lchmodSync = chmodFixSync(fs.lchmodSync);
      fs.stat = statFix(fs.stat);
      fs.fstat = statFix(fs.fstat);
      fs.lstat = statFix(fs.lstat);
      fs.statSync = statFixSync(fs.statSync);
      fs.fstatSync = statFixSync(fs.fstatSync);
      fs.lstatSync = statFixSync(fs.lstatSync);
      if (fs.chmod && !fs.lchmod) {
        fs.lchmod = function(path, mode, cb) {
          if (cb)
            process.nextTick(cb);
        };
        fs.lchmodSync = function() {
        };
      }
      if (fs.chown && !fs.lchown) {
        fs.lchown = function(path, uid, gid, cb) {
          if (cb)
            process.nextTick(cb);
        };
        fs.lchownSync = function() {
        };
      }
      if (platform === "win32") {
        fs.rename = typeof fs.rename !== "function" ? fs.rename : function(fs$rename) {
          function rename(from, to, cb) {
            var start = Date.now();
            var backoff = 0;
            fs$rename(from, to, function CB(er) {
              if (er && (er.code === "EACCES" || er.code === "EPERM" || er.code === "EBUSY") && Date.now() - start < 6e4) {
                setTimeout(function() {
                  fs.stat(to, function(stater, st) {
                    if (stater && stater.code === "ENOENT")
                      fs$rename(from, to, CB);
                    else
                      cb(er);
                  });
                }, backoff);
                if (backoff < 100)
                  backoff += 10;
                return;
              }
              if (cb)
                cb(er);
            });
          }
          if (Object.setPrototypeOf)
            Object.setPrototypeOf(rename, fs$rename);
          return rename;
        }(fs.rename);
      }
      fs.read = typeof fs.read !== "function" ? fs.read : function(fs$read) {
        function read(fd, buffer, offset, length, position, callback_) {
          var callback;
          if (callback_ && typeof callback_ === "function") {
            var eagCounter = 0;
            callback = function(er, _2, __) {
              if (er && er.code === "EAGAIN" && eagCounter < 10) {
                eagCounter++;
                return fs$read.call(fs, fd, buffer, offset, length, position, callback);
              }
              callback_.apply(this, arguments);
            };
          }
          return fs$read.call(fs, fd, buffer, offset, length, position, callback);
        }
        if (Object.setPrototypeOf)
          Object.setPrototypeOf(read, fs$read);
        return read;
      }(fs.read);
      fs.readSync = typeof fs.readSync !== "function" ? fs.readSync : /* @__PURE__ */ function(fs$readSync) {
        return function(fd, buffer, offset, length, position) {
          var eagCounter = 0;
          while (true) {
            try {
              return fs$readSync.call(fs, fd, buffer, offset, length, position);
            } catch (er) {
              if (er.code === "EAGAIN" && eagCounter < 10) {
                eagCounter++;
                continue;
              }
              throw er;
            }
          }
        };
      }(fs.readSync);
      function patchLchmod(fs2) {
        fs2.lchmod = function(path, mode, callback) {
          fs2.open(
            path,
            constants.O_WRONLY | constants.O_SYMLINK,
            mode,
            function(err, fd) {
              if (err) {
                if (callback)
                  callback(err);
                return;
              }
              fs2.fchmod(fd, mode, function(err2) {
                fs2.close(fd, function(err22) {
                  if (callback)
                    callback(err2 || err22);
                });
              });
            }
          );
        };
        fs2.lchmodSync = function(path, mode) {
          var fd = fs2.openSync(path, constants.O_WRONLY | constants.O_SYMLINK, mode);
          var threw = true;
          var ret2;
          try {
            ret2 = fs2.fchmodSync(fd, mode);
            threw = false;
          } finally {
            if (threw) {
              try {
                fs2.closeSync(fd);
              } catch (er) {
              }
            } else {
              fs2.closeSync(fd);
            }
          }
          return ret2;
        };
      }
      function patchLutimes(fs2) {
        if (constants.hasOwnProperty("O_SYMLINK") && fs2.futimes) {
          fs2.lutimes = function(path, at, mt, cb) {
            fs2.open(path, constants.O_SYMLINK, function(er, fd) {
              if (er) {
                if (cb)
                  cb(er);
                return;
              }
              fs2.futimes(fd, at, mt, function(er2) {
                fs2.close(fd, function(er22) {
                  if (cb)
                    cb(er2 || er22);
                });
              });
            });
          };
          fs2.lutimesSync = function(path, at, mt) {
            var fd = fs2.openSync(path, constants.O_SYMLINK);
            var ret2;
            var threw = true;
            try {
              ret2 = fs2.futimesSync(fd, at, mt);
              threw = false;
            } finally {
              if (threw) {
                try {
                  fs2.closeSync(fd);
                } catch (er) {
                }
              } else {
                fs2.closeSync(fd);
              }
            }
            return ret2;
          };
        } else if (fs2.futimes) {
          fs2.lutimes = function(_a, _b, _c, cb) {
            if (cb)
              process.nextTick(cb);
          };
          fs2.lutimesSync = function() {
          };
        }
      }
      function chmodFix(orig) {
        if (!orig)
          return orig;
        return function(target, mode, cb) {
          return orig.call(fs, target, mode, function(er) {
            if (chownErOk(er))
              er = null;
            if (cb)
              cb.apply(this, arguments);
          });
        };
      }
      function chmodFixSync(orig) {
        if (!orig)
          return orig;
        return function(target, mode) {
          try {
            return orig.call(fs, target, mode);
          } catch (er) {
            if (!chownErOk(er))
              throw er;
          }
        };
      }
      function chownFix(orig) {
        if (!orig)
          return orig;
        return function(target, uid, gid, cb) {
          return orig.call(fs, target, uid, gid, function(er) {
            if (chownErOk(er))
              er = null;
            if (cb)
              cb.apply(this, arguments);
          });
        };
      }
      function chownFixSync(orig) {
        if (!orig)
          return orig;
        return function(target, uid, gid) {
          try {
            return orig.call(fs, target, uid, gid);
          } catch (er) {
            if (!chownErOk(er))
              throw er;
          }
        };
      }
      function statFix(orig) {
        if (!orig)
          return orig;
        return function(target, options, cb) {
          if (typeof options === "function") {
            cb = options;
            options = null;
          }
          function callback(er, stats) {
            if (stats) {
              if (stats.uid < 0)
                stats.uid += 4294967296;
              if (stats.gid < 0)
                stats.gid += 4294967296;
            }
            if (cb)
              cb.apply(this, arguments);
          }
          return options ? orig.call(fs, target, options, callback) : orig.call(fs, target, callback);
        };
      }
      function statFixSync(orig) {
        if (!orig)
          return orig;
        return function(target, options) {
          var stats = options ? orig.call(fs, target, options) : orig.call(fs, target);
          if (stats) {
            if (stats.uid < 0)
              stats.uid += 4294967296;
            if (stats.gid < 0)
              stats.gid += 4294967296;
          }
          return stats;
        };
      }
      function chownErOk(er) {
        if (!er)
          return true;
        if (er.code === "ENOSYS")
          return true;
        var nonroot = !process.getuid || process.getuid() !== 0;
        if (nonroot) {
          if (er.code === "EINVAL" || er.code === "EPERM")
            return true;
        }
        return false;
      }
    }
  }
});

// ../../../node_modules/graceful-fs/legacy-streams.js
var require_legacy_streams = __commonJS({
  "../../../node_modules/graceful-fs/legacy-streams.js"(exports2, module2) {
    var Stream = require("stream").Stream;
    module2.exports = legacy;
    function legacy(fs) {
      return {
        ReadStream,
        WriteStream
      };
      function ReadStream(path, options) {
        if (!(this instanceof ReadStream))
          return new ReadStream(path, options);
        Stream.call(this);
        var self2 = this;
        this.path = path;
        this.fd = null;
        this.readable = true;
        this.paused = false;
        this.flags = "r";
        this.mode = 438;
        this.bufferSize = 64 * 1024;
        options = options || {};
        var keys = Object.keys(options);
        for (var index = 0, length = keys.length; index < length; index++) {
          var key = keys[index];
          this[key] = options[key];
        }
        if (this.encoding)
          this.setEncoding(this.encoding);
        if (this.start !== void 0) {
          if ("number" !== typeof this.start) {
            throw TypeError("start must be a Number");
          }
          if (this.end === void 0) {
            this.end = Infinity;
          } else if ("number" !== typeof this.end) {
            throw TypeError("end must be a Number");
          }
          if (this.start > this.end) {
            throw new Error("start must be <= end");
          }
          this.pos = this.start;
        }
        if (this.fd !== null) {
          process.nextTick(function() {
            self2._read();
          });
          return;
        }
        fs.open(this.path, this.flags, this.mode, function(err, fd) {
          if (err) {
            self2.emit("error", err);
            self2.readable = false;
            return;
          }
          self2.fd = fd;
          self2.emit("open", fd);
          self2._read();
        });
      }
      function WriteStream(path, options) {
        if (!(this instanceof WriteStream))
          return new WriteStream(path, options);
        Stream.call(this);
        this.path = path;
        this.fd = null;
        this.writable = true;
        this.flags = "w";
        this.encoding = "binary";
        this.mode = 438;
        this.bytesWritten = 0;
        options = options || {};
        var keys = Object.keys(options);
        for (var index = 0, length = keys.length; index < length; index++) {
          var key = keys[index];
          this[key] = options[key];
        }
        if (this.start !== void 0) {
          if ("number" !== typeof this.start) {
            throw TypeError("start must be a Number");
          }
          if (this.start < 0) {
            throw new Error("start must be >= zero");
          }
          this.pos = this.start;
        }
        this.busy = false;
        this._queue = [];
        if (this.fd === null) {
          this._open = fs.open;
          this._queue.push([this._open, this.path, this.flags, this.mode, void 0]);
          this.flush();
        }
      }
    }
  }
});

// ../../../node_modules/graceful-fs/clone.js
var require_clone = __commonJS({
  "../../../node_modules/graceful-fs/clone.js"(exports2, module2) {
    "use strict";
    module2.exports = clone;
    var getPrototypeOf = Object.getPrototypeOf || function(obj2) {
      return obj2.__proto__;
    };
    function clone(obj2) {
      if (obj2 === null || typeof obj2 !== "object")
        return obj2;
      if (obj2 instanceof Object)
        var copy = { __proto__: getPrototypeOf(obj2) };
      else
        var copy = /* @__PURE__ */ Object.create(null);
      Object.getOwnPropertyNames(obj2).forEach(function(key) {
        Object.defineProperty(copy, key, Object.getOwnPropertyDescriptor(obj2, key));
      });
      return copy;
    }
  }
});

// ../../../node_modules/graceful-fs/graceful-fs.js
var require_graceful_fs = __commonJS({
  "../../../node_modules/graceful-fs/graceful-fs.js"(exports2, module2) {
    var fs = require("fs");
    var polyfills = require_polyfills();
    var legacy = require_legacy_streams();
    var clone = require_clone();
    var util = require("util");
    var gracefulQueue;
    var previousSymbol;
    if (typeof Symbol === "function" && typeof Symbol.for === "function") {
      gracefulQueue = Symbol.for("graceful-fs.queue");
      previousSymbol = Symbol.for("graceful-fs.previous");
    } else {
      gracefulQueue = "___graceful-fs.queue";
      previousSymbol = "___graceful-fs.previous";
    }
    function noop() {
    }
    function publishQueue(context, queue2) {
      Object.defineProperty(context, gracefulQueue, {
        get: function() {
          return queue2;
        }
      });
    }
    var debug = noop;
    if (util.debuglog)
      debug = util.debuglog("gfs4");
    else if (/\bgfs4\b/i.test(process.env.NODE_DEBUG || ""))
      debug = function() {
        var m = util.format.apply(util, arguments);
        m = "GFS4: " + m.split(/\n/).join("\nGFS4: ");
        console.error(m);
      };
    if (!fs[gracefulQueue]) {
      queue = global[gracefulQueue] || [];
      publishQueue(fs, queue);
      fs.close = function(fs$close) {
        function close(fd, cb) {
          return fs$close.call(fs, fd, function(err) {
            if (!err) {
              resetQueue();
            }
            if (typeof cb === "function")
              cb.apply(this, arguments);
          });
        }
        Object.defineProperty(close, previousSymbol, {
          value: fs$close
        });
        return close;
      }(fs.close);
      fs.closeSync = function(fs$closeSync) {
        function closeSync(fd) {
          fs$closeSync.apply(fs, arguments);
          resetQueue();
        }
        Object.defineProperty(closeSync, previousSymbol, {
          value: fs$closeSync
        });
        return closeSync;
      }(fs.closeSync);
      if (/\bgfs4\b/i.test(process.env.NODE_DEBUG || "")) {
        process.on("exit", function() {
          debug(fs[gracefulQueue]);
          require("assert").equal(fs[gracefulQueue].length, 0);
        });
      }
    }
    var queue;
    if (!global[gracefulQueue]) {
      publishQueue(global, fs[gracefulQueue]);
    }
    module2.exports = patch(clone(fs));
    if (process.env.TEST_GRACEFUL_FS_GLOBAL_PATCH && !fs.__patched) {
      module2.exports = patch(fs);
      fs.__patched = true;
    }
    function patch(fs2) {
      polyfills(fs2);
      fs2.gracefulify = patch;
      fs2.createReadStream = createReadStream;
      fs2.createWriteStream = createWriteStream;
      var fs$readFile = fs2.readFile;
      fs2.readFile = readFile;
      function readFile(path, options, cb) {
        if (typeof options === "function")
          cb = options, options = null;
        return go$readFile(path, options, cb);
        function go$readFile(path2, options2, cb2, startTime) {
          return fs$readFile(path2, options2, function(err) {
            if (err && (err.code === "EMFILE" || err.code === "ENFILE"))
              enqueue([go$readFile, [path2, options2, cb2], err, startTime || Date.now(), Date.now()]);
            else {
              if (typeof cb2 === "function")
                cb2.apply(this, arguments);
            }
          });
        }
      }
      var fs$writeFile = fs2.writeFile;
      fs2.writeFile = writeFile;
      function writeFile(path, data, options, cb) {
        if (typeof options === "function")
          cb = options, options = null;
        return go$writeFile(path, data, options, cb);
        function go$writeFile(path2, data2, options2, cb2, startTime) {
          return fs$writeFile(path2, data2, options2, function(err) {
            if (err && (err.code === "EMFILE" || err.code === "ENFILE"))
              enqueue([go$writeFile, [path2, data2, options2, cb2], err, startTime || Date.now(), Date.now()]);
            else {
              if (typeof cb2 === "function")
                cb2.apply(this, arguments);
            }
          });
        }
      }
      var fs$appendFile = fs2.appendFile;
      if (fs$appendFile)
        fs2.appendFile = appendFile;
      function appendFile(path, data, options, cb) {
        if (typeof options === "function")
          cb = options, options = null;
        return go$appendFile(path, data, options, cb);
        function go$appendFile(path2, data2, options2, cb2, startTime) {
          return fs$appendFile(path2, data2, options2, function(err) {
            if (err && (err.code === "EMFILE" || err.code === "ENFILE"))
              enqueue([go$appendFile, [path2, data2, options2, cb2], err, startTime || Date.now(), Date.now()]);
            else {
              if (typeof cb2 === "function")
                cb2.apply(this, arguments);
            }
          });
        }
      }
      var fs$copyFile = fs2.copyFile;
      if (fs$copyFile)
        fs2.copyFile = copyFile;
      function copyFile(src, dest, flags, cb) {
        if (typeof flags === "function") {
          cb = flags;
          flags = 0;
        }
        return go$copyFile(src, dest, flags, cb);
        function go$copyFile(src2, dest2, flags2, cb2, startTime) {
          return fs$copyFile(src2, dest2, flags2, function(err) {
            if (err && (err.code === "EMFILE" || err.code === "ENFILE"))
              enqueue([go$copyFile, [src2, dest2, flags2, cb2], err, startTime || Date.now(), Date.now()]);
            else {
              if (typeof cb2 === "function")
                cb2.apply(this, arguments);
            }
          });
        }
      }
      var fs$readdir = fs2.readdir;
      fs2.readdir = readdir;
      var noReaddirOptionVersions = /^v[0-5]\./;
      function readdir(path, options, cb) {
        if (typeof options === "function")
          cb = options, options = null;
        var go$readdir = noReaddirOptionVersions.test(process.version) ? function go$readdir2(path2, options2, cb2, startTime) {
          return fs$readdir(path2, fs$readdirCallback(
            path2,
            options2,
            cb2,
            startTime
          ));
        } : function go$readdir2(path2, options2, cb2, startTime) {
          return fs$readdir(path2, options2, fs$readdirCallback(
            path2,
            options2,
            cb2,
            startTime
          ));
        };
        return go$readdir(path, options, cb);
        function fs$readdirCallback(path2, options2, cb2, startTime) {
          return function(err, files) {
            if (err && (err.code === "EMFILE" || err.code === "ENFILE"))
              enqueue([
                go$readdir,
                [path2, options2, cb2],
                err,
                startTime || Date.now(),
                Date.now()
              ]);
            else {
              if (files && files.sort)
                files.sort();
              if (typeof cb2 === "function")
                cb2.call(this, err, files);
            }
          };
        }
      }
      if (process.version.substr(0, 4) === "v0.8") {
        var legStreams = legacy(fs2);
        ReadStream = legStreams.ReadStream;
        WriteStream = legStreams.WriteStream;
      }
      var fs$ReadStream = fs2.ReadStream;
      if (fs$ReadStream) {
        ReadStream.prototype = Object.create(fs$ReadStream.prototype);
        ReadStream.prototype.open = ReadStream$open;
      }
      var fs$WriteStream = fs2.WriteStream;
      if (fs$WriteStream) {
        WriteStream.prototype = Object.create(fs$WriteStream.prototype);
        WriteStream.prototype.open = WriteStream$open;
      }
      Object.defineProperty(fs2, "ReadStream", {
        get: function() {
          return ReadStream;
        },
        set: function(val) {
          ReadStream = val;
        },
        enumerable: true,
        configurable: true
      });
      Object.defineProperty(fs2, "WriteStream", {
        get: function() {
          return WriteStream;
        },
        set: function(val) {
          WriteStream = val;
        },
        enumerable: true,
        configurable: true
      });
      var FileReadStream = ReadStream;
      Object.defineProperty(fs2, "FileReadStream", {
        get: function() {
          return FileReadStream;
        },
        set: function(val) {
          FileReadStream = val;
        },
        enumerable: true,
        configurable: true
      });
      var FileWriteStream = WriteStream;
      Object.defineProperty(fs2, "FileWriteStream", {
        get: function() {
          return FileWriteStream;
        },
        set: function(val) {
          FileWriteStream = val;
        },
        enumerable: true,
        configurable: true
      });
      function ReadStream(path, options) {
        if (this instanceof ReadStream)
          return fs$ReadStream.apply(this, arguments), this;
        else
          return ReadStream.apply(Object.create(ReadStream.prototype), arguments);
      }
      function ReadStream$open() {
        var that = this;
        open(that.path, that.flags, that.mode, function(err, fd) {
          if (err) {
            if (that.autoClose)
              that.destroy();
            that.emit("error", err);
          } else {
            that.fd = fd;
            that.emit("open", fd);
            that.read();
          }
        });
      }
      function WriteStream(path, options) {
        if (this instanceof WriteStream)
          return fs$WriteStream.apply(this, arguments), this;
        else
          return WriteStream.apply(Object.create(WriteStream.prototype), arguments);
      }
      function WriteStream$open() {
        var that = this;
        open(that.path, that.flags, that.mode, function(err, fd) {
          if (err) {
            that.destroy();
            that.emit("error", err);
          } else {
            that.fd = fd;
            that.emit("open", fd);
          }
        });
      }
      function createReadStream(path, options) {
        return new fs2.ReadStream(path, options);
      }
      function createWriteStream(path, options) {
        return new fs2.WriteStream(path, options);
      }
      var fs$open = fs2.open;
      fs2.open = open;
      function open(path, flags, mode, cb) {
        if (typeof mode === "function")
          cb = mode, mode = null;
        return go$open(path, flags, mode, cb);
        function go$open(path2, flags2, mode2, cb2, startTime) {
          return fs$open(path2, flags2, mode2, function(err, fd) {
            if (err && (err.code === "EMFILE" || err.code === "ENFILE"))
              enqueue([go$open, [path2, flags2, mode2, cb2], err, startTime || Date.now(), Date.now()]);
            else {
              if (typeof cb2 === "function")
                cb2.apply(this, arguments);
            }
          });
        }
      }
      return fs2;
    }
    function enqueue(elem) {
      debug("ENQUEUE", elem[0].name, elem[1]);
      fs[gracefulQueue].push(elem);
      retry();
    }
    var retryTimer;
    function resetQueue() {
      var now = Date.now();
      for (var i = 0; i < fs[gracefulQueue].length; ++i) {
        if (fs[gracefulQueue][i].length > 2) {
          fs[gracefulQueue][i][3] = now;
          fs[gracefulQueue][i][4] = now;
        }
      }
      retry();
    }
    function retry() {
      clearTimeout(retryTimer);
      retryTimer = void 0;
      if (fs[gracefulQueue].length === 0)
        return;
      var elem = fs[gracefulQueue].shift();
      var fn = elem[0];
      var args = elem[1];
      var err = elem[2];
      var startTime = elem[3];
      var lastTime = elem[4];
      if (startTime === void 0) {
        debug("RETRY", fn.name, args);
        fn.apply(null, args);
      } else if (Date.now() - startTime >= 6e4) {
        debug("TIMEOUT", fn.name, args);
        var cb = args.pop();
        if (typeof cb === "function")
          cb.call(null, err);
      } else {
        var sinceAttempt = Date.now() - lastTime;
        var sinceStart = Math.max(lastTime - startTime, 1);
        var desiredDelay = Math.min(sinceStart * 1.2, 100);
        if (sinceAttempt >= desiredDelay) {
          debug("RETRY", fn.name, args);
          fn.apply(null, args.concat([startTime]));
        } else {
          fs[gracefulQueue].push(elem);
        }
      }
      if (retryTimer === void 0) {
        retryTimer = setTimeout(retry, 0);
      }
    }
  }
});

// ../../../node_modules/lazystream/node_modules/isarray/index.js
var require_isarray2 = __commonJS({
  "../../../node_modules/lazystream/node_modules/isarray/index.js"(exports2, module2) {
    var toString = {}.toString;
    module2.exports = Array.isArray || function(arr) {
      return toString.call(arr) == "[object Array]";
    };
  }
});

// ../../../node_modules/lazystream/node_modules/readable-stream/lib/internal/streams/stream.js
var require_stream3 = __commonJS({
  "../../../node_modules/lazystream/node_modules/readable-stream/lib/internal/streams/stream.js"(exports2, module2) {
    module2.exports = require("stream");
  }
});

// ../../../node_modules/lazystream/node_modules/safe-buffer/index.js
var require_safe_buffer3 = __commonJS({
  "../../../node_modules/lazystream/node_modules/safe-buffer/index.js"(exports2, module2) {
    var buffer = require("buffer");
    var Buffer2 = buffer.Buffer;
    function copyProps(src, dst) {
      for (var key in src) {
        dst[key] = src[key];
      }
    }
    if (Buffer2.from && Buffer2.alloc && Buffer2.allocUnsafe && Buffer2.allocUnsafeSlow) {
      module2.exports = buffer;
    } else {
      copyProps(buffer, exports2);
      exports2.Buffer = SafeBuffer;
    }
    function SafeBuffer(arg, encodingOrOffset, length) {
      return Buffer2(arg, encodingOrOffset, length);
    }
    copyProps(Buffer2, SafeBuffer);
    SafeBuffer.from = function(arg, encodingOrOffset, length) {
      if (typeof arg === "number") {
        throw new TypeError("Argument must not be a number");
      }
      return Buffer2(arg, encodingOrOffset, length);
    };
    SafeBuffer.alloc = function(size, fill, encoding) {
      if (typeof size !== "number") {
        throw new TypeError("Argument must be a number");
      }
      var buf = Buffer2(size);
      if (fill !== void 0) {
        if (typeof encoding === "string") {
          buf.fill(fill, encoding);
        } else {
          buf.fill(fill);
        }
      } else {
        buf.fill(0);
      }
      return buf;
    };
    SafeBuffer.allocUnsafe = function(size) {
      if (typeof size !== "number") {
        throw new TypeError("Argument must be a number");
      }
      return Buffer2(size);
    };
    SafeBuffer.allocUnsafeSlow = function(size) {
      if (typeof size !== "number") {
        throw new TypeError("Argument must be a number");
      }
      return buffer.SlowBuffer(size);
    };
  }
});

// ../../../node_modules/lazystream/node_modules/readable-stream/lib/internal/streams/BufferList.js
var require_BufferList2 = __commonJS({
  "../../../node_modules/lazystream/node_modules/readable-stream/lib/internal/streams/BufferList.js"(exports2, module2) {
    "use strict";
    function _classCallCheck(instance, Constructor) {
      if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
      }
    }
    var Buffer2 = require_safe_buffer3().Buffer;
    var util = require("util");
    function copyBuffer(src, target, offset) {
      src.copy(target, offset);
    }
    module2.exports = function() {
      function BufferList() {
        _classCallCheck(this, BufferList);
        this.head = null;
        this.tail = null;
        this.length = 0;
      }
      BufferList.prototype.push = function push(v) {
        var entry = { data: v, next: null };
        if (this.length > 0)
          this.tail.next = entry;
        else
          this.head = entry;
        this.tail = entry;
        ++this.length;
      };
      BufferList.prototype.unshift = function unshift(v) {
        var entry = { data: v, next: this.head };
        if (this.length === 0)
          this.tail = entry;
        this.head = entry;
        ++this.length;
      };
      BufferList.prototype.shift = function shift() {
        if (this.length === 0)
          return;
        var ret2 = this.head.data;
        if (this.length === 1)
          this.head = this.tail = null;
        else
          this.head = this.head.next;
        --this.length;
        return ret2;
      };
      BufferList.prototype.clear = function clear() {
        this.head = this.tail = null;
        this.length = 0;
      };
      BufferList.prototype.join = function join(s) {
        if (this.length === 0)
          return "";
        var p = this.head;
        var ret2 = "" + p.data;
        while (p = p.next) {
          ret2 += s + p.data;
        }
        return ret2;
      };
      BufferList.prototype.concat = function concat(n) {
        if (this.length === 0)
          return Buffer2.alloc(0);
        var ret2 = Buffer2.allocUnsafe(n >>> 0);
        var p = this.head;
        var i = 0;
        while (p) {
          copyBuffer(p.data, ret2, i);
          i += p.data.length;
          p = p.next;
        }
        return ret2;
      };
      return BufferList;
    }();
    if (util && util.inspect && util.inspect.custom) {
      module2.exports.prototype[util.inspect.custom] = function() {
        var obj2 = util.inspect({ length: this.length });
        return this.constructor.name + " " + obj2;
      };
    }
  }
});

// ../../../node_modules/lazystream/node_modules/readable-stream/lib/internal/streams/destroy.js
var require_destroy3 = __commonJS({
  "../../../node_modules/lazystream/node_modules/readable-stream/lib/internal/streams/destroy.js"(exports2, module2) {
    "use strict";
    var pna = require_process_nextick_args();
    function destroy(err, cb) {
      var _this = this;
      var readableDestroyed = this._readableState && this._readableState.destroyed;
      var writableDestroyed = this._writableState && this._writableState.destroyed;
      if (readableDestroyed || writableDestroyed) {
        if (cb) {
          cb(err);
        } else if (err) {
          if (!this._writableState) {
            pna.nextTick(emitErrorNT, this, err);
          } else if (!this._writableState.errorEmitted) {
            this._writableState.errorEmitted = true;
            pna.nextTick(emitErrorNT, this, err);
          }
        }
        return this;
      }
      if (this._readableState) {
        this._readableState.destroyed = true;
      }
      if (this._writableState) {
        this._writableState.destroyed = true;
      }
      this._destroy(err || null, function(err2) {
        if (!cb && err2) {
          if (!_this._writableState) {
            pna.nextTick(emitErrorNT, _this, err2);
          } else if (!_this._writableState.errorEmitted) {
            _this._writableState.errorEmitted = true;
            pna.nextTick(emitErrorNT, _this, err2);
          }
        } else if (cb) {
          cb(err2);
        }
      });
      return this;
    }
    function undestroy() {
      if (this._readableState) {
        this._readableState.destroyed = false;
        this._readableState.reading = false;
        this._readableState.ended = false;
        this._readableState.endEmitted = false;
      }
      if (this._writableState) {
        this._writableState.destroyed = false;
        this._writableState.ended = false;
        this._writableState.ending = false;
        this._writableState.finalCalled = false;
        this._writableState.prefinished = false;
        this._writableState.finished = false;
        this._writableState.errorEmitted = false;
      }
    }
    function emitErrorNT(self2, err) {
      self2.emit("error", err);
    }
    module2.exports = {
      destroy,
      undestroy
    };
  }
});

// ../../../node_modules/lazystream/node_modules/readable-stream/lib/_stream_writable.js
var require_stream_writable3 = __commonJS({
  "../../../node_modules/lazystream/node_modules/readable-stream/lib/_stream_writable.js"(exports2, module2) {
    "use strict";
    var pna = require_process_nextick_args();
    module2.exports = Writable;
    function CorkedRequest(state) {
      var _this = this;
      this.next = null;
      this.entry = null;
      this.finish = function() {
        onCorkedFinish(_this, state);
      };
    }
    var asyncWrite = !process.browser && ["v0.10", "v0.9."].indexOf(process.version.slice(0, 5)) > -1 ? setImmediate : pna.nextTick;
    var Duplex;
    Writable.WritableState = WritableState;
    var util = Object.create(require_util());
    util.inherits = require_inherits();
    var internalUtil = {
      deprecate: require_node()
    };
    var Stream = require_stream3();
    var Buffer2 = require_safe_buffer3().Buffer;
    var OurUint8Array = (typeof global !== "undefined" ? global : typeof window !== "undefined" ? window : typeof self !== "undefined" ? self : {}).Uint8Array || function() {
    };
    function _uint8ArrayToBuffer(chunk) {
      return Buffer2.from(chunk);
    }
    function _isUint8Array(obj2) {
      return Buffer2.isBuffer(obj2) || obj2 instanceof OurUint8Array;
    }
    var destroyImpl = require_destroy3();
    util.inherits(Writable, Stream);
    function nop() {
    }
    function WritableState(options, stream) {
      Duplex = Duplex || require_stream_duplex3();
      options = options || {};
      var isDuplex = stream instanceof Duplex;
      this.objectMode = !!options.objectMode;
      if (isDuplex)
        this.objectMode = this.objectMode || !!options.writableObjectMode;
      var hwm = options.highWaterMark;
      var writableHwm = options.writableHighWaterMark;
      var defaultHwm = this.objectMode ? 16 : 16 * 1024;
      if (hwm || hwm === 0)
        this.highWaterMark = hwm;
      else if (isDuplex && (writableHwm || writableHwm === 0))
        this.highWaterMark = writableHwm;
      else
        this.highWaterMark = defaultHwm;
      this.highWaterMark = Math.floor(this.highWaterMark);
      this.finalCalled = false;
      this.needDrain = false;
      this.ending = false;
      this.ended = false;
      this.finished = false;
      this.destroyed = false;
      var noDecode = options.decodeStrings === false;
      this.decodeStrings = !noDecode;
      this.defaultEncoding = options.defaultEncoding || "utf8";
      this.length = 0;
      this.writing = false;
      this.corked = 0;
      this.sync = true;
      this.bufferProcessing = false;
      this.onwrite = function(er) {
        onwrite(stream, er);
      };
      this.writecb = null;
      this.writelen = 0;
      this.bufferedRequest = null;
      this.lastBufferedRequest = null;
      this.pendingcb = 0;
      this.prefinished = false;
      this.errorEmitted = false;
      this.bufferedRequestCount = 0;
      this.corkedRequestsFree = new CorkedRequest(this);
    }
    WritableState.prototype.getBuffer = function getBuffer() {
      var current = this.bufferedRequest;
      var out = [];
      while (current) {
        out.push(current);
        current = current.next;
      }
      return out;
    };
    (function() {
      try {
        Object.defineProperty(WritableState.prototype, "buffer", {
          get: internalUtil.deprecate(function() {
            return this.getBuffer();
          }, "_writableState.buffer is deprecated. Use _writableState.getBuffer instead.", "DEP0003")
        });
      } catch (_2) {
      }
    })();
    var realHasInstance;
    if (typeof Symbol === "function" && Symbol.hasInstance && typeof Function.prototype[Symbol.hasInstance] === "function") {
      realHasInstance = Function.prototype[Symbol.hasInstance];
      Object.defineProperty(Writable, Symbol.hasInstance, {
        value: function(object) {
          if (realHasInstance.call(this, object))
            return true;
          if (this !== Writable)
            return false;
          return object && object._writableState instanceof WritableState;
        }
      });
    } else {
      realHasInstance = function(object) {
        return object instanceof this;
      };
    }
    function Writable(options) {
      Duplex = Duplex || require_stream_duplex3();
      if (!realHasInstance.call(Writable, this) && !(this instanceof Duplex)) {
        return new Writable(options);
      }
      this._writableState = new WritableState(options, this);
      this.writable = true;
      if (options) {
        if (typeof options.write === "function")
          this._write = options.write;
        if (typeof options.writev === "function")
          this._writev = options.writev;
        if (typeof options.destroy === "function")
          this._destroy = options.destroy;
        if (typeof options.final === "function")
          this._final = options.final;
      }
      Stream.call(this);
    }
    Writable.prototype.pipe = function() {
      this.emit("error", new Error("Cannot pipe, not readable"));
    };
    function writeAfterEnd(stream, cb) {
      var er = new Error("write after end");
      stream.emit("error", er);
      pna.nextTick(cb, er);
    }
    function validChunk(stream, state, chunk, cb) {
      var valid = true;
      var er = false;
      if (chunk === null) {
        er = new TypeError("May not write null values to stream");
      } else if (typeof chunk !== "string" && chunk !== void 0 && !state.objectMode) {
        er = new TypeError("Invalid non-string/buffer chunk");
      }
      if (er) {
        stream.emit("error", er);
        pna.nextTick(cb, er);
        valid = false;
      }
      return valid;
    }
    Writable.prototype.write = function(chunk, encoding, cb) {
      var state = this._writableState;
      var ret2 = false;
      var isBuf = !state.objectMode && _isUint8Array(chunk);
      if (isBuf && !Buffer2.isBuffer(chunk)) {
        chunk = _uint8ArrayToBuffer(chunk);
      }
      if (typeof encoding === "function") {
        cb = encoding;
        encoding = null;
      }
      if (isBuf)
        encoding = "buffer";
      else if (!encoding)
        encoding = state.defaultEncoding;
      if (typeof cb !== "function")
        cb = nop;
      if (state.ended)
        writeAfterEnd(this, cb);
      else if (isBuf || validChunk(this, state, chunk, cb)) {
        state.pendingcb++;
        ret2 = writeOrBuffer(this, state, isBuf, chunk, encoding, cb);
      }
      return ret2;
    };
    Writable.prototype.cork = function() {
      var state = this._writableState;
      state.corked++;
    };
    Writable.prototype.uncork = function() {
      var state = this._writableState;
      if (state.corked) {
        state.corked--;
        if (!state.writing && !state.corked && !state.bufferProcessing && state.bufferedRequest)
          clearBuffer(this, state);
      }
    };
    Writable.prototype.setDefaultEncoding = function setDefaultEncoding(encoding) {
      if (typeof encoding === "string")
        encoding = encoding.toLowerCase();
      if (!(["hex", "utf8", "utf-8", "ascii", "binary", "base64", "ucs2", "ucs-2", "utf16le", "utf-16le", "raw"].indexOf((encoding + "").toLowerCase()) > -1))
        throw new TypeError("Unknown encoding: " + encoding);
      this._writableState.defaultEncoding = encoding;
      return this;
    };
    function decodeChunk(state, chunk, encoding) {
      if (!state.objectMode && state.decodeStrings !== false && typeof chunk === "string") {
        chunk = Buffer2.from(chunk, encoding);
      }
      return chunk;
    }
    Object.defineProperty(Writable.prototype, "writableHighWaterMark", {
      // making it explicit this property is not enumerable
      // because otherwise some prototype manipulation in
      // userland will fail
      enumerable: false,
      get: function() {
        return this._writableState.highWaterMark;
      }
    });
    function writeOrBuffer(stream, state, isBuf, chunk, encoding, cb) {
      if (!isBuf) {
        var newChunk = decodeChunk(state, chunk, encoding);
        if (chunk !== newChunk) {
          isBuf = true;
          encoding = "buffer";
          chunk = newChunk;
        }
      }
      var len = state.objectMode ? 1 : chunk.length;
      state.length += len;
      var ret2 = state.length < state.highWaterMark;
      if (!ret2)
        state.needDrain = true;
      if (state.writing || state.corked) {
        var last = state.lastBufferedRequest;
        state.lastBufferedRequest = {
          chunk,
          encoding,
          isBuf,
          callback: cb,
          next: null
        };
        if (last) {
          last.next = state.lastBufferedRequest;
        } else {
          state.bufferedRequest = state.lastBufferedRequest;
        }
        state.bufferedRequestCount += 1;
      } else {
        doWrite(stream, state, false, len, chunk, encoding, cb);
      }
      return ret2;
    }
    function doWrite(stream, state, writev, len, chunk, encoding, cb) {
      state.writelen = len;
      state.writecb = cb;
      state.writing = true;
      state.sync = true;
      if (writev)
        stream._writev(chunk, state.onwrite);
      else
        stream._write(chunk, encoding, state.onwrite);
      state.sync = false;
    }
    function onwriteError(stream, state, sync, er, cb) {
      --state.pendingcb;
      if (sync) {
        pna.nextTick(cb, er);
        pna.nextTick(finishMaybe, stream, state);
        stream._writableState.errorEmitted = true;
        stream.emit("error", er);
      } else {
        cb(er);
        stream._writableState.errorEmitted = true;
        stream.emit("error", er);
        finishMaybe(stream, state);
      }
    }
    function onwriteStateUpdate(state) {
      state.writing = false;
      state.writecb = null;
      state.length -= state.writelen;
      state.writelen = 0;
    }
    function onwrite(stream, er) {
      var state = stream._writableState;
      var sync = state.sync;
      var cb = state.writecb;
      onwriteStateUpdate(state);
      if (er)
        onwriteError(stream, state, sync, er, cb);
      else {
        var finished = needFinish(state);
        if (!finished && !state.corked && !state.bufferProcessing && state.bufferedRequest) {
          clearBuffer(stream, state);
        }
        if (sync) {
          asyncWrite(afterWrite, stream, state, finished, cb);
        } else {
          afterWrite(stream, state, finished, cb);
        }
      }
    }
    function afterWrite(stream, state, finished, cb) {
      if (!finished)
        onwriteDrain(stream, state);
      state.pendingcb--;
      cb();
      finishMaybe(stream, state);
    }
    function onwriteDrain(stream, state) {
      if (state.length === 0 && state.needDrain) {
        state.needDrain = false;
        stream.emit("drain");
      }
    }
    function clearBuffer(stream, state) {
      state.bufferProcessing = true;
      var entry = state.bufferedRequest;
      if (stream._writev && entry && entry.next) {
        var l2 = state.bufferedRequestCount;
        var buffer = new Array(l2);
        var holder = state.corkedRequestsFree;
        holder.entry = entry;
        var count = 0;
        var allBuffers = true;
        while (entry) {
          buffer[count] = entry;
          if (!entry.isBuf)
            allBuffers = false;
          entry = entry.next;
          count += 1;
        }
        buffer.allBuffers = allBuffers;
        doWrite(stream, state, true, state.length, buffer, "", holder.finish);
        state.pendingcb++;
        state.lastBufferedRequest = null;
        if (holder.next) {
          state.corkedRequestsFree = holder.next;
          holder.next = null;
        } else {
          state.corkedRequestsFree = new CorkedRequest(state);
        }
        state.bufferedRequestCount = 0;
      } else {
        while (entry) {
          var chunk = entry.chunk;
          var encoding = entry.encoding;
          var cb = entry.callback;
          var len = state.objectMode ? 1 : chunk.length;
          doWrite(stream, state, false, len, chunk, encoding, cb);
          entry = entry.next;
          state.bufferedRequestCount--;
          if (state.writing) {
            break;
          }
        }
        if (entry === null)
          state.lastBufferedRequest = null;
      }
      state.bufferedRequest = entry;
      state.bufferProcessing = false;
    }
    Writable.prototype._write = function(chunk, encoding, cb) {
      cb(new Error("_write() is not implemented"));
    };
    Writable.prototype._writev = null;
    Writable.prototype.end = function(chunk, encoding, cb) {
      var state = this._writableState;
      if (typeof chunk === "function") {
        cb = chunk;
        chunk = null;
        encoding = null;
      } else if (typeof encoding === "function") {
        cb = encoding;
        encoding = null;
      }
      if (chunk !== null && chunk !== void 0)
        this.write(chunk, encoding);
      if (state.corked) {
        state.corked = 1;
        this.uncork();
      }
      if (!state.ending)
        endWritable(this, state, cb);
    };
    function needFinish(state) {
      return state.ending && state.length === 0 && state.bufferedRequest === null && !state.finished && !state.writing;
    }
    function callFinal(stream, state) {
      stream._final(function(err) {
        state.pendingcb--;
        if (err) {
          stream.emit("error", err);
        }
        state.prefinished = true;
        stream.emit("prefinish");
        finishMaybe(stream, state);
      });
    }
    function prefinish(stream, state) {
      if (!state.prefinished && !state.finalCalled) {
        if (typeof stream._final === "function") {
          state.pendingcb++;
          state.finalCalled = true;
          pna.nextTick(callFinal, stream, state);
        } else {
          state.prefinished = true;
          stream.emit("prefinish");
        }
      }
    }
    function finishMaybe(stream, state) {
      var need = needFinish(state);
      if (need) {
        prefinish(stream, state);
        if (state.pendingcb === 0) {
          state.finished = true;
          stream.emit("finish");
        }
      }
      return need;
    }
    function endWritable(stream, state, cb) {
      state.ending = true;
      finishMaybe(stream, state);
      if (cb) {
        if (state.finished)
          pna.nextTick(cb);
        else
          stream.once("finish", cb);
      }
      state.ended = true;
      stream.writable = false;
    }
    function onCorkedFinish(corkReq, state, err) {
      var entry = corkReq.entry;
      corkReq.entry = null;
      while (entry) {
        var cb = entry.callback;
        state.pendingcb--;
        cb(err);
        entry = entry.next;
      }
      state.corkedRequestsFree.next = corkReq;
    }
    Object.defineProperty(Writable.prototype, "destroyed", {
      get: function() {
        if (this._writableState === void 0) {
          return false;
        }
        return this._writableState.destroyed;
      },
      set: function(value) {
        if (!this._writableState) {
          return;
        }
        this._writableState.destroyed = value;
      }
    });
    Writable.prototype.destroy = destroyImpl.destroy;
    Writable.prototype._undestroy = destroyImpl.undestroy;
    Writable.prototype._destroy = function(err, cb) {
      this.end();
      cb(err);
    };
  }
});

// ../../../node_modules/lazystream/node_modules/readable-stream/lib/_stream_duplex.js
var require_stream_duplex3 = __commonJS({
  "../../../node_modules/lazystream/node_modules/readable-stream/lib/_stream_duplex.js"(exports2, module2) {
    "use strict";
    var pna = require_process_nextick_args();
    var objectKeys = Object.keys || function(obj2) {
      var keys2 = [];
      for (var key in obj2) {
        keys2.push(key);
      }
      return keys2;
    };
    module2.exports = Duplex;
    var util = Object.create(require_util());
    util.inherits = require_inherits();
    var Readable = require_stream_readable3();
    var Writable = require_stream_writable3();
    util.inherits(Duplex, Readable);
    {
      keys = objectKeys(Writable.prototype);
      for (v = 0; v < keys.length; v++) {
        method = keys[v];
        if (!Duplex.prototype[method])
          Duplex.prototype[method] = Writable.prototype[method];
      }
    }
    var keys;
    var method;
    var v;
    function Duplex(options) {
      if (!(this instanceof Duplex))
        return new Duplex(options);
      Readable.call(this, options);
      Writable.call(this, options);
      if (options && options.readable === false)
        this.readable = false;
      if (options && options.writable === false)
        this.writable = false;
      this.allowHalfOpen = true;
      if (options && options.allowHalfOpen === false)
        this.allowHalfOpen = false;
      this.once("end", onend);
    }
    Object.defineProperty(Duplex.prototype, "writableHighWaterMark", {
      // making it explicit this property is not enumerable
      // because otherwise some prototype manipulation in
      // userland will fail
      enumerable: false,
      get: function() {
        return this._writableState.highWaterMark;
      }
    });
    function onend() {
      if (this.allowHalfOpen || this._writableState.ended)
        return;
      pna.nextTick(onEndNT, this);
    }
    function onEndNT(self2) {
      self2.end();
    }
    Object.defineProperty(Duplex.prototype, "destroyed", {
      get: function() {
        if (this._readableState === void 0 || this._writableState === void 0) {
          return false;
        }
        return this._readableState.destroyed && this._writableState.destroyed;
      },
      set: function(value) {
        if (this._readableState === void 0 || this._writableState === void 0) {
          return;
        }
        this._readableState.destroyed = value;
        this._writableState.destroyed = value;
      }
    });
    Duplex.prototype._destroy = function(err, cb) {
      this.push(null);
      this.end();
      pna.nextTick(cb, err);
    };
  }
});

// ../../../node_modules/lazystream/node_modules/string_decoder/lib/string_decoder.js
var require_string_decoder3 = __commonJS({
  "../../../node_modules/lazystream/node_modules/string_decoder/lib/string_decoder.js"(exports2) {
    "use strict";
    var Buffer2 = require_safe_buffer3().Buffer;
    var isEncoding = Buffer2.isEncoding || function(encoding) {
      encoding = "" + encoding;
      switch (encoding && encoding.toLowerCase()) {
        case "hex":
        case "utf8":
        case "utf-8":
        case "ascii":
        case "binary":
        case "base64":
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
        case "raw":
          return true;
        default:
          return false;
      }
    };
    function _normalizeEncoding(enc) {
      if (!enc)
        return "utf8";
      var retried;
      while (true) {
        switch (enc) {
          case "utf8":
          case "utf-8":
            return "utf8";
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
            return "utf16le";
          case "latin1":
          case "binary":
            return "latin1";
          case "base64":
          case "ascii":
          case "hex":
            return enc;
          default:
            if (retried)
              return;
            enc = ("" + enc).toLowerCase();
            retried = true;
        }
      }
    }
    function normalizeEncoding(enc) {
      var nenc = _normalizeEncoding(enc);
      if (typeof nenc !== "string" && (Buffer2.isEncoding === isEncoding || !isEncoding(enc)))
        throw new Error("Unknown encoding: " + enc);
      return nenc || enc;
    }
    exports2.StringDecoder = StringDecoder;
    function StringDecoder(encoding) {
      this.encoding = normalizeEncoding(encoding);
      var nb;
      switch (this.encoding) {
        case "utf16le":
          this.text = utf16Text;
          this.end = utf16End;
          nb = 4;
          break;
        case "utf8":
          this.fillLast = utf8FillLast;
          nb = 4;
          break;
        case "base64":
          this.text = base64Text;
          this.end = base64End;
          nb = 3;
          break;
        default:
          this.write = simpleWrite;
          this.end = simpleEnd;
          return;
      }
      this.lastNeed = 0;
      this.lastTotal = 0;
      this.lastChar = Buffer2.allocUnsafe(nb);
    }
    StringDecoder.prototype.write = function(buf) {
      if (buf.length === 0)
        return "";
      var r;
      var i;
      if (this.lastNeed) {
        r = this.fillLast(buf);
        if (r === void 0)
          return "";
        i = this.lastNeed;
        this.lastNeed = 0;
      } else {
        i = 0;
      }
      if (i < buf.length)
        return r ? r + this.text(buf, i) : this.text(buf, i);
      return r || "";
    };
    StringDecoder.prototype.end = utf8End;
    StringDecoder.prototype.text = utf8Text;
    StringDecoder.prototype.fillLast = function(buf) {
      if (this.lastNeed <= buf.length) {
        buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, this.lastNeed);
        return this.lastChar.toString(this.encoding, 0, this.lastTotal);
      }
      buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, buf.length);
      this.lastNeed -= buf.length;
    };
    function utf8CheckByte(byte) {
      if (byte <= 127)
        return 0;
      else if (byte >> 5 === 6)
        return 2;
      else if (byte >> 4 === 14)
        return 3;
      else if (byte >> 3 === 30)
        return 4;
      return byte >> 6 === 2 ? -1 : -2;
    }
    function utf8CheckIncomplete(self2, buf, i) {
      var j = buf.length - 1;
      if (j < i)
        return 0;
      var nb = utf8CheckByte(buf[j]);
      if (nb >= 0) {
        if (nb > 0)
          self2.lastNeed = nb - 1;
        return nb;
      }
      if (--j < i || nb === -2)
        return 0;
      nb = utf8CheckByte(buf[j]);
      if (nb >= 0) {
        if (nb > 0)
          self2.lastNeed = nb - 2;
        return nb;
      }
      if (--j < i || nb === -2)
        return 0;
      nb = utf8CheckByte(buf[j]);
      if (nb >= 0) {
        if (nb > 0) {
          if (nb === 2)
            nb = 0;
          else
            self2.lastNeed = nb - 3;
        }
        return nb;
      }
      return 0;
    }
    function utf8CheckExtraBytes(self2, buf, p) {
      if ((buf[0] & 192) !== 128) {
        self2.lastNeed = 0;
        return "\uFFFD";
      }
      if (self2.lastNeed > 1 && buf.length > 1) {
        if ((buf[1] & 192) !== 128) {
          self2.lastNeed = 1;
          return "\uFFFD";
        }
        if (self2.lastNeed > 2 && buf.length > 2) {
          if ((buf[2] & 192) !== 128) {
            self2.lastNeed = 2;
            return "\uFFFD";
          }
        }
      }
    }
    function utf8FillLast(buf) {
      var p = this.lastTotal - this.lastNeed;
      var r = utf8CheckExtraBytes(this, buf, p);
      if (r !== void 0)
        return r;
      if (this.lastNeed <= buf.length) {
        buf.copy(this.lastChar, p, 0, this.lastNeed);
        return this.lastChar.toString(this.encoding, 0, this.lastTotal);
      }
      buf.copy(this.lastChar, p, 0, buf.length);
      this.lastNeed -= buf.length;
    }
    function utf8Text(buf, i) {
      var total = utf8CheckIncomplete(this, buf, i);
      if (!this.lastNeed)
        return buf.toString("utf8", i);
      this.lastTotal = total;
      var end = buf.length - (total - this.lastNeed);
      buf.copy(this.lastChar, 0, end);
      return buf.toString("utf8", i, end);
    }
    function utf8End(buf) {
      var r = buf && buf.length ? this.write(buf) : "";
      if (this.lastNeed)
        return r + "\uFFFD";
      return r;
    }
    function utf16Text(buf, i) {
      if ((buf.length - i) % 2 === 0) {
        var r = buf.toString("utf16le", i);
        if (r) {
          var c = r.charCodeAt(r.length - 1);
          if (c >= 55296 && c <= 56319) {
            this.lastNeed = 2;
            this.lastTotal = 4;
            this.lastChar[0] = buf[buf.length - 2];
            this.lastChar[1] = buf[buf.length - 1];
            return r.slice(0, -1);
          }
        }
        return r;
      }
      this.lastNeed = 1;
      this.lastTotal = 2;
      this.lastChar[0] = buf[buf.length - 1];
      return buf.toString("utf16le", i, buf.length - 1);
    }
    function utf16End(buf) {
      var r = buf && buf.length ? this.write(buf) : "";
      if (this.lastNeed) {
        var end = this.lastTotal - this.lastNeed;
        return r + this.lastChar.toString("utf16le", 0, end);
      }
      return r;
    }
    function base64Text(buf, i) {
      var n = (buf.length - i) % 3;
      if (n === 0)
        return buf.toString("base64", i);
      this.lastNeed = 3 - n;
      this.lastTotal = 3;
      if (n === 1) {
        this.lastChar[0] = buf[buf.length - 1];
      } else {
        this.lastChar[0] = buf[buf.length - 2];
        this.lastChar[1] = buf[buf.length - 1];
      }
      return buf.toString("base64", i, buf.length - n);
    }
    function base64End(buf) {
      var r = buf && buf.length ? this.write(buf) : "";
      if (this.lastNeed)
        return r + this.lastChar.toString("base64", 0, 3 - this.lastNeed);
      return r;
    }
    function simpleWrite(buf) {
      return buf.toString(this.encoding);
    }
    function simpleEnd(buf) {
      return buf && buf.length ? this.write(buf) : "";
    }
  }
});

// ../../../node_modules/lazystream/node_modules/readable-stream/lib/_stream_readable.js
var require_stream_readable3 = __commonJS({
  "../../../node_modules/lazystream/node_modules/readable-stream/lib/_stream_readable.js"(exports2, module2) {
    "use strict";
    var pna = require_process_nextick_args();
    module2.exports = Readable;
    var isArray = require_isarray2();
    var Duplex;
    Readable.ReadableState = ReadableState;
    var EE = require("events").EventEmitter;
    var EElistenerCount = function(emitter, type) {
      return emitter.listeners(type).length;
    };
    var Stream = require_stream3();
    var Buffer2 = require_safe_buffer3().Buffer;
    var OurUint8Array = (typeof global !== "undefined" ? global : typeof window !== "undefined" ? window : typeof self !== "undefined" ? self : {}).Uint8Array || function() {
    };
    function _uint8ArrayToBuffer(chunk) {
      return Buffer2.from(chunk);
    }
    function _isUint8Array(obj2) {
      return Buffer2.isBuffer(obj2) || obj2 instanceof OurUint8Array;
    }
    var util = Object.create(require_util());
    util.inherits = require_inherits();
    var debugUtil = require("util");
    var debug = void 0;
    if (debugUtil && debugUtil.debuglog) {
      debug = debugUtil.debuglog("stream");
    } else {
      debug = function() {
      };
    }
    var BufferList = require_BufferList2();
    var destroyImpl = require_destroy3();
    var StringDecoder;
    util.inherits(Readable, Stream);
    var kProxyEvents = ["error", "close", "destroy", "pause", "resume"];
    function prependListener(emitter, event, fn) {
      if (typeof emitter.prependListener === "function")
        return emitter.prependListener(event, fn);
      if (!emitter._events || !emitter._events[event])
        emitter.on(event, fn);
      else if (isArray(emitter._events[event]))
        emitter._events[event].unshift(fn);
      else
        emitter._events[event] = [fn, emitter._events[event]];
    }
    function ReadableState(options, stream) {
      Duplex = Duplex || require_stream_duplex3();
      options = options || {};
      var isDuplex = stream instanceof Duplex;
      this.objectMode = !!options.objectMode;
      if (isDuplex)
        this.objectMode = this.objectMode || !!options.readableObjectMode;
      var hwm = options.highWaterMark;
      var readableHwm = options.readableHighWaterMark;
      var defaultHwm = this.objectMode ? 16 : 16 * 1024;
      if (hwm || hwm === 0)
        this.highWaterMark = hwm;
      else if (isDuplex && (readableHwm || readableHwm === 0))
        this.highWaterMark = readableHwm;
      else
        this.highWaterMark = defaultHwm;
      this.highWaterMark = Math.floor(this.highWaterMark);
      this.buffer = new BufferList();
      this.length = 0;
      this.pipes = null;
      this.pipesCount = 0;
      this.flowing = null;
      this.ended = false;
      this.endEmitted = false;
      this.reading = false;
      this.sync = true;
      this.needReadable = false;
      this.emittedReadable = false;
      this.readableListening = false;
      this.resumeScheduled = false;
      this.destroyed = false;
      this.defaultEncoding = options.defaultEncoding || "utf8";
      this.awaitDrain = 0;
      this.readingMore = false;
      this.decoder = null;
      this.encoding = null;
      if (options.encoding) {
        if (!StringDecoder)
          StringDecoder = require_string_decoder3().StringDecoder;
        this.decoder = new StringDecoder(options.encoding);
        this.encoding = options.encoding;
      }
    }
    function Readable(options) {
      Duplex = Duplex || require_stream_duplex3();
      if (!(this instanceof Readable))
        return new Readable(options);
      this._readableState = new ReadableState(options, this);
      this.readable = true;
      if (options) {
        if (typeof options.read === "function")
          this._read = options.read;
        if (typeof options.destroy === "function")
          this._destroy = options.destroy;
      }
      Stream.call(this);
    }
    Object.defineProperty(Readable.prototype, "destroyed", {
      get: function() {
        if (this._readableState === void 0) {
          return false;
        }
        return this._readableState.destroyed;
      },
      set: function(value) {
        if (!this._readableState) {
          return;
        }
        this._readableState.destroyed = value;
      }
    });
    Readable.prototype.destroy = destroyImpl.destroy;
    Readable.prototype._undestroy = destroyImpl.undestroy;
    Readable.prototype._destroy = function(err, cb) {
      this.push(null);
      cb(err);
    };
    Readable.prototype.push = function(chunk, encoding) {
      var state = this._readableState;
      var skipChunkCheck;
      if (!state.objectMode) {
        if (typeof chunk === "string") {
          encoding = encoding || state.defaultEncoding;
          if (encoding !== state.encoding) {
            chunk = Buffer2.from(chunk, encoding);
            encoding = "";
          }
          skipChunkCheck = true;
        }
      } else {
        skipChunkCheck = true;
      }
      return readableAddChunk(this, chunk, encoding, false, skipChunkCheck);
    };
    Readable.prototype.unshift = function(chunk) {
      return readableAddChunk(this, chunk, null, true, false);
    };
    function readableAddChunk(stream, chunk, encoding, addToFront, skipChunkCheck) {
      var state = stream._readableState;
      if (chunk === null) {
        state.reading = false;
        onEofChunk(stream, state);
      } else {
        var er;
        if (!skipChunkCheck)
          er = chunkInvalid(state, chunk);
        if (er) {
          stream.emit("error", er);
        } else if (state.objectMode || chunk && chunk.length > 0) {
          if (typeof chunk !== "string" && !state.objectMode && Object.getPrototypeOf(chunk) !== Buffer2.prototype) {
            chunk = _uint8ArrayToBuffer(chunk);
          }
          if (addToFront) {
            if (state.endEmitted)
              stream.emit("error", new Error("stream.unshift() after end event"));
            else
              addChunk(stream, state, chunk, true);
          } else if (state.ended) {
            stream.emit("error", new Error("stream.push() after EOF"));
          } else {
            state.reading = false;
            if (state.decoder && !encoding) {
              chunk = state.decoder.write(chunk);
              if (state.objectMode || chunk.length !== 0)
                addChunk(stream, state, chunk, false);
              else
                maybeReadMore(stream, state);
            } else {
              addChunk(stream, state, chunk, false);
            }
          }
        } else if (!addToFront) {
          state.reading = false;
        }
      }
      return needMoreData(state);
    }
    function addChunk(stream, state, chunk, addToFront) {
      if (state.flowing && state.length === 0 && !state.sync) {
        stream.emit("data", chunk);
        stream.read(0);
      } else {
        state.length += state.objectMode ? 1 : chunk.length;
        if (addToFront)
          state.buffer.unshift(chunk);
        else
          state.buffer.push(chunk);
        if (state.needReadable)
          emitReadable(stream);
      }
      maybeReadMore(stream, state);
    }
    function chunkInvalid(state, chunk) {
      var er;
      if (!_isUint8Array(chunk) && typeof chunk !== "string" && chunk !== void 0 && !state.objectMode) {
        er = new TypeError("Invalid non-string/buffer chunk");
      }
      return er;
    }
    function needMoreData(state) {
      return !state.ended && (state.needReadable || state.length < state.highWaterMark || state.length === 0);
    }
    Readable.prototype.isPaused = function() {
      return this._readableState.flowing === false;
    };
    Readable.prototype.setEncoding = function(enc) {
      if (!StringDecoder)
        StringDecoder = require_string_decoder3().StringDecoder;
      this._readableState.decoder = new StringDecoder(enc);
      this._readableState.encoding = enc;
      return this;
    };
    var MAX_HWM = 8388608;
    function computeNewHighWaterMark(n) {
      if (n >= MAX_HWM) {
        n = MAX_HWM;
      } else {
        n--;
        n |= n >>> 1;
        n |= n >>> 2;
        n |= n >>> 4;
        n |= n >>> 8;
        n |= n >>> 16;
        n++;
      }
      return n;
    }
    function howMuchToRead(n, state) {
      if (n <= 0 || state.length === 0 && state.ended)
        return 0;
      if (state.objectMode)
        return 1;
      if (n !== n) {
        if (state.flowing && state.length)
          return state.buffer.head.data.length;
        else
          return state.length;
      }
      if (n > state.highWaterMark)
        state.highWaterMark = computeNewHighWaterMark(n);
      if (n <= state.length)
        return n;
      if (!state.ended) {
        state.needReadable = true;
        return 0;
      }
      return state.length;
    }
    Readable.prototype.read = function(n) {
      debug("read", n);
      n = parseInt(n, 10);
      var state = this._readableState;
      var nOrig = n;
      if (n !== 0)
        state.emittedReadable = false;
      if (n === 0 && state.needReadable && (state.length >= state.highWaterMark || state.ended)) {
        debug("read: emitReadable", state.length, state.ended);
        if (state.length === 0 && state.ended)
          endReadable(this);
        else
          emitReadable(this);
        return null;
      }
      n = howMuchToRead(n, state);
      if (n === 0 && state.ended) {
        if (state.length === 0)
          endReadable(this);
        return null;
      }
      var doRead = state.needReadable;
      debug("need readable", doRead);
      if (state.length === 0 || state.length - n < state.highWaterMark) {
        doRead = true;
        debug("length less than watermark", doRead);
      }
      if (state.ended || state.reading) {
        doRead = false;
        debug("reading or ended", doRead);
      } else if (doRead) {
        debug("do read");
        state.reading = true;
        state.sync = true;
        if (state.length === 0)
          state.needReadable = true;
        this._read(state.highWaterMark);
        state.sync = false;
        if (!state.reading)
          n = howMuchToRead(nOrig, state);
      }
      var ret2;
      if (n > 0)
        ret2 = fromList(n, state);
      else
        ret2 = null;
      if (ret2 === null) {
        state.needReadable = true;
        n = 0;
      } else {
        state.length -= n;
      }
      if (state.length === 0) {
        if (!state.ended)
          state.needReadable = true;
        if (nOrig !== n && state.ended)
          endReadable(this);
      }
      if (ret2 !== null)
        this.emit("data", ret2);
      return ret2;
    };
    function onEofChunk(stream, state) {
      if (state.ended)
        return;
      if (state.decoder) {
        var chunk = state.decoder.end();
        if (chunk && chunk.length) {
          state.buffer.push(chunk);
          state.length += state.objectMode ? 1 : chunk.length;
        }
      }
      state.ended = true;
      emitReadable(stream);
    }
    function emitReadable(stream) {
      var state = stream._readableState;
      state.needReadable = false;
      if (!state.emittedReadable) {
        debug("emitReadable", state.flowing);
        state.emittedReadable = true;
        if (state.sync)
          pna.nextTick(emitReadable_, stream);
        else
          emitReadable_(stream);
      }
    }
    function emitReadable_(stream) {
      debug("emit readable");
      stream.emit("readable");
      flow(stream);
    }
    function maybeReadMore(stream, state) {
      if (!state.readingMore) {
        state.readingMore = true;
        pna.nextTick(maybeReadMore_, stream, state);
      }
    }
    function maybeReadMore_(stream, state) {
      var len = state.length;
      while (!state.reading && !state.flowing && !state.ended && state.length < state.highWaterMark) {
        debug("maybeReadMore read 0");
        stream.read(0);
        if (len === state.length)
          break;
        else
          len = state.length;
      }
      state.readingMore = false;
    }
    Readable.prototype._read = function(n) {
      this.emit("error", new Error("_read() is not implemented"));
    };
    Readable.prototype.pipe = function(dest, pipeOpts) {
      var src = this;
      var state = this._readableState;
      switch (state.pipesCount) {
        case 0:
          state.pipes = dest;
          break;
        case 1:
          state.pipes = [state.pipes, dest];
          break;
        default:
          state.pipes.push(dest);
          break;
      }
      state.pipesCount += 1;
      debug("pipe count=%d opts=%j", state.pipesCount, pipeOpts);
      var doEnd = (!pipeOpts || pipeOpts.end !== false) && dest !== process.stdout && dest !== process.stderr;
      var endFn = doEnd ? onend : unpipe;
      if (state.endEmitted)
        pna.nextTick(endFn);
      else
        src.once("end", endFn);
      dest.on("unpipe", onunpipe);
      function onunpipe(readable, unpipeInfo) {
        debug("onunpipe");
        if (readable === src) {
          if (unpipeInfo && unpipeInfo.hasUnpiped === false) {
            unpipeInfo.hasUnpiped = true;
            cleanup();
          }
        }
      }
      function onend() {
        debug("onend");
        dest.end();
      }
      var ondrain = pipeOnDrain(src);
      dest.on("drain", ondrain);
      var cleanedUp = false;
      function cleanup() {
        debug("cleanup");
        dest.removeListener("close", onclose);
        dest.removeListener("finish", onfinish);
        dest.removeListener("drain", ondrain);
        dest.removeListener("error", onerror);
        dest.removeListener("unpipe", onunpipe);
        src.removeListener("end", onend);
        src.removeListener("end", unpipe);
        src.removeListener("data", ondata);
        cleanedUp = true;
        if (state.awaitDrain && (!dest._writableState || dest._writableState.needDrain))
          ondrain();
      }
      var increasedAwaitDrain = false;
      src.on("data", ondata);
      function ondata(chunk) {
        debug("ondata");
        increasedAwaitDrain = false;
        var ret2 = dest.write(chunk);
        if (false === ret2 && !increasedAwaitDrain) {
          if ((state.pipesCount === 1 && state.pipes === dest || state.pipesCount > 1 && indexOf(state.pipes, dest) !== -1) && !cleanedUp) {
            debug("false write response, pause", state.awaitDrain);
            state.awaitDrain++;
            increasedAwaitDrain = true;
          }
          src.pause();
        }
      }
      function onerror(er) {
        debug("onerror", er);
        unpipe();
        dest.removeListener("error", onerror);
        if (EElistenerCount(dest, "error") === 0)
          dest.emit("error", er);
      }
      prependListener(dest, "error", onerror);
      function onclose() {
        dest.removeListener("finish", onfinish);
        unpipe();
      }
      dest.once("close", onclose);
      function onfinish() {
        debug("onfinish");
        dest.removeListener("close", onclose);
        unpipe();
      }
      dest.once("finish", onfinish);
      function unpipe() {
        debug("unpipe");
        src.unpipe(dest);
      }
      dest.emit("pipe", src);
      if (!state.flowing) {
        debug("pipe resume");
        src.resume();
      }
      return dest;
    };
    function pipeOnDrain(src) {
      return function() {
        var state = src._readableState;
        debug("pipeOnDrain", state.awaitDrain);
        if (state.awaitDrain)
          state.awaitDrain--;
        if (state.awaitDrain === 0 && EElistenerCount(src, "data")) {
          state.flowing = true;
          flow(src);
        }
      };
    }
    Readable.prototype.unpipe = function(dest) {
      var state = this._readableState;
      var unpipeInfo = { hasUnpiped: false };
      if (state.pipesCount === 0)
        return this;
      if (state.pipesCount === 1) {
        if (dest && dest !== state.pipes)
          return this;
        if (!dest)
          dest = state.pipes;
        state.pipes = null;
        state.pipesCount = 0;
        state.flowing = false;
        if (dest)
          dest.emit("unpipe", this, unpipeInfo);
        return this;
      }
      if (!dest) {
        var dests = state.pipes;
        var len = state.pipesCount;
        state.pipes = null;
        state.pipesCount = 0;
        state.flowing = false;
        for (var i = 0; i < len; i++) {
          dests[i].emit("unpipe", this, { hasUnpiped: false });
        }
        return this;
      }
      var index = indexOf(state.pipes, dest);
      if (index === -1)
        return this;
      state.pipes.splice(index, 1);
      state.pipesCount -= 1;
      if (state.pipesCount === 1)
        state.pipes = state.pipes[0];
      dest.emit("unpipe", this, unpipeInfo);
      return this;
    };
    Readable.prototype.on = function(ev, fn) {
      var res = Stream.prototype.on.call(this, ev, fn);
      if (ev === "data") {
        if (this._readableState.flowing !== false)
          this.resume();
      } else if (ev === "readable") {
        var state = this._readableState;
        if (!state.endEmitted && !state.readableListening) {
          state.readableListening = state.needReadable = true;
          state.emittedReadable = false;
          if (!state.reading) {
            pna.nextTick(nReadingNextTick, this);
          } else if (state.length) {
            emitReadable(this);
          }
        }
      }
      return res;
    };
    Readable.prototype.addListener = Readable.prototype.on;
    function nReadingNextTick(self2) {
      debug("readable nexttick read 0");
      self2.read(0);
    }
    Readable.prototype.resume = function() {
      var state = this._readableState;
      if (!state.flowing) {
        debug("resume");
        state.flowing = true;
        resume(this, state);
      }
      return this;
    };
    function resume(stream, state) {
      if (!state.resumeScheduled) {
        state.resumeScheduled = true;
        pna.nextTick(resume_, stream, state);
      }
    }
    function resume_(stream, state) {
      if (!state.reading) {
        debug("resume read 0");
        stream.read(0);
      }
      state.resumeScheduled = false;
      state.awaitDrain = 0;
      stream.emit("resume");
      flow(stream);
      if (state.flowing && !state.reading)
        stream.read(0);
    }
    Readable.prototype.pause = function() {
      debug("call pause flowing=%j", this._readableState.flowing);
      if (false !== this._readableState.flowing) {
        debug("pause");
        this._readableState.flowing = false;
        this.emit("pause");
      }
      return this;
    };
    function flow(stream) {
      var state = stream._readableState;
      debug("flow", state.flowing);
      while (state.flowing && stream.read() !== null) {
      }
    }
    Readable.prototype.wrap = function(stream) {
      var _this = this;
      var state = this._readableState;
      var paused = false;
      stream.on("end", function() {
        debug("wrapped end");
        if (state.decoder && !state.ended) {
          var chunk = state.decoder.end();
          if (chunk && chunk.length)
            _this.push(chunk);
        }
        _this.push(null);
      });
      stream.on("data", function(chunk) {
        debug("wrapped data");
        if (state.decoder)
          chunk = state.decoder.write(chunk);
        if (state.objectMode && (chunk === null || chunk === void 0))
          return;
        else if (!state.objectMode && (!chunk || !chunk.length))
          return;
        var ret2 = _this.push(chunk);
        if (!ret2) {
          paused = true;
          stream.pause();
        }
      });
      for (var i in stream) {
        if (this[i] === void 0 && typeof stream[i] === "function") {
          this[i] = /* @__PURE__ */ function(method) {
            return function() {
              return stream[method].apply(stream, arguments);
            };
          }(i);
        }
      }
      for (var n = 0; n < kProxyEvents.length; n++) {
        stream.on(kProxyEvents[n], this.emit.bind(this, kProxyEvents[n]));
      }
      this._read = function(n2) {
        debug("wrapped _read", n2);
        if (paused) {
          paused = false;
          stream.resume();
        }
      };
      return this;
    };
    Object.defineProperty(Readable.prototype, "readableHighWaterMark", {
      // making it explicit this property is not enumerable
      // because otherwise some prototype manipulation in
      // userland will fail
      enumerable: false,
      get: function() {
        return this._readableState.highWaterMark;
      }
    });
    Readable._fromList = fromList;
    function fromList(n, state) {
      if (state.length === 0)
        return null;
      var ret2;
      if (state.objectMode)
        ret2 = state.buffer.shift();
      else if (!n || n >= state.length) {
        if (state.decoder)
          ret2 = state.buffer.join("");
        else if (state.buffer.length === 1)
          ret2 = state.buffer.head.data;
        else
          ret2 = state.buffer.concat(state.length);
        state.buffer.clear();
      } else {
        ret2 = fromListPartial(n, state.buffer, state.decoder);
      }
      return ret2;
    }
    function fromListPartial(n, list, hasStrings) {
      var ret2;
      if (n < list.head.data.length) {
        ret2 = list.head.data.slice(0, n);
        list.head.data = list.head.data.slice(n);
      } else if (n === list.head.data.length) {
        ret2 = list.shift();
      } else {
        ret2 = hasStrings ? copyFromBufferString(n, list) : copyFromBuffer(n, list);
      }
      return ret2;
    }
    function copyFromBufferString(n, list) {
      var p = list.head;
      var c = 1;
      var ret2 = p.data;
      n -= ret2.length;
      while (p = p.next) {
        var str = p.data;
        var nb = n > str.length ? str.length : n;
        if (nb === str.length)
          ret2 += str;
        else
          ret2 += str.slice(0, n);
        n -= nb;
        if (n === 0) {
          if (nb === str.length) {
            ++c;
            if (p.next)
              list.head = p.next;
            else
              list.head = list.tail = null;
          } else {
            list.head = p;
            p.data = str.slice(nb);
          }
          break;
        }
        ++c;
      }
      list.length -= c;
      return ret2;
    }
    function copyFromBuffer(n, list) {
      var ret2 = Buffer2.allocUnsafe(n);
      var p = list.head;
      var c = 1;
      p.data.copy(ret2);
      n -= p.data.length;
      while (p = p.next) {
        var buf = p.data;
        var nb = n > buf.length ? buf.length : n;
        buf.copy(ret2, ret2.length - n, 0, nb);
        n -= nb;
        if (n === 0) {
          if (nb === buf.length) {
            ++c;
            if (p.next)
              list.head = p.next;
            else
              list.head = list.tail = null;
          } else {
            list.head = p;
            p.data = buf.slice(nb);
          }
          break;
        }
        ++c;
      }
      list.length -= c;
      return ret2;
    }
    function endReadable(stream) {
      var state = stream._readableState;
      if (state.length > 0)
        throw new Error('"endReadable()" called on non-empty stream');
      if (!state.endEmitted) {
        state.ended = true;
        pna.nextTick(endReadableNT, state, stream);
      }
    }
    function endReadableNT(state, stream) {
      if (!state.endEmitted && state.length === 0) {
        state.endEmitted = true;
        stream.readable = false;
        stream.emit("end");
      }
    }
    function indexOf(xs, x) {
      for (var i = 0, l2 = xs.length; i < l2; i++) {
        if (xs[i] === x)
          return i;
      }
      return -1;
    }
  }
});

// ../../../node_modules/lazystream/node_modules/readable-stream/lib/_stream_transform.js
var require_stream_transform3 = __commonJS({
  "../../../node_modules/lazystream/node_modules/readable-stream/lib/_stream_transform.js"(exports2, module2) {
    "use strict";
    module2.exports = Transform;
    var Duplex = require_stream_duplex3();
    var util = Object.create(require_util());
    util.inherits = require_inherits();
    util.inherits(Transform, Duplex);
    function afterTransform(er, data) {
      var ts = this._transformState;
      ts.transforming = false;
      var cb = ts.writecb;
      if (!cb) {
        return this.emit("error", new Error("write callback called multiple times"));
      }
      ts.writechunk = null;
      ts.writecb = null;
      if (data != null)
        this.push(data);
      cb(er);
      var rs = this._readableState;
      rs.reading = false;
      if (rs.needReadable || rs.length < rs.highWaterMark) {
        this._read(rs.highWaterMark);
      }
    }
    function Transform(options) {
      if (!(this instanceof Transform))
        return new Transform(options);
      Duplex.call(this, options);
      this._transformState = {
        afterTransform: afterTransform.bind(this),
        needTransform: false,
        transforming: false,
        writecb: null,
        writechunk: null,
        writeencoding: null
      };
      this._readableState.needReadable = true;
      this._readableState.sync = false;
      if (options) {
        if (typeof options.transform === "function")
          this._transform = options.transform;
        if (typeof options.flush === "function")
          this._flush = options.flush;
      }
      this.on("prefinish", prefinish);
    }
    function prefinish() {
      var _this = this;
      if (typeof this._flush === "function") {
        this._flush(function(er, data) {
          done(_this, er, data);
        });
      } else {
        done(this, null, null);
      }
    }
    Transform.prototype.push = function(chunk, encoding) {
      this._transformState.needTransform = false;
      return Duplex.prototype.push.call(this, chunk, encoding);
    };
    Transform.prototype._transform = function(chunk, encoding, cb) {
      throw new Error("_transform() is not implemented");
    };
    Transform.prototype._write = function(chunk, encoding, cb) {
      var ts = this._transformState;
      ts.writecb = cb;
      ts.writechunk = chunk;
      ts.writeencoding = encoding;
      if (!ts.transforming) {
        var rs = this._readableState;
        if (ts.needTransform || rs.needReadable || rs.length < rs.highWaterMark)
          this._read(rs.highWaterMark);
      }
    };
    Transform.prototype._read = function(n) {
      var ts = this._transformState;
      if (ts.writechunk !== null && ts.writecb && !ts.transforming) {
        ts.transforming = true;
        this._transform(ts.writechunk, ts.writeencoding, ts.afterTransform);
      } else {
        ts.needTransform = true;
      }
    };
    Transform.prototype._destroy = function(err, cb) {
      var _this2 = this;
      Duplex.prototype._destroy.call(this, err, function(err2) {
        cb(err2);
        _this2.emit("close");
      });
    };
    function done(stream, er, data) {
      if (er)
        return stream.emit("error", er);
      if (data != null)
        stream.push(data);
      if (stream._writableState.length)
        throw new Error("Calling transform done when ws.length != 0");
      if (stream._transformState.transforming)
        throw new Error("Calling transform done when still transforming");
      return stream.push(null);
    }
  }
});

// ../../../node_modules/lazystream/node_modules/readable-stream/lib/_stream_passthrough.js
var require_stream_passthrough3 = __commonJS({
  "../../../node_modules/lazystream/node_modules/readable-stream/lib/_stream_passthrough.js"(exports2, module2) {
    "use strict";
    module2.exports = PassThrough;
    var Transform = require_stream_transform3();
    var util = Object.create(require_util());
    util.inherits = require_inherits();
    util.inherits(PassThrough, Transform);
    function PassThrough(options) {
      if (!(this instanceof PassThrough))
        return new PassThrough(options);
      Transform.call(this, options);
    }
    PassThrough.prototype._transform = function(chunk, encoding, cb) {
      cb(null, chunk);
    };
  }
});

// ../../../node_modules/lazystream/node_modules/readable-stream/readable.js
var require_readable3 = __commonJS({
  "../../../node_modules/lazystream/node_modules/readable-stream/readable.js"(exports2, module2) {
    var Stream = require("stream");
    if (process.env.READABLE_STREAM === "disable" && Stream) {
      module2.exports = Stream;
      exports2 = module2.exports = Stream.Readable;
      exports2.Readable = Stream.Readable;
      exports2.Writable = Stream.Writable;
      exports2.Duplex = Stream.Duplex;
      exports2.Transform = Stream.Transform;
      exports2.PassThrough = Stream.PassThrough;
      exports2.Stream = Stream;
    } else {
      exports2 = module2.exports = require_stream_readable3();
      exports2.Stream = Stream || exports2;
      exports2.Readable = exports2;
      exports2.Writable = require_stream_writable3();
      exports2.Duplex = require_stream_duplex3();
      exports2.Transform = require_stream_transform3();
      exports2.PassThrough = require_stream_passthrough3();
    }
  }
});

// ../../../node_modules/lazystream/node_modules/readable-stream/passthrough.js
var require_passthrough = __commonJS({
  "../../../node_modules/lazystream/node_modules/readable-stream/passthrough.js"(exports2, module2) {
    module2.exports = require_readable3().PassThrough;
  }
});

// ../../../node_modules/lazystream/lib/lazystream.js
var require_lazystream = __commonJS({
  "../../../node_modules/lazystream/lib/lazystream.js"(exports2, module2) {
    var util = require("util");
    var PassThrough = require_passthrough();
    module2.exports = {
      Readable,
      Writable
    };
    util.inherits(Readable, PassThrough);
    util.inherits(Writable, PassThrough);
    function beforeFirstCall(instance, method, callback) {
      instance[method] = function() {
        delete instance[method];
        callback.apply(this, arguments);
        return this[method].apply(this, arguments);
      };
    }
    function Readable(fn, options) {
      if (!(this instanceof Readable))
        return new Readable(fn, options);
      PassThrough.call(this, options);
      beforeFirstCall(this, "_read", function() {
        var source = fn.call(this, options);
        var emit = this.emit.bind(this, "error");
        source.on("error", emit);
        source.pipe(this);
      });
      this.emit("readable");
    }
    function Writable(fn, options) {
      if (!(this instanceof Writable))
        return new Writable(fn, options);
      PassThrough.call(this, options);
      beforeFirstCall(this, "_write", function() {
        var destination = fn.call(this, options);
        var emit = this.emit.bind(this, "error");
        destination.on("error", emit);
        this.pipe(destination);
      });
      this.emit("writable");
    }
  }
});

// ../../../node_modules/normalize-path/index.js
var require_normalize_path = __commonJS({
  "../../../node_modules/normalize-path/index.js"(exports2, module2) {
    module2.exports = function(path, stripTrailing) {
      if (typeof path !== "string") {
        throw new TypeError("expected path to be a string");
      }
      if (path === "\\" || path === "/")
        return "/";
      var len = path.length;
      if (len <= 1)
        return path;
      var prefix = "";
      if (len > 4 && path[3] === "\\") {
        var ch = path[2];
        if ((ch === "?" || ch === ".") && path.slice(0, 2) === "\\\\") {
          path = path.slice(2);
          prefix = "//";
        }
      }
      var segs = path.split(/[/\\]+/);
      if (stripTrailing !== false && segs[segs.length - 1] === "") {
        segs.pop();
      }
      return prefix + segs.join("/");
    };
  }
});

// ../../../node_modules/lodash.defaults/index.js
var require_lodash9 = __commonJS({
  "../../../node_modules/lodash.defaults/index.js"(exports2, module2) {
    var MAX_SAFE_INTEGER = 9007199254740991;
    var argsTag = "[object Arguments]";
    var funcTag = "[object Function]";
    var genTag = "[object GeneratorFunction]";
    var reIsUint = /^(?:0|[1-9]\d*)$/;
    function apply(func, thisArg, args) {
      switch (args.length) {
        case 0:
          return func.call(thisArg);
        case 1:
          return func.call(thisArg, args[0]);
        case 2:
          return func.call(thisArg, args[0], args[1]);
        case 3:
          return func.call(thisArg, args[0], args[1], args[2]);
      }
      return func.apply(thisArg, args);
    }
    function baseTimes(n, iteratee) {
      var index = -1, result = Array(n);
      while (++index < n) {
        result[index] = iteratee(index);
      }
      return result;
    }
    var objectProto = Object.prototype;
    var hasOwnProperty = objectProto.hasOwnProperty;
    var objectToString = objectProto.toString;
    var propertyIsEnumerable = objectProto.propertyIsEnumerable;
    var nativeMax = Math.max;
    function arrayLikeKeys(value, inherited) {
      var result = isArray(value) || isArguments(value) ? baseTimes(value.length, String) : [];
      var length = result.length, skipIndexes = !!length;
      for (var key in value) {
        if ((inherited || hasOwnProperty.call(value, key)) && !(skipIndexes && (key == "length" || isIndex(key, length)))) {
          result.push(key);
        }
      }
      return result;
    }
    function assignInDefaults(objValue, srcValue, key, object) {
      if (objValue === void 0 || eq(objValue, objectProto[key]) && !hasOwnProperty.call(object, key)) {
        return srcValue;
      }
      return objValue;
    }
    function assignValue(object, key, value) {
      var objValue = object[key];
      if (!(hasOwnProperty.call(object, key) && eq(objValue, value)) || value === void 0 && !(key in object)) {
        object[key] = value;
      }
    }
    function baseKeysIn(object) {
      if (!isObject2(object)) {
        return nativeKeysIn(object);
      }
      var isProto = isPrototype(object), result = [];
      for (var key in object) {
        if (!(key == "constructor" && (isProto || !hasOwnProperty.call(object, key)))) {
          result.push(key);
        }
      }
      return result;
    }
    function baseRest(func, start) {
      start = nativeMax(start === void 0 ? func.length - 1 : start, 0);
      return function() {
        var args = arguments, index = -1, length = nativeMax(args.length - start, 0), array = Array(length);
        while (++index < length) {
          array[index] = args[start + index];
        }
        index = -1;
        var otherArgs = Array(start + 1);
        while (++index < start) {
          otherArgs[index] = args[index];
        }
        otherArgs[start] = array;
        return apply(func, this, otherArgs);
      };
    }
    function copyObject(source, props, object, customizer) {
      object || (object = {});
      var index = -1, length = props.length;
      while (++index < length) {
        var key = props[index];
        var newValue = customizer ? customizer(object[key], source[key], key, object, source) : void 0;
        assignValue(object, key, newValue === void 0 ? source[key] : newValue);
      }
      return object;
    }
    function createAssigner(assigner) {
      return baseRest(function(object, sources) {
        var index = -1, length = sources.length, customizer = length > 1 ? sources[length - 1] : void 0, guard = length > 2 ? sources[2] : void 0;
        customizer = assigner.length > 3 && typeof customizer == "function" ? (length--, customizer) : void 0;
        if (guard && isIterateeCall(sources[0], sources[1], guard)) {
          customizer = length < 3 ? void 0 : customizer;
          length = 1;
        }
        object = Object(object);
        while (++index < length) {
          var source = sources[index];
          if (source) {
            assigner(object, source, index, customizer);
          }
        }
        return object;
      });
    }
    function isIndex(value, length) {
      length = length == null ? MAX_SAFE_INTEGER : length;
      return !!length && (typeof value == "number" || reIsUint.test(value)) && (value > -1 && value % 1 == 0 && value < length);
    }
    function isIterateeCall(value, index, object) {
      if (!isObject2(object)) {
        return false;
      }
      var type = typeof index;
      if (type == "number" ? isArrayLike(object) && isIndex(index, object.length) : type == "string" && index in object) {
        return eq(object[index], value);
      }
      return false;
    }
    function isPrototype(value) {
      var Ctor = value && value.constructor, proto = typeof Ctor == "function" && Ctor.prototype || objectProto;
      return value === proto;
    }
    function nativeKeysIn(object) {
      var result = [];
      if (object != null) {
        for (var key in Object(object)) {
          result.push(key);
        }
      }
      return result;
    }
    function eq(value, other) {
      return value === other || value !== value && other !== other;
    }
    function isArguments(value) {
      return isArrayLikeObject(value) && hasOwnProperty.call(value, "callee") && (!propertyIsEnumerable.call(value, "callee") || objectToString.call(value) == argsTag);
    }
    var isArray = Array.isArray;
    function isArrayLike(value) {
      return value != null && isLength(value.length) && !isFunction(value);
    }
    function isArrayLikeObject(value) {
      return isObjectLike(value) && isArrayLike(value);
    }
    function isFunction(value) {
      var tag = isObject2(value) ? objectToString.call(value) : "";
      return tag == funcTag || tag == genTag;
    }
    function isLength(value) {
      return typeof value == "number" && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
    }
    function isObject2(value) {
      var type = typeof value;
      return !!value && (type == "object" || type == "function");
    }
    function isObjectLike(value) {
      return !!value && typeof value == "object";
    }
    var assignInWith = createAssigner(function(object, source, srcIndex, customizer) {
      copyObject(source, keysIn(source), object, customizer);
    });
    var defaults = baseRest(function(args) {
      args.push(void 0, assignInDefaults);
      return apply(assignInWith, void 0, args);
    });
    function keysIn(object) {
      return isArrayLike(object) ? arrayLikeKeys(object, true) : baseKeysIn(object);
    }
    module2.exports = defaults;
  }
});

// ../../../node_modules/archiver-utils/node_modules/isarray/index.js
var require_isarray3 = __commonJS({
  "../../../node_modules/archiver-utils/node_modules/isarray/index.js"(exports2, module2) {
    var toString = {}.toString;
    module2.exports = Array.isArray || function(arr) {
      return toString.call(arr) == "[object Array]";
    };
  }
});

// ../../../node_modules/archiver-utils/node_modules/readable-stream/lib/internal/streams/stream.js
var require_stream4 = __commonJS({
  "../../../node_modules/archiver-utils/node_modules/readable-stream/lib/internal/streams/stream.js"(exports2, module2) {
    module2.exports = require("stream");
  }
});

// ../../../node_modules/archiver-utils/node_modules/safe-buffer/index.js
var require_safe_buffer4 = __commonJS({
  "../../../node_modules/archiver-utils/node_modules/safe-buffer/index.js"(exports2, module2) {
    var buffer = require("buffer");
    var Buffer2 = buffer.Buffer;
    function copyProps(src, dst) {
      for (var key in src) {
        dst[key] = src[key];
      }
    }
    if (Buffer2.from && Buffer2.alloc && Buffer2.allocUnsafe && Buffer2.allocUnsafeSlow) {
      module2.exports = buffer;
    } else {
      copyProps(buffer, exports2);
      exports2.Buffer = SafeBuffer;
    }
    function SafeBuffer(arg, encodingOrOffset, length) {
      return Buffer2(arg, encodingOrOffset, length);
    }
    copyProps(Buffer2, SafeBuffer);
    SafeBuffer.from = function(arg, encodingOrOffset, length) {
      if (typeof arg === "number") {
        throw new TypeError("Argument must not be a number");
      }
      return Buffer2(arg, encodingOrOffset, length);
    };
    SafeBuffer.alloc = function(size, fill, encoding) {
      if (typeof size !== "number") {
        throw new TypeError("Argument must be a number");
      }
      var buf = Buffer2(size);
      if (fill !== void 0) {
        if (typeof encoding === "string") {
          buf.fill(fill, encoding);
        } else {
          buf.fill(fill);
        }
      } else {
        buf.fill(0);
      }
      return buf;
    };
    SafeBuffer.allocUnsafe = function(size) {
      if (typeof size !== "number") {
        throw new TypeError("Argument must be a number");
      }
      return Buffer2(size);
    };
    SafeBuffer.allocUnsafeSlow = function(size) {
      if (typeof size !== "number") {
        throw new TypeError("Argument must be a number");
      }
      return buffer.SlowBuffer(size);
    };
  }
});

// ../../../node_modules/archiver-utils/node_modules/readable-stream/lib/internal/streams/BufferList.js
var require_BufferList3 = __commonJS({
  "../../../node_modules/archiver-utils/node_modules/readable-stream/lib/internal/streams/BufferList.js"(exports2, module2) {
    "use strict";
    function _classCallCheck(instance, Constructor) {
      if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
      }
    }
    var Buffer2 = require_safe_buffer4().Buffer;
    var util = require("util");
    function copyBuffer(src, target, offset) {
      src.copy(target, offset);
    }
    module2.exports = function() {
      function BufferList() {
        _classCallCheck(this, BufferList);
        this.head = null;
        this.tail = null;
        this.length = 0;
      }
      BufferList.prototype.push = function push(v) {
        var entry = { data: v, next: null };
        if (this.length > 0)
          this.tail.next = entry;
        else
          this.head = entry;
        this.tail = entry;
        ++this.length;
      };
      BufferList.prototype.unshift = function unshift(v) {
        var entry = { data: v, next: this.head };
        if (this.length === 0)
          this.tail = entry;
        this.head = entry;
        ++this.length;
      };
      BufferList.prototype.shift = function shift() {
        if (this.length === 0)
          return;
        var ret2 = this.head.data;
        if (this.length === 1)
          this.head = this.tail = null;
        else
          this.head = this.head.next;
        --this.length;
        return ret2;
      };
      BufferList.prototype.clear = function clear() {
        this.head = this.tail = null;
        this.length = 0;
      };
      BufferList.prototype.join = function join(s) {
        if (this.length === 0)
          return "";
        var p = this.head;
        var ret2 = "" + p.data;
        while (p = p.next) {
          ret2 += s + p.data;
        }
        return ret2;
      };
      BufferList.prototype.concat = function concat(n) {
        if (this.length === 0)
          return Buffer2.alloc(0);
        var ret2 = Buffer2.allocUnsafe(n >>> 0);
        var p = this.head;
        var i = 0;
        while (p) {
          copyBuffer(p.data, ret2, i);
          i += p.data.length;
          p = p.next;
        }
        return ret2;
      };
      return BufferList;
    }();
    if (util && util.inspect && util.inspect.custom) {
      module2.exports.prototype[util.inspect.custom] = function() {
        var obj2 = util.inspect({ length: this.length });
        return this.constructor.name + " " + obj2;
      };
    }
  }
});

// ../../../node_modules/archiver-utils/node_modules/readable-stream/lib/internal/streams/destroy.js
var require_destroy4 = __commonJS({
  "../../../node_modules/archiver-utils/node_modules/readable-stream/lib/internal/streams/destroy.js"(exports2, module2) {
    "use strict";
    var pna = require_process_nextick_args();
    function destroy(err, cb) {
      var _this = this;
      var readableDestroyed = this._readableState && this._readableState.destroyed;
      var writableDestroyed = this._writableState && this._writableState.destroyed;
      if (readableDestroyed || writableDestroyed) {
        if (cb) {
          cb(err);
        } else if (err) {
          if (!this._writableState) {
            pna.nextTick(emitErrorNT, this, err);
          } else if (!this._writableState.errorEmitted) {
            this._writableState.errorEmitted = true;
            pna.nextTick(emitErrorNT, this, err);
          }
        }
        return this;
      }
      if (this._readableState) {
        this._readableState.destroyed = true;
      }
      if (this._writableState) {
        this._writableState.destroyed = true;
      }
      this._destroy(err || null, function(err2) {
        if (!cb && err2) {
          if (!_this._writableState) {
            pna.nextTick(emitErrorNT, _this, err2);
          } else if (!_this._writableState.errorEmitted) {
            _this._writableState.errorEmitted = true;
            pna.nextTick(emitErrorNT, _this, err2);
          }
        } else if (cb) {
          cb(err2);
        }
      });
      return this;
    }
    function undestroy() {
      if (this._readableState) {
        this._readableState.destroyed = false;
        this._readableState.reading = false;
        this._readableState.ended = false;
        this._readableState.endEmitted = false;
      }
      if (this._writableState) {
        this._writableState.destroyed = false;
        this._writableState.ended = false;
        this._writableState.ending = false;
        this._writableState.finalCalled = false;
        this._writableState.prefinished = false;
        this._writableState.finished = false;
        this._writableState.errorEmitted = false;
      }
    }
    function emitErrorNT(self2, err) {
      self2.emit("error", err);
    }
    module2.exports = {
      destroy,
      undestroy
    };
  }
});

// ../../../node_modules/archiver-utils/node_modules/readable-stream/lib/_stream_writable.js
var require_stream_writable4 = __commonJS({
  "../../../node_modules/archiver-utils/node_modules/readable-stream/lib/_stream_writable.js"(exports2, module2) {
    "use strict";
    var pna = require_process_nextick_args();
    module2.exports = Writable;
    function CorkedRequest(state) {
      var _this = this;
      this.next = null;
      this.entry = null;
      this.finish = function() {
        onCorkedFinish(_this, state);
      };
    }
    var asyncWrite = !process.browser && ["v0.10", "v0.9."].indexOf(process.version.slice(0, 5)) > -1 ? setImmediate : pna.nextTick;
    var Duplex;
    Writable.WritableState = WritableState;
    var util = Object.create(require_util());
    util.inherits = require_inherits();
    var internalUtil = {
      deprecate: require_node()
    };
    var Stream = require_stream4();
    var Buffer2 = require_safe_buffer4().Buffer;
    var OurUint8Array = (typeof global !== "undefined" ? global : typeof window !== "undefined" ? window : typeof self !== "undefined" ? self : {}).Uint8Array || function() {
    };
    function _uint8ArrayToBuffer(chunk) {
      return Buffer2.from(chunk);
    }
    function _isUint8Array(obj2) {
      return Buffer2.isBuffer(obj2) || obj2 instanceof OurUint8Array;
    }
    var destroyImpl = require_destroy4();
    util.inherits(Writable, Stream);
    function nop() {
    }
    function WritableState(options, stream) {
      Duplex = Duplex || require_stream_duplex4();
      options = options || {};
      var isDuplex = stream instanceof Duplex;
      this.objectMode = !!options.objectMode;
      if (isDuplex)
        this.objectMode = this.objectMode || !!options.writableObjectMode;
      var hwm = options.highWaterMark;
      var writableHwm = options.writableHighWaterMark;
      var defaultHwm = this.objectMode ? 16 : 16 * 1024;
      if (hwm || hwm === 0)
        this.highWaterMark = hwm;
      else if (isDuplex && (writableHwm || writableHwm === 0))
        this.highWaterMark = writableHwm;
      else
        this.highWaterMark = defaultHwm;
      this.highWaterMark = Math.floor(this.highWaterMark);
      this.finalCalled = false;
      this.needDrain = false;
      this.ending = false;
      this.ended = false;
      this.finished = false;
      this.destroyed = false;
      var noDecode = options.decodeStrings === false;
      this.decodeStrings = !noDecode;
      this.defaultEncoding = options.defaultEncoding || "utf8";
      this.length = 0;
      this.writing = false;
      this.corked = 0;
      this.sync = true;
      this.bufferProcessing = false;
      this.onwrite = function(er) {
        onwrite(stream, er);
      };
      this.writecb = null;
      this.writelen = 0;
      this.bufferedRequest = null;
      this.lastBufferedRequest = null;
      this.pendingcb = 0;
      this.prefinished = false;
      this.errorEmitted = false;
      this.bufferedRequestCount = 0;
      this.corkedRequestsFree = new CorkedRequest(this);
    }
    WritableState.prototype.getBuffer = function getBuffer() {
      var current = this.bufferedRequest;
      var out = [];
      while (current) {
        out.push(current);
        current = current.next;
      }
      return out;
    };
    (function() {
      try {
        Object.defineProperty(WritableState.prototype, "buffer", {
          get: internalUtil.deprecate(function() {
            return this.getBuffer();
          }, "_writableState.buffer is deprecated. Use _writableState.getBuffer instead.", "DEP0003")
        });
      } catch (_2) {
      }
    })();
    var realHasInstance;
    if (typeof Symbol === "function" && Symbol.hasInstance && typeof Function.prototype[Symbol.hasInstance] === "function") {
      realHasInstance = Function.prototype[Symbol.hasInstance];
      Object.defineProperty(Writable, Symbol.hasInstance, {
        value: function(object) {
          if (realHasInstance.call(this, object))
            return true;
          if (this !== Writable)
            return false;
          return object && object._writableState instanceof WritableState;
        }
      });
    } else {
      realHasInstance = function(object) {
        return object instanceof this;
      };
    }
    function Writable(options) {
      Duplex = Duplex || require_stream_duplex4();
      if (!realHasInstance.call(Writable, this) && !(this instanceof Duplex)) {
        return new Writable(options);
      }
      this._writableState = new WritableState(options, this);
      this.writable = true;
      if (options) {
        if (typeof options.write === "function")
          this._write = options.write;
        if (typeof options.writev === "function")
          this._writev = options.writev;
        if (typeof options.destroy === "function")
          this._destroy = options.destroy;
        if (typeof options.final === "function")
          this._final = options.final;
      }
      Stream.call(this);
    }
    Writable.prototype.pipe = function() {
      this.emit("error", new Error("Cannot pipe, not readable"));
    };
    function writeAfterEnd(stream, cb) {
      var er = new Error("write after end");
      stream.emit("error", er);
      pna.nextTick(cb, er);
    }
    function validChunk(stream, state, chunk, cb) {
      var valid = true;
      var er = false;
      if (chunk === null) {
        er = new TypeError("May not write null values to stream");
      } else if (typeof chunk !== "string" && chunk !== void 0 && !state.objectMode) {
        er = new TypeError("Invalid non-string/buffer chunk");
      }
      if (er) {
        stream.emit("error", er);
        pna.nextTick(cb, er);
        valid = false;
      }
      return valid;
    }
    Writable.prototype.write = function(chunk, encoding, cb) {
      var state = this._writableState;
      var ret2 = false;
      var isBuf = !state.objectMode && _isUint8Array(chunk);
      if (isBuf && !Buffer2.isBuffer(chunk)) {
        chunk = _uint8ArrayToBuffer(chunk);
      }
      if (typeof encoding === "function") {
        cb = encoding;
        encoding = null;
      }
      if (isBuf)
        encoding = "buffer";
      else if (!encoding)
        encoding = state.defaultEncoding;
      if (typeof cb !== "function")
        cb = nop;
      if (state.ended)
        writeAfterEnd(this, cb);
      else if (isBuf || validChunk(this, state, chunk, cb)) {
        state.pendingcb++;
        ret2 = writeOrBuffer(this, state, isBuf, chunk, encoding, cb);
      }
      return ret2;
    };
    Writable.prototype.cork = function() {
      var state = this._writableState;
      state.corked++;
    };
    Writable.prototype.uncork = function() {
      var state = this._writableState;
      if (state.corked) {
        state.corked--;
        if (!state.writing && !state.corked && !state.bufferProcessing && state.bufferedRequest)
          clearBuffer(this, state);
      }
    };
    Writable.prototype.setDefaultEncoding = function setDefaultEncoding(encoding) {
      if (typeof encoding === "string")
        encoding = encoding.toLowerCase();
      if (!(["hex", "utf8", "utf-8", "ascii", "binary", "base64", "ucs2", "ucs-2", "utf16le", "utf-16le", "raw"].indexOf((encoding + "").toLowerCase()) > -1))
        throw new TypeError("Unknown encoding: " + encoding);
      this._writableState.defaultEncoding = encoding;
      return this;
    };
    function decodeChunk(state, chunk, encoding) {
      if (!state.objectMode && state.decodeStrings !== false && typeof chunk === "string") {
        chunk = Buffer2.from(chunk, encoding);
      }
      return chunk;
    }
    Object.defineProperty(Writable.prototype, "writableHighWaterMark", {
      // making it explicit this property is not enumerable
      // because otherwise some prototype manipulation in
      // userland will fail
      enumerable: false,
      get: function() {
        return this._writableState.highWaterMark;
      }
    });
    function writeOrBuffer(stream, state, isBuf, chunk, encoding, cb) {
      if (!isBuf) {
        var newChunk = decodeChunk(state, chunk, encoding);
        if (chunk !== newChunk) {
          isBuf = true;
          encoding = "buffer";
          chunk = newChunk;
        }
      }
      var len = state.objectMode ? 1 : chunk.length;
      state.length += len;
      var ret2 = state.length < state.highWaterMark;
      if (!ret2)
        state.needDrain = true;
      if (state.writing || state.corked) {
        var last = state.lastBufferedRequest;
        state.lastBufferedRequest = {
          chunk,
          encoding,
          isBuf,
          callback: cb,
          next: null
        };
        if (last) {
          last.next = state.lastBufferedRequest;
        } else {
          state.bufferedRequest = state.lastBufferedRequest;
        }
        state.bufferedRequestCount += 1;
      } else {
        doWrite(stream, state, false, len, chunk, encoding, cb);
      }
      return ret2;
    }
    function doWrite(stream, state, writev, len, chunk, encoding, cb) {
      state.writelen = len;
      state.writecb = cb;
      state.writing = true;
      state.sync = true;
      if (writev)
        stream._writev(chunk, state.onwrite);
      else
        stream._write(chunk, encoding, state.onwrite);
      state.sync = false;
    }
    function onwriteError(stream, state, sync, er, cb) {
      --state.pendingcb;
      if (sync) {
        pna.nextTick(cb, er);
        pna.nextTick(finishMaybe, stream, state);
        stream._writableState.errorEmitted = true;
        stream.emit("error", er);
      } else {
        cb(er);
        stream._writableState.errorEmitted = true;
        stream.emit("error", er);
        finishMaybe(stream, state);
      }
    }
    function onwriteStateUpdate(state) {
      state.writing = false;
      state.writecb = null;
      state.length -= state.writelen;
      state.writelen = 0;
    }
    function onwrite(stream, er) {
      var state = stream._writableState;
      var sync = state.sync;
      var cb = state.writecb;
      onwriteStateUpdate(state);
      if (er)
        onwriteError(stream, state, sync, er, cb);
      else {
        var finished = needFinish(state);
        if (!finished && !state.corked && !state.bufferProcessing && state.bufferedRequest) {
          clearBuffer(stream, state);
        }
        if (sync) {
          asyncWrite(afterWrite, stream, state, finished, cb);
        } else {
          afterWrite(stream, state, finished, cb);
        }
      }
    }
    function afterWrite(stream, state, finished, cb) {
      if (!finished)
        onwriteDrain(stream, state);
      state.pendingcb--;
      cb();
      finishMaybe(stream, state);
    }
    function onwriteDrain(stream, state) {
      if (state.length === 0 && state.needDrain) {
        state.needDrain = false;
        stream.emit("drain");
      }
    }
    function clearBuffer(stream, state) {
      state.bufferProcessing = true;
      var entry = state.bufferedRequest;
      if (stream._writev && entry && entry.next) {
        var l2 = state.bufferedRequestCount;
        var buffer = new Array(l2);
        var holder = state.corkedRequestsFree;
        holder.entry = entry;
        var count = 0;
        var allBuffers = true;
        while (entry) {
          buffer[count] = entry;
          if (!entry.isBuf)
            allBuffers = false;
          entry = entry.next;
          count += 1;
        }
        buffer.allBuffers = allBuffers;
        doWrite(stream, state, true, state.length, buffer, "", holder.finish);
        state.pendingcb++;
        state.lastBufferedRequest = null;
        if (holder.next) {
          state.corkedRequestsFree = holder.next;
          holder.next = null;
        } else {
          state.corkedRequestsFree = new CorkedRequest(state);
        }
        state.bufferedRequestCount = 0;
      } else {
        while (entry) {
          var chunk = entry.chunk;
          var encoding = entry.encoding;
          var cb = entry.callback;
          var len = state.objectMode ? 1 : chunk.length;
          doWrite(stream, state, false, len, chunk, encoding, cb);
          entry = entry.next;
          state.bufferedRequestCount--;
          if (state.writing) {
            break;
          }
        }
        if (entry === null)
          state.lastBufferedRequest = null;
      }
      state.bufferedRequest = entry;
      state.bufferProcessing = false;
    }
    Writable.prototype._write = function(chunk, encoding, cb) {
      cb(new Error("_write() is not implemented"));
    };
    Writable.prototype._writev = null;
    Writable.prototype.end = function(chunk, encoding, cb) {
      var state = this._writableState;
      if (typeof chunk === "function") {
        cb = chunk;
        chunk = null;
        encoding = null;
      } else if (typeof encoding === "function") {
        cb = encoding;
        encoding = null;
      }
      if (chunk !== null && chunk !== void 0)
        this.write(chunk, encoding);
      if (state.corked) {
        state.corked = 1;
        this.uncork();
      }
      if (!state.ending)
        endWritable(this, state, cb);
    };
    function needFinish(state) {
      return state.ending && state.length === 0 && state.bufferedRequest === null && !state.finished && !state.writing;
    }
    function callFinal(stream, state) {
      stream._final(function(err) {
        state.pendingcb--;
        if (err) {
          stream.emit("error", err);
        }
        state.prefinished = true;
        stream.emit("prefinish");
        finishMaybe(stream, state);
      });
    }
    function prefinish(stream, state) {
      if (!state.prefinished && !state.finalCalled) {
        if (typeof stream._final === "function") {
          state.pendingcb++;
          state.finalCalled = true;
          pna.nextTick(callFinal, stream, state);
        } else {
          state.prefinished = true;
          stream.emit("prefinish");
        }
      }
    }
    function finishMaybe(stream, state) {
      var need = needFinish(state);
      if (need) {
        prefinish(stream, state);
        if (state.pendingcb === 0) {
          state.finished = true;
          stream.emit("finish");
        }
      }
      return need;
    }
    function endWritable(stream, state, cb) {
      state.ending = true;
      finishMaybe(stream, state);
      if (cb) {
        if (state.finished)
          pna.nextTick(cb);
        else
          stream.once("finish", cb);
      }
      state.ended = true;
      stream.writable = false;
    }
    function onCorkedFinish(corkReq, state, err) {
      var entry = corkReq.entry;
      corkReq.entry = null;
      while (entry) {
        var cb = entry.callback;
        state.pendingcb--;
        cb(err);
        entry = entry.next;
      }
      state.corkedRequestsFree.next = corkReq;
    }
    Object.defineProperty(Writable.prototype, "destroyed", {
      get: function() {
        if (this._writableState === void 0) {
          return false;
        }
        return this._writableState.destroyed;
      },
      set: function(value) {
        if (!this._writableState) {
          return;
        }
        this._writableState.destroyed = value;
      }
    });
    Writable.prototype.destroy = destroyImpl.destroy;
    Writable.prototype._undestroy = destroyImpl.undestroy;
    Writable.prototype._destroy = function(err, cb) {
      this.end();
      cb(err);
    };
  }
});

// ../../../node_modules/archiver-utils/node_modules/readable-stream/lib/_stream_duplex.js
var require_stream_duplex4 = __commonJS({
  "../../../node_modules/archiver-utils/node_modules/readable-stream/lib/_stream_duplex.js"(exports2, module2) {
    "use strict";
    var pna = require_process_nextick_args();
    var objectKeys = Object.keys || function(obj2) {
      var keys2 = [];
      for (var key in obj2) {
        keys2.push(key);
      }
      return keys2;
    };
    module2.exports = Duplex;
    var util = Object.create(require_util());
    util.inherits = require_inherits();
    var Readable = require_stream_readable4();
    var Writable = require_stream_writable4();
    util.inherits(Duplex, Readable);
    {
      keys = objectKeys(Writable.prototype);
      for (v = 0; v < keys.length; v++) {
        method = keys[v];
        if (!Duplex.prototype[method])
          Duplex.prototype[method] = Writable.prototype[method];
      }
    }
    var keys;
    var method;
    var v;
    function Duplex(options) {
      if (!(this instanceof Duplex))
        return new Duplex(options);
      Readable.call(this, options);
      Writable.call(this, options);
      if (options && options.readable === false)
        this.readable = false;
      if (options && options.writable === false)
        this.writable = false;
      this.allowHalfOpen = true;
      if (options && options.allowHalfOpen === false)
        this.allowHalfOpen = false;
      this.once("end", onend);
    }
    Object.defineProperty(Duplex.prototype, "writableHighWaterMark", {
      // making it explicit this property is not enumerable
      // because otherwise some prototype manipulation in
      // userland will fail
      enumerable: false,
      get: function() {
        return this._writableState.highWaterMark;
      }
    });
    function onend() {
      if (this.allowHalfOpen || this._writableState.ended)
        return;
      pna.nextTick(onEndNT, this);
    }
    function onEndNT(self2) {
      self2.end();
    }
    Object.defineProperty(Duplex.prototype, "destroyed", {
      get: function() {
        if (this._readableState === void 0 || this._writableState === void 0) {
          return false;
        }
        return this._readableState.destroyed && this._writableState.destroyed;
      },
      set: function(value) {
        if (this._readableState === void 0 || this._writableState === void 0) {
          return;
        }
        this._readableState.destroyed = value;
        this._writableState.destroyed = value;
      }
    });
    Duplex.prototype._destroy = function(err, cb) {
      this.push(null);
      this.end();
      pna.nextTick(cb, err);
    };
  }
});

// ../../../node_modules/archiver-utils/node_modules/string_decoder/lib/string_decoder.js
var require_string_decoder4 = __commonJS({
  "../../../node_modules/archiver-utils/node_modules/string_decoder/lib/string_decoder.js"(exports2) {
    "use strict";
    var Buffer2 = require_safe_buffer4().Buffer;
    var isEncoding = Buffer2.isEncoding || function(encoding) {
      encoding = "" + encoding;
      switch (encoding && encoding.toLowerCase()) {
        case "hex":
        case "utf8":
        case "utf-8":
        case "ascii":
        case "binary":
        case "base64":
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
        case "raw":
          return true;
        default:
          return false;
      }
    };
    function _normalizeEncoding(enc) {
      if (!enc)
        return "utf8";
      var retried;
      while (true) {
        switch (enc) {
          case "utf8":
          case "utf-8":
            return "utf8";
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
            return "utf16le";
          case "latin1":
          case "binary":
            return "latin1";
          case "base64":
          case "ascii":
          case "hex":
            return enc;
          default:
            if (retried)
              return;
            enc = ("" + enc).toLowerCase();
            retried = true;
        }
      }
    }
    function normalizeEncoding(enc) {
      var nenc = _normalizeEncoding(enc);
      if (typeof nenc !== "string" && (Buffer2.isEncoding === isEncoding || !isEncoding(enc)))
        throw new Error("Unknown encoding: " + enc);
      return nenc || enc;
    }
    exports2.StringDecoder = StringDecoder;
    function StringDecoder(encoding) {
      this.encoding = normalizeEncoding(encoding);
      var nb;
      switch (this.encoding) {
        case "utf16le":
          this.text = utf16Text;
          this.end = utf16End;
          nb = 4;
          break;
        case "utf8":
          this.fillLast = utf8FillLast;
          nb = 4;
          break;
        case "base64":
          this.text = base64Text;
          this.end = base64End;
          nb = 3;
          break;
        default:
          this.write = simpleWrite;
          this.end = simpleEnd;
          return;
      }
      this.lastNeed = 0;
      this.lastTotal = 0;
      this.lastChar = Buffer2.allocUnsafe(nb);
    }
    StringDecoder.prototype.write = function(buf) {
      if (buf.length === 0)
        return "";
      var r;
      var i;
      if (this.lastNeed) {
        r = this.fillLast(buf);
        if (r === void 0)
          return "";
        i = this.lastNeed;
        this.lastNeed = 0;
      } else {
        i = 0;
      }
      if (i < buf.length)
        return r ? r + this.text(buf, i) : this.text(buf, i);
      return r || "";
    };
    StringDecoder.prototype.end = utf8End;
    StringDecoder.prototype.text = utf8Text;
    StringDecoder.prototype.fillLast = function(buf) {
      if (this.lastNeed <= buf.length) {
        buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, this.lastNeed);
        return this.lastChar.toString(this.encoding, 0, this.lastTotal);
      }
      buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, buf.length);
      this.lastNeed -= buf.length;
    };
    function utf8CheckByte(byte) {
      if (byte <= 127)
        return 0;
      else if (byte >> 5 === 6)
        return 2;
      else if (byte >> 4 === 14)
        return 3;
      else if (byte >> 3 === 30)
        return 4;
      return byte >> 6 === 2 ? -1 : -2;
    }
    function utf8CheckIncomplete(self2, buf, i) {
      var j = buf.length - 1;
      if (j < i)
        return 0;
      var nb = utf8CheckByte(buf[j]);
      if (nb >= 0) {
        if (nb > 0)
          self2.lastNeed = nb - 1;
        return nb;
      }
      if (--j < i || nb === -2)
        return 0;
      nb = utf8CheckByte(buf[j]);
      if (nb >= 0) {
        if (nb > 0)
          self2.lastNeed = nb - 2;
        return nb;
      }
      if (--j < i || nb === -2)
        return 0;
      nb = utf8CheckByte(buf[j]);
      if (nb >= 0) {
        if (nb > 0) {
          if (nb === 2)
            nb = 0;
          else
            self2.lastNeed = nb - 3;
        }
        return nb;
      }
      return 0;
    }
    function utf8CheckExtraBytes(self2, buf, p) {
      if ((buf[0] & 192) !== 128) {
        self2.lastNeed = 0;
        return "\uFFFD";
      }
      if (self2.lastNeed > 1 && buf.length > 1) {
        if ((buf[1] & 192) !== 128) {
          self2.lastNeed = 1;
          return "\uFFFD";
        }
        if (self2.lastNeed > 2 && buf.length > 2) {
          if ((buf[2] & 192) !== 128) {
            self2.lastNeed = 2;
            return "\uFFFD";
          }
        }
      }
    }
    function utf8FillLast(buf) {
      var p = this.lastTotal - this.lastNeed;
      var r = utf8CheckExtraBytes(this, buf, p);
      if (r !== void 0)
        return r;
      if (this.lastNeed <= buf.length) {
        buf.copy(this.lastChar, p, 0, this.lastNeed);
        return this.lastChar.toString(this.encoding, 0, this.lastTotal);
      }
      buf.copy(this.lastChar, p, 0, buf.length);
      this.lastNeed -= buf.length;
    }
    function utf8Text(buf, i) {
      var total = utf8CheckIncomplete(this, buf, i);
      if (!this.lastNeed)
        return buf.toString("utf8", i);
      this.lastTotal = total;
      var end = buf.length - (total - this.lastNeed);
      buf.copy(this.lastChar, 0, end);
      return buf.toString("utf8", i, end);
    }
    function utf8End(buf) {
      var r = buf && buf.length ? this.write(buf) : "";
      if (this.lastNeed)
        return r + "\uFFFD";
      return r;
    }
    function utf16Text(buf, i) {
      if ((buf.length - i) % 2 === 0) {
        var r = buf.toString("utf16le", i);
        if (r) {
          var c = r.charCodeAt(r.length - 1);
          if (c >= 55296 && c <= 56319) {
            this.lastNeed = 2;
            this.lastTotal = 4;
            this.lastChar[0] = buf[buf.length - 2];
            this.lastChar[1] = buf[buf.length - 1];
            return r.slice(0, -1);
          }
        }
        return r;
      }
      this.lastNeed = 1;
      this.lastTotal = 2;
      this.lastChar[0] = buf[buf.length - 1];
      return buf.toString("utf16le", i, buf.length - 1);
    }
    function utf16End(buf) {
      var r = buf && buf.length ? this.write(buf) : "";
      if (this.lastNeed) {
        var end = this.lastTotal - this.lastNeed;
        return r + this.lastChar.toString("utf16le", 0, end);
      }
      return r;
    }
    function base64Text(buf, i) {
      var n = (buf.length - i) % 3;
      if (n === 0)
        return buf.toString("base64", i);
      this.lastNeed = 3 - n;
      this.lastTotal = 3;
      if (n === 1) {
        this.lastChar[0] = buf[buf.length - 1];
      } else {
        this.lastChar[0] = buf[buf.length - 2];
        this.lastChar[1] = buf[buf.length - 1];
      }
      return buf.toString("base64", i, buf.length - n);
    }
    function base64End(buf) {
      var r = buf && buf.length ? this.write(buf) : "";
      if (this.lastNeed)
        return r + this.lastChar.toString("base64", 0, 3 - this.lastNeed);
      return r;
    }
    function simpleWrite(buf) {
      return buf.toString(this.encoding);
    }
    function simpleEnd(buf) {
      return buf && buf.length ? this.write(buf) : "";
    }
  }
});

// ../../../node_modules/archiver-utils/node_modules/readable-stream/lib/_stream_readable.js
var require_stream_readable4 = __commonJS({
  "../../../node_modules/archiver-utils/node_modules/readable-stream/lib/_stream_readable.js"(exports2, module2) {
    "use strict";
    var pna = require_process_nextick_args();
    module2.exports = Readable;
    var isArray = require_isarray3();
    var Duplex;
    Readable.ReadableState = ReadableState;
    var EE = require("events").EventEmitter;
    var EElistenerCount = function(emitter, type) {
      return emitter.listeners(type).length;
    };
    var Stream = require_stream4();
    var Buffer2 = require_safe_buffer4().Buffer;
    var OurUint8Array = (typeof global !== "undefined" ? global : typeof window !== "undefined" ? window : typeof self !== "undefined" ? self : {}).Uint8Array || function() {
    };
    function _uint8ArrayToBuffer(chunk) {
      return Buffer2.from(chunk);
    }
    function _isUint8Array(obj2) {
      return Buffer2.isBuffer(obj2) || obj2 instanceof OurUint8Array;
    }
    var util = Object.create(require_util());
    util.inherits = require_inherits();
    var debugUtil = require("util");
    var debug = void 0;
    if (debugUtil && debugUtil.debuglog) {
      debug = debugUtil.debuglog("stream");
    } else {
      debug = function() {
      };
    }
    var BufferList = require_BufferList3();
    var destroyImpl = require_destroy4();
    var StringDecoder;
    util.inherits(Readable, Stream);
    var kProxyEvents = ["error", "close", "destroy", "pause", "resume"];
    function prependListener(emitter, event, fn) {
      if (typeof emitter.prependListener === "function")
        return emitter.prependListener(event, fn);
      if (!emitter._events || !emitter._events[event])
        emitter.on(event, fn);
      else if (isArray(emitter._events[event]))
        emitter._events[event].unshift(fn);
      else
        emitter._events[event] = [fn, emitter._events[event]];
    }
    function ReadableState(options, stream) {
      Duplex = Duplex || require_stream_duplex4();
      options = options || {};
      var isDuplex = stream instanceof Duplex;
      this.objectMode = !!options.objectMode;
      if (isDuplex)
        this.objectMode = this.objectMode || !!options.readableObjectMode;
      var hwm = options.highWaterMark;
      var readableHwm = options.readableHighWaterMark;
      var defaultHwm = this.objectMode ? 16 : 16 * 1024;
      if (hwm || hwm === 0)
        this.highWaterMark = hwm;
      else if (isDuplex && (readableHwm || readableHwm === 0))
        this.highWaterMark = readableHwm;
      else
        this.highWaterMark = defaultHwm;
      this.highWaterMark = Math.floor(this.highWaterMark);
      this.buffer = new BufferList();
      this.length = 0;
      this.pipes = null;
      this.pipesCount = 0;
      this.flowing = null;
      this.ended = false;
      this.endEmitted = false;
      this.reading = false;
      this.sync = true;
      this.needReadable = false;
      this.emittedReadable = false;
      this.readableListening = false;
      this.resumeScheduled = false;
      this.destroyed = false;
      this.defaultEncoding = options.defaultEncoding || "utf8";
      this.awaitDrain = 0;
      this.readingMore = false;
      this.decoder = null;
      this.encoding = null;
      if (options.encoding) {
        if (!StringDecoder)
          StringDecoder = require_string_decoder4().StringDecoder;
        this.decoder = new StringDecoder(options.encoding);
        this.encoding = options.encoding;
      }
    }
    function Readable(options) {
      Duplex = Duplex || require_stream_duplex4();
      if (!(this instanceof Readable))
        return new Readable(options);
      this._readableState = new ReadableState(options, this);
      this.readable = true;
      if (options) {
        if (typeof options.read === "function")
          this._read = options.read;
        if (typeof options.destroy === "function")
          this._destroy = options.destroy;
      }
      Stream.call(this);
    }
    Object.defineProperty(Readable.prototype, "destroyed", {
      get: function() {
        if (this._readableState === void 0) {
          return false;
        }
        return this._readableState.destroyed;
      },
      set: function(value) {
        if (!this._readableState) {
          return;
        }
        this._readableState.destroyed = value;
      }
    });
    Readable.prototype.destroy = destroyImpl.destroy;
    Readable.prototype._undestroy = destroyImpl.undestroy;
    Readable.prototype._destroy = function(err, cb) {
      this.push(null);
      cb(err);
    };
    Readable.prototype.push = function(chunk, encoding) {
      var state = this._readableState;
      var skipChunkCheck;
      if (!state.objectMode) {
        if (typeof chunk === "string") {
          encoding = encoding || state.defaultEncoding;
          if (encoding !== state.encoding) {
            chunk = Buffer2.from(chunk, encoding);
            encoding = "";
          }
          skipChunkCheck = true;
        }
      } else {
        skipChunkCheck = true;
      }
      return readableAddChunk(this, chunk, encoding, false, skipChunkCheck);
    };
    Readable.prototype.unshift = function(chunk) {
      return readableAddChunk(this, chunk, null, true, false);
    };
    function readableAddChunk(stream, chunk, encoding, addToFront, skipChunkCheck) {
      var state = stream._readableState;
      if (chunk === null) {
        state.reading = false;
        onEofChunk(stream, state);
      } else {
        var er;
        if (!skipChunkCheck)
          er = chunkInvalid(state, chunk);
        if (er) {
          stream.emit("error", er);
        } else if (state.objectMode || chunk && chunk.length > 0) {
          if (typeof chunk !== "string" && !state.objectMode && Object.getPrototypeOf(chunk) !== Buffer2.prototype) {
            chunk = _uint8ArrayToBuffer(chunk);
          }
          if (addToFront) {
            if (state.endEmitted)
              stream.emit("error", new Error("stream.unshift() after end event"));
            else
              addChunk(stream, state, chunk, true);
          } else if (state.ended) {
            stream.emit("error", new Error("stream.push() after EOF"));
          } else {
            state.reading = false;
            if (state.decoder && !encoding) {
              chunk = state.decoder.write(chunk);
              if (state.objectMode || chunk.length !== 0)
                addChunk(stream, state, chunk, false);
              else
                maybeReadMore(stream, state);
            } else {
              addChunk(stream, state, chunk, false);
            }
          }
        } else if (!addToFront) {
          state.reading = false;
        }
      }
      return needMoreData(state);
    }
    function addChunk(stream, state, chunk, addToFront) {
      if (state.flowing && state.length === 0 && !state.sync) {
        stream.emit("data", chunk);
        stream.read(0);
      } else {
        state.length += state.objectMode ? 1 : chunk.length;
        if (addToFront)
          state.buffer.unshift(chunk);
        else
          state.buffer.push(chunk);
        if (state.needReadable)
          emitReadable(stream);
      }
      maybeReadMore(stream, state);
    }
    function chunkInvalid(state, chunk) {
      var er;
      if (!_isUint8Array(chunk) && typeof chunk !== "string" && chunk !== void 0 && !state.objectMode) {
        er = new TypeError("Invalid non-string/buffer chunk");
      }
      return er;
    }
    function needMoreData(state) {
      return !state.ended && (state.needReadable || state.length < state.highWaterMark || state.length === 0);
    }
    Readable.prototype.isPaused = function() {
      return this._readableState.flowing === false;
    };
    Readable.prototype.setEncoding = function(enc) {
      if (!StringDecoder)
        StringDecoder = require_string_decoder4().StringDecoder;
      this._readableState.decoder = new StringDecoder(enc);
      this._readableState.encoding = enc;
      return this;
    };
    var MAX_HWM = 8388608;
    function computeNewHighWaterMark(n) {
      if (n >= MAX_HWM) {
        n = MAX_HWM;
      } else {
        n--;
        n |= n >>> 1;
        n |= n >>> 2;
        n |= n >>> 4;
        n |= n >>> 8;
        n |= n >>> 16;
        n++;
      }
      return n;
    }
    function howMuchToRead(n, state) {
      if (n <= 0 || state.length === 0 && state.ended)
        return 0;
      if (state.objectMode)
        return 1;
      if (n !== n) {
        if (state.flowing && state.length)
          return state.buffer.head.data.length;
        else
          return state.length;
      }
      if (n > state.highWaterMark)
        state.highWaterMark = computeNewHighWaterMark(n);
      if (n <= state.length)
        return n;
      if (!state.ended) {
        state.needReadable = true;
        return 0;
      }
      return state.length;
    }
    Readable.prototype.read = function(n) {
      debug("read", n);
      n = parseInt(n, 10);
      var state = this._readableState;
      var nOrig = n;
      if (n !== 0)
        state.emittedReadable = false;
      if (n === 0 && state.needReadable && (state.length >= state.highWaterMark || state.ended)) {
        debug("read: emitReadable", state.length, state.ended);
        if (state.length === 0 && state.ended)
          endReadable(this);
        else
          emitReadable(this);
        return null;
      }
      n = howMuchToRead(n, state);
      if (n === 0 && state.ended) {
        if (state.length === 0)
          endReadable(this);
        return null;
      }
      var doRead = state.needReadable;
      debug("need readable", doRead);
      if (state.length === 0 || state.length - n < state.highWaterMark) {
        doRead = true;
        debug("length less than watermark", doRead);
      }
      if (state.ended || state.reading) {
        doRead = false;
        debug("reading or ended", doRead);
      } else if (doRead) {
        debug("do read");
        state.reading = true;
        state.sync = true;
        if (state.length === 0)
          state.needReadable = true;
        this._read(state.highWaterMark);
        state.sync = false;
        if (!state.reading)
          n = howMuchToRead(nOrig, state);
      }
      var ret2;
      if (n > 0)
        ret2 = fromList(n, state);
      else
        ret2 = null;
      if (ret2 === null) {
        state.needReadable = true;
        n = 0;
      } else {
        state.length -= n;
      }
      if (state.length === 0) {
        if (!state.ended)
          state.needReadable = true;
        if (nOrig !== n && state.ended)
          endReadable(this);
      }
      if (ret2 !== null)
        this.emit("data", ret2);
      return ret2;
    };
    function onEofChunk(stream, state) {
      if (state.ended)
        return;
      if (state.decoder) {
        var chunk = state.decoder.end();
        if (chunk && chunk.length) {
          state.buffer.push(chunk);
          state.length += state.objectMode ? 1 : chunk.length;
        }
      }
      state.ended = true;
      emitReadable(stream);
    }
    function emitReadable(stream) {
      var state = stream._readableState;
      state.needReadable = false;
      if (!state.emittedReadable) {
        debug("emitReadable", state.flowing);
        state.emittedReadable = true;
        if (state.sync)
          pna.nextTick(emitReadable_, stream);
        else
          emitReadable_(stream);
      }
    }
    function emitReadable_(stream) {
      debug("emit readable");
      stream.emit("readable");
      flow(stream);
    }
    function maybeReadMore(stream, state) {
      if (!state.readingMore) {
        state.readingMore = true;
        pna.nextTick(maybeReadMore_, stream, state);
      }
    }
    function maybeReadMore_(stream, state) {
      var len = state.length;
      while (!state.reading && !state.flowing && !state.ended && state.length < state.highWaterMark) {
        debug("maybeReadMore read 0");
        stream.read(0);
        if (len === state.length)
          break;
        else
          len = state.length;
      }
      state.readingMore = false;
    }
    Readable.prototype._read = function(n) {
      this.emit("error", new Error("_read() is not implemented"));
    };
    Readable.prototype.pipe = function(dest, pipeOpts) {
      var src = this;
      var state = this._readableState;
      switch (state.pipesCount) {
        case 0:
          state.pipes = dest;
          break;
        case 1:
          state.pipes = [state.pipes, dest];
          break;
        default:
          state.pipes.push(dest);
          break;
      }
      state.pipesCount += 1;
      debug("pipe count=%d opts=%j", state.pipesCount, pipeOpts);
      var doEnd = (!pipeOpts || pipeOpts.end !== false) && dest !== process.stdout && dest !== process.stderr;
      var endFn = doEnd ? onend : unpipe;
      if (state.endEmitted)
        pna.nextTick(endFn);
      else
        src.once("end", endFn);
      dest.on("unpipe", onunpipe);
      function onunpipe(readable, unpipeInfo) {
        debug("onunpipe");
        if (readable === src) {
          if (unpipeInfo && unpipeInfo.hasUnpiped === false) {
            unpipeInfo.hasUnpiped = true;
            cleanup();
          }
        }
      }
      function onend() {
        debug("onend");
        dest.end();
      }
      var ondrain = pipeOnDrain(src);
      dest.on("drain", ondrain);
      var cleanedUp = false;
      function cleanup() {
        debug("cleanup");
        dest.removeListener("close", onclose);
        dest.removeListener("finish", onfinish);
        dest.removeListener("drain", ondrain);
        dest.removeListener("error", onerror);
        dest.removeListener("unpipe", onunpipe);
        src.removeListener("end", onend);
        src.removeListener("end", unpipe);
        src.removeListener("data", ondata);
        cleanedUp = true;
        if (state.awaitDrain && (!dest._writableState || dest._writableState.needDrain))
          ondrain();
      }
      var increasedAwaitDrain = false;
      src.on("data", ondata);
      function ondata(chunk) {
        debug("ondata");
        increasedAwaitDrain = false;
        var ret2 = dest.write(chunk);
        if (false === ret2 && !increasedAwaitDrain) {
          if ((state.pipesCount === 1 && state.pipes === dest || state.pipesCount > 1 && indexOf(state.pipes, dest) !== -1) && !cleanedUp) {
            debug("false write response, pause", state.awaitDrain);
            state.awaitDrain++;
            increasedAwaitDrain = true;
          }
          src.pause();
        }
      }
      function onerror(er) {
        debug("onerror", er);
        unpipe();
        dest.removeListener("error", onerror);
        if (EElistenerCount(dest, "error") === 0)
          dest.emit("error", er);
      }
      prependListener(dest, "error", onerror);
      function onclose() {
        dest.removeListener("finish", onfinish);
        unpipe();
      }
      dest.once("close", onclose);
      function onfinish() {
        debug("onfinish");
        dest.removeListener("close", onclose);
        unpipe();
      }
      dest.once("finish", onfinish);
      function unpipe() {
        debug("unpipe");
        src.unpipe(dest);
      }
      dest.emit("pipe", src);
      if (!state.flowing) {
        debug("pipe resume");
        src.resume();
      }
      return dest;
    };
    function pipeOnDrain(src) {
      return function() {
        var state = src._readableState;
        debug("pipeOnDrain", state.awaitDrain);
        if (state.awaitDrain)
          state.awaitDrain--;
        if (state.awaitDrain === 0 && EElistenerCount(src, "data")) {
          state.flowing = true;
          flow(src);
        }
      };
    }
    Readable.prototype.unpipe = function(dest) {
      var state = this._readableState;
      var unpipeInfo = { hasUnpiped: false };
      if (state.pipesCount === 0)
        return this;
      if (state.pipesCount === 1) {
        if (dest && dest !== state.pipes)
          return this;
        if (!dest)
          dest = state.pipes;
        state.pipes = null;
        state.pipesCount = 0;
        state.flowing = false;
        if (dest)
          dest.emit("unpipe", this, unpipeInfo);
        return this;
      }
      if (!dest) {
        var dests = state.pipes;
        var len = state.pipesCount;
        state.pipes = null;
        state.pipesCount = 0;
        state.flowing = false;
        for (var i = 0; i < len; i++) {
          dests[i].emit("unpipe", this, { hasUnpiped: false });
        }
        return this;
      }
      var index = indexOf(state.pipes, dest);
      if (index === -1)
        return this;
      state.pipes.splice(index, 1);
      state.pipesCount -= 1;
      if (state.pipesCount === 1)
        state.pipes = state.pipes[0];
      dest.emit("unpipe", this, unpipeInfo);
      return this;
    };
    Readable.prototype.on = function(ev, fn) {
      var res = Stream.prototype.on.call(this, ev, fn);
      if (ev === "data") {
        if (this._readableState.flowing !== false)
          this.resume();
      } else if (ev === "readable") {
        var state = this._readableState;
        if (!state.endEmitted && !state.readableListening) {
          state.readableListening = state.needReadable = true;
          state.emittedReadable = false;
          if (!state.reading) {
            pna.nextTick(nReadingNextTick, this);
          } else if (state.length) {
            emitReadable(this);
          }
        }
      }
      return res;
    };
    Readable.prototype.addListener = Readable.prototype.on;
    function nReadingNextTick(self2) {
      debug("readable nexttick read 0");
      self2.read(0);
    }
    Readable.prototype.resume = function() {
      var state = this._readableState;
      if (!state.flowing) {
        debug("resume");
        state.flowing = true;
        resume(this, state);
      }
      return this;
    };
    function resume(stream, state) {
      if (!state.resumeScheduled) {
        state.resumeScheduled = true;
        pna.nextTick(resume_, stream, state);
      }
    }
    function resume_(stream, state) {
      if (!state.reading) {
        debug("resume read 0");
        stream.read(0);
      }
      state.resumeScheduled = false;
      state.awaitDrain = 0;
      stream.emit("resume");
      flow(stream);
      if (state.flowing && !state.reading)
        stream.read(0);
    }
    Readable.prototype.pause = function() {
      debug("call pause flowing=%j", this._readableState.flowing);
      if (false !== this._readableState.flowing) {
        debug("pause");
        this._readableState.flowing = false;
        this.emit("pause");
      }
      return this;
    };
    function flow(stream) {
      var state = stream._readableState;
      debug("flow", state.flowing);
      while (state.flowing && stream.read() !== null) {
      }
    }
    Readable.prototype.wrap = function(stream) {
      var _this = this;
      var state = this._readableState;
      var paused = false;
      stream.on("end", function() {
        debug("wrapped end");
        if (state.decoder && !state.ended) {
          var chunk = state.decoder.end();
          if (chunk && chunk.length)
            _this.push(chunk);
        }
        _this.push(null);
      });
      stream.on("data", function(chunk) {
        debug("wrapped data");
        if (state.decoder)
          chunk = state.decoder.write(chunk);
        if (state.objectMode && (chunk === null || chunk === void 0))
          return;
        else if (!state.objectMode && (!chunk || !chunk.length))
          return;
        var ret2 = _this.push(chunk);
        if (!ret2) {
          paused = true;
          stream.pause();
        }
      });
      for (var i in stream) {
        if (this[i] === void 0 && typeof stream[i] === "function") {
          this[i] = /* @__PURE__ */ function(method) {
            return function() {
              return stream[method].apply(stream, arguments);
            };
          }(i);
        }
      }
      for (var n = 0; n < kProxyEvents.length; n++) {
        stream.on(kProxyEvents[n], this.emit.bind(this, kProxyEvents[n]));
      }
      this._read = function(n2) {
        debug("wrapped _read", n2);
        if (paused) {
          paused = false;
          stream.resume();
        }
      };
      return this;
    };
    Object.defineProperty(Readable.prototype, "readableHighWaterMark", {
      // making it explicit this property is not enumerable
      // because otherwise some prototype manipulation in
      // userland will fail
      enumerable: false,
      get: function() {
        return this._readableState.highWaterMark;
      }
    });
    Readable._fromList = fromList;
    function fromList(n, state) {
      if (state.length === 0)
        return null;
      var ret2;
      if (state.objectMode)
        ret2 = state.buffer.shift();
      else if (!n || n >= state.length) {
        if (state.decoder)
          ret2 = state.buffer.join("");
        else if (state.buffer.length === 1)
          ret2 = state.buffer.head.data;
        else
          ret2 = state.buffer.concat(state.length);
        state.buffer.clear();
      } else {
        ret2 = fromListPartial(n, state.buffer, state.decoder);
      }
      return ret2;
    }
    function fromListPartial(n, list, hasStrings) {
      var ret2;
      if (n < list.head.data.length) {
        ret2 = list.head.data.slice(0, n);
        list.head.data = list.head.data.slice(n);
      } else if (n === list.head.data.length) {
        ret2 = list.shift();
      } else {
        ret2 = hasStrings ? copyFromBufferString(n, list) : copyFromBuffer(n, list);
      }
      return ret2;
    }
    function copyFromBufferString(n, list) {
      var p = list.head;
      var c = 1;
      var ret2 = p.data;
      n -= ret2.length;
      while (p = p.next) {
        var str = p.data;
        var nb = n > str.length ? str.length : n;
        if (nb === str.length)
          ret2 += str;
        else
          ret2 += str.slice(0, n);
        n -= nb;
        if (n === 0) {
          if (nb === str.length) {
            ++c;
            if (p.next)
              list.head = p.next;
            else
              list.head = list.tail = null;
          } else {
            list.head = p;
            p.data = str.slice(nb);
          }
          break;
        }
        ++c;
      }
      list.length -= c;
      return ret2;
    }
    function copyFromBuffer(n, list) {
      var ret2 = Buffer2.allocUnsafe(n);
      var p = list.head;
      var c = 1;
      p.data.copy(ret2);
      n -= p.data.length;
      while (p = p.next) {
        var buf = p.data;
        var nb = n > buf.length ? buf.length : n;
        buf.copy(ret2, ret2.length - n, 0, nb);
        n -= nb;
        if (n === 0) {
          if (nb === buf.length) {
            ++c;
            if (p.next)
              list.head = p.next;
            else
              list.head = list.tail = null;
          } else {
            list.head = p;
            p.data = buf.slice(nb);
          }
          break;
        }
        ++c;
      }
      list.length -= c;
      return ret2;
    }
    function endReadable(stream) {
      var state = stream._readableState;
      if (state.length > 0)
        throw new Error('"endReadable()" called on non-empty stream');
      if (!state.endEmitted) {
        state.ended = true;
        pna.nextTick(endReadableNT, state, stream);
      }
    }
    function endReadableNT(state, stream) {
      if (!state.endEmitted && state.length === 0) {
        state.endEmitted = true;
        stream.readable = false;
        stream.emit("end");
      }
    }
    function indexOf(xs, x) {
      for (var i = 0, l2 = xs.length; i < l2; i++) {
        if (xs[i] === x)
          return i;
      }
      return -1;
    }
  }
});

// ../../../node_modules/archiver-utils/node_modules/readable-stream/lib/_stream_transform.js
var require_stream_transform4 = __commonJS({
  "../../../node_modules/archiver-utils/node_modules/readable-stream/lib/_stream_transform.js"(exports2, module2) {
    "use strict";
    module2.exports = Transform;
    var Duplex = require_stream_duplex4();
    var util = Object.create(require_util());
    util.inherits = require_inherits();
    util.inherits(Transform, Duplex);
    function afterTransform(er, data) {
      var ts = this._transformState;
      ts.transforming = false;
      var cb = ts.writecb;
      if (!cb) {
        return this.emit("error", new Error("write callback called multiple times"));
      }
      ts.writechunk = null;
      ts.writecb = null;
      if (data != null)
        this.push(data);
      cb(er);
      var rs = this._readableState;
      rs.reading = false;
      if (rs.needReadable || rs.length < rs.highWaterMark) {
        this._read(rs.highWaterMark);
      }
    }
    function Transform(options) {
      if (!(this instanceof Transform))
        return new Transform(options);
      Duplex.call(this, options);
      this._transformState = {
        afterTransform: afterTransform.bind(this),
        needTransform: false,
        transforming: false,
        writecb: null,
        writechunk: null,
        writeencoding: null
      };
      this._readableState.needReadable = true;
      this._readableState.sync = false;
      if (options) {
        if (typeof options.transform === "function")
          this._transform = options.transform;
        if (typeof options.flush === "function")
          this._flush = options.flush;
      }
      this.on("prefinish", prefinish);
    }
    function prefinish() {
      var _this = this;
      if (typeof this._flush === "function") {
        this._flush(function(er, data) {
          done(_this, er, data);
        });
      } else {
        done(this, null, null);
      }
    }
    Transform.prototype.push = function(chunk, encoding) {
      this._transformState.needTransform = false;
      return Duplex.prototype.push.call(this, chunk, encoding);
    };
    Transform.prototype._transform = function(chunk, encoding, cb) {
      throw new Error("_transform() is not implemented");
    };
    Transform.prototype._write = function(chunk, encoding, cb) {
      var ts = this._transformState;
      ts.writecb = cb;
      ts.writechunk = chunk;
      ts.writeencoding = encoding;
      if (!ts.transforming) {
        var rs = this._readableState;
        if (ts.needTransform || rs.needReadable || rs.length < rs.highWaterMark)
          this._read(rs.highWaterMark);
      }
    };
    Transform.prototype._read = function(n) {
      var ts = this._transformState;
      if (ts.writechunk !== null && ts.writecb && !ts.transforming) {
        ts.transforming = true;
        this._transform(ts.writechunk, ts.writeencoding, ts.afterTransform);
      } else {
        ts.needTransform = true;
      }
    };
    Transform.prototype._destroy = function(err, cb) {
      var _this2 = this;
      Duplex.prototype._destroy.call(this, err, function(err2) {
        cb(err2);
        _this2.emit("close");
      });
    };
    function done(stream, er, data) {
      if (er)
        return stream.emit("error", er);
      if (data != null)
        stream.push(data);
      if (stream._writableState.length)
        throw new Error("Calling transform done when ws.length != 0");
      if (stream._transformState.transforming)
        throw new Error("Calling transform done when still transforming");
      return stream.push(null);
    }
  }
});

// ../../../node_modules/archiver-utils/node_modules/readable-stream/lib/_stream_passthrough.js
var require_stream_passthrough4 = __commonJS({
  "../../../node_modules/archiver-utils/node_modules/readable-stream/lib/_stream_passthrough.js"(exports2, module2) {
    "use strict";
    module2.exports = PassThrough;
    var Transform = require_stream_transform4();
    var util = Object.create(require_util());
    util.inherits = require_inherits();
    util.inherits(PassThrough, Transform);
    function PassThrough(options) {
      if (!(this instanceof PassThrough))
        return new PassThrough(options);
      Transform.call(this, options);
    }
    PassThrough.prototype._transform = function(chunk, encoding, cb) {
      cb(null, chunk);
    };
  }
});

// ../../../node_modules/archiver-utils/node_modules/readable-stream/readable.js
var require_readable4 = __commonJS({
  "../../../node_modules/archiver-utils/node_modules/readable-stream/readable.js"(exports2, module2) {
    var Stream = require("stream");
    if (process.env.READABLE_STREAM === "disable" && Stream) {
      module2.exports = Stream;
      exports2 = module2.exports = Stream.Readable;
      exports2.Readable = Stream.Readable;
      exports2.Writable = Stream.Writable;
      exports2.Duplex = Stream.Duplex;
      exports2.Transform = Stream.Transform;
      exports2.PassThrough = Stream.PassThrough;
      exports2.Stream = Stream;
    } else {
      exports2 = module2.exports = require_stream_readable4();
      exports2.Stream = Stream || exports2;
      exports2.Readable = exports2;
      exports2.Writable = require_stream_writable4();
      exports2.Duplex = require_stream_duplex4();
      exports2.Transform = require_stream_transform4();
      exports2.PassThrough = require_stream_passthrough4();
    }
  }
});

// ../../../node_modules/lodash.flatten/index.js
var require_lodash10 = __commonJS({
  "../../../node_modules/lodash.flatten/index.js"(exports2, module2) {
    var MAX_SAFE_INTEGER = 9007199254740991;
    var argsTag = "[object Arguments]";
    var funcTag = "[object Function]";
    var genTag = "[object GeneratorFunction]";
    var freeGlobal = typeof global == "object" && global && global.Object === Object && global;
    var freeSelf = typeof self == "object" && self && self.Object === Object && self;
    var root = freeGlobal || freeSelf || Function("return this")();
    function arrayPush(array, values) {
      var index = -1, length = values.length, offset = array.length;
      while (++index < length) {
        array[offset + index] = values[index];
      }
      return array;
    }
    var objectProto = Object.prototype;
    var hasOwnProperty = objectProto.hasOwnProperty;
    var objectToString = objectProto.toString;
    var Symbol2 = root.Symbol;
    var propertyIsEnumerable = objectProto.propertyIsEnumerable;
    var spreadableSymbol = Symbol2 ? Symbol2.isConcatSpreadable : void 0;
    function baseFlatten(array, depth, predicate, isStrict, result) {
      var index = -1, length = array.length;
      predicate || (predicate = isFlattenable);
      result || (result = []);
      while (++index < length) {
        var value = array[index];
        if (depth > 0 && predicate(value)) {
          if (depth > 1) {
            baseFlatten(value, depth - 1, predicate, isStrict, result);
          } else {
            arrayPush(result, value);
          }
        } else if (!isStrict) {
          result[result.length] = value;
        }
      }
      return result;
    }
    function isFlattenable(value) {
      return isArray(value) || isArguments(value) || !!(spreadableSymbol && value && value[spreadableSymbol]);
    }
    function flatten(array) {
      var length = array ? array.length : 0;
      return length ? baseFlatten(array, 1) : [];
    }
    function isArguments(value) {
      return isArrayLikeObject(value) && hasOwnProperty.call(value, "callee") && (!propertyIsEnumerable.call(value, "callee") || objectToString.call(value) == argsTag);
    }
    var isArray = Array.isArray;
    function isArrayLike(value) {
      return value != null && isLength(value.length) && !isFunction(value);
    }
    function isArrayLikeObject(value) {
      return isObjectLike(value) && isArrayLike(value);
    }
    function isFunction(value) {
      var tag = isObject2(value) ? objectToString.call(value) : "";
      return tag == funcTag || tag == genTag;
    }
    function isLength(value) {
      return typeof value == "number" && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
    }
    function isObject2(value) {
      var type = typeof value;
      return !!value && (type == "object" || type == "function");
    }
    function isObjectLike(value) {
      return !!value && typeof value == "object";
    }
    module2.exports = flatten;
  }
});

// ../../../node_modules/lodash.difference/index.js
var require_lodash11 = __commonJS({
  "../../../node_modules/lodash.difference/index.js"(exports2, module2) {
    var LARGE_ARRAY_SIZE = 200;
    var HASH_UNDEFINED = "__lodash_hash_undefined__";
    var MAX_SAFE_INTEGER = 9007199254740991;
    var argsTag = "[object Arguments]";
    var funcTag = "[object Function]";
    var genTag = "[object GeneratorFunction]";
    var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;
    var reIsHostCtor = /^\[object .+?Constructor\]$/;
    var freeGlobal = typeof global == "object" && global && global.Object === Object && global;
    var freeSelf = typeof self == "object" && self && self.Object === Object && self;
    var root = freeGlobal || freeSelf || Function("return this")();
    function apply(func, thisArg, args) {
      switch (args.length) {
        case 0:
          return func.call(thisArg);
        case 1:
          return func.call(thisArg, args[0]);
        case 2:
          return func.call(thisArg, args[0], args[1]);
        case 3:
          return func.call(thisArg, args[0], args[1], args[2]);
      }
      return func.apply(thisArg, args);
    }
    function arrayIncludes(array, value) {
      var length = array ? array.length : 0;
      return !!length && baseIndexOf(array, value, 0) > -1;
    }
    function arrayIncludesWith(array, value, comparator) {
      var index = -1, length = array ? array.length : 0;
      while (++index < length) {
        if (comparator(value, array[index])) {
          return true;
        }
      }
      return false;
    }
    function arrayMap(array, iteratee) {
      var index = -1, length = array ? array.length : 0, result = Array(length);
      while (++index < length) {
        result[index] = iteratee(array[index], index, array);
      }
      return result;
    }
    function arrayPush(array, values) {
      var index = -1, length = values.length, offset = array.length;
      while (++index < length) {
        array[offset + index] = values[index];
      }
      return array;
    }
    function baseFindIndex(array, predicate, fromIndex, fromRight) {
      var length = array.length, index = fromIndex + (fromRight ? 1 : -1);
      while (fromRight ? index-- : ++index < length) {
        if (predicate(array[index], index, array)) {
          return index;
        }
      }
      return -1;
    }
    function baseIndexOf(array, value, fromIndex) {
      if (value !== value) {
        return baseFindIndex(array, baseIsNaN, fromIndex);
      }
      var index = fromIndex - 1, length = array.length;
      while (++index < length) {
        if (array[index] === value) {
          return index;
        }
      }
      return -1;
    }
    function baseIsNaN(value) {
      return value !== value;
    }
    function baseUnary(func) {
      return function(value) {
        return func(value);
      };
    }
    function cacheHas(cache, key) {
      return cache.has(key);
    }
    function getValue(object, key) {
      return object == null ? void 0 : object[key];
    }
    function isHostObject(value) {
      var result = false;
      if (value != null && typeof value.toString != "function") {
        try {
          result = !!(value + "");
        } catch (e) {
        }
      }
      return result;
    }
    var arrayProto = Array.prototype;
    var funcProto = Function.prototype;
    var objectProto = Object.prototype;
    var coreJsData = root["__core-js_shared__"];
    var maskSrcKey = function() {
      var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || "");
      return uid ? "Symbol(src)_1." + uid : "";
    }();
    var funcToString = funcProto.toString;
    var hasOwnProperty = objectProto.hasOwnProperty;
    var objectToString = objectProto.toString;
    var reIsNative = RegExp(
      "^" + funcToString.call(hasOwnProperty).replace(reRegExpChar, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"
    );
    var Symbol2 = root.Symbol;
    var propertyIsEnumerable = objectProto.propertyIsEnumerable;
    var splice = arrayProto.splice;
    var spreadableSymbol = Symbol2 ? Symbol2.isConcatSpreadable : void 0;
    var nativeMax = Math.max;
    var Map2 = getNative(root, "Map");
    var nativeCreate = getNative(Object, "create");
    function Hash(entries) {
      var index = -1, length = entries ? entries.length : 0;
      this.clear();
      while (++index < length) {
        var entry = entries[index];
        this.set(entry[0], entry[1]);
      }
    }
    function hashClear() {
      this.__data__ = nativeCreate ? nativeCreate(null) : {};
    }
    function hashDelete(key) {
      return this.has(key) && delete this.__data__[key];
    }
    function hashGet(key) {
      var data = this.__data__;
      if (nativeCreate) {
        var result = data[key];
        return result === HASH_UNDEFINED ? void 0 : result;
      }
      return hasOwnProperty.call(data, key) ? data[key] : void 0;
    }
    function hashHas(key) {
      var data = this.__data__;
      return nativeCreate ? data[key] !== void 0 : hasOwnProperty.call(data, key);
    }
    function hashSet(key, value) {
      var data = this.__data__;
      data[key] = nativeCreate && value === void 0 ? HASH_UNDEFINED : value;
      return this;
    }
    Hash.prototype.clear = hashClear;
    Hash.prototype["delete"] = hashDelete;
    Hash.prototype.get = hashGet;
    Hash.prototype.has = hashHas;
    Hash.prototype.set = hashSet;
    function ListCache(entries) {
      var index = -1, length = entries ? entries.length : 0;
      this.clear();
      while (++index < length) {
        var entry = entries[index];
        this.set(entry[0], entry[1]);
      }
    }
    function listCacheClear() {
      this.__data__ = [];
    }
    function listCacheDelete(key) {
      var data = this.__data__, index = assocIndexOf(data, key);
      if (index < 0) {
        return false;
      }
      var lastIndex = data.length - 1;
      if (index == lastIndex) {
        data.pop();
      } else {
        splice.call(data, index, 1);
      }
      return true;
    }
    function listCacheGet(key) {
      var data = this.__data__, index = assocIndexOf(data, key);
      return index < 0 ? void 0 : data[index][1];
    }
    function listCacheHas(key) {
      return assocIndexOf(this.__data__, key) > -1;
    }
    function listCacheSet(key, value) {
      var data = this.__data__, index = assocIndexOf(data, key);
      if (index < 0) {
        data.push([key, value]);
      } else {
        data[index][1] = value;
      }
      return this;
    }
    ListCache.prototype.clear = listCacheClear;
    ListCache.prototype["delete"] = listCacheDelete;
    ListCache.prototype.get = listCacheGet;
    ListCache.prototype.has = listCacheHas;
    ListCache.prototype.set = listCacheSet;
    function MapCache(entries) {
      var index = -1, length = entries ? entries.length : 0;
      this.clear();
      while (++index < length) {
        var entry = entries[index];
        this.set(entry[0], entry[1]);
      }
    }
    function mapCacheClear() {
      this.__data__ = {
        "hash": new Hash(),
        "map": new (Map2 || ListCache)(),
        "string": new Hash()
      };
    }
    function mapCacheDelete(key) {
      return getMapData(this, key)["delete"](key);
    }
    function mapCacheGet(key) {
      return getMapData(this, key).get(key);
    }
    function mapCacheHas(key) {
      return getMapData(this, key).has(key);
    }
    function mapCacheSet(key, value) {
      getMapData(this, key).set(key, value);
      return this;
    }
    MapCache.prototype.clear = mapCacheClear;
    MapCache.prototype["delete"] = mapCacheDelete;
    MapCache.prototype.get = mapCacheGet;
    MapCache.prototype.has = mapCacheHas;
    MapCache.prototype.set = mapCacheSet;
    function SetCache(values) {
      var index = -1, length = values ? values.length : 0;
      this.__data__ = new MapCache();
      while (++index < length) {
        this.add(values[index]);
      }
    }
    function setCacheAdd(value) {
      this.__data__.set(value, HASH_UNDEFINED);
      return this;
    }
    function setCacheHas(value) {
      return this.__data__.has(value);
    }
    SetCache.prototype.add = SetCache.prototype.push = setCacheAdd;
    SetCache.prototype.has = setCacheHas;
    function assocIndexOf(array, key) {
      var length = array.length;
      while (length--) {
        if (eq(array[length][0], key)) {
          return length;
        }
      }
      return -1;
    }
    function baseDifference(array, values, iteratee, comparator) {
      var index = -1, includes = arrayIncludes, isCommon = true, length = array.length, result = [], valuesLength = values.length;
      if (!length) {
        return result;
      }
      if (iteratee) {
        values = arrayMap(values, baseUnary(iteratee));
      }
      if (comparator) {
        includes = arrayIncludesWith;
        isCommon = false;
      } else if (values.length >= LARGE_ARRAY_SIZE) {
        includes = cacheHas;
        isCommon = false;
        values = new SetCache(values);
      }
      outer:
        while (++index < length) {
          var value = array[index], computed = iteratee ? iteratee(value) : value;
          value = comparator || value !== 0 ? value : 0;
          if (isCommon && computed === computed) {
            var valuesIndex = valuesLength;
            while (valuesIndex--) {
              if (values[valuesIndex] === computed) {
                continue outer;
              }
            }
            result.push(value);
          } else if (!includes(values, computed, comparator)) {
            result.push(value);
          }
        }
      return result;
    }
    function baseFlatten(array, depth, predicate, isStrict, result) {
      var index = -1, length = array.length;
      predicate || (predicate = isFlattenable);
      result || (result = []);
      while (++index < length) {
        var value = array[index];
        if (depth > 0 && predicate(value)) {
          if (depth > 1) {
            baseFlatten(value, depth - 1, predicate, isStrict, result);
          } else {
            arrayPush(result, value);
          }
        } else if (!isStrict) {
          result[result.length] = value;
        }
      }
      return result;
    }
    function baseIsNative(value) {
      if (!isObject2(value) || isMasked(value)) {
        return false;
      }
      var pattern = isFunction(value) || isHostObject(value) ? reIsNative : reIsHostCtor;
      return pattern.test(toSource(value));
    }
    function baseRest(func, start) {
      start = nativeMax(start === void 0 ? func.length - 1 : start, 0);
      return function() {
        var args = arguments, index = -1, length = nativeMax(args.length - start, 0), array = Array(length);
        while (++index < length) {
          array[index] = args[start + index];
        }
        index = -1;
        var otherArgs = Array(start + 1);
        while (++index < start) {
          otherArgs[index] = args[index];
        }
        otherArgs[start] = array;
        return apply(func, this, otherArgs);
      };
    }
    function getMapData(map, key) {
      var data = map.__data__;
      return isKeyable(key) ? data[typeof key == "string" ? "string" : "hash"] : data.map;
    }
    function getNative(object, key) {
      var value = getValue(object, key);
      return baseIsNative(value) ? value : void 0;
    }
    function isFlattenable(value) {
      return isArray(value) || isArguments(value) || !!(spreadableSymbol && value && value[spreadableSymbol]);
    }
    function isKeyable(value) {
      var type = typeof value;
      return type == "string" || type == "number" || type == "symbol" || type == "boolean" ? value !== "__proto__" : value === null;
    }
    function isMasked(func) {
      return !!maskSrcKey && maskSrcKey in func;
    }
    function toSource(func) {
      if (func != null) {
        try {
          return funcToString.call(func);
        } catch (e) {
        }
        try {
          return func + "";
        } catch (e) {
        }
      }
      return "";
    }
    var difference = baseRest(function(array, values) {
      return isArrayLikeObject(array) ? baseDifference(array, baseFlatten(values, 1, isArrayLikeObject, true)) : [];
    });
    function eq(value, other) {
      return value === other || value !== value && other !== other;
    }
    function isArguments(value) {
      return isArrayLikeObject(value) && hasOwnProperty.call(value, "callee") && (!propertyIsEnumerable.call(value, "callee") || objectToString.call(value) == argsTag);
    }
    var isArray = Array.isArray;
    function isArrayLike(value) {
      return value != null && isLength(value.length) && !isFunction(value);
    }
    function isArrayLikeObject(value) {
      return isObjectLike(value) && isArrayLike(value);
    }
    function isFunction(value) {
      var tag = isObject2(value) ? objectToString.call(value) : "";
      return tag == funcTag || tag == genTag;
    }
    function isLength(value) {
      return typeof value == "number" && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
    }
    function isObject2(value) {
      var type = typeof value;
      return !!value && (type == "object" || type == "function");
    }
    function isObjectLike(value) {
      return !!value && typeof value == "object";
    }
    module2.exports = difference;
  }
});

// ../../../node_modules/lodash.union/index.js
var require_lodash12 = __commonJS({
  "../../../node_modules/lodash.union/index.js"(exports2, module2) {
    var LARGE_ARRAY_SIZE = 200;
    var HASH_UNDEFINED = "__lodash_hash_undefined__";
    var INFINITY = 1 / 0;
    var MAX_SAFE_INTEGER = 9007199254740991;
    var argsTag = "[object Arguments]";
    var funcTag = "[object Function]";
    var genTag = "[object GeneratorFunction]";
    var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;
    var reIsHostCtor = /^\[object .+?Constructor\]$/;
    var freeGlobal = typeof global == "object" && global && global.Object === Object && global;
    var freeSelf = typeof self == "object" && self && self.Object === Object && self;
    var root = freeGlobal || freeSelf || Function("return this")();
    function apply(func, thisArg, args) {
      switch (args.length) {
        case 0:
          return func.call(thisArg);
        case 1:
          return func.call(thisArg, args[0]);
        case 2:
          return func.call(thisArg, args[0], args[1]);
        case 3:
          return func.call(thisArg, args[0], args[1], args[2]);
      }
      return func.apply(thisArg, args);
    }
    function arrayIncludes(array, value) {
      var length = array ? array.length : 0;
      return !!length && baseIndexOf(array, value, 0) > -1;
    }
    function arrayIncludesWith(array, value, comparator) {
      var index = -1, length = array ? array.length : 0;
      while (++index < length) {
        if (comparator(value, array[index])) {
          return true;
        }
      }
      return false;
    }
    function arrayPush(array, values) {
      var index = -1, length = values.length, offset = array.length;
      while (++index < length) {
        array[offset + index] = values[index];
      }
      return array;
    }
    function baseFindIndex(array, predicate, fromIndex, fromRight) {
      var length = array.length, index = fromIndex + (fromRight ? 1 : -1);
      while (fromRight ? index-- : ++index < length) {
        if (predicate(array[index], index, array)) {
          return index;
        }
      }
      return -1;
    }
    function baseIndexOf(array, value, fromIndex) {
      if (value !== value) {
        return baseFindIndex(array, baseIsNaN, fromIndex);
      }
      var index = fromIndex - 1, length = array.length;
      while (++index < length) {
        if (array[index] === value) {
          return index;
        }
      }
      return -1;
    }
    function baseIsNaN(value) {
      return value !== value;
    }
    function cacheHas(cache, key) {
      return cache.has(key);
    }
    function getValue(object, key) {
      return object == null ? void 0 : object[key];
    }
    function isHostObject(value) {
      var result = false;
      if (value != null && typeof value.toString != "function") {
        try {
          result = !!(value + "");
        } catch (e) {
        }
      }
      return result;
    }
    function setToArray(set) {
      var index = -1, result = Array(set.size);
      set.forEach(function(value) {
        result[++index] = value;
      });
      return result;
    }
    var arrayProto = Array.prototype;
    var funcProto = Function.prototype;
    var objectProto = Object.prototype;
    var coreJsData = root["__core-js_shared__"];
    var maskSrcKey = function() {
      var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || "");
      return uid ? "Symbol(src)_1." + uid : "";
    }();
    var funcToString = funcProto.toString;
    var hasOwnProperty = objectProto.hasOwnProperty;
    var objectToString = objectProto.toString;
    var reIsNative = RegExp(
      "^" + funcToString.call(hasOwnProperty).replace(reRegExpChar, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"
    );
    var Symbol2 = root.Symbol;
    var propertyIsEnumerable = objectProto.propertyIsEnumerable;
    var splice = arrayProto.splice;
    var spreadableSymbol = Symbol2 ? Symbol2.isConcatSpreadable : void 0;
    var nativeMax = Math.max;
    var Map2 = getNative(root, "Map");
    var Set2 = getNative(root, "Set");
    var nativeCreate = getNative(Object, "create");
    function Hash(entries) {
      var index = -1, length = entries ? entries.length : 0;
      this.clear();
      while (++index < length) {
        var entry = entries[index];
        this.set(entry[0], entry[1]);
      }
    }
    function hashClear() {
      this.__data__ = nativeCreate ? nativeCreate(null) : {};
    }
    function hashDelete(key) {
      return this.has(key) && delete this.__data__[key];
    }
    function hashGet(key) {
      var data = this.__data__;
      if (nativeCreate) {
        var result = data[key];
        return result === HASH_UNDEFINED ? void 0 : result;
      }
      return hasOwnProperty.call(data, key) ? data[key] : void 0;
    }
    function hashHas(key) {
      var data = this.__data__;
      return nativeCreate ? data[key] !== void 0 : hasOwnProperty.call(data, key);
    }
    function hashSet(key, value) {
      var data = this.__data__;
      data[key] = nativeCreate && value === void 0 ? HASH_UNDEFINED : value;
      return this;
    }
    Hash.prototype.clear = hashClear;
    Hash.prototype["delete"] = hashDelete;
    Hash.prototype.get = hashGet;
    Hash.prototype.has = hashHas;
    Hash.prototype.set = hashSet;
    function ListCache(entries) {
      var index = -1, length = entries ? entries.length : 0;
      this.clear();
      while (++index < length) {
        var entry = entries[index];
        this.set(entry[0], entry[1]);
      }
    }
    function listCacheClear() {
      this.__data__ = [];
    }
    function listCacheDelete(key) {
      var data = this.__data__, index = assocIndexOf(data, key);
      if (index < 0) {
        return false;
      }
      var lastIndex = data.length - 1;
      if (index == lastIndex) {
        data.pop();
      } else {
        splice.call(data, index, 1);
      }
      return true;
    }
    function listCacheGet(key) {
      var data = this.__data__, index = assocIndexOf(data, key);
      return index < 0 ? void 0 : data[index][1];
    }
    function listCacheHas(key) {
      return assocIndexOf(this.__data__, key) > -1;
    }
    function listCacheSet(key, value) {
      var data = this.__data__, index = assocIndexOf(data, key);
      if (index < 0) {
        data.push([key, value]);
      } else {
        data[index][1] = value;
      }
      return this;
    }
    ListCache.prototype.clear = listCacheClear;
    ListCache.prototype["delete"] = listCacheDelete;
    ListCache.prototype.get = listCacheGet;
    ListCache.prototype.has = listCacheHas;
    ListCache.prototype.set = listCacheSet;
    function MapCache(entries) {
      var index = -1, length = entries ? entries.length : 0;
      this.clear();
      while (++index < length) {
        var entry = entries[index];
        this.set(entry[0], entry[1]);
      }
    }
    function mapCacheClear() {
      this.__data__ = {
        "hash": new Hash(),
        "map": new (Map2 || ListCache)(),
        "string": new Hash()
      };
    }
    function mapCacheDelete(key) {
      return getMapData(this, key)["delete"](key);
    }
    function mapCacheGet(key) {
      return getMapData(this, key).get(key);
    }
    function mapCacheHas(key) {
      return getMapData(this, key).has(key);
    }
    function mapCacheSet(key, value) {
      getMapData(this, key).set(key, value);
      return this;
    }
    MapCache.prototype.clear = mapCacheClear;
    MapCache.prototype["delete"] = mapCacheDelete;
    MapCache.prototype.get = mapCacheGet;
    MapCache.prototype.has = mapCacheHas;
    MapCache.prototype.set = mapCacheSet;
    function SetCache(values) {
      var index = -1, length = values ? values.length : 0;
      this.__data__ = new MapCache();
      while (++index < length) {
        this.add(values[index]);
      }
    }
    function setCacheAdd(value) {
      this.__data__.set(value, HASH_UNDEFINED);
      return this;
    }
    function setCacheHas(value) {
      return this.__data__.has(value);
    }
    SetCache.prototype.add = SetCache.prototype.push = setCacheAdd;
    SetCache.prototype.has = setCacheHas;
    function assocIndexOf(array, key) {
      var length = array.length;
      while (length--) {
        if (eq(array[length][0], key)) {
          return length;
        }
      }
      return -1;
    }
    function baseFlatten(array, depth, predicate, isStrict, result) {
      var index = -1, length = array.length;
      predicate || (predicate = isFlattenable);
      result || (result = []);
      while (++index < length) {
        var value = array[index];
        if (depth > 0 && predicate(value)) {
          if (depth > 1) {
            baseFlatten(value, depth - 1, predicate, isStrict, result);
          } else {
            arrayPush(result, value);
          }
        } else if (!isStrict) {
          result[result.length] = value;
        }
      }
      return result;
    }
    function baseIsNative(value) {
      if (!isObject2(value) || isMasked(value)) {
        return false;
      }
      var pattern = isFunction(value) || isHostObject(value) ? reIsNative : reIsHostCtor;
      return pattern.test(toSource(value));
    }
    function baseRest(func, start) {
      start = nativeMax(start === void 0 ? func.length - 1 : start, 0);
      return function() {
        var args = arguments, index = -1, length = nativeMax(args.length - start, 0), array = Array(length);
        while (++index < length) {
          array[index] = args[start + index];
        }
        index = -1;
        var otherArgs = Array(start + 1);
        while (++index < start) {
          otherArgs[index] = args[index];
        }
        otherArgs[start] = array;
        return apply(func, this, otherArgs);
      };
    }
    function baseUniq(array, iteratee, comparator) {
      var index = -1, includes = arrayIncludes, length = array.length, isCommon = true, result = [], seen = result;
      if (comparator) {
        isCommon = false;
        includes = arrayIncludesWith;
      } else if (length >= LARGE_ARRAY_SIZE) {
        var set = iteratee ? null : createSet(array);
        if (set) {
          return setToArray(set);
        }
        isCommon = false;
        includes = cacheHas;
        seen = new SetCache();
      } else {
        seen = iteratee ? [] : result;
      }
      outer:
        while (++index < length) {
          var value = array[index], computed = iteratee ? iteratee(value) : value;
          value = comparator || value !== 0 ? value : 0;
          if (isCommon && computed === computed) {
            var seenIndex = seen.length;
            while (seenIndex--) {
              if (seen[seenIndex] === computed) {
                continue outer;
              }
            }
            if (iteratee) {
              seen.push(computed);
            }
            result.push(value);
          } else if (!includes(seen, computed, comparator)) {
            if (seen !== result) {
              seen.push(computed);
            }
            result.push(value);
          }
        }
      return result;
    }
    var createSet = !(Set2 && 1 / setToArray(new Set2([, -0]))[1] == INFINITY) ? noop : function(values) {
      return new Set2(values);
    };
    function getMapData(map, key) {
      var data = map.__data__;
      return isKeyable(key) ? data[typeof key == "string" ? "string" : "hash"] : data.map;
    }
    function getNative(object, key) {
      var value = getValue(object, key);
      return baseIsNative(value) ? value : void 0;
    }
    function isFlattenable(value) {
      return isArray(value) || isArguments(value) || !!(spreadableSymbol && value && value[spreadableSymbol]);
    }
    function isKeyable(value) {
      var type = typeof value;
      return type == "string" || type == "number" || type == "symbol" || type == "boolean" ? value !== "__proto__" : value === null;
    }
    function isMasked(func) {
      return !!maskSrcKey && maskSrcKey in func;
    }
    function toSource(func) {
      if (func != null) {
        try {
          return funcToString.call(func);
        } catch (e) {
        }
        try {
          return func + "";
        } catch (e) {
        }
      }
      return "";
    }
    var union = baseRest(function(arrays) {
      return baseUniq(baseFlatten(arrays, 1, isArrayLikeObject, true));
    });
    function eq(value, other) {
      return value === other || value !== value && other !== other;
    }
    function isArguments(value) {
      return isArrayLikeObject(value) && hasOwnProperty.call(value, "callee") && (!propertyIsEnumerable.call(value, "callee") || objectToString.call(value) == argsTag);
    }
    var isArray = Array.isArray;
    function isArrayLike(value) {
      return value != null && isLength(value.length) && !isFunction(value);
    }
    function isArrayLikeObject(value) {
      return isObjectLike(value) && isArrayLike(value);
    }
    function isFunction(value) {
      var tag = isObject2(value) ? objectToString.call(value) : "";
      return tag == funcTag || tag == genTag;
    }
    function isLength(value) {
      return typeof value == "number" && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
    }
    function isObject2(value) {
      var type = typeof value;
      return !!value && (type == "object" || type == "function");
    }
    function isObjectLike(value) {
      return !!value && typeof value == "object";
    }
    function noop() {
    }
    module2.exports = union;
  }
});

// ../../../node_modules/lodash.isplainobject/index.js
var require_lodash13 = __commonJS({
  "../../../node_modules/lodash.isplainobject/index.js"(exports2, module2) {
    var objectTag = "[object Object]";
    function isHostObject(value) {
      var result = false;
      if (value != null && typeof value.toString != "function") {
        try {
          result = !!(value + "");
        } catch (e) {
        }
      }
      return result;
    }
    function overArg(func, transform) {
      return function(arg) {
        return func(transform(arg));
      };
    }
    var funcProto = Function.prototype;
    var objectProto = Object.prototype;
    var funcToString = funcProto.toString;
    var hasOwnProperty = objectProto.hasOwnProperty;
    var objectCtorString = funcToString.call(Object);
    var objectToString = objectProto.toString;
    var getPrototype = overArg(Object.getPrototypeOf, Object);
    function isObjectLike(value) {
      return !!value && typeof value == "object";
    }
    function isPlainObject(value) {
      if (!isObjectLike(value) || objectToString.call(value) != objectTag || isHostObject(value)) {
        return false;
      }
      var proto = getPrototype(value);
      if (proto === null) {
        return true;
      }
      var Ctor = hasOwnProperty.call(proto, "constructor") && proto.constructor;
      return typeof Ctor == "function" && Ctor instanceof Ctor && funcToString.call(Ctor) == objectCtorString;
    }
    module2.exports = isPlainObject;
  }
});

// ../../../node_modules/fs.realpath/old.js
var require_old = __commonJS({
  "../../../node_modules/fs.realpath/old.js"(exports2) {
    var pathModule = require("path");
    var isWindows = process.platform === "win32";
    var fs = require("fs");
    var DEBUG = process.env.NODE_DEBUG && /fs/.test(process.env.NODE_DEBUG);
    function rethrow() {
      var callback;
      if (DEBUG) {
        var backtrace = new Error();
        callback = debugCallback;
      } else
        callback = missingCallback;
      return callback;
      function debugCallback(err) {
        if (err) {
          backtrace.message = err.message;
          err = backtrace;
          missingCallback(err);
        }
      }
      function missingCallback(err) {
        if (err) {
          if (process.throwDeprecation)
            throw err;
          else if (!process.noDeprecation) {
            var msg = "fs: missing callback " + (err.stack || err.message);
            if (process.traceDeprecation)
              console.trace(msg);
            else
              console.error(msg);
          }
        }
      }
    }
    function maybeCallback(cb) {
      return typeof cb === "function" ? cb : rethrow();
    }
    var normalize = pathModule.normalize;
    if (isWindows) {
      nextPartRe = /(.*?)(?:[\/\\]+|$)/g;
    } else {
      nextPartRe = /(.*?)(?:[\/]+|$)/g;
    }
    var nextPartRe;
    if (isWindows) {
      splitRootRe = /^(?:[a-zA-Z]:|[\\\/]{2}[^\\\/]+[\\\/][^\\\/]+)?[\\\/]*/;
    } else {
      splitRootRe = /^[\/]*/;
    }
    var splitRootRe;
    exports2.realpathSync = function realpathSync(p, cache) {
      p = pathModule.resolve(p);
      if (cache && Object.prototype.hasOwnProperty.call(cache, p)) {
        return cache[p];
      }
      var original = p, seenLinks = {}, knownHard = {};
      var pos;
      var current;
      var base;
      var previous;
      start();
      function start() {
        var m = splitRootRe.exec(p);
        pos = m[0].length;
        current = m[0];
        base = m[0];
        previous = "";
        if (isWindows && !knownHard[base]) {
          fs.lstatSync(base);
          knownHard[base] = true;
        }
      }
      while (pos < p.length) {
        nextPartRe.lastIndex = pos;
        var result = nextPartRe.exec(p);
        previous = current;
        current += result[0];
        base = previous + result[1];
        pos = nextPartRe.lastIndex;
        if (knownHard[base] || cache && cache[base] === base) {
          continue;
        }
        var resolvedLink;
        if (cache && Object.prototype.hasOwnProperty.call(cache, base)) {
          resolvedLink = cache[base];
        } else {
          var stat = fs.lstatSync(base);
          if (!stat.isSymbolicLink()) {
            knownHard[base] = true;
            if (cache)
              cache[base] = base;
            continue;
          }
          var linkTarget = null;
          if (!isWindows) {
            var id = stat.dev.toString(32) + ":" + stat.ino.toString(32);
            if (seenLinks.hasOwnProperty(id)) {
              linkTarget = seenLinks[id];
            }
          }
          if (linkTarget === null) {
            fs.statSync(base);
            linkTarget = fs.readlinkSync(base);
          }
          resolvedLink = pathModule.resolve(previous, linkTarget);
          if (cache)
            cache[base] = resolvedLink;
          if (!isWindows)
            seenLinks[id] = linkTarget;
        }
        p = pathModule.resolve(resolvedLink, p.slice(pos));
        start();
      }
      if (cache)
        cache[original] = p;
      return p;
    };
    exports2.realpath = function realpath(p, cache, cb) {
      if (typeof cb !== "function") {
        cb = maybeCallback(cache);
        cache = null;
      }
      p = pathModule.resolve(p);
      if (cache && Object.prototype.hasOwnProperty.call(cache, p)) {
        return process.nextTick(cb.bind(null, null, cache[p]));
      }
      var original = p, seenLinks = {}, knownHard = {};
      var pos;
      var current;
      var base;
      var previous;
      start();
      function start() {
        var m = splitRootRe.exec(p);
        pos = m[0].length;
        current = m[0];
        base = m[0];
        previous = "";
        if (isWindows && !knownHard[base]) {
          fs.lstat(base, function(err) {
            if (err)
              return cb(err);
            knownHard[base] = true;
            LOOP();
          });
        } else {
          process.nextTick(LOOP);
        }
      }
      function LOOP() {
        if (pos >= p.length) {
          if (cache)
            cache[original] = p;
          return cb(null, p);
        }
        nextPartRe.lastIndex = pos;
        var result = nextPartRe.exec(p);
        previous = current;
        current += result[0];
        base = previous + result[1];
        pos = nextPartRe.lastIndex;
        if (knownHard[base] || cache && cache[base] === base) {
          return process.nextTick(LOOP);
        }
        if (cache && Object.prototype.hasOwnProperty.call(cache, base)) {
          return gotResolvedLink(cache[base]);
        }
        return fs.lstat(base, gotStat);
      }
      function gotStat(err, stat) {
        if (err)
          return cb(err);
        if (!stat.isSymbolicLink()) {
          knownHard[base] = true;
          if (cache)
            cache[base] = base;
          return process.nextTick(LOOP);
        }
        if (!isWindows) {
          var id = stat.dev.toString(32) + ":" + stat.ino.toString(32);
          if (seenLinks.hasOwnProperty(id)) {
            return gotTarget(null, seenLinks[id], base);
          }
        }
        fs.stat(base, function(err2) {
          if (err2)
            return cb(err2);
          fs.readlink(base, function(err3, target) {
            if (!isWindows)
              seenLinks[id] = target;
            gotTarget(err3, target);
          });
        });
      }
      function gotTarget(err, target, base2) {
        if (err)
          return cb(err);
        var resolvedLink = pathModule.resolve(previous, target);
        if (cache)
          cache[base2] = resolvedLink;
        gotResolvedLink(resolvedLink);
      }
      function gotResolvedLink(resolvedLink) {
        p = pathModule.resolve(resolvedLink, p.slice(pos));
        start();
      }
    };
  }
});

// ../../../node_modules/fs.realpath/index.js
var require_fs = __commonJS({
  "../../../node_modules/fs.realpath/index.js"(exports2, module2) {
    module2.exports = realpath;
    realpath.realpath = realpath;
    realpath.sync = realpathSync;
    realpath.realpathSync = realpathSync;
    realpath.monkeypatch = monkeypatch;
    realpath.unmonkeypatch = unmonkeypatch;
    var fs = require("fs");
    var origRealpath = fs.realpath;
    var origRealpathSync = fs.realpathSync;
    var version2 = process.version;
    var ok = /^v[0-5]\./.test(version2);
    var old = require_old();
    function newError(er) {
      return er && er.syscall === "realpath" && (er.code === "ELOOP" || er.code === "ENOMEM" || er.code === "ENAMETOOLONG");
    }
    function realpath(p, cache, cb) {
      if (ok) {
        return origRealpath(p, cache, cb);
      }
      if (typeof cache === "function") {
        cb = cache;
        cache = null;
      }
      origRealpath(p, cache, function(er, result) {
        if (newError(er)) {
          old.realpath(p, cache, cb);
        } else {
          cb(er, result);
        }
      });
    }
    function realpathSync(p, cache) {
      if (ok) {
        return origRealpathSync(p, cache);
      }
      try {
        return origRealpathSync(p, cache);
      } catch (er) {
        if (newError(er)) {
          return old.realpathSync(p, cache);
        } else {
          throw er;
        }
      }
    }
    function monkeypatch() {
      fs.realpath = realpath;
      fs.realpathSync = realpathSync;
    }
    function unmonkeypatch() {
      fs.realpath = origRealpath;
      fs.realpathSync = origRealpathSync;
    }
  }
});

// ../../../node_modules/concat-map/index.js
var require_concat_map = __commonJS({
  "../../../node_modules/concat-map/index.js"(exports2, module2) {
    module2.exports = function(xs, fn) {
      var res = [];
      for (var i = 0; i < xs.length; i++) {
        var x = fn(xs[i], i);
        if (isArray(x))
          res.push.apply(res, x);
        else
          res.push(x);
      }
      return res;
    };
    var isArray = Array.isArray || function(xs) {
      return Object.prototype.toString.call(xs) === "[object Array]";
    };
  }
});

// ../../../node_modules/archiver-utils/node_modules/brace-expansion/index.js
var require_brace_expansion2 = __commonJS({
  "../../../node_modules/archiver-utils/node_modules/brace-expansion/index.js"(exports2, module2) {
    var concatMap = require_concat_map();
    var balanced = require_balanced_match();
    module2.exports = expandTop;
    var escSlash = "\0SLASH" + Math.random() + "\0";
    var escOpen = "\0OPEN" + Math.random() + "\0";
    var escClose = "\0CLOSE" + Math.random() + "\0";
    var escComma = "\0COMMA" + Math.random() + "\0";
    var escPeriod = "\0PERIOD" + Math.random() + "\0";
    function numeric(str) {
      return parseInt(str, 10) == str ? parseInt(str, 10) : str.charCodeAt(0);
    }
    function escapeBraces(str) {
      return str.split("\\\\").join(escSlash).split("\\{").join(escOpen).split("\\}").join(escClose).split("\\,").join(escComma).split("\\.").join(escPeriod);
    }
    function unescapeBraces(str) {
      return str.split(escSlash).join("\\").split(escOpen).join("{").split(escClose).join("}").split(escComma).join(",").split(escPeriod).join(".");
    }
    function parseCommaParts(str) {
      if (!str)
        return [""];
      var parts = [];
      var m = balanced("{", "}", str);
      if (!m)
        return str.split(",");
      var pre = m.pre;
      var body = m.body;
      var post = m.post;
      var p = pre.split(",");
      p[p.length - 1] += "{" + body + "}";
      var postParts = parseCommaParts(post);
      if (post.length) {
        p[p.length - 1] += postParts.shift();
        p.push.apply(p, postParts);
      }
      parts.push.apply(parts, p);
      return parts;
    }
    function expandTop(str) {
      if (!str)
        return [];
      if (str.substr(0, 2) === "{}") {
        str = "\\{\\}" + str.substr(2);
      }
      return expand(escapeBraces(str), true).map(unescapeBraces);
    }
    function embrace(str) {
      return "{" + str + "}";
    }
    function isPadded(el) {
      return /^-?0\d/.test(el);
    }
    function lte(i, y) {
      return i <= y;
    }
    function gte(i, y) {
      return i >= y;
    }
    function expand(str, isTop) {
      var expansions = [];
      var m = balanced("{", "}", str);
      if (!m || /\$$/.test(m.pre))
        return [str];
      var isNumericSequence = /^-?\d+\.\.-?\d+(?:\.\.-?\d+)?$/.test(m.body);
      var isAlphaSequence = /^[a-zA-Z]\.\.[a-zA-Z](?:\.\.-?\d+)?$/.test(m.body);
      var isSequence = isNumericSequence || isAlphaSequence;
      var isOptions = m.body.indexOf(",") >= 0;
      if (!isSequence && !isOptions) {
        if (m.post.match(/,.*\}/)) {
          str = m.pre + "{" + m.body + escClose + m.post;
          return expand(str);
        }
        return [str];
      }
      var n;
      if (isSequence) {
        n = m.body.split(/\.\./);
      } else {
        n = parseCommaParts(m.body);
        if (n.length === 1) {
          n = expand(n[0], false).map(embrace);
          if (n.length === 1) {
            var post = m.post.length ? expand(m.post, false) : [""];
            return post.map(function(p) {
              return m.pre + n[0] + p;
            });
          }
        }
      }
      var pre = m.pre;
      var post = m.post.length ? expand(m.post, false) : [""];
      var N;
      if (isSequence) {
        var x = numeric(n[0]);
        var y = numeric(n[1]);
        var width = Math.max(n[0].length, n[1].length);
        var incr = n.length == 3 ? Math.abs(numeric(n[2])) : 1;
        var test = lte;
        var reverse = y < x;
        if (reverse) {
          incr *= -1;
          test = gte;
        }
        var pad = n.some(isPadded);
        N = [];
        for (var i = x; test(i, y); i += incr) {
          var c;
          if (isAlphaSequence) {
            c = String.fromCharCode(i);
            if (c === "\\")
              c = "";
          } else {
            c = String(i);
            if (pad) {
              var need = width - c.length;
              if (need > 0) {
                var z = new Array(need + 1).join("0");
                if (i < 0)
                  c = "-" + z + c.slice(1);
                else
                  c = z + c;
              }
            }
          }
          N.push(c);
        }
      } else {
        N = concatMap(n, function(el) {
          return expand(el, false);
        });
      }
      for (var j = 0; j < N.length; j++) {
        for (var k = 0; k < post.length; k++) {
          var expansion = pre + N[j] + post[k];
          if (!isTop || isSequence || expansion)
            expansions.push(expansion);
        }
      }
      return expansions;
    }
  }
});

// ../../../node_modules/archiver-utils/node_modules/minimatch/minimatch.js
var require_minimatch2 = __commonJS({
  "../../../node_modules/archiver-utils/node_modules/minimatch/minimatch.js"(exports2, module2) {
    module2.exports = minimatch;
    minimatch.Minimatch = Minimatch;
    var path = function() {
      try {
        return require("path");
      } catch (e) {
      }
    }() || {
      sep: "/"
    };
    minimatch.sep = path.sep;
    var GLOBSTAR = minimatch.GLOBSTAR = Minimatch.GLOBSTAR = {};
    var expand = require_brace_expansion2();
    var plTypes = {
      "!": { open: "(?:(?!(?:", close: "))[^/]*?)" },
      "?": { open: "(?:", close: ")?" },
      "+": { open: "(?:", close: ")+" },
      "*": { open: "(?:", close: ")*" },
      "@": { open: "(?:", close: ")" }
    };
    var qmark = "[^/]";
    var star = qmark + "*?";
    var twoStarDot = "(?:(?!(?:\\/|^)(?:\\.{1,2})($|\\/)).)*?";
    var twoStarNoDot = "(?:(?!(?:\\/|^)\\.).)*?";
    var reSpecials = charSet("().*{}+?[]^$\\!");
    function charSet(s) {
      return s.split("").reduce(function(set, c) {
        set[c] = true;
        return set;
      }, {});
    }
    var slashSplit = /\/+/;
    minimatch.filter = filter;
    function filter(pattern, options) {
      options = options || {};
      return function(p, i, list) {
        return minimatch(p, pattern, options);
      };
    }
    function ext(a, b) {
      b = b || {};
      var t = {};
      Object.keys(a).forEach(function(k) {
        t[k] = a[k];
      });
      Object.keys(b).forEach(function(k) {
        t[k] = b[k];
      });
      return t;
    }
    minimatch.defaults = function(def) {
      if (!def || typeof def !== "object" || !Object.keys(def).length) {
        return minimatch;
      }
      var orig = minimatch;
      var m = function minimatch2(p, pattern, options) {
        return orig(p, pattern, ext(def, options));
      };
      m.Minimatch = function Minimatch2(pattern, options) {
        return new orig.Minimatch(pattern, ext(def, options));
      };
      m.Minimatch.defaults = function defaults(options) {
        return orig.defaults(ext(def, options)).Minimatch;
      };
      m.filter = function filter2(pattern, options) {
        return orig.filter(pattern, ext(def, options));
      };
      m.defaults = function defaults(options) {
        return orig.defaults(ext(def, options));
      };
      m.makeRe = function makeRe2(pattern, options) {
        return orig.makeRe(pattern, ext(def, options));
      };
      m.braceExpand = function braceExpand2(pattern, options) {
        return orig.braceExpand(pattern, ext(def, options));
      };
      m.match = function(list, pattern, options) {
        return orig.match(list, pattern, ext(def, options));
      };
      return m;
    };
    Minimatch.defaults = function(def) {
      return minimatch.defaults(def).Minimatch;
    };
    function minimatch(p, pattern, options) {
      assertValidPattern(pattern);
      if (!options)
        options = {};
      if (!options.nocomment && pattern.charAt(0) === "#") {
        return false;
      }
      return new Minimatch(pattern, options).match(p);
    }
    function Minimatch(pattern, options) {
      if (!(this instanceof Minimatch)) {
        return new Minimatch(pattern, options);
      }
      assertValidPattern(pattern);
      if (!options)
        options = {};
      pattern = pattern.trim();
      if (!options.allowWindowsEscape && path.sep !== "/") {
        pattern = pattern.split(path.sep).join("/");
      }
      this.options = options;
      this.set = [];
      this.pattern = pattern;
      this.regexp = null;
      this.negate = false;
      this.comment = false;
      this.empty = false;
      this.partial = !!options.partial;
      this.make();
    }
    Minimatch.prototype.debug = function() {
    };
    Minimatch.prototype.make = make;
    function make() {
      var pattern = this.pattern;
      var options = this.options;
      if (!options.nocomment && pattern.charAt(0) === "#") {
        this.comment = true;
        return;
      }
      if (!pattern) {
        this.empty = true;
        return;
      }
      this.parseNegate();
      var set = this.globSet = this.braceExpand();
      if (options.debug)
        this.debug = function debug() {
          console.error.apply(console, arguments);
        };
      this.debug(this.pattern, set);
      set = this.globParts = set.map(function(s) {
        return s.split(slashSplit);
      });
      this.debug(this.pattern, set);
      set = set.map(function(s, si, set2) {
        return s.map(this.parse, this);
      }, this);
      this.debug(this.pattern, set);
      set = set.filter(function(s) {
        return s.indexOf(false) === -1;
      });
      this.debug(this.pattern, set);
      this.set = set;
    }
    Minimatch.prototype.parseNegate = parseNegate;
    function parseNegate() {
      var pattern = this.pattern;
      var negate = false;
      var options = this.options;
      var negateOffset = 0;
      if (options.nonegate)
        return;
      for (var i = 0, l2 = pattern.length; i < l2 && pattern.charAt(i) === "!"; i++) {
        negate = !negate;
        negateOffset++;
      }
      if (negateOffset)
        this.pattern = pattern.substr(negateOffset);
      this.negate = negate;
    }
    minimatch.braceExpand = function(pattern, options) {
      return braceExpand(pattern, options);
    };
    Minimatch.prototype.braceExpand = braceExpand;
    function braceExpand(pattern, options) {
      if (!options) {
        if (this instanceof Minimatch) {
          options = this.options;
        } else {
          options = {};
        }
      }
      pattern = typeof pattern === "undefined" ? this.pattern : pattern;
      assertValidPattern(pattern);
      if (options.nobrace || !/\{(?:(?!\{).)*\}/.test(pattern)) {
        return [pattern];
      }
      return expand(pattern);
    }
    var MAX_PATTERN_LENGTH = 1024 * 64;
    var assertValidPattern = function(pattern) {
      if (typeof pattern !== "string") {
        throw new TypeError("invalid pattern");
      }
      if (pattern.length > MAX_PATTERN_LENGTH) {
        throw new TypeError("pattern is too long");
      }
    };
    Minimatch.prototype.parse = parse2;
    var SUBPARSE = {};
    function parse2(pattern, isSub) {
      assertValidPattern(pattern);
      var options = this.options;
      if (pattern === "**") {
        if (!options.noglobstar)
          return GLOBSTAR;
        else
          pattern = "*";
      }
      if (pattern === "")
        return "";
      var re = "";
      var hasMagic = !!options.nocase;
      var escaping = false;
      var patternListStack = [];
      var negativeLists = [];
      var stateChar;
      var inClass = false;
      var reClassStart = -1;
      var classStart = -1;
      var patternStart = pattern.charAt(0) === "." ? "" : options.dot ? "(?!(?:^|\\/)\\.{1,2}(?:$|\\/))" : "(?!\\.)";
      var self2 = this;
      function clearStateChar() {
        if (stateChar) {
          switch (stateChar) {
            case "*":
              re += star;
              hasMagic = true;
              break;
            case "?":
              re += qmark;
              hasMagic = true;
              break;
            default:
              re += "\\" + stateChar;
              break;
          }
          self2.debug("clearStateChar %j %j", stateChar, re);
          stateChar = false;
        }
      }
      for (var i = 0, len = pattern.length, c; i < len && (c = pattern.charAt(i)); i++) {
        this.debug("%s	%s %s %j", pattern, i, re, c);
        if (escaping && reSpecials[c]) {
          re += "\\" + c;
          escaping = false;
          continue;
        }
        switch (c) {
          case "/": {
            return false;
          }
          case "\\":
            clearStateChar();
            escaping = true;
            continue;
          case "?":
          case "*":
          case "+":
          case "@":
          case "!":
            this.debug("%s	%s %s %j <-- stateChar", pattern, i, re, c);
            if (inClass) {
              this.debug("  in class");
              if (c === "!" && i === classStart + 1)
                c = "^";
              re += c;
              continue;
            }
            self2.debug("call clearStateChar %j", stateChar);
            clearStateChar();
            stateChar = c;
            if (options.noext)
              clearStateChar();
            continue;
          case "(":
            if (inClass) {
              re += "(";
              continue;
            }
            if (!stateChar) {
              re += "\\(";
              continue;
            }
            patternListStack.push({
              type: stateChar,
              start: i - 1,
              reStart: re.length,
              open: plTypes[stateChar].open,
              close: plTypes[stateChar].close
            });
            re += stateChar === "!" ? "(?:(?!(?:" : "(?:";
            this.debug("plType %j %j", stateChar, re);
            stateChar = false;
            continue;
          case ")":
            if (inClass || !patternListStack.length) {
              re += "\\)";
              continue;
            }
            clearStateChar();
            hasMagic = true;
            var pl = patternListStack.pop();
            re += pl.close;
            if (pl.type === "!") {
              negativeLists.push(pl);
            }
            pl.reEnd = re.length;
            continue;
          case "|":
            if (inClass || !patternListStack.length || escaping) {
              re += "\\|";
              escaping = false;
              continue;
            }
            clearStateChar();
            re += "|";
            continue;
          case "[":
            clearStateChar();
            if (inClass) {
              re += "\\" + c;
              continue;
            }
            inClass = true;
            classStart = i;
            reClassStart = re.length;
            re += c;
            continue;
          case "]":
            if (i === classStart + 1 || !inClass) {
              re += "\\" + c;
              escaping = false;
              continue;
            }
            var cs = pattern.substring(classStart + 1, i);
            try {
              RegExp("[" + cs + "]");
            } catch (er) {
              var sp = this.parse(cs, SUBPARSE);
              re = re.substr(0, reClassStart) + "\\[" + sp[0] + "\\]";
              hasMagic = hasMagic || sp[1];
              inClass = false;
              continue;
            }
            hasMagic = true;
            inClass = false;
            re += c;
            continue;
          default:
            clearStateChar();
            if (escaping) {
              escaping = false;
            } else if (reSpecials[c] && !(c === "^" && inClass)) {
              re += "\\";
            }
            re += c;
        }
      }
      if (inClass) {
        cs = pattern.substr(classStart + 1);
        sp = this.parse(cs, SUBPARSE);
        re = re.substr(0, reClassStart) + "\\[" + sp[0];
        hasMagic = hasMagic || sp[1];
      }
      for (pl = patternListStack.pop(); pl; pl = patternListStack.pop()) {
        var tail = re.slice(pl.reStart + pl.open.length);
        this.debug("setting tail", re, pl);
        tail = tail.replace(/((?:\\{2}){0,64})(\\?)\|/g, function(_2, $1, $2) {
          if (!$2) {
            $2 = "\\";
          }
          return $1 + $1 + $2 + "|";
        });
        this.debug("tail=%j\n   %s", tail, tail, pl, re);
        var t = pl.type === "*" ? star : pl.type === "?" ? qmark : "\\" + pl.type;
        hasMagic = true;
        re = re.slice(0, pl.reStart) + t + "\\(" + tail;
      }
      clearStateChar();
      if (escaping) {
        re += "\\\\";
      }
      var addPatternStart = false;
      switch (re.charAt(0)) {
        case "[":
        case ".":
        case "(":
          addPatternStart = true;
      }
      for (var n = negativeLists.length - 1; n > -1; n--) {
        var nl = negativeLists[n];
        var nlBefore = re.slice(0, nl.reStart);
        var nlFirst = re.slice(nl.reStart, nl.reEnd - 8);
        var nlLast = re.slice(nl.reEnd - 8, nl.reEnd);
        var nlAfter = re.slice(nl.reEnd);
        nlLast += nlAfter;
        var openParensBefore = nlBefore.split("(").length - 1;
        var cleanAfter = nlAfter;
        for (i = 0; i < openParensBefore; i++) {
          cleanAfter = cleanAfter.replace(/\)[+*?]?/, "");
        }
        nlAfter = cleanAfter;
        var dollar = "";
        if (nlAfter === "" && isSub !== SUBPARSE) {
          dollar = "$";
        }
        var newRe = nlBefore + nlFirst + nlAfter + dollar + nlLast;
        re = newRe;
      }
      if (re !== "" && hasMagic) {
        re = "(?=.)" + re;
      }
      if (addPatternStart) {
        re = patternStart + re;
      }
      if (isSub === SUBPARSE) {
        return [re, hasMagic];
      }
      if (!hasMagic) {
        return globUnescape(pattern);
      }
      var flags = options.nocase ? "i" : "";
      try {
        var regExp = new RegExp("^" + re + "$", flags);
      } catch (er) {
        return new RegExp("$.");
      }
      regExp._glob = pattern;
      regExp._src = re;
      return regExp;
    }
    minimatch.makeRe = function(pattern, options) {
      return new Minimatch(pattern, options || {}).makeRe();
    };
    Minimatch.prototype.makeRe = makeRe;
    function makeRe() {
      if (this.regexp || this.regexp === false)
        return this.regexp;
      var set = this.set;
      if (!set.length) {
        this.regexp = false;
        return this.regexp;
      }
      var options = this.options;
      var twoStar = options.noglobstar ? star : options.dot ? twoStarDot : twoStarNoDot;
      var flags = options.nocase ? "i" : "";
      var re = set.map(function(pattern) {
        return pattern.map(function(p) {
          return p === GLOBSTAR ? twoStar : typeof p === "string" ? regExpEscape(p) : p._src;
        }).join("\\/");
      }).join("|");
      re = "^(?:" + re + ")$";
      if (this.negate)
        re = "^(?!" + re + ").*$";
      try {
        this.regexp = new RegExp(re, flags);
      } catch (ex) {
        this.regexp = false;
      }
      return this.regexp;
    }
    minimatch.match = function(list, pattern, options) {
      options = options || {};
      var mm = new Minimatch(pattern, options);
      list = list.filter(function(f) {
        return mm.match(f);
      });
      if (mm.options.nonull && !list.length) {
        list.push(pattern);
      }
      return list;
    };
    Minimatch.prototype.match = function match(f, partial) {
      if (typeof partial === "undefined")
        partial = this.partial;
      this.debug("match", f, this.pattern);
      if (this.comment)
        return false;
      if (this.empty)
        return f === "";
      if (f === "/" && partial)
        return true;
      var options = this.options;
      if (path.sep !== "/") {
        f = f.split(path.sep).join("/");
      }
      f = f.split(slashSplit);
      this.debug(this.pattern, "split", f);
      var set = this.set;
      this.debug(this.pattern, "set", set);
      var filename;
      var i;
      for (i = f.length - 1; i >= 0; i--) {
        filename = f[i];
        if (filename)
          break;
      }
      for (i = 0; i < set.length; i++) {
        var pattern = set[i];
        var file = f;
        if (options.matchBase && pattern.length === 1) {
          file = [filename];
        }
        var hit = this.matchOne(file, pattern, partial);
        if (hit) {
          if (options.flipNegate)
            return true;
          return !this.negate;
        }
      }
      if (options.flipNegate)
        return false;
      return this.negate;
    };
    Minimatch.prototype.matchOne = function(file, pattern, partial) {
      var options = this.options;
      this.debug(
        "matchOne",
        { "this": this, file, pattern }
      );
      this.debug("matchOne", file.length, pattern.length);
      for (var fi = 0, pi = 0, fl = file.length, pl = pattern.length; fi < fl && pi < pl; fi++, pi++) {
        this.debug("matchOne loop");
        var p = pattern[pi];
        var f = file[fi];
        this.debug(pattern, p, f);
        if (p === false)
          return false;
        if (p === GLOBSTAR) {
          this.debug("GLOBSTAR", [pattern, p, f]);
          var fr = fi;
          var pr = pi + 1;
          if (pr === pl) {
            this.debug("** at the end");
            for (; fi < fl; fi++) {
              if (file[fi] === "." || file[fi] === ".." || !options.dot && file[fi].charAt(0) === ".")
                return false;
            }
            return true;
          }
          while (fr < fl) {
            var swallowee = file[fr];
            this.debug("\nglobstar while", file, fr, pattern, pr, swallowee);
            if (this.matchOne(file.slice(fr), pattern.slice(pr), partial)) {
              this.debug("globstar found match!", fr, fl, swallowee);
              return true;
            } else {
              if (swallowee === "." || swallowee === ".." || !options.dot && swallowee.charAt(0) === ".") {
                this.debug("dot detected!", file, fr, pattern, pr);
                break;
              }
              this.debug("globstar swallow a segment, and continue");
              fr++;
            }
          }
          if (partial) {
            this.debug("\n>>> no match, partial?", file, fr, pattern, pr);
            if (fr === fl)
              return true;
          }
          return false;
        }
        var hit;
        if (typeof p === "string") {
          hit = f === p;
          this.debug("string match", p, f, hit);
        } else {
          hit = f.match(p);
          this.debug("pattern match", p, f, hit);
        }
        if (!hit)
          return false;
      }
      if (fi === fl && pi === pl) {
        return true;
      } else if (fi === fl) {
        return partial;
      } else if (pi === pl) {
        return fi === fl - 1 && file[fi] === "";
      }
      throw new Error("wtf?");
    };
    function globUnescape(s) {
      return s.replace(/\\(.)/g, "$1");
    }
    function regExpEscape(s) {
      return s.replace(/[-[\]{}()*+?.,\\^$|#\s]/g, "\\$&");
    }
  }
});

// ../../../node_modules/path-is-absolute/index.js
var require_path_is_absolute = __commonJS({
  "../../../node_modules/path-is-absolute/index.js"(exports2, module2) {
    "use strict";
    function posix(path) {
      return path.charAt(0) === "/";
    }
    function win32(path) {
      var splitDeviceRe = /^([a-zA-Z]:|[\\\/]{2}[^\\\/]+[\\\/]+[^\\\/]+)?([\\\/])?([\s\S]*?)$/;
      var result = splitDeviceRe.exec(path);
      var device = result[1] || "";
      var isUnc = Boolean(device && device.charAt(1) !== ":");
      return Boolean(result[2] || isUnc);
    }
    module2.exports = process.platform === "win32" ? win32 : posix;
    module2.exports.posix = posix;
    module2.exports.win32 = win32;
  }
});

// ../../../node_modules/archiver-utils/node_modules/glob/common.js
var require_common2 = __commonJS({
  "../../../node_modules/archiver-utils/node_modules/glob/common.js"(exports2) {
    exports2.setopts = setopts;
    exports2.ownProp = ownProp;
    exports2.makeAbs = makeAbs;
    exports2.finish = finish;
    exports2.mark = mark;
    exports2.isIgnored = isIgnored;
    exports2.childrenIgnored = childrenIgnored;
    function ownProp(obj2, field) {
      return Object.prototype.hasOwnProperty.call(obj2, field);
    }
    var fs = require("fs");
    var path = require("path");
    var minimatch = require_minimatch2();
    var isAbsolute = require_path_is_absolute();
    var Minimatch = minimatch.Minimatch;
    function alphasort(a, b) {
      return a.localeCompare(b, "en");
    }
    function setupIgnores(self2, options) {
      self2.ignore = options.ignore || [];
      if (!Array.isArray(self2.ignore))
        self2.ignore = [self2.ignore];
      if (self2.ignore.length) {
        self2.ignore = self2.ignore.map(ignoreMap);
      }
    }
    function ignoreMap(pattern) {
      var gmatcher = null;
      if (pattern.slice(-3) === "/**") {
        var gpattern = pattern.replace(/(\/\*\*)+$/, "");
        gmatcher = new Minimatch(gpattern, { dot: true });
      }
      return {
        matcher: new Minimatch(pattern, { dot: true }),
        gmatcher
      };
    }
    function setopts(self2, pattern, options) {
      if (!options)
        options = {};
      if (options.matchBase && -1 === pattern.indexOf("/")) {
        if (options.noglobstar) {
          throw new Error("base matching requires globstar");
        }
        pattern = "**/" + pattern;
      }
      self2.silent = !!options.silent;
      self2.pattern = pattern;
      self2.strict = options.strict !== false;
      self2.realpath = !!options.realpath;
      self2.realpathCache = options.realpathCache || /* @__PURE__ */ Object.create(null);
      self2.follow = !!options.follow;
      self2.dot = !!options.dot;
      self2.mark = !!options.mark;
      self2.nodir = !!options.nodir;
      if (self2.nodir)
        self2.mark = true;
      self2.sync = !!options.sync;
      self2.nounique = !!options.nounique;
      self2.nonull = !!options.nonull;
      self2.nosort = !!options.nosort;
      self2.nocase = !!options.nocase;
      self2.stat = !!options.stat;
      self2.noprocess = !!options.noprocess;
      self2.absolute = !!options.absolute;
      self2.fs = options.fs || fs;
      self2.maxLength = options.maxLength || Infinity;
      self2.cache = options.cache || /* @__PURE__ */ Object.create(null);
      self2.statCache = options.statCache || /* @__PURE__ */ Object.create(null);
      self2.symlinks = options.symlinks || /* @__PURE__ */ Object.create(null);
      setupIgnores(self2, options);
      self2.changedCwd = false;
      var cwd = process.cwd();
      if (!ownProp(options, "cwd"))
        self2.cwd = cwd;
      else {
        self2.cwd = path.resolve(options.cwd);
        self2.changedCwd = self2.cwd !== cwd;
      }
      self2.root = options.root || path.resolve(self2.cwd, "/");
      self2.root = path.resolve(self2.root);
      if (process.platform === "win32")
        self2.root = self2.root.replace(/\\/g, "/");
      self2.cwdAbs = isAbsolute(self2.cwd) ? self2.cwd : makeAbs(self2, self2.cwd);
      if (process.platform === "win32")
        self2.cwdAbs = self2.cwdAbs.replace(/\\/g, "/");
      self2.nomount = !!options.nomount;
      options.nonegate = true;
      options.nocomment = true;
      options.allowWindowsEscape = false;
      self2.minimatch = new Minimatch(pattern, options);
      self2.options = self2.minimatch.options;
    }
    function finish(self2) {
      var nou = self2.nounique;
      var all = nou ? [] : /* @__PURE__ */ Object.create(null);
      for (var i = 0, l2 = self2.matches.length; i < l2; i++) {
        var matches = self2.matches[i];
        if (!matches || Object.keys(matches).length === 0) {
          if (self2.nonull) {
            var literal = self2.minimatch.globSet[i];
            if (nou)
              all.push(literal);
            else
              all[literal] = true;
          }
        } else {
          var m = Object.keys(matches);
          if (nou)
            all.push.apply(all, m);
          else
            m.forEach(function(m2) {
              all[m2] = true;
            });
        }
      }
      if (!nou)
        all = Object.keys(all);
      if (!self2.nosort)
        all = all.sort(alphasort);
      if (self2.mark) {
        for (var i = 0; i < all.length; i++) {
          all[i] = self2._mark(all[i]);
        }
        if (self2.nodir) {
          all = all.filter(function(e) {
            var notDir = !/\/$/.test(e);
            var c = self2.cache[e] || self2.cache[makeAbs(self2, e)];
            if (notDir && c)
              notDir = c !== "DIR" && !Array.isArray(c);
            return notDir;
          });
        }
      }
      if (self2.ignore.length)
        all = all.filter(function(m2) {
          return !isIgnored(self2, m2);
        });
      self2.found = all;
    }
    function mark(self2, p) {
      var abs = makeAbs(self2, p);
      var c = self2.cache[abs];
      var m = p;
      if (c) {
        var isDir = c === "DIR" || Array.isArray(c);
        var slash = p.slice(-1) === "/";
        if (isDir && !slash)
          m += "/";
        else if (!isDir && slash)
          m = m.slice(0, -1);
        if (m !== p) {
          var mabs = makeAbs(self2, m);
          self2.statCache[mabs] = self2.statCache[abs];
          self2.cache[mabs] = self2.cache[abs];
        }
      }
      return m;
    }
    function makeAbs(self2, f) {
      var abs = f;
      if (f.charAt(0) === "/") {
        abs = path.join(self2.root, f);
      } else if (isAbsolute(f) || f === "") {
        abs = f;
      } else if (self2.changedCwd) {
        abs = path.resolve(self2.cwd, f);
      } else {
        abs = path.resolve(f);
      }
      if (process.platform === "win32")
        abs = abs.replace(/\\/g, "/");
      return abs;
    }
    function isIgnored(self2, path2) {
      if (!self2.ignore.length)
        return false;
      return self2.ignore.some(function(item) {
        return item.matcher.match(path2) || !!(item.gmatcher && item.gmatcher.match(path2));
      });
    }
    function childrenIgnored(self2, path2) {
      if (!self2.ignore.length)
        return false;
      return self2.ignore.some(function(item) {
        return !!(item.gmatcher && item.gmatcher.match(path2));
      });
    }
  }
});

// ../../../node_modules/archiver-utils/node_modules/glob/sync.js
var require_sync = __commonJS({
  "../../../node_modules/archiver-utils/node_modules/glob/sync.js"(exports2, module2) {
    module2.exports = globSync;
    globSync.GlobSync = GlobSync;
    var rp = require_fs();
    var minimatch = require_minimatch2();
    var Minimatch = minimatch.Minimatch;
    var Glob = require_glob().Glob;
    var util = require("util");
    var path = require("path");
    var assert = require("assert");
    var isAbsolute = require_path_is_absolute();
    var common = require_common2();
    var setopts = common.setopts;
    var ownProp = common.ownProp;
    var childrenIgnored = common.childrenIgnored;
    var isIgnored = common.isIgnored;
    function globSync(pattern, options) {
      if (typeof options === "function" || arguments.length === 3)
        throw new TypeError("callback provided to sync glob\nSee: https://github.com/isaacs/node-glob/issues/167");
      return new GlobSync(pattern, options).found;
    }
    function GlobSync(pattern, options) {
      if (!pattern)
        throw new Error("must provide pattern");
      if (typeof options === "function" || arguments.length === 3)
        throw new TypeError("callback provided to sync glob\nSee: https://github.com/isaacs/node-glob/issues/167");
      if (!(this instanceof GlobSync))
        return new GlobSync(pattern, options);
      setopts(this, pattern, options);
      if (this.noprocess)
        return this;
      var n = this.minimatch.set.length;
      this.matches = new Array(n);
      for (var i = 0; i < n; i++) {
        this._process(this.minimatch.set[i], i, false);
      }
      this._finish();
    }
    GlobSync.prototype._finish = function() {
      assert.ok(this instanceof GlobSync);
      if (this.realpath) {
        var self2 = this;
        this.matches.forEach(function(matchset, index) {
          var set = self2.matches[index] = /* @__PURE__ */ Object.create(null);
          for (var p in matchset) {
            try {
              p = self2._makeAbs(p);
              var real = rp.realpathSync(p, self2.realpathCache);
              set[real] = true;
            } catch (er) {
              if (er.syscall === "stat")
                set[self2._makeAbs(p)] = true;
              else
                throw er;
            }
          }
        });
      }
      common.finish(this);
    };
    GlobSync.prototype._process = function(pattern, index, inGlobStar) {
      assert.ok(this instanceof GlobSync);
      var n = 0;
      while (typeof pattern[n] === "string") {
        n++;
      }
      var prefix;
      switch (n) {
        case pattern.length:
          this._processSimple(pattern.join("/"), index);
          return;
        case 0:
          prefix = null;
          break;
        default:
          prefix = pattern.slice(0, n).join("/");
          break;
      }
      var remain = pattern.slice(n);
      var read;
      if (prefix === null)
        read = ".";
      else if (isAbsolute(prefix) || isAbsolute(pattern.map(function(p) {
        return typeof p === "string" ? p : "[*]";
      }).join("/"))) {
        if (!prefix || !isAbsolute(prefix))
          prefix = "/" + prefix;
        read = prefix;
      } else
        read = prefix;
      var abs = this._makeAbs(read);
      if (childrenIgnored(this, read))
        return;
      var isGlobStar = remain[0] === minimatch.GLOBSTAR;
      if (isGlobStar)
        this._processGlobStar(prefix, read, abs, remain, index, inGlobStar);
      else
        this._processReaddir(prefix, read, abs, remain, index, inGlobStar);
    };
    GlobSync.prototype._processReaddir = function(prefix, read, abs, remain, index, inGlobStar) {
      var entries = this._readdir(abs, inGlobStar);
      if (!entries)
        return;
      var pn = remain[0];
      var negate = !!this.minimatch.negate;
      var rawGlob = pn._glob;
      var dotOk = this.dot || rawGlob.charAt(0) === ".";
      var matchedEntries = [];
      for (var i = 0; i < entries.length; i++) {
        var e = entries[i];
        if (e.charAt(0) !== "." || dotOk) {
          var m;
          if (negate && !prefix) {
            m = !e.match(pn);
          } else {
            m = e.match(pn);
          }
          if (m)
            matchedEntries.push(e);
        }
      }
      var len = matchedEntries.length;
      if (len === 0)
        return;
      if (remain.length === 1 && !this.mark && !this.stat) {
        if (!this.matches[index])
          this.matches[index] = /* @__PURE__ */ Object.create(null);
        for (var i = 0; i < len; i++) {
          var e = matchedEntries[i];
          if (prefix) {
            if (prefix.slice(-1) !== "/")
              e = prefix + "/" + e;
            else
              e = prefix + e;
          }
          if (e.charAt(0) === "/" && !this.nomount) {
            e = path.join(this.root, e);
          }
          this._emitMatch(index, e);
        }
        return;
      }
      remain.shift();
      for (var i = 0; i < len; i++) {
        var e = matchedEntries[i];
        var newPattern;
        if (prefix)
          newPattern = [prefix, e];
        else
          newPattern = [e];
        this._process(newPattern.concat(remain), index, inGlobStar);
      }
    };
    GlobSync.prototype._emitMatch = function(index, e) {
      if (isIgnored(this, e))
        return;
      var abs = this._makeAbs(e);
      if (this.mark)
        e = this._mark(e);
      if (this.absolute) {
        e = abs;
      }
      if (this.matches[index][e])
        return;
      if (this.nodir) {
        var c = this.cache[abs];
        if (c === "DIR" || Array.isArray(c))
          return;
      }
      this.matches[index][e] = true;
      if (this.stat)
        this._stat(e);
    };
    GlobSync.prototype._readdirInGlobStar = function(abs) {
      if (this.follow)
        return this._readdir(abs, false);
      var entries;
      var lstat;
      var stat;
      try {
        lstat = this.fs.lstatSync(abs);
      } catch (er) {
        if (er.code === "ENOENT") {
          return null;
        }
      }
      var isSym = lstat && lstat.isSymbolicLink();
      this.symlinks[abs] = isSym;
      if (!isSym && lstat && !lstat.isDirectory())
        this.cache[abs] = "FILE";
      else
        entries = this._readdir(abs, false);
      return entries;
    };
    GlobSync.prototype._readdir = function(abs, inGlobStar) {
      var entries;
      if (inGlobStar && !ownProp(this.symlinks, abs))
        return this._readdirInGlobStar(abs);
      if (ownProp(this.cache, abs)) {
        var c = this.cache[abs];
        if (!c || c === "FILE")
          return null;
        if (Array.isArray(c))
          return c;
      }
      try {
        return this._readdirEntries(abs, this.fs.readdirSync(abs));
      } catch (er) {
        this._readdirError(abs, er);
        return null;
      }
    };
    GlobSync.prototype._readdirEntries = function(abs, entries) {
      if (!this.mark && !this.stat) {
        for (var i = 0; i < entries.length; i++) {
          var e = entries[i];
          if (abs === "/")
            e = abs + e;
          else
            e = abs + "/" + e;
          this.cache[e] = true;
        }
      }
      this.cache[abs] = entries;
      return entries;
    };
    GlobSync.prototype._readdirError = function(f, er) {
      switch (er.code) {
        case "ENOTSUP":
        case "ENOTDIR":
          var abs = this._makeAbs(f);
          this.cache[abs] = "FILE";
          if (abs === this.cwdAbs) {
            var error = new Error(er.code + " invalid cwd " + this.cwd);
            error.path = this.cwd;
            error.code = er.code;
            throw error;
          }
          break;
        case "ENOENT":
        case "ELOOP":
        case "ENAMETOOLONG":
        case "UNKNOWN":
          this.cache[this._makeAbs(f)] = false;
          break;
        default:
          this.cache[this._makeAbs(f)] = false;
          if (this.strict)
            throw er;
          if (!this.silent)
            console.error("glob error", er);
          break;
      }
    };
    GlobSync.prototype._processGlobStar = function(prefix, read, abs, remain, index, inGlobStar) {
      var entries = this._readdir(abs, inGlobStar);
      if (!entries)
        return;
      var remainWithoutGlobStar = remain.slice(1);
      var gspref = prefix ? [prefix] : [];
      var noGlobStar = gspref.concat(remainWithoutGlobStar);
      this._process(noGlobStar, index, false);
      var len = entries.length;
      var isSym = this.symlinks[abs];
      if (isSym && inGlobStar)
        return;
      for (var i = 0; i < len; i++) {
        var e = entries[i];
        if (e.charAt(0) === "." && !this.dot)
          continue;
        var instead = gspref.concat(entries[i], remainWithoutGlobStar);
        this._process(instead, index, true);
        var below = gspref.concat(entries[i], remain);
        this._process(below, index, true);
      }
    };
    GlobSync.prototype._processSimple = function(prefix, index) {
      var exists = this._stat(prefix);
      if (!this.matches[index])
        this.matches[index] = /* @__PURE__ */ Object.create(null);
      if (!exists)
        return;
      if (prefix && isAbsolute(prefix) && !this.nomount) {
        var trail = /[\/\\]$/.test(prefix);
        if (prefix.charAt(0) === "/") {
          prefix = path.join(this.root, prefix);
        } else {
          prefix = path.resolve(this.root, prefix);
          if (trail)
            prefix += "/";
        }
      }
      if (process.platform === "win32")
        prefix = prefix.replace(/\\/g, "/");
      this._emitMatch(index, prefix);
    };
    GlobSync.prototype._stat = function(f) {
      var abs = this._makeAbs(f);
      var needDir = f.slice(-1) === "/";
      if (f.length > this.maxLength)
        return false;
      if (!this.stat && ownProp(this.cache, abs)) {
        var c = this.cache[abs];
        if (Array.isArray(c))
          c = "DIR";
        if (!needDir || c === "DIR")
          return c;
        if (needDir && c === "FILE")
          return false;
      }
      var exists;
      var stat = this.statCache[abs];
      if (!stat) {
        var lstat;
        try {
          lstat = this.fs.lstatSync(abs);
        } catch (er) {
          if (er && (er.code === "ENOENT" || er.code === "ENOTDIR")) {
            this.statCache[abs] = false;
            return false;
          }
        }
        if (lstat && lstat.isSymbolicLink()) {
          try {
            stat = this.fs.statSync(abs);
          } catch (er) {
            stat = lstat;
          }
        } else {
          stat = lstat;
        }
      }
      this.statCache[abs] = stat;
      var c = true;
      if (stat)
        c = stat.isDirectory() ? "DIR" : "FILE";
      this.cache[abs] = this.cache[abs] || c;
      if (needDir && c === "FILE")
        return false;
      return c;
    };
    GlobSync.prototype._mark = function(p) {
      return common.mark(this, p);
    };
    GlobSync.prototype._makeAbs = function(f) {
      return common.makeAbs(this, f);
    };
  }
});

// ../../../node_modules/wrappy/wrappy.js
var require_wrappy = __commonJS({
  "../../../node_modules/wrappy/wrappy.js"(exports2, module2) {
    module2.exports = wrappy;
    function wrappy(fn, cb) {
      if (fn && cb)
        return wrappy(fn)(cb);
      if (typeof fn !== "function")
        throw new TypeError("need wrapper function");
      Object.keys(fn).forEach(function(k) {
        wrapper[k] = fn[k];
      });
      return wrapper;
      function wrapper() {
        var args = new Array(arguments.length);
        for (var i = 0; i < args.length; i++) {
          args[i] = arguments[i];
        }
        var ret2 = fn.apply(this, args);
        var cb2 = args[args.length - 1];
        if (typeof ret2 === "function" && ret2 !== cb2) {
          Object.keys(cb2).forEach(function(k) {
            ret2[k] = cb2[k];
          });
        }
        return ret2;
      }
    }
  }
});

// ../../../node_modules/once/once.js
var require_once = __commonJS({
  "../../../node_modules/once/once.js"(exports2, module2) {
    var wrappy = require_wrappy();
    module2.exports = wrappy(once);
    module2.exports.strict = wrappy(onceStrict);
    once.proto = once(function() {
      Object.defineProperty(Function.prototype, "once", {
        value: function() {
          return once(this);
        },
        configurable: true
      });
      Object.defineProperty(Function.prototype, "onceStrict", {
        value: function() {
          return onceStrict(this);
        },
        configurable: true
      });
    });
    function once(fn) {
      var f = function() {
        if (f.called)
          return f.value;
        f.called = true;
        return f.value = fn.apply(this, arguments);
      };
      f.called = false;
      return f;
    }
    function onceStrict(fn) {
      var f = function() {
        if (f.called)
          throw new Error(f.onceError);
        f.called = true;
        return f.value = fn.apply(this, arguments);
      };
      var name = fn.name || "Function wrapped with `once`";
      f.onceError = name + " shouldn't be called more than once";
      f.called = false;
      return f;
    }
  }
});

// ../../../node_modules/inflight/inflight.js
var require_inflight = __commonJS({
  "../../../node_modules/inflight/inflight.js"(exports2, module2) {
    var wrappy = require_wrappy();
    var reqs = /* @__PURE__ */ Object.create(null);
    var once = require_once();
    module2.exports = wrappy(inflight);
    function inflight(key, cb) {
      if (reqs[key]) {
        reqs[key].push(cb);
        return null;
      } else {
        reqs[key] = [cb];
        return makeres(key);
      }
    }
    function makeres(key) {
      return once(function RES() {
        var cbs = reqs[key];
        var len = cbs.length;
        var args = slice(arguments);
        try {
          for (var i = 0; i < len; i++) {
            cbs[i].apply(null, args);
          }
        } finally {
          if (cbs.length > len) {
            cbs.splice(0, len);
            process.nextTick(function() {
              RES.apply(null, args);
            });
          } else {
            delete reqs[key];
          }
        }
      });
    }
    function slice(args) {
      var length = args.length;
      var array = [];
      for (var i = 0; i < length; i++)
        array[i] = args[i];
      return array;
    }
  }
});

// ../../../node_modules/archiver-utils/node_modules/glob/glob.js
var require_glob = __commonJS({
  "../../../node_modules/archiver-utils/node_modules/glob/glob.js"(exports2, module2) {
    module2.exports = glob;
    var rp = require_fs();
    var minimatch = require_minimatch2();
    var Minimatch = minimatch.Minimatch;
    var inherits2 = require_inherits();
    var EE = require("events").EventEmitter;
    var path = require("path");
    var assert = require("assert");
    var isAbsolute = require_path_is_absolute();
    var globSync = require_sync();
    var common = require_common2();
    var setopts = common.setopts;
    var ownProp = common.ownProp;
    var inflight = require_inflight();
    var util = require("util");
    var childrenIgnored = common.childrenIgnored;
    var isIgnored = common.isIgnored;
    var once = require_once();
    function glob(pattern, options, cb) {
      if (typeof options === "function")
        cb = options, options = {};
      if (!options)
        options = {};
      if (options.sync) {
        if (cb)
          throw new TypeError("callback provided to sync glob");
        return globSync(pattern, options);
      }
      return new Glob(pattern, options, cb);
    }
    glob.sync = globSync;
    var GlobSync = glob.GlobSync = globSync.GlobSync;
    glob.glob = glob;
    function extend(origin, add) {
      if (add === null || typeof add !== "object") {
        return origin;
      }
      var keys = Object.keys(add);
      var i = keys.length;
      while (i--) {
        origin[keys[i]] = add[keys[i]];
      }
      return origin;
    }
    glob.hasMagic = function(pattern, options_) {
      var options = extend({}, options_);
      options.noprocess = true;
      var g = new Glob(pattern, options);
      var set = g.minimatch.set;
      if (!pattern)
        return false;
      if (set.length > 1)
        return true;
      for (var j = 0; j < set[0].length; j++) {
        if (typeof set[0][j] !== "string")
          return true;
      }
      return false;
    };
    glob.Glob = Glob;
    inherits2(Glob, EE);
    function Glob(pattern, options, cb) {
      if (typeof options === "function") {
        cb = options;
        options = null;
      }
      if (options && options.sync) {
        if (cb)
          throw new TypeError("callback provided to sync glob");
        return new GlobSync(pattern, options);
      }
      if (!(this instanceof Glob))
        return new Glob(pattern, options, cb);
      setopts(this, pattern, options);
      this._didRealPath = false;
      var n = this.minimatch.set.length;
      this.matches = new Array(n);
      if (typeof cb === "function") {
        cb = once(cb);
        this.on("error", cb);
        this.on("end", function(matches) {
          cb(null, matches);
        });
      }
      var self2 = this;
      this._processing = 0;
      this._emitQueue = [];
      this._processQueue = [];
      this.paused = false;
      if (this.noprocess)
        return this;
      if (n === 0)
        return done();
      var sync = true;
      for (var i = 0; i < n; i++) {
        this._process(this.minimatch.set[i], i, false, done);
      }
      sync = false;
      function done() {
        --self2._processing;
        if (self2._processing <= 0) {
          if (sync) {
            process.nextTick(function() {
              self2._finish();
            });
          } else {
            self2._finish();
          }
        }
      }
    }
    Glob.prototype._finish = function() {
      assert(this instanceof Glob);
      if (this.aborted)
        return;
      if (this.realpath && !this._didRealpath)
        return this._realpath();
      common.finish(this);
      this.emit("end", this.found);
    };
    Glob.prototype._realpath = function() {
      if (this._didRealpath)
        return;
      this._didRealpath = true;
      var n = this.matches.length;
      if (n === 0)
        return this._finish();
      var self2 = this;
      for (var i = 0; i < this.matches.length; i++)
        this._realpathSet(i, next);
      function next() {
        if (--n === 0)
          self2._finish();
      }
    };
    Glob.prototype._realpathSet = function(index, cb) {
      var matchset = this.matches[index];
      if (!matchset)
        return cb();
      var found = Object.keys(matchset);
      var self2 = this;
      var n = found.length;
      if (n === 0)
        return cb();
      var set = this.matches[index] = /* @__PURE__ */ Object.create(null);
      found.forEach(function(p, i) {
        p = self2._makeAbs(p);
        rp.realpath(p, self2.realpathCache, function(er, real) {
          if (!er)
            set[real] = true;
          else if (er.syscall === "stat")
            set[p] = true;
          else
            self2.emit("error", er);
          if (--n === 0) {
            self2.matches[index] = set;
            cb();
          }
        });
      });
    };
    Glob.prototype._mark = function(p) {
      return common.mark(this, p);
    };
    Glob.prototype._makeAbs = function(f) {
      return common.makeAbs(this, f);
    };
    Glob.prototype.abort = function() {
      this.aborted = true;
      this.emit("abort");
    };
    Glob.prototype.pause = function() {
      if (!this.paused) {
        this.paused = true;
        this.emit("pause");
      }
    };
    Glob.prototype.resume = function() {
      if (this.paused) {
        this.emit("resume");
        this.paused = false;
        if (this._emitQueue.length) {
          var eq = this._emitQueue.slice(0);
          this._emitQueue.length = 0;
          for (var i = 0; i < eq.length; i++) {
            var e = eq[i];
            this._emitMatch(e[0], e[1]);
          }
        }
        if (this._processQueue.length) {
          var pq = this._processQueue.slice(0);
          this._processQueue.length = 0;
          for (var i = 0; i < pq.length; i++) {
            var p = pq[i];
            this._processing--;
            this._process(p[0], p[1], p[2], p[3]);
          }
        }
      }
    };
    Glob.prototype._process = function(pattern, index, inGlobStar, cb) {
      assert(this instanceof Glob);
      assert(typeof cb === "function");
      if (this.aborted)
        return;
      this._processing++;
      if (this.paused) {
        this._processQueue.push([pattern, index, inGlobStar, cb]);
        return;
      }
      var n = 0;
      while (typeof pattern[n] === "string") {
        n++;
      }
      var prefix;
      switch (n) {
        case pattern.length:
          this._processSimple(pattern.join("/"), index, cb);
          return;
        case 0:
          prefix = null;
          break;
        default:
          prefix = pattern.slice(0, n).join("/");
          break;
      }
      var remain = pattern.slice(n);
      var read;
      if (prefix === null)
        read = ".";
      else if (isAbsolute(prefix) || isAbsolute(pattern.map(function(p) {
        return typeof p === "string" ? p : "[*]";
      }).join("/"))) {
        if (!prefix || !isAbsolute(prefix))
          prefix = "/" + prefix;
        read = prefix;
      } else
        read = prefix;
      var abs = this._makeAbs(read);
      if (childrenIgnored(this, read))
        return cb();
      var isGlobStar = remain[0] === minimatch.GLOBSTAR;
      if (isGlobStar)
        this._processGlobStar(prefix, read, abs, remain, index, inGlobStar, cb);
      else
        this._processReaddir(prefix, read, abs, remain, index, inGlobStar, cb);
    };
    Glob.prototype._processReaddir = function(prefix, read, abs, remain, index, inGlobStar, cb) {
      var self2 = this;
      this._readdir(abs, inGlobStar, function(er, entries) {
        return self2._processReaddir2(prefix, read, abs, remain, index, inGlobStar, entries, cb);
      });
    };
    Glob.prototype._processReaddir2 = function(prefix, read, abs, remain, index, inGlobStar, entries, cb) {
      if (!entries)
        return cb();
      var pn = remain[0];
      var negate = !!this.minimatch.negate;
      var rawGlob = pn._glob;
      var dotOk = this.dot || rawGlob.charAt(0) === ".";
      var matchedEntries = [];
      for (var i = 0; i < entries.length; i++) {
        var e = entries[i];
        if (e.charAt(0) !== "." || dotOk) {
          var m;
          if (negate && !prefix) {
            m = !e.match(pn);
          } else {
            m = e.match(pn);
          }
          if (m)
            matchedEntries.push(e);
        }
      }
      var len = matchedEntries.length;
      if (len === 0)
        return cb();
      if (remain.length === 1 && !this.mark && !this.stat) {
        if (!this.matches[index])
          this.matches[index] = /* @__PURE__ */ Object.create(null);
        for (var i = 0; i < len; i++) {
          var e = matchedEntries[i];
          if (prefix) {
            if (prefix !== "/")
              e = prefix + "/" + e;
            else
              e = prefix + e;
          }
          if (e.charAt(0) === "/" && !this.nomount) {
            e = path.join(this.root, e);
          }
          this._emitMatch(index, e);
        }
        return cb();
      }
      remain.shift();
      for (var i = 0; i < len; i++) {
        var e = matchedEntries[i];
        var newPattern;
        if (prefix) {
          if (prefix !== "/")
            e = prefix + "/" + e;
          else
            e = prefix + e;
        }
        this._process([e].concat(remain), index, inGlobStar, cb);
      }
      cb();
    };
    Glob.prototype._emitMatch = function(index, e) {
      if (this.aborted)
        return;
      if (isIgnored(this, e))
        return;
      if (this.paused) {
        this._emitQueue.push([index, e]);
        return;
      }
      var abs = isAbsolute(e) ? e : this._makeAbs(e);
      if (this.mark)
        e = this._mark(e);
      if (this.absolute)
        e = abs;
      if (this.matches[index][e])
        return;
      if (this.nodir) {
        var c = this.cache[abs];
        if (c === "DIR" || Array.isArray(c))
          return;
      }
      this.matches[index][e] = true;
      var st = this.statCache[abs];
      if (st)
        this.emit("stat", e, st);
      this.emit("match", e);
    };
    Glob.prototype._readdirInGlobStar = function(abs, cb) {
      if (this.aborted)
        return;
      if (this.follow)
        return this._readdir(abs, false, cb);
      var lstatkey = "lstat\0" + abs;
      var self2 = this;
      var lstatcb = inflight(lstatkey, lstatcb_);
      if (lstatcb)
        self2.fs.lstat(abs, lstatcb);
      function lstatcb_(er, lstat) {
        if (er && er.code === "ENOENT")
          return cb();
        var isSym = lstat && lstat.isSymbolicLink();
        self2.symlinks[abs] = isSym;
        if (!isSym && lstat && !lstat.isDirectory()) {
          self2.cache[abs] = "FILE";
          cb();
        } else
          self2._readdir(abs, false, cb);
      }
    };
    Glob.prototype._readdir = function(abs, inGlobStar, cb) {
      if (this.aborted)
        return;
      cb = inflight("readdir\0" + abs + "\0" + inGlobStar, cb);
      if (!cb)
        return;
      if (inGlobStar && !ownProp(this.symlinks, abs))
        return this._readdirInGlobStar(abs, cb);
      if (ownProp(this.cache, abs)) {
        var c = this.cache[abs];
        if (!c || c === "FILE")
          return cb();
        if (Array.isArray(c))
          return cb(null, c);
      }
      var self2 = this;
      self2.fs.readdir(abs, readdirCb(this, abs, cb));
    };
    function readdirCb(self2, abs, cb) {
      return function(er, entries) {
        if (er)
          self2._readdirError(abs, er, cb);
        else
          self2._readdirEntries(abs, entries, cb);
      };
    }
    Glob.prototype._readdirEntries = function(abs, entries, cb) {
      if (this.aborted)
        return;
      if (!this.mark && !this.stat) {
        for (var i = 0; i < entries.length; i++) {
          var e = entries[i];
          if (abs === "/")
            e = abs + e;
          else
            e = abs + "/" + e;
          this.cache[e] = true;
        }
      }
      this.cache[abs] = entries;
      return cb(null, entries);
    };
    Glob.prototype._readdirError = function(f, er, cb) {
      if (this.aborted)
        return;
      switch (er.code) {
        case "ENOTSUP":
        case "ENOTDIR":
          var abs = this._makeAbs(f);
          this.cache[abs] = "FILE";
          if (abs === this.cwdAbs) {
            var error = new Error(er.code + " invalid cwd " + this.cwd);
            error.path = this.cwd;
            error.code = er.code;
            this.emit("error", error);
            this.abort();
          }
          break;
        case "ENOENT":
        case "ELOOP":
        case "ENAMETOOLONG":
        case "UNKNOWN":
          this.cache[this._makeAbs(f)] = false;
          break;
        default:
          this.cache[this._makeAbs(f)] = false;
          if (this.strict) {
            this.emit("error", er);
            this.abort();
          }
          if (!this.silent)
            console.error("glob error", er);
          break;
      }
      return cb();
    };
    Glob.prototype._processGlobStar = function(prefix, read, abs, remain, index, inGlobStar, cb) {
      var self2 = this;
      this._readdir(abs, inGlobStar, function(er, entries) {
        self2._processGlobStar2(prefix, read, abs, remain, index, inGlobStar, entries, cb);
      });
    };
    Glob.prototype._processGlobStar2 = function(prefix, read, abs, remain, index, inGlobStar, entries, cb) {
      if (!entries)
        return cb();
      var remainWithoutGlobStar = remain.slice(1);
      var gspref = prefix ? [prefix] : [];
      var noGlobStar = gspref.concat(remainWithoutGlobStar);
      this._process(noGlobStar, index, false, cb);
      var isSym = this.symlinks[abs];
      var len = entries.length;
      if (isSym && inGlobStar)
        return cb();
      for (var i = 0; i < len; i++) {
        var e = entries[i];
        if (e.charAt(0) === "." && !this.dot)
          continue;
        var instead = gspref.concat(entries[i], remainWithoutGlobStar);
        this._process(instead, index, true, cb);
        var below = gspref.concat(entries[i], remain);
        this._process(below, index, true, cb);
      }
      cb();
    };
    Glob.prototype._processSimple = function(prefix, index, cb) {
      var self2 = this;
      this._stat(prefix, function(er, exists) {
        self2._processSimple2(prefix, index, er, exists, cb);
      });
    };
    Glob.prototype._processSimple2 = function(prefix, index, er, exists, cb) {
      if (!this.matches[index])
        this.matches[index] = /* @__PURE__ */ Object.create(null);
      if (!exists)
        return cb();
      if (prefix && isAbsolute(prefix) && !this.nomount) {
        var trail = /[\/\\]$/.test(prefix);
        if (prefix.charAt(0) === "/") {
          prefix = path.join(this.root, prefix);
        } else {
          prefix = path.resolve(this.root, prefix);
          if (trail)
            prefix += "/";
        }
      }
      if (process.platform === "win32")
        prefix = prefix.replace(/\\/g, "/");
      this._emitMatch(index, prefix);
      cb();
    };
    Glob.prototype._stat = function(f, cb) {
      var abs = this._makeAbs(f);
      var needDir = f.slice(-1) === "/";
      if (f.length > this.maxLength)
        return cb();
      if (!this.stat && ownProp(this.cache, abs)) {
        var c = this.cache[abs];
        if (Array.isArray(c))
          c = "DIR";
        if (!needDir || c === "DIR")
          return cb(null, c);
        if (needDir && c === "FILE")
          return cb();
      }
      var exists;
      var stat = this.statCache[abs];
      if (stat !== void 0) {
        if (stat === false)
          return cb(null, stat);
        else {
          var type = stat.isDirectory() ? "DIR" : "FILE";
          if (needDir && type === "FILE")
            return cb();
          else
            return cb(null, type, stat);
        }
      }
      var self2 = this;
      var statcb = inflight("stat\0" + abs, lstatcb_);
      if (statcb)
        self2.fs.lstat(abs, statcb);
      function lstatcb_(er, lstat) {
        if (lstat && lstat.isSymbolicLink()) {
          return self2.fs.stat(abs, function(er2, stat2) {
            if (er2)
              self2._stat2(f, abs, null, lstat, cb);
            else
              self2._stat2(f, abs, er2, stat2, cb);
          });
        } else {
          self2._stat2(f, abs, er, lstat, cb);
        }
      }
    };
    Glob.prototype._stat2 = function(f, abs, er, stat, cb) {
      if (er && (er.code === "ENOENT" || er.code === "ENOTDIR")) {
        this.statCache[abs] = false;
        return cb();
      }
      var needDir = f.slice(-1) === "/";
      this.statCache[abs] = stat;
      if (abs.slice(-1) === "/" && stat && !stat.isDirectory())
        return cb(null, false, stat);
      var c = true;
      if (stat)
        c = stat.isDirectory() ? "DIR" : "FILE";
      this.cache[abs] = this.cache[abs] || c;
      if (needDir && c === "FILE")
        return cb();
      return cb(null, c, stat);
    };
  }
});

// ../../../node_modules/archiver-utils/file.js
var require_file = __commonJS({
  "../../../node_modules/archiver-utils/file.js"(exports2, module2) {
    var fs = require_graceful_fs();
    var path = require("path");
    var flatten = require_lodash10();
    var difference = require_lodash11();
    var union = require_lodash12();
    var isPlainObject = require_lodash13();
    var glob = require_glob();
    var file = module2.exports = {};
    var pathSeparatorRe = /[\/\\]/g;
    var processPatterns = function(patterns, fn) {
      var result = [];
      flatten(patterns).forEach(function(pattern) {
        var exclusion = pattern.indexOf("!") === 0;
        if (exclusion) {
          pattern = pattern.slice(1);
        }
        var matches = fn(pattern);
        if (exclusion) {
          result = difference(result, matches);
        } else {
          result = union(result, matches);
        }
      });
      return result;
    };
    file.exists = function() {
      var filepath = path.join.apply(path, arguments);
      return fs.existsSync(filepath);
    };
    file.expand = function(...args) {
      var options = isPlainObject(args[0]) ? args.shift() : {};
      var patterns = Array.isArray(args[0]) ? args[0] : args;
      if (patterns.length === 0) {
        return [];
      }
      var matches = processPatterns(patterns, function(pattern) {
        return glob.sync(pattern, options);
      });
      if (options.filter) {
        matches = matches.filter(function(filepath) {
          filepath = path.join(options.cwd || "", filepath);
          try {
            if (typeof options.filter === "function") {
              return options.filter(filepath);
            } else {
              return fs.statSync(filepath)[options.filter]();
            }
          } catch (e) {
            return false;
          }
        });
      }
      return matches;
    };
    file.expandMapping = function(patterns, destBase, options) {
      options = Object.assign({
        rename: function(destBase2, destPath) {
          return path.join(destBase2 || "", destPath);
        }
      }, options);
      var files = [];
      var fileByDest = {};
      file.expand(options, patterns).forEach(function(src) {
        var destPath = src;
        if (options.flatten) {
          destPath = path.basename(destPath);
        }
        if (options.ext) {
          destPath = destPath.replace(/(\.[^\/]*)?$/, options.ext);
        }
        var dest = options.rename(destBase, destPath, options);
        if (options.cwd) {
          src = path.join(options.cwd, src);
        }
        dest = dest.replace(pathSeparatorRe, "/");
        src = src.replace(pathSeparatorRe, "/");
        if (fileByDest[dest]) {
          fileByDest[dest].src.push(src);
        } else {
          files.push({
            src: [src],
            dest
          });
          fileByDest[dest] = files[files.length - 1];
        }
      });
      return files;
    };
    file.normalizeFilesArray = function(data) {
      var files = [];
      data.forEach(function(obj2) {
        var prop;
        if ("src" in obj2 || "dest" in obj2) {
          files.push(obj2);
        }
      });
      if (files.length === 0) {
        return [];
      }
      files = _(files).chain().forEach(function(obj2) {
        if (!("src" in obj2) || !obj2.src) {
          return;
        }
        if (Array.isArray(obj2.src)) {
          obj2.src = flatten(obj2.src);
        } else {
          obj2.src = [obj2.src];
        }
      }).map(function(obj2) {
        var expandOptions = Object.assign({}, obj2);
        delete expandOptions.src;
        delete expandOptions.dest;
        if (obj2.expand) {
          return file.expandMapping(obj2.src, obj2.dest, expandOptions).map(function(mapObj) {
            var result2 = Object.assign({}, obj2);
            result2.orig = Object.assign({}, obj2);
            result2.src = mapObj.src;
            result2.dest = mapObj.dest;
            ["expand", "cwd", "flatten", "rename", "ext"].forEach(function(prop) {
              delete result2[prop];
            });
            return result2;
          });
        }
        var result = Object.assign({}, obj2);
        result.orig = Object.assign({}, obj2);
        if ("src" in result) {
          Object.defineProperty(result, "src", {
            enumerable: true,
            get: function fn() {
              var src;
              if (!("result" in fn)) {
                src = obj2.src;
                src = Array.isArray(src) ? flatten(src) : [src];
                fn.result = file.expand(expandOptions, src);
              }
              return fn.result;
            }
          });
        }
        if ("dest" in result) {
          result.dest = obj2.dest;
        }
        return result;
      }).flatten().value();
      return files;
    };
  }
});

// ../../../node_modules/archiver-utils/index.js
var require_archiver_utils = __commonJS({
  "../../../node_modules/archiver-utils/index.js"(exports2, module2) {
    var fs = require_graceful_fs();
    var path = require("path");
    var nutil = require("util");
    var lazystream = require_lazystream();
    var normalizePath = require_normalize_path();
    var defaults = require_lodash9();
    var Stream = require("stream").Stream;
    var PassThrough = require_readable4().PassThrough;
    var utils = module2.exports = {};
    utils.file = require_file();
    utils.collectStream = function(source, callback) {
      var collection = [];
      var size = 0;
      source.on("error", callback);
      source.on("data", function(chunk) {
        collection.push(chunk);
        size += chunk.length;
      });
      source.on("end", function() {
        var buf = new Buffer(size);
        var offset = 0;
        collection.forEach(function(data) {
          data.copy(buf, offset);
          offset += data.length;
        });
        callback(null, buf);
      });
    };
    utils.dateify = function(dateish) {
      dateish = dateish || /* @__PURE__ */ new Date();
      if (dateish instanceof Date) {
        dateish = dateish;
      } else if (typeof dateish === "string") {
        dateish = new Date(dateish);
      } else {
        dateish = /* @__PURE__ */ new Date();
      }
      return dateish;
    };
    utils.defaults = function(object, source, guard) {
      var args = arguments;
      args[0] = args[0] || {};
      return defaults(...args);
    };
    utils.isStream = function(source) {
      return source instanceof Stream;
    };
    utils.lazyReadStream = function(filepath) {
      return new lazystream.Readable(function() {
        return fs.createReadStream(filepath);
      });
    };
    utils.normalizeInputSource = function(source) {
      if (source === null) {
        return new Buffer(0);
      } else if (typeof source === "string") {
        return new Buffer(source);
      } else if (utils.isStream(source) && !source._readableState) {
        var normalized = new PassThrough();
        source.pipe(normalized);
        return normalized;
      }
      return source;
    };
    utils.sanitizePath = function(filepath) {
      return normalizePath(filepath, false).replace(/^\w+:/, "").replace(/^(\.\.\/|\/)+/, "");
    };
    utils.trailingSlashIt = function(str) {
      return str.slice(-1) !== "/" ? str + "/" : str;
    };
    utils.unixifyPath = function(filepath) {
      return normalizePath(filepath, false).replace(/^\w+:/, "");
    };
    utils.walkdir = function(dirpath, base, callback) {
      var results = [];
      if (typeof base === "function") {
        callback = base;
        base = dirpath;
      }
      fs.readdir(dirpath, function(err, list) {
        var i = 0;
        var file;
        var filepath;
        if (err) {
          return callback(err);
        }
        (function next() {
          file = list[i++];
          if (!file) {
            return callback(null, results);
          }
          filepath = path.join(dirpath, file);
          fs.stat(filepath, function(err2, stats) {
            results.push({
              path: filepath,
              relative: path.relative(base, filepath).replace(/\\/g, "/"),
              stats
            });
            if (stats && stats.isDirectory()) {
              utils.walkdir(filepath, base, function(err3, res) {
                res.forEach(function(dirEntry) {
                  results.push(dirEntry);
                });
                next();
              });
            } else {
              next();
            }
          });
        })();
      });
    };
  }
});

// ../../../node_modules/archiver/lib/error.js
var require_error = __commonJS({
  "../../../node_modules/archiver/lib/error.js"(exports2, module2) {
    var util = require("util");
    var ERROR_CODES = {
      "ABORTED": "archive was aborted",
      "DIRECTORYDIRPATHREQUIRED": "diretory dirpath argument must be a non-empty string value",
      "DIRECTORYFUNCTIONINVALIDDATA": "invalid data returned by directory custom data function",
      "ENTRYNAMEREQUIRED": "entry name must be a non-empty string value",
      "FILEFILEPATHREQUIRED": "file filepath argument must be a non-empty string value",
      "FINALIZING": "archive already finalizing",
      "QUEUECLOSED": "queue closed",
      "NOENDMETHOD": "no suitable finalize/end method defined by module",
      "DIRECTORYNOTSUPPORTED": "support for directory entries not defined by module",
      "FORMATSET": "archive format already set",
      "INPUTSTEAMBUFFERREQUIRED": "input source must be valid Stream or Buffer instance",
      "MODULESET": "module already set",
      "SYMLINKNOTSUPPORTED": "support for symlink entries not defined by module",
      "SYMLINKFILEPATHREQUIRED": "symlink filepath argument must be a non-empty string value",
      "SYMLINKTARGETREQUIRED": "symlink target argument must be a non-empty string value",
      "ENTRYNOTSUPPORTED": "entry not supported"
    };
    function ArchiverError(code, data) {
      Error.captureStackTrace(this, this.constructor);
      this.message = ERROR_CODES[code] || code;
      this.code = code;
      this.data = data;
    }
    util.inherits(ArchiverError, Error);
    exports2 = module2.exports = ArchiverError;
  }
});

// ../../../node_modules/archiver/node_modules/readable-stream/lib/internal/streams/stream.js
var require_stream5 = __commonJS({
  "../../../node_modules/archiver/node_modules/readable-stream/lib/internal/streams/stream.js"(exports2, module2) {
    module2.exports = require("stream");
  }
});

// ../../../node_modules/archiver/node_modules/readable-stream/lib/internal/streams/buffer_list.js
var require_buffer_list2 = __commonJS({
  "../../../node_modules/archiver/node_modules/readable-stream/lib/internal/streams/buffer_list.js"(exports2, module2) {
    "use strict";
    function ownKeys(object, enumerableOnly) {
      var keys = Object.keys(object);
      if (Object.getOwnPropertySymbols) {
        var symbols = Object.getOwnPropertySymbols(object);
        enumerableOnly && (symbols = symbols.filter(function(sym) {
          return Object.getOwnPropertyDescriptor(object, sym).enumerable;
        })), keys.push.apply(keys, symbols);
      }
      return keys;
    }
    function _objectSpread(target) {
      for (var i = 1; i < arguments.length; i++) {
        var source = null != arguments[i] ? arguments[i] : {};
        i % 2 ? ownKeys(Object(source), true).forEach(function(key) {
          _defineProperty(target, key, source[key]);
        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function(key) {
          Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
        });
      }
      return target;
    }
    function _defineProperty(obj2, key, value) {
      key = _toPropertyKey(key);
      if (key in obj2) {
        Object.defineProperty(obj2, key, { value, enumerable: true, configurable: true, writable: true });
      } else {
        obj2[key] = value;
      }
      return obj2;
    }
    function _classCallCheck(instance, Constructor) {
      if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
      }
    }
    function _defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor)
          descriptor.writable = true;
        Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor);
      }
    }
    function _createClass(Constructor, protoProps, staticProps) {
      if (protoProps)
        _defineProperties(Constructor.prototype, protoProps);
      if (staticProps)
        _defineProperties(Constructor, staticProps);
      Object.defineProperty(Constructor, "prototype", { writable: false });
      return Constructor;
    }
    function _toPropertyKey(arg) {
      var key = _toPrimitive(arg, "string");
      return typeof key === "symbol" ? key : String(key);
    }
    function _toPrimitive(input, hint) {
      if (typeof input !== "object" || input === null)
        return input;
      var prim = input[Symbol.toPrimitive];
      if (prim !== void 0) {
        var res = prim.call(input, hint || "default");
        if (typeof res !== "object")
          return res;
        throw new TypeError("@@toPrimitive must return a primitive value.");
      }
      return (hint === "string" ? String : Number)(input);
    }
    var _require = require("buffer");
    var Buffer2 = _require.Buffer;
    var _require2 = require("util");
    var inspect = _require2.inspect;
    var custom = inspect && inspect.custom || "inspect";
    function copyBuffer(src, target, offset) {
      Buffer2.prototype.copy.call(src, target, offset);
    }
    module2.exports = /* @__PURE__ */ function() {
      function BufferList() {
        _classCallCheck(this, BufferList);
        this.head = null;
        this.tail = null;
        this.length = 0;
      }
      _createClass(BufferList, [{
        key: "push",
        value: function push(v) {
          var entry = {
            data: v,
            next: null
          };
          if (this.length > 0)
            this.tail.next = entry;
          else
            this.head = entry;
          this.tail = entry;
          ++this.length;
        }
      }, {
        key: "unshift",
        value: function unshift(v) {
          var entry = {
            data: v,
            next: this.head
          };
          if (this.length === 0)
            this.tail = entry;
          this.head = entry;
          ++this.length;
        }
      }, {
        key: "shift",
        value: function shift() {
          if (this.length === 0)
            return;
          var ret2 = this.head.data;
          if (this.length === 1)
            this.head = this.tail = null;
          else
            this.head = this.head.next;
          --this.length;
          return ret2;
        }
      }, {
        key: "clear",
        value: function clear() {
          this.head = this.tail = null;
          this.length = 0;
        }
      }, {
        key: "join",
        value: function join(s) {
          if (this.length === 0)
            return "";
          var p = this.head;
          var ret2 = "" + p.data;
          while (p = p.next)
            ret2 += s + p.data;
          return ret2;
        }
      }, {
        key: "concat",
        value: function concat(n) {
          if (this.length === 0)
            return Buffer2.alloc(0);
          var ret2 = Buffer2.allocUnsafe(n >>> 0);
          var p = this.head;
          var i = 0;
          while (p) {
            copyBuffer(p.data, ret2, i);
            i += p.data.length;
            p = p.next;
          }
          return ret2;
        }
        // Consumes a specified amount of bytes or characters from the buffered data.
      }, {
        key: "consume",
        value: function consume(n, hasStrings) {
          var ret2;
          if (n < this.head.data.length) {
            ret2 = this.head.data.slice(0, n);
            this.head.data = this.head.data.slice(n);
          } else if (n === this.head.data.length) {
            ret2 = this.shift();
          } else {
            ret2 = hasStrings ? this._getString(n) : this._getBuffer(n);
          }
          return ret2;
        }
      }, {
        key: "first",
        value: function first() {
          return this.head.data;
        }
        // Consumes a specified amount of characters from the buffered data.
      }, {
        key: "_getString",
        value: function _getString(n) {
          var p = this.head;
          var c = 1;
          var ret2 = p.data;
          n -= ret2.length;
          while (p = p.next) {
            var str = p.data;
            var nb = n > str.length ? str.length : n;
            if (nb === str.length)
              ret2 += str;
            else
              ret2 += str.slice(0, n);
            n -= nb;
            if (n === 0) {
              if (nb === str.length) {
                ++c;
                if (p.next)
                  this.head = p.next;
                else
                  this.head = this.tail = null;
              } else {
                this.head = p;
                p.data = str.slice(nb);
              }
              break;
            }
            ++c;
          }
          this.length -= c;
          return ret2;
        }
        // Consumes a specified amount of bytes from the buffered data.
      }, {
        key: "_getBuffer",
        value: function _getBuffer(n) {
          var ret2 = Buffer2.allocUnsafe(n);
          var p = this.head;
          var c = 1;
          p.data.copy(ret2);
          n -= p.data.length;
          while (p = p.next) {
            var buf = p.data;
            var nb = n > buf.length ? buf.length : n;
            buf.copy(ret2, ret2.length - n, 0, nb);
            n -= nb;
            if (n === 0) {
              if (nb === buf.length) {
                ++c;
                if (p.next)
                  this.head = p.next;
                else
                  this.head = this.tail = null;
              } else {
                this.head = p;
                p.data = buf.slice(nb);
              }
              break;
            }
            ++c;
          }
          this.length -= c;
          return ret2;
        }
        // Make sure the linked list only shows the minimal necessary information.
      }, {
        key: custom,
        value: function value(_2, options) {
          return inspect(this, _objectSpread(_objectSpread({}, options), {}, {
            // Only inspect one level.
            depth: 0,
            // It should not recurse.
            customInspect: false
          }));
        }
      }]);
      return BufferList;
    }();
  }
});

// ../../../node_modules/archiver/node_modules/readable-stream/lib/internal/streams/destroy.js
var require_destroy5 = __commonJS({
  "../../../node_modules/archiver/node_modules/readable-stream/lib/internal/streams/destroy.js"(exports2, module2) {
    "use strict";
    function destroy(err, cb) {
      var _this = this;
      var readableDestroyed = this._readableState && this._readableState.destroyed;
      var writableDestroyed = this._writableState && this._writableState.destroyed;
      if (readableDestroyed || writableDestroyed) {
        if (cb) {
          cb(err);
        } else if (err) {
          if (!this._writableState) {
            process.nextTick(emitErrorNT, this, err);
          } else if (!this._writableState.errorEmitted) {
            this._writableState.errorEmitted = true;
            process.nextTick(emitErrorNT, this, err);
          }
        }
        return this;
      }
      if (this._readableState) {
        this._readableState.destroyed = true;
      }
      if (this._writableState) {
        this._writableState.destroyed = true;
      }
      this._destroy(err || null, function(err2) {
        if (!cb && err2) {
          if (!_this._writableState) {
            process.nextTick(emitErrorAndCloseNT, _this, err2);
          } else if (!_this._writableState.errorEmitted) {
            _this._writableState.errorEmitted = true;
            process.nextTick(emitErrorAndCloseNT, _this, err2);
          } else {
            process.nextTick(emitCloseNT, _this);
          }
        } else if (cb) {
          process.nextTick(emitCloseNT, _this);
          cb(err2);
        } else {
          process.nextTick(emitCloseNT, _this);
        }
      });
      return this;
    }
    function emitErrorAndCloseNT(self2, err) {
      emitErrorNT(self2, err);
      emitCloseNT(self2);
    }
    function emitCloseNT(self2) {
      if (self2._writableState && !self2._writableState.emitClose)
        return;
      if (self2._readableState && !self2._readableState.emitClose)
        return;
      self2.emit("close");
    }
    function undestroy() {
      if (this._readableState) {
        this._readableState.destroyed = false;
        this._readableState.reading = false;
        this._readableState.ended = false;
        this._readableState.endEmitted = false;
      }
      if (this._writableState) {
        this._writableState.destroyed = false;
        this._writableState.ended = false;
        this._writableState.ending = false;
        this._writableState.finalCalled = false;
        this._writableState.prefinished = false;
        this._writableState.finished = false;
        this._writableState.errorEmitted = false;
      }
    }
    function emitErrorNT(self2, err) {
      self2.emit("error", err);
    }
    function errorOrDestroy(stream, err) {
      var rState = stream._readableState;
      var wState = stream._writableState;
      if (rState && rState.autoDestroy || wState && wState.autoDestroy)
        stream.destroy(err);
      else
        stream.emit("error", err);
    }
    module2.exports = {
      destroy,
      undestroy,
      errorOrDestroy
    };
  }
});

// ../../../node_modules/archiver/node_modules/readable-stream/errors.js
var require_errors2 = __commonJS({
  "../../../node_modules/archiver/node_modules/readable-stream/errors.js"(exports2, module2) {
    "use strict";
    var codes = {};
    function createErrorType(code, message, Base) {
      if (!Base) {
        Base = Error;
      }
      function getMessage(arg1, arg2, arg3) {
        if (typeof message === "string") {
          return message;
        } else {
          return message(arg1, arg2, arg3);
        }
      }
      class NodeError extends Base {
        constructor(arg1, arg2, arg3) {
          super(getMessage(arg1, arg2, arg3));
        }
      }
      NodeError.prototype.name = Base.name;
      NodeError.prototype.code = code;
      codes[code] = NodeError;
    }
    function oneOf(expected, thing) {
      if (Array.isArray(expected)) {
        const len = expected.length;
        expected = expected.map((i) => String(i));
        if (len > 2) {
          return `one of ${thing} ${expected.slice(0, len - 1).join(", ")}, or ` + expected[len - 1];
        } else if (len === 2) {
          return `one of ${thing} ${expected[0]} or ${expected[1]}`;
        } else {
          return `of ${thing} ${expected[0]}`;
        }
      } else {
        return `of ${thing} ${String(expected)}`;
      }
    }
    function startsWith(str, search, pos) {
      return str.substr(!pos || pos < 0 ? 0 : +pos, search.length) === search;
    }
    function endsWith(str, search, this_len) {
      if (this_len === void 0 || this_len > str.length) {
        this_len = str.length;
      }
      return str.substring(this_len - search.length, this_len) === search;
    }
    function includes(str, search, start) {
      if (typeof start !== "number") {
        start = 0;
      }
      if (start + search.length > str.length) {
        return false;
      } else {
        return str.indexOf(search, start) !== -1;
      }
    }
    createErrorType("ERR_INVALID_OPT_VALUE", function(name, value) {
      return 'The value "' + value + '" is invalid for option "' + name + '"';
    }, TypeError);
    createErrorType("ERR_INVALID_ARG_TYPE", function(name, expected, actual) {
      let determiner;
      if (typeof expected === "string" && startsWith(expected, "not ")) {
        determiner = "must not be";
        expected = expected.replace(/^not /, "");
      } else {
        determiner = "must be";
      }
      let msg;
      if (endsWith(name, " argument")) {
        msg = `The ${name} ${determiner} ${oneOf(expected, "type")}`;
      } else {
        const type = includes(name, ".") ? "property" : "argument";
        msg = `The "${name}" ${type} ${determiner} ${oneOf(expected, "type")}`;
      }
      msg += `. Received type ${typeof actual}`;
      return msg;
    }, TypeError);
    createErrorType("ERR_STREAM_PUSH_AFTER_EOF", "stream.push() after EOF");
    createErrorType("ERR_METHOD_NOT_IMPLEMENTED", function(name) {
      return "The " + name + " method is not implemented";
    });
    createErrorType("ERR_STREAM_PREMATURE_CLOSE", "Premature close");
    createErrorType("ERR_STREAM_DESTROYED", function(name) {
      return "Cannot call " + name + " after a stream was destroyed";
    });
    createErrorType("ERR_MULTIPLE_CALLBACK", "Callback called multiple times");
    createErrorType("ERR_STREAM_CANNOT_PIPE", "Cannot pipe, not readable");
    createErrorType("ERR_STREAM_WRITE_AFTER_END", "write after end");
    createErrorType("ERR_STREAM_NULL_VALUES", "May not write null values to stream", TypeError);
    createErrorType("ERR_UNKNOWN_ENCODING", function(arg) {
      return "Unknown encoding: " + arg;
    }, TypeError);
    createErrorType("ERR_STREAM_UNSHIFT_AFTER_END_EVENT", "stream.unshift() after end event");
    module2.exports.codes = codes;
  }
});

// ../../../node_modules/archiver/node_modules/readable-stream/lib/internal/streams/state.js
var require_state2 = __commonJS({
  "../../../node_modules/archiver/node_modules/readable-stream/lib/internal/streams/state.js"(exports2, module2) {
    "use strict";
    var ERR_INVALID_OPT_VALUE = require_errors2().codes.ERR_INVALID_OPT_VALUE;
    function highWaterMarkFrom(options, isDuplex, duplexKey) {
      return options.highWaterMark != null ? options.highWaterMark : isDuplex ? options[duplexKey] : null;
    }
    function getHighWaterMark(state, options, duplexKey, isDuplex) {
      var hwm = highWaterMarkFrom(options, isDuplex, duplexKey);
      if (hwm != null) {
        if (!(isFinite(hwm) && Math.floor(hwm) === hwm) || hwm < 0) {
          var name = isDuplex ? duplexKey : "highWaterMark";
          throw new ERR_INVALID_OPT_VALUE(name, hwm);
        }
        return Math.floor(hwm);
      }
      return state.objectMode ? 16 : 16 * 1024;
    }
    module2.exports = {
      getHighWaterMark
    };
  }
});

// ../../../node_modules/archiver/node_modules/readable-stream/lib/_stream_writable.js
var require_stream_writable5 = __commonJS({
  "../../../node_modules/archiver/node_modules/readable-stream/lib/_stream_writable.js"(exports2, module2) {
    "use strict";
    module2.exports = Writable;
    function CorkedRequest(state) {
      var _this = this;
      this.next = null;
      this.entry = null;
      this.finish = function() {
        onCorkedFinish(_this, state);
      };
    }
    var Duplex;
    Writable.WritableState = WritableState;
    var internalUtil = {
      deprecate: require_node()
    };
    var Stream = require_stream5();
    var Buffer2 = require("buffer").Buffer;
    var OurUint8Array = (typeof global !== "undefined" ? global : typeof window !== "undefined" ? window : typeof self !== "undefined" ? self : {}).Uint8Array || function() {
    };
    function _uint8ArrayToBuffer(chunk) {
      return Buffer2.from(chunk);
    }
    function _isUint8Array(obj2) {
      return Buffer2.isBuffer(obj2) || obj2 instanceof OurUint8Array;
    }
    var destroyImpl = require_destroy5();
    var _require = require_state2();
    var getHighWaterMark = _require.getHighWaterMark;
    var _require$codes = require_errors2().codes;
    var ERR_INVALID_ARG_TYPE = _require$codes.ERR_INVALID_ARG_TYPE;
    var ERR_METHOD_NOT_IMPLEMENTED = _require$codes.ERR_METHOD_NOT_IMPLEMENTED;
    var ERR_MULTIPLE_CALLBACK = _require$codes.ERR_MULTIPLE_CALLBACK;
    var ERR_STREAM_CANNOT_PIPE = _require$codes.ERR_STREAM_CANNOT_PIPE;
    var ERR_STREAM_DESTROYED = _require$codes.ERR_STREAM_DESTROYED;
    var ERR_STREAM_NULL_VALUES = _require$codes.ERR_STREAM_NULL_VALUES;
    var ERR_STREAM_WRITE_AFTER_END = _require$codes.ERR_STREAM_WRITE_AFTER_END;
    var ERR_UNKNOWN_ENCODING = _require$codes.ERR_UNKNOWN_ENCODING;
    var errorOrDestroy = destroyImpl.errorOrDestroy;
    require_inherits()(Writable, Stream);
    function nop() {
    }
    function WritableState(options, stream, isDuplex) {
      Duplex = Duplex || require_stream_duplex5();
      options = options || {};
      if (typeof isDuplex !== "boolean")
        isDuplex = stream instanceof Duplex;
      this.objectMode = !!options.objectMode;
      if (isDuplex)
        this.objectMode = this.objectMode || !!options.writableObjectMode;
      this.highWaterMark = getHighWaterMark(this, options, "writableHighWaterMark", isDuplex);
      this.finalCalled = false;
      this.needDrain = false;
      this.ending = false;
      this.ended = false;
      this.finished = false;
      this.destroyed = false;
      var noDecode = options.decodeStrings === false;
      this.decodeStrings = !noDecode;
      this.defaultEncoding = options.defaultEncoding || "utf8";
      this.length = 0;
      this.writing = false;
      this.corked = 0;
      this.sync = true;
      this.bufferProcessing = false;
      this.onwrite = function(er) {
        onwrite(stream, er);
      };
      this.writecb = null;
      this.writelen = 0;
      this.bufferedRequest = null;
      this.lastBufferedRequest = null;
      this.pendingcb = 0;
      this.prefinished = false;
      this.errorEmitted = false;
      this.emitClose = options.emitClose !== false;
      this.autoDestroy = !!options.autoDestroy;
      this.bufferedRequestCount = 0;
      this.corkedRequestsFree = new CorkedRequest(this);
    }
    WritableState.prototype.getBuffer = function getBuffer() {
      var current = this.bufferedRequest;
      var out = [];
      while (current) {
        out.push(current);
        current = current.next;
      }
      return out;
    };
    (function() {
      try {
        Object.defineProperty(WritableState.prototype, "buffer", {
          get: internalUtil.deprecate(function writableStateBufferGetter() {
            return this.getBuffer();
          }, "_writableState.buffer is deprecated. Use _writableState.getBuffer instead.", "DEP0003")
        });
      } catch (_2) {
      }
    })();
    var realHasInstance;
    if (typeof Symbol === "function" && Symbol.hasInstance && typeof Function.prototype[Symbol.hasInstance] === "function") {
      realHasInstance = Function.prototype[Symbol.hasInstance];
      Object.defineProperty(Writable, Symbol.hasInstance, {
        value: function value(object) {
          if (realHasInstance.call(this, object))
            return true;
          if (this !== Writable)
            return false;
          return object && object._writableState instanceof WritableState;
        }
      });
    } else {
      realHasInstance = function realHasInstance2(object) {
        return object instanceof this;
      };
    }
    function Writable(options) {
      Duplex = Duplex || require_stream_duplex5();
      var isDuplex = this instanceof Duplex;
      if (!isDuplex && !realHasInstance.call(Writable, this))
        return new Writable(options);
      this._writableState = new WritableState(options, this, isDuplex);
      this.writable = true;
      if (options) {
        if (typeof options.write === "function")
          this._write = options.write;
        if (typeof options.writev === "function")
          this._writev = options.writev;
        if (typeof options.destroy === "function")
          this._destroy = options.destroy;
        if (typeof options.final === "function")
          this._final = options.final;
      }
      Stream.call(this);
    }
    Writable.prototype.pipe = function() {
      errorOrDestroy(this, new ERR_STREAM_CANNOT_PIPE());
    };
    function writeAfterEnd(stream, cb) {
      var er = new ERR_STREAM_WRITE_AFTER_END();
      errorOrDestroy(stream, er);
      process.nextTick(cb, er);
    }
    function validChunk(stream, state, chunk, cb) {
      var er;
      if (chunk === null) {
        er = new ERR_STREAM_NULL_VALUES();
      } else if (typeof chunk !== "string" && !state.objectMode) {
        er = new ERR_INVALID_ARG_TYPE("chunk", ["string", "Buffer"], chunk);
      }
      if (er) {
        errorOrDestroy(stream, er);
        process.nextTick(cb, er);
        return false;
      }
      return true;
    }
    Writable.prototype.write = function(chunk, encoding, cb) {
      var state = this._writableState;
      var ret2 = false;
      var isBuf = !state.objectMode && _isUint8Array(chunk);
      if (isBuf && !Buffer2.isBuffer(chunk)) {
        chunk = _uint8ArrayToBuffer(chunk);
      }
      if (typeof encoding === "function") {
        cb = encoding;
        encoding = null;
      }
      if (isBuf)
        encoding = "buffer";
      else if (!encoding)
        encoding = state.defaultEncoding;
      if (typeof cb !== "function")
        cb = nop;
      if (state.ending)
        writeAfterEnd(this, cb);
      else if (isBuf || validChunk(this, state, chunk, cb)) {
        state.pendingcb++;
        ret2 = writeOrBuffer(this, state, isBuf, chunk, encoding, cb);
      }
      return ret2;
    };
    Writable.prototype.cork = function() {
      this._writableState.corked++;
    };
    Writable.prototype.uncork = function() {
      var state = this._writableState;
      if (state.corked) {
        state.corked--;
        if (!state.writing && !state.corked && !state.bufferProcessing && state.bufferedRequest)
          clearBuffer(this, state);
      }
    };
    Writable.prototype.setDefaultEncoding = function setDefaultEncoding(encoding) {
      if (typeof encoding === "string")
        encoding = encoding.toLowerCase();
      if (!(["hex", "utf8", "utf-8", "ascii", "binary", "base64", "ucs2", "ucs-2", "utf16le", "utf-16le", "raw"].indexOf((encoding + "").toLowerCase()) > -1))
        throw new ERR_UNKNOWN_ENCODING(encoding);
      this._writableState.defaultEncoding = encoding;
      return this;
    };
    Object.defineProperty(Writable.prototype, "writableBuffer", {
      // making it explicit this property is not enumerable
      // because otherwise some prototype manipulation in
      // userland will fail
      enumerable: false,
      get: function get() {
        return this._writableState && this._writableState.getBuffer();
      }
    });
    function decodeChunk(state, chunk, encoding) {
      if (!state.objectMode && state.decodeStrings !== false && typeof chunk === "string") {
        chunk = Buffer2.from(chunk, encoding);
      }
      return chunk;
    }
    Object.defineProperty(Writable.prototype, "writableHighWaterMark", {
      // making it explicit this property is not enumerable
      // because otherwise some prototype manipulation in
      // userland will fail
      enumerable: false,
      get: function get() {
        return this._writableState.highWaterMark;
      }
    });
    function writeOrBuffer(stream, state, isBuf, chunk, encoding, cb) {
      if (!isBuf) {
        var newChunk = decodeChunk(state, chunk, encoding);
        if (chunk !== newChunk) {
          isBuf = true;
          encoding = "buffer";
          chunk = newChunk;
        }
      }
      var len = state.objectMode ? 1 : chunk.length;
      state.length += len;
      var ret2 = state.length < state.highWaterMark;
      if (!ret2)
        state.needDrain = true;
      if (state.writing || state.corked) {
        var last = state.lastBufferedRequest;
        state.lastBufferedRequest = {
          chunk,
          encoding,
          isBuf,
          callback: cb,
          next: null
        };
        if (last) {
          last.next = state.lastBufferedRequest;
        } else {
          state.bufferedRequest = state.lastBufferedRequest;
        }
        state.bufferedRequestCount += 1;
      } else {
        doWrite(stream, state, false, len, chunk, encoding, cb);
      }
      return ret2;
    }
    function doWrite(stream, state, writev, len, chunk, encoding, cb) {
      state.writelen = len;
      state.writecb = cb;
      state.writing = true;
      state.sync = true;
      if (state.destroyed)
        state.onwrite(new ERR_STREAM_DESTROYED("write"));
      else if (writev)
        stream._writev(chunk, state.onwrite);
      else
        stream._write(chunk, encoding, state.onwrite);
      state.sync = false;
    }
    function onwriteError(stream, state, sync, er, cb) {
      --state.pendingcb;
      if (sync) {
        process.nextTick(cb, er);
        process.nextTick(finishMaybe, stream, state);
        stream._writableState.errorEmitted = true;
        errorOrDestroy(stream, er);
      } else {
        cb(er);
        stream._writableState.errorEmitted = true;
        errorOrDestroy(stream, er);
        finishMaybe(stream, state);
      }
    }
    function onwriteStateUpdate(state) {
      state.writing = false;
      state.writecb = null;
      state.length -= state.writelen;
      state.writelen = 0;
    }
    function onwrite(stream, er) {
      var state = stream._writableState;
      var sync = state.sync;
      var cb = state.writecb;
      if (typeof cb !== "function")
        throw new ERR_MULTIPLE_CALLBACK();
      onwriteStateUpdate(state);
      if (er)
        onwriteError(stream, state, sync, er, cb);
      else {
        var finished = needFinish(state) || stream.destroyed;
        if (!finished && !state.corked && !state.bufferProcessing && state.bufferedRequest) {
          clearBuffer(stream, state);
        }
        if (sync) {
          process.nextTick(afterWrite, stream, state, finished, cb);
        } else {
          afterWrite(stream, state, finished, cb);
        }
      }
    }
    function afterWrite(stream, state, finished, cb) {
      if (!finished)
        onwriteDrain(stream, state);
      state.pendingcb--;
      cb();
      finishMaybe(stream, state);
    }
    function onwriteDrain(stream, state) {
      if (state.length === 0 && state.needDrain) {
        state.needDrain = false;
        stream.emit("drain");
      }
    }
    function clearBuffer(stream, state) {
      state.bufferProcessing = true;
      var entry = state.bufferedRequest;
      if (stream._writev && entry && entry.next) {
        var l2 = state.bufferedRequestCount;
        var buffer = new Array(l2);
        var holder = state.corkedRequestsFree;
        holder.entry = entry;
        var count = 0;
        var allBuffers = true;
        while (entry) {
          buffer[count] = entry;
          if (!entry.isBuf)
            allBuffers = false;
          entry = entry.next;
          count += 1;
        }
        buffer.allBuffers = allBuffers;
        doWrite(stream, state, true, state.length, buffer, "", holder.finish);
        state.pendingcb++;
        state.lastBufferedRequest = null;
        if (holder.next) {
          state.corkedRequestsFree = holder.next;
          holder.next = null;
        } else {
          state.corkedRequestsFree = new CorkedRequest(state);
        }
        state.bufferedRequestCount = 0;
      } else {
        while (entry) {
          var chunk = entry.chunk;
          var encoding = entry.encoding;
          var cb = entry.callback;
          var len = state.objectMode ? 1 : chunk.length;
          doWrite(stream, state, false, len, chunk, encoding, cb);
          entry = entry.next;
          state.bufferedRequestCount--;
          if (state.writing) {
            break;
          }
        }
        if (entry === null)
          state.lastBufferedRequest = null;
      }
      state.bufferedRequest = entry;
      state.bufferProcessing = false;
    }
    Writable.prototype._write = function(chunk, encoding, cb) {
      cb(new ERR_METHOD_NOT_IMPLEMENTED("_write()"));
    };
    Writable.prototype._writev = null;
    Writable.prototype.end = function(chunk, encoding, cb) {
      var state = this._writableState;
      if (typeof chunk === "function") {
        cb = chunk;
        chunk = null;
        encoding = null;
      } else if (typeof encoding === "function") {
        cb = encoding;
        encoding = null;
      }
      if (chunk !== null && chunk !== void 0)
        this.write(chunk, encoding);
      if (state.corked) {
        state.corked = 1;
        this.uncork();
      }
      if (!state.ending)
        endWritable(this, state, cb);
      return this;
    };
    Object.defineProperty(Writable.prototype, "writableLength", {
      // making it explicit this property is not enumerable
      // because otherwise some prototype manipulation in
      // userland will fail
      enumerable: false,
      get: function get() {
        return this._writableState.length;
      }
    });
    function needFinish(state) {
      return state.ending && state.length === 0 && state.bufferedRequest === null && !state.finished && !state.writing;
    }
    function callFinal(stream, state) {
      stream._final(function(err) {
        state.pendingcb--;
        if (err) {
          errorOrDestroy(stream, err);
        }
        state.prefinished = true;
        stream.emit("prefinish");
        finishMaybe(stream, state);
      });
    }
    function prefinish(stream, state) {
      if (!state.prefinished && !state.finalCalled) {
        if (typeof stream._final === "function" && !state.destroyed) {
          state.pendingcb++;
          state.finalCalled = true;
          process.nextTick(callFinal, stream, state);
        } else {
          state.prefinished = true;
          stream.emit("prefinish");
        }
      }
    }
    function finishMaybe(stream, state) {
      var need = needFinish(state);
      if (need) {
        prefinish(stream, state);
        if (state.pendingcb === 0) {
          state.finished = true;
          stream.emit("finish");
          if (state.autoDestroy) {
            var rState = stream._readableState;
            if (!rState || rState.autoDestroy && rState.endEmitted) {
              stream.destroy();
            }
          }
        }
      }
      return need;
    }
    function endWritable(stream, state, cb) {
      state.ending = true;
      finishMaybe(stream, state);
      if (cb) {
        if (state.finished)
          process.nextTick(cb);
        else
          stream.once("finish", cb);
      }
      state.ended = true;
      stream.writable = false;
    }
    function onCorkedFinish(corkReq, state, err) {
      var entry = corkReq.entry;
      corkReq.entry = null;
      while (entry) {
        var cb = entry.callback;
        state.pendingcb--;
        cb(err);
        entry = entry.next;
      }
      state.corkedRequestsFree.next = corkReq;
    }
    Object.defineProperty(Writable.prototype, "destroyed", {
      // making it explicit this property is not enumerable
      // because otherwise some prototype manipulation in
      // userland will fail
      enumerable: false,
      get: function get() {
        if (this._writableState === void 0) {
          return false;
        }
        return this._writableState.destroyed;
      },
      set: function set(value) {
        if (!this._writableState) {
          return;
        }
        this._writableState.destroyed = value;
      }
    });
    Writable.prototype.destroy = destroyImpl.destroy;
    Writable.prototype._undestroy = destroyImpl.undestroy;
    Writable.prototype._destroy = function(err, cb) {
      cb(err);
    };
  }
});

// ../../../node_modules/archiver/node_modules/readable-stream/lib/_stream_duplex.js
var require_stream_duplex5 = __commonJS({
  "../../../node_modules/archiver/node_modules/readable-stream/lib/_stream_duplex.js"(exports2, module2) {
    "use strict";
    var objectKeys = Object.keys || function(obj2) {
      var keys2 = [];
      for (var key in obj2)
        keys2.push(key);
      return keys2;
    };
    module2.exports = Duplex;
    var Readable = require_stream_readable5();
    var Writable = require_stream_writable5();
    require_inherits()(Duplex, Readable);
    {
      keys = objectKeys(Writable.prototype);
      for (v = 0; v < keys.length; v++) {
        method = keys[v];
        if (!Duplex.prototype[method])
          Duplex.prototype[method] = Writable.prototype[method];
      }
    }
    var keys;
    var method;
    var v;
    function Duplex(options) {
      if (!(this instanceof Duplex))
        return new Duplex(options);
      Readable.call(this, options);
      Writable.call(this, options);
      this.allowHalfOpen = true;
      if (options) {
        if (options.readable === false)
          this.readable = false;
        if (options.writable === false)
          this.writable = false;
        if (options.allowHalfOpen === false) {
          this.allowHalfOpen = false;
          this.once("end", onend);
        }
      }
    }
    Object.defineProperty(Duplex.prototype, "writableHighWaterMark", {
      // making it explicit this property is not enumerable
      // because otherwise some prototype manipulation in
      // userland will fail
      enumerable: false,
      get: function get() {
        return this._writableState.highWaterMark;
      }
    });
    Object.defineProperty(Duplex.prototype, "writableBuffer", {
      // making it explicit this property is not enumerable
      // because otherwise some prototype manipulation in
      // userland will fail
      enumerable: false,
      get: function get() {
        return this._writableState && this._writableState.getBuffer();
      }
    });
    Object.defineProperty(Duplex.prototype, "writableLength", {
      // making it explicit this property is not enumerable
      // because otherwise some prototype manipulation in
      // userland will fail
      enumerable: false,
      get: function get() {
        return this._writableState.length;
      }
    });
    function onend() {
      if (this._writableState.ended)
        return;
      process.nextTick(onEndNT, this);
    }
    function onEndNT(self2) {
      self2.end();
    }
    Object.defineProperty(Duplex.prototype, "destroyed", {
      // making it explicit this property is not enumerable
      // because otherwise some prototype manipulation in
      // userland will fail
      enumerable: false,
      get: function get() {
        if (this._readableState === void 0 || this._writableState === void 0) {
          return false;
        }
        return this._readableState.destroyed && this._writableState.destroyed;
      },
      set: function set(value) {
        if (this._readableState === void 0 || this._writableState === void 0) {
          return;
        }
        this._readableState.destroyed = value;
        this._writableState.destroyed = value;
      }
    });
  }
});

// ../../../node_modules/archiver/node_modules/string_decoder/lib/string_decoder.js
var require_string_decoder5 = __commonJS({
  "../../../node_modules/archiver/node_modules/string_decoder/lib/string_decoder.js"(exports2) {
    "use strict";
    var Buffer2 = require_safe_buffer2().Buffer;
    var isEncoding = Buffer2.isEncoding || function(encoding) {
      encoding = "" + encoding;
      switch (encoding && encoding.toLowerCase()) {
        case "hex":
        case "utf8":
        case "utf-8":
        case "ascii":
        case "binary":
        case "base64":
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
        case "raw":
          return true;
        default:
          return false;
      }
    };
    function _normalizeEncoding(enc) {
      if (!enc)
        return "utf8";
      var retried;
      while (true) {
        switch (enc) {
          case "utf8":
          case "utf-8":
            return "utf8";
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
            return "utf16le";
          case "latin1":
          case "binary":
            return "latin1";
          case "base64":
          case "ascii":
          case "hex":
            return enc;
          default:
            if (retried)
              return;
            enc = ("" + enc).toLowerCase();
            retried = true;
        }
      }
    }
    function normalizeEncoding(enc) {
      var nenc = _normalizeEncoding(enc);
      if (typeof nenc !== "string" && (Buffer2.isEncoding === isEncoding || !isEncoding(enc)))
        throw new Error("Unknown encoding: " + enc);
      return nenc || enc;
    }
    exports2.StringDecoder = StringDecoder;
    function StringDecoder(encoding) {
      this.encoding = normalizeEncoding(encoding);
      var nb;
      switch (this.encoding) {
        case "utf16le":
          this.text = utf16Text;
          this.end = utf16End;
          nb = 4;
          break;
        case "utf8":
          this.fillLast = utf8FillLast;
          nb = 4;
          break;
        case "base64":
          this.text = base64Text;
          this.end = base64End;
          nb = 3;
          break;
        default:
          this.write = simpleWrite;
          this.end = simpleEnd;
          return;
      }
      this.lastNeed = 0;
      this.lastTotal = 0;
      this.lastChar = Buffer2.allocUnsafe(nb);
    }
    StringDecoder.prototype.write = function(buf) {
      if (buf.length === 0)
        return "";
      var r;
      var i;
      if (this.lastNeed) {
        r = this.fillLast(buf);
        if (r === void 0)
          return "";
        i = this.lastNeed;
        this.lastNeed = 0;
      } else {
        i = 0;
      }
      if (i < buf.length)
        return r ? r + this.text(buf, i) : this.text(buf, i);
      return r || "";
    };
    StringDecoder.prototype.end = utf8End;
    StringDecoder.prototype.text = utf8Text;
    StringDecoder.prototype.fillLast = function(buf) {
      if (this.lastNeed <= buf.length) {
        buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, this.lastNeed);
        return this.lastChar.toString(this.encoding, 0, this.lastTotal);
      }
      buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, buf.length);
      this.lastNeed -= buf.length;
    };
    function utf8CheckByte(byte) {
      if (byte <= 127)
        return 0;
      else if (byte >> 5 === 6)
        return 2;
      else if (byte >> 4 === 14)
        return 3;
      else if (byte >> 3 === 30)
        return 4;
      return byte >> 6 === 2 ? -1 : -2;
    }
    function utf8CheckIncomplete(self2, buf, i) {
      var j = buf.length - 1;
      if (j < i)
        return 0;
      var nb = utf8CheckByte(buf[j]);
      if (nb >= 0) {
        if (nb > 0)
          self2.lastNeed = nb - 1;
        return nb;
      }
      if (--j < i || nb === -2)
        return 0;
      nb = utf8CheckByte(buf[j]);
      if (nb >= 0) {
        if (nb > 0)
          self2.lastNeed = nb - 2;
        return nb;
      }
      if (--j < i || nb === -2)
        return 0;
      nb = utf8CheckByte(buf[j]);
      if (nb >= 0) {
        if (nb > 0) {
          if (nb === 2)
            nb = 0;
          else
            self2.lastNeed = nb - 3;
        }
        return nb;
      }
      return 0;
    }
    function utf8CheckExtraBytes(self2, buf, p) {
      if ((buf[0] & 192) !== 128) {
        self2.lastNeed = 0;
        return "\uFFFD";
      }
      if (self2.lastNeed > 1 && buf.length > 1) {
        if ((buf[1] & 192) !== 128) {
          self2.lastNeed = 1;
          return "\uFFFD";
        }
        if (self2.lastNeed > 2 && buf.length > 2) {
          if ((buf[2] & 192) !== 128) {
            self2.lastNeed = 2;
            return "\uFFFD";
          }
        }
      }
    }
    function utf8FillLast(buf) {
      var p = this.lastTotal - this.lastNeed;
      var r = utf8CheckExtraBytes(this, buf, p);
      if (r !== void 0)
        return r;
      if (this.lastNeed <= buf.length) {
        buf.copy(this.lastChar, p, 0, this.lastNeed);
        return this.lastChar.toString(this.encoding, 0, this.lastTotal);
      }
      buf.copy(this.lastChar, p, 0, buf.length);
      this.lastNeed -= buf.length;
    }
    function utf8Text(buf, i) {
      var total = utf8CheckIncomplete(this, buf, i);
      if (!this.lastNeed)
        return buf.toString("utf8", i);
      this.lastTotal = total;
      var end = buf.length - (total - this.lastNeed);
      buf.copy(this.lastChar, 0, end);
      return buf.toString("utf8", i, end);
    }
    function utf8End(buf) {
      var r = buf && buf.length ? this.write(buf) : "";
      if (this.lastNeed)
        return r + "\uFFFD";
      return r;
    }
    function utf16Text(buf, i) {
      if ((buf.length - i) % 2 === 0) {
        var r = buf.toString("utf16le", i);
        if (r) {
          var c = r.charCodeAt(r.length - 1);
          if (c >= 55296 && c <= 56319) {
            this.lastNeed = 2;
            this.lastTotal = 4;
            this.lastChar[0] = buf[buf.length - 2];
            this.lastChar[1] = buf[buf.length - 1];
            return r.slice(0, -1);
          }
        }
        return r;
      }
      this.lastNeed = 1;
      this.lastTotal = 2;
      this.lastChar[0] = buf[buf.length - 1];
      return buf.toString("utf16le", i, buf.length - 1);
    }
    function utf16End(buf) {
      var r = buf && buf.length ? this.write(buf) : "";
      if (this.lastNeed) {
        var end = this.lastTotal - this.lastNeed;
        return r + this.lastChar.toString("utf16le", 0, end);
      }
      return r;
    }
    function base64Text(buf, i) {
      var n = (buf.length - i) % 3;
      if (n === 0)
        return buf.toString("base64", i);
      this.lastNeed = 3 - n;
      this.lastTotal = 3;
      if (n === 1) {
        this.lastChar[0] = buf[buf.length - 1];
      } else {
        this.lastChar[0] = buf[buf.length - 2];
        this.lastChar[1] = buf[buf.length - 1];
      }
      return buf.toString("base64", i, buf.length - n);
    }
    function base64End(buf) {
      var r = buf && buf.length ? this.write(buf) : "";
      if (this.lastNeed)
        return r + this.lastChar.toString("base64", 0, 3 - this.lastNeed);
      return r;
    }
    function simpleWrite(buf) {
      return buf.toString(this.encoding);
    }
    function simpleEnd(buf) {
      return buf && buf.length ? this.write(buf) : "";
    }
  }
});

// ../../../node_modules/archiver/node_modules/readable-stream/lib/internal/streams/end-of-stream.js
var require_end_of_stream2 = __commonJS({
  "../../../node_modules/archiver/node_modules/readable-stream/lib/internal/streams/end-of-stream.js"(exports2, module2) {
    "use strict";
    var ERR_STREAM_PREMATURE_CLOSE = require_errors2().codes.ERR_STREAM_PREMATURE_CLOSE;
    function once(callback) {
      var called = false;
      return function() {
        if (called)
          return;
        called = true;
        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }
        callback.apply(this, args);
      };
    }
    function noop() {
    }
    function isRequest(stream) {
      return stream.setHeader && typeof stream.abort === "function";
    }
    function eos(stream, opts, callback) {
      if (typeof opts === "function")
        return eos(stream, null, opts);
      if (!opts)
        opts = {};
      callback = once(callback || noop);
      var readable = opts.readable || opts.readable !== false && stream.readable;
      var writable = opts.writable || opts.writable !== false && stream.writable;
      var onlegacyfinish = function onlegacyfinish2() {
        if (!stream.writable)
          onfinish();
      };
      var writableEnded = stream._writableState && stream._writableState.finished;
      var onfinish = function onfinish2() {
        writable = false;
        writableEnded = true;
        if (!readable)
          callback.call(stream);
      };
      var readableEnded = stream._readableState && stream._readableState.endEmitted;
      var onend = function onend2() {
        readable = false;
        readableEnded = true;
        if (!writable)
          callback.call(stream);
      };
      var onerror = function onerror2(err) {
        callback.call(stream, err);
      };
      var onclose = function onclose2() {
        var err;
        if (readable && !readableEnded) {
          if (!stream._readableState || !stream._readableState.ended)
            err = new ERR_STREAM_PREMATURE_CLOSE();
          return callback.call(stream, err);
        }
        if (writable && !writableEnded) {
          if (!stream._writableState || !stream._writableState.ended)
            err = new ERR_STREAM_PREMATURE_CLOSE();
          return callback.call(stream, err);
        }
      };
      var onrequest = function onrequest2() {
        stream.req.on("finish", onfinish);
      };
      if (isRequest(stream)) {
        stream.on("complete", onfinish);
        stream.on("abort", onclose);
        if (stream.req)
          onrequest();
        else
          stream.on("request", onrequest);
      } else if (writable && !stream._writableState) {
        stream.on("end", onlegacyfinish);
        stream.on("close", onlegacyfinish);
      }
      stream.on("end", onend);
      stream.on("finish", onfinish);
      if (opts.error !== false)
        stream.on("error", onerror);
      stream.on("close", onclose);
      return function() {
        stream.removeListener("complete", onfinish);
        stream.removeListener("abort", onclose);
        stream.removeListener("request", onrequest);
        if (stream.req)
          stream.req.removeListener("finish", onfinish);
        stream.removeListener("end", onlegacyfinish);
        stream.removeListener("close", onlegacyfinish);
        stream.removeListener("finish", onfinish);
        stream.removeListener("end", onend);
        stream.removeListener("error", onerror);
        stream.removeListener("close", onclose);
      };
    }
    module2.exports = eos;
  }
});

// ../../../node_modules/archiver/node_modules/readable-stream/lib/internal/streams/async_iterator.js
var require_async_iterator2 = __commonJS({
  "../../../node_modules/archiver/node_modules/readable-stream/lib/internal/streams/async_iterator.js"(exports2, module2) {
    "use strict";
    var _Object$setPrototypeO;
    function _defineProperty(obj2, key, value) {
      key = _toPropertyKey(key);
      if (key in obj2) {
        Object.defineProperty(obj2, key, { value, enumerable: true, configurable: true, writable: true });
      } else {
        obj2[key] = value;
      }
      return obj2;
    }
    function _toPropertyKey(arg) {
      var key = _toPrimitive(arg, "string");
      return typeof key === "symbol" ? key : String(key);
    }
    function _toPrimitive(input, hint) {
      if (typeof input !== "object" || input === null)
        return input;
      var prim = input[Symbol.toPrimitive];
      if (prim !== void 0) {
        var res = prim.call(input, hint || "default");
        if (typeof res !== "object")
          return res;
        throw new TypeError("@@toPrimitive must return a primitive value.");
      }
      return (hint === "string" ? String : Number)(input);
    }
    var finished = require_end_of_stream2();
    var kLastResolve = Symbol("lastResolve");
    var kLastReject = Symbol("lastReject");
    var kError = Symbol("error");
    var kEnded = Symbol("ended");
    var kLastPromise = Symbol("lastPromise");
    var kHandlePromise = Symbol("handlePromise");
    var kStream = Symbol("stream");
    function createIterResult(value, done) {
      return {
        value,
        done
      };
    }
    function readAndResolve(iter) {
      var resolve = iter[kLastResolve];
      if (resolve !== null) {
        var data = iter[kStream].read();
        if (data !== null) {
          iter[kLastPromise] = null;
          iter[kLastResolve] = null;
          iter[kLastReject] = null;
          resolve(createIterResult(data, false));
        }
      }
    }
    function onReadable(iter) {
      process.nextTick(readAndResolve, iter);
    }
    function wrapForNext(lastPromise, iter) {
      return function(resolve, reject) {
        lastPromise.then(function() {
          if (iter[kEnded]) {
            resolve(createIterResult(void 0, true));
            return;
          }
          iter[kHandlePromise](resolve, reject);
        }, reject);
      };
    }
    var AsyncIteratorPrototype = Object.getPrototypeOf(function() {
    });
    var ReadableStreamAsyncIteratorPrototype = Object.setPrototypeOf((_Object$setPrototypeO = {
      get stream() {
        return this[kStream];
      },
      next: function next() {
        var _this = this;
        var error = this[kError];
        if (error !== null) {
          return Promise.reject(error);
        }
        if (this[kEnded]) {
          return Promise.resolve(createIterResult(void 0, true));
        }
        if (this[kStream].destroyed) {
          return new Promise(function(resolve, reject) {
            process.nextTick(function() {
              if (_this[kError]) {
                reject(_this[kError]);
              } else {
                resolve(createIterResult(void 0, true));
              }
            });
          });
        }
        var lastPromise = this[kLastPromise];
        var promise;
        if (lastPromise) {
          promise = new Promise(wrapForNext(lastPromise, this));
        } else {
          var data = this[kStream].read();
          if (data !== null) {
            return Promise.resolve(createIterResult(data, false));
          }
          promise = new Promise(this[kHandlePromise]);
        }
        this[kLastPromise] = promise;
        return promise;
      }
    }, _defineProperty(_Object$setPrototypeO, Symbol.asyncIterator, function() {
      return this;
    }), _defineProperty(_Object$setPrototypeO, "return", function _return() {
      var _this2 = this;
      return new Promise(function(resolve, reject) {
        _this2[kStream].destroy(null, function(err) {
          if (err) {
            reject(err);
            return;
          }
          resolve(createIterResult(void 0, true));
        });
      });
    }), _Object$setPrototypeO), AsyncIteratorPrototype);
    var createReadableStreamAsyncIterator = function createReadableStreamAsyncIterator2(stream) {
      var _Object$create;
      var iterator = Object.create(ReadableStreamAsyncIteratorPrototype, (_Object$create = {}, _defineProperty(_Object$create, kStream, {
        value: stream,
        writable: true
      }), _defineProperty(_Object$create, kLastResolve, {
        value: null,
        writable: true
      }), _defineProperty(_Object$create, kLastReject, {
        value: null,
        writable: true
      }), _defineProperty(_Object$create, kError, {
        value: null,
        writable: true
      }), _defineProperty(_Object$create, kEnded, {
        value: stream._readableState.endEmitted,
        writable: true
      }), _defineProperty(_Object$create, kHandlePromise, {
        value: function value(resolve, reject) {
          var data = iterator[kStream].read();
          if (data) {
            iterator[kLastPromise] = null;
            iterator[kLastResolve] = null;
            iterator[kLastReject] = null;
            resolve(createIterResult(data, false));
          } else {
            iterator[kLastResolve] = resolve;
            iterator[kLastReject] = reject;
          }
        },
        writable: true
      }), _Object$create));
      iterator[kLastPromise] = null;
      finished(stream, function(err) {
        if (err && err.code !== "ERR_STREAM_PREMATURE_CLOSE") {
          var reject = iterator[kLastReject];
          if (reject !== null) {
            iterator[kLastPromise] = null;
            iterator[kLastResolve] = null;
            iterator[kLastReject] = null;
            reject(err);
          }
          iterator[kError] = err;
          return;
        }
        var resolve = iterator[kLastResolve];
        if (resolve !== null) {
          iterator[kLastPromise] = null;
          iterator[kLastResolve] = null;
          iterator[kLastReject] = null;
          resolve(createIterResult(void 0, true));
        }
        iterator[kEnded] = true;
      });
      stream.on("readable", onReadable.bind(null, iterator));
      return iterator;
    };
    module2.exports = createReadableStreamAsyncIterator;
  }
});

// ../../../node_modules/archiver/node_modules/readable-stream/lib/internal/streams/from.js
var require_from2 = __commonJS({
  "../../../node_modules/archiver/node_modules/readable-stream/lib/internal/streams/from.js"(exports2, module2) {
    "use strict";
    function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {
      try {
        var info = gen[key](arg);
        var value = info.value;
      } catch (error) {
        reject(error);
        return;
      }
      if (info.done) {
        resolve(value);
      } else {
        Promise.resolve(value).then(_next, _throw);
      }
    }
    function _asyncToGenerator(fn) {
      return function() {
        var self2 = this, args = arguments;
        return new Promise(function(resolve, reject) {
          var gen = fn.apply(self2, args);
          function _next(value) {
            asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value);
          }
          function _throw(err) {
            asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err);
          }
          _next(void 0);
        });
      };
    }
    function ownKeys(object, enumerableOnly) {
      var keys = Object.keys(object);
      if (Object.getOwnPropertySymbols) {
        var symbols = Object.getOwnPropertySymbols(object);
        enumerableOnly && (symbols = symbols.filter(function(sym) {
          return Object.getOwnPropertyDescriptor(object, sym).enumerable;
        })), keys.push.apply(keys, symbols);
      }
      return keys;
    }
    function _objectSpread(target) {
      for (var i = 1; i < arguments.length; i++) {
        var source = null != arguments[i] ? arguments[i] : {};
        i % 2 ? ownKeys(Object(source), true).forEach(function(key) {
          _defineProperty(target, key, source[key]);
        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function(key) {
          Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
        });
      }
      return target;
    }
    function _defineProperty(obj2, key, value) {
      key = _toPropertyKey(key);
      if (key in obj2) {
        Object.defineProperty(obj2, key, { value, enumerable: true, configurable: true, writable: true });
      } else {
        obj2[key] = value;
      }
      return obj2;
    }
    function _toPropertyKey(arg) {
      var key = _toPrimitive(arg, "string");
      return typeof key === "symbol" ? key : String(key);
    }
    function _toPrimitive(input, hint) {
      if (typeof input !== "object" || input === null)
        return input;
      var prim = input[Symbol.toPrimitive];
      if (prim !== void 0) {
        var res = prim.call(input, hint || "default");
        if (typeof res !== "object")
          return res;
        throw new TypeError("@@toPrimitive must return a primitive value.");
      }
      return (hint === "string" ? String : Number)(input);
    }
    var ERR_INVALID_ARG_TYPE = require_errors2().codes.ERR_INVALID_ARG_TYPE;
    function from(Readable, iterable, opts) {
      var iterator;
      if (iterable && typeof iterable.next === "function") {
        iterator = iterable;
      } else if (iterable && iterable[Symbol.asyncIterator])
        iterator = iterable[Symbol.asyncIterator]();
      else if (iterable && iterable[Symbol.iterator])
        iterator = iterable[Symbol.iterator]();
      else
        throw new ERR_INVALID_ARG_TYPE("iterable", ["Iterable"], iterable);
      var readable = new Readable(_objectSpread({
        objectMode: true
      }, opts));
      var reading = false;
      readable._read = function() {
        if (!reading) {
          reading = true;
          next();
        }
      };
      function next() {
        return _next2.apply(this, arguments);
      }
      function _next2() {
        _next2 = _asyncToGenerator(function* () {
          try {
            var _yield$iterator$next = yield iterator.next(), value = _yield$iterator$next.value, done = _yield$iterator$next.done;
            if (done) {
              readable.push(null);
            } else if (readable.push(yield value)) {
              next();
            } else {
              reading = false;
            }
          } catch (err) {
            readable.destroy(err);
          }
        });
        return _next2.apply(this, arguments);
      }
      return readable;
    }
    module2.exports = from;
  }
});

// ../../../node_modules/archiver/node_modules/readable-stream/lib/_stream_readable.js
var require_stream_readable5 = __commonJS({
  "../../../node_modules/archiver/node_modules/readable-stream/lib/_stream_readable.js"(exports2, module2) {
    "use strict";
    module2.exports = Readable;
    var Duplex;
    Readable.ReadableState = ReadableState;
    var EE = require("events").EventEmitter;
    var EElistenerCount = function EElistenerCount2(emitter, type) {
      return emitter.listeners(type).length;
    };
    var Stream = require_stream5();
    var Buffer2 = require("buffer").Buffer;
    var OurUint8Array = (typeof global !== "undefined" ? global : typeof window !== "undefined" ? window : typeof self !== "undefined" ? self : {}).Uint8Array || function() {
    };
    function _uint8ArrayToBuffer(chunk) {
      return Buffer2.from(chunk);
    }
    function _isUint8Array(obj2) {
      return Buffer2.isBuffer(obj2) || obj2 instanceof OurUint8Array;
    }
    var debugUtil = require("util");
    var debug;
    if (debugUtil && debugUtil.debuglog) {
      debug = debugUtil.debuglog("stream");
    } else {
      debug = function debug2() {
      };
    }
    var BufferList = require_buffer_list2();
    var destroyImpl = require_destroy5();
    var _require = require_state2();
    var getHighWaterMark = _require.getHighWaterMark;
    var _require$codes = require_errors2().codes;
    var ERR_INVALID_ARG_TYPE = _require$codes.ERR_INVALID_ARG_TYPE;
    var ERR_STREAM_PUSH_AFTER_EOF = _require$codes.ERR_STREAM_PUSH_AFTER_EOF;
    var ERR_METHOD_NOT_IMPLEMENTED = _require$codes.ERR_METHOD_NOT_IMPLEMENTED;
    var ERR_STREAM_UNSHIFT_AFTER_END_EVENT = _require$codes.ERR_STREAM_UNSHIFT_AFTER_END_EVENT;
    var StringDecoder;
    var createReadableStreamAsyncIterator;
    var from;
    require_inherits()(Readable, Stream);
    var errorOrDestroy = destroyImpl.errorOrDestroy;
    var kProxyEvents = ["error", "close", "destroy", "pause", "resume"];
    function prependListener(emitter, event, fn) {
      if (typeof emitter.prependListener === "function")
        return emitter.prependListener(event, fn);
      if (!emitter._events || !emitter._events[event])
        emitter.on(event, fn);
      else if (Array.isArray(emitter._events[event]))
        emitter._events[event].unshift(fn);
      else
        emitter._events[event] = [fn, emitter._events[event]];
    }
    function ReadableState(options, stream, isDuplex) {
      Duplex = Duplex || require_stream_duplex5();
      options = options || {};
      if (typeof isDuplex !== "boolean")
        isDuplex = stream instanceof Duplex;
      this.objectMode = !!options.objectMode;
      if (isDuplex)
        this.objectMode = this.objectMode || !!options.readableObjectMode;
      this.highWaterMark = getHighWaterMark(this, options, "readableHighWaterMark", isDuplex);
      this.buffer = new BufferList();
      this.length = 0;
      this.pipes = null;
      this.pipesCount = 0;
      this.flowing = null;
      this.ended = false;
      this.endEmitted = false;
      this.reading = false;
      this.sync = true;
      this.needReadable = false;
      this.emittedReadable = false;
      this.readableListening = false;
      this.resumeScheduled = false;
      this.paused = true;
      this.emitClose = options.emitClose !== false;
      this.autoDestroy = !!options.autoDestroy;
      this.destroyed = false;
      this.defaultEncoding = options.defaultEncoding || "utf8";
      this.awaitDrain = 0;
      this.readingMore = false;
      this.decoder = null;
      this.encoding = null;
      if (options.encoding) {
        if (!StringDecoder)
          StringDecoder = require_string_decoder5().StringDecoder;
        this.decoder = new StringDecoder(options.encoding);
        this.encoding = options.encoding;
      }
    }
    function Readable(options) {
      Duplex = Duplex || require_stream_duplex5();
      if (!(this instanceof Readable))
        return new Readable(options);
      var isDuplex = this instanceof Duplex;
      this._readableState = new ReadableState(options, this, isDuplex);
      this.readable = true;
      if (options) {
        if (typeof options.read === "function")
          this._read = options.read;
        if (typeof options.destroy === "function")
          this._destroy = options.destroy;
      }
      Stream.call(this);
    }
    Object.defineProperty(Readable.prototype, "destroyed", {
      // making it explicit this property is not enumerable
      // because otherwise some prototype manipulation in
      // userland will fail
      enumerable: false,
      get: function get() {
        if (this._readableState === void 0) {
          return false;
        }
        return this._readableState.destroyed;
      },
      set: function set(value) {
        if (!this._readableState) {
          return;
        }
        this._readableState.destroyed = value;
      }
    });
    Readable.prototype.destroy = destroyImpl.destroy;
    Readable.prototype._undestroy = destroyImpl.undestroy;
    Readable.prototype._destroy = function(err, cb) {
      cb(err);
    };
    Readable.prototype.push = function(chunk, encoding) {
      var state = this._readableState;
      var skipChunkCheck;
      if (!state.objectMode) {
        if (typeof chunk === "string") {
          encoding = encoding || state.defaultEncoding;
          if (encoding !== state.encoding) {
            chunk = Buffer2.from(chunk, encoding);
            encoding = "";
          }
          skipChunkCheck = true;
        }
      } else {
        skipChunkCheck = true;
      }
      return readableAddChunk(this, chunk, encoding, false, skipChunkCheck);
    };
    Readable.prototype.unshift = function(chunk) {
      return readableAddChunk(this, chunk, null, true, false);
    };
    function readableAddChunk(stream, chunk, encoding, addToFront, skipChunkCheck) {
      debug("readableAddChunk", chunk);
      var state = stream._readableState;
      if (chunk === null) {
        state.reading = false;
        onEofChunk(stream, state);
      } else {
        var er;
        if (!skipChunkCheck)
          er = chunkInvalid(state, chunk);
        if (er) {
          errorOrDestroy(stream, er);
        } else if (state.objectMode || chunk && chunk.length > 0) {
          if (typeof chunk !== "string" && !state.objectMode && Object.getPrototypeOf(chunk) !== Buffer2.prototype) {
            chunk = _uint8ArrayToBuffer(chunk);
          }
          if (addToFront) {
            if (state.endEmitted)
              errorOrDestroy(stream, new ERR_STREAM_UNSHIFT_AFTER_END_EVENT());
            else
              addChunk(stream, state, chunk, true);
          } else if (state.ended) {
            errorOrDestroy(stream, new ERR_STREAM_PUSH_AFTER_EOF());
          } else if (state.destroyed) {
            return false;
          } else {
            state.reading = false;
            if (state.decoder && !encoding) {
              chunk = state.decoder.write(chunk);
              if (state.objectMode || chunk.length !== 0)
                addChunk(stream, state, chunk, false);
              else
                maybeReadMore(stream, state);
            } else {
              addChunk(stream, state, chunk, false);
            }
          }
        } else if (!addToFront) {
          state.reading = false;
          maybeReadMore(stream, state);
        }
      }
      return !state.ended && (state.length < state.highWaterMark || state.length === 0);
    }
    function addChunk(stream, state, chunk, addToFront) {
      if (state.flowing && state.length === 0 && !state.sync) {
        state.awaitDrain = 0;
        stream.emit("data", chunk);
      } else {
        state.length += state.objectMode ? 1 : chunk.length;
        if (addToFront)
          state.buffer.unshift(chunk);
        else
          state.buffer.push(chunk);
        if (state.needReadable)
          emitReadable(stream);
      }
      maybeReadMore(stream, state);
    }
    function chunkInvalid(state, chunk) {
      var er;
      if (!_isUint8Array(chunk) && typeof chunk !== "string" && chunk !== void 0 && !state.objectMode) {
        er = new ERR_INVALID_ARG_TYPE("chunk", ["string", "Buffer", "Uint8Array"], chunk);
      }
      return er;
    }
    Readable.prototype.isPaused = function() {
      return this._readableState.flowing === false;
    };
    Readable.prototype.setEncoding = function(enc) {
      if (!StringDecoder)
        StringDecoder = require_string_decoder5().StringDecoder;
      var decoder = new StringDecoder(enc);
      this._readableState.decoder = decoder;
      this._readableState.encoding = this._readableState.decoder.encoding;
      var p = this._readableState.buffer.head;
      var content = "";
      while (p !== null) {
        content += decoder.write(p.data);
        p = p.next;
      }
      this._readableState.buffer.clear();
      if (content !== "")
        this._readableState.buffer.push(content);
      this._readableState.length = content.length;
      return this;
    };
    var MAX_HWM = 1073741824;
    function computeNewHighWaterMark(n) {
      if (n >= MAX_HWM) {
        n = MAX_HWM;
      } else {
        n--;
        n |= n >>> 1;
        n |= n >>> 2;
        n |= n >>> 4;
        n |= n >>> 8;
        n |= n >>> 16;
        n++;
      }
      return n;
    }
    function howMuchToRead(n, state) {
      if (n <= 0 || state.length === 0 && state.ended)
        return 0;
      if (state.objectMode)
        return 1;
      if (n !== n) {
        if (state.flowing && state.length)
          return state.buffer.head.data.length;
        else
          return state.length;
      }
      if (n > state.highWaterMark)
        state.highWaterMark = computeNewHighWaterMark(n);
      if (n <= state.length)
        return n;
      if (!state.ended) {
        state.needReadable = true;
        return 0;
      }
      return state.length;
    }
    Readable.prototype.read = function(n) {
      debug("read", n);
      n = parseInt(n, 10);
      var state = this._readableState;
      var nOrig = n;
      if (n !== 0)
        state.emittedReadable = false;
      if (n === 0 && state.needReadable && ((state.highWaterMark !== 0 ? state.length >= state.highWaterMark : state.length > 0) || state.ended)) {
        debug("read: emitReadable", state.length, state.ended);
        if (state.length === 0 && state.ended)
          endReadable(this);
        else
          emitReadable(this);
        return null;
      }
      n = howMuchToRead(n, state);
      if (n === 0 && state.ended) {
        if (state.length === 0)
          endReadable(this);
        return null;
      }
      var doRead = state.needReadable;
      debug("need readable", doRead);
      if (state.length === 0 || state.length - n < state.highWaterMark) {
        doRead = true;
        debug("length less than watermark", doRead);
      }
      if (state.ended || state.reading) {
        doRead = false;
        debug("reading or ended", doRead);
      } else if (doRead) {
        debug("do read");
        state.reading = true;
        state.sync = true;
        if (state.length === 0)
          state.needReadable = true;
        this._read(state.highWaterMark);
        state.sync = false;
        if (!state.reading)
          n = howMuchToRead(nOrig, state);
      }
      var ret2;
      if (n > 0)
        ret2 = fromList(n, state);
      else
        ret2 = null;
      if (ret2 === null) {
        state.needReadable = state.length <= state.highWaterMark;
        n = 0;
      } else {
        state.length -= n;
        state.awaitDrain = 0;
      }
      if (state.length === 0) {
        if (!state.ended)
          state.needReadable = true;
        if (nOrig !== n && state.ended)
          endReadable(this);
      }
      if (ret2 !== null)
        this.emit("data", ret2);
      return ret2;
    };
    function onEofChunk(stream, state) {
      debug("onEofChunk");
      if (state.ended)
        return;
      if (state.decoder) {
        var chunk = state.decoder.end();
        if (chunk && chunk.length) {
          state.buffer.push(chunk);
          state.length += state.objectMode ? 1 : chunk.length;
        }
      }
      state.ended = true;
      if (state.sync) {
        emitReadable(stream);
      } else {
        state.needReadable = false;
        if (!state.emittedReadable) {
          state.emittedReadable = true;
          emitReadable_(stream);
        }
      }
    }
    function emitReadable(stream) {
      var state = stream._readableState;
      debug("emitReadable", state.needReadable, state.emittedReadable);
      state.needReadable = false;
      if (!state.emittedReadable) {
        debug("emitReadable", state.flowing);
        state.emittedReadable = true;
        process.nextTick(emitReadable_, stream);
      }
    }
    function emitReadable_(stream) {
      var state = stream._readableState;
      debug("emitReadable_", state.destroyed, state.length, state.ended);
      if (!state.destroyed && (state.length || state.ended)) {
        stream.emit("readable");
        state.emittedReadable = false;
      }
      state.needReadable = !state.flowing && !state.ended && state.length <= state.highWaterMark;
      flow(stream);
    }
    function maybeReadMore(stream, state) {
      if (!state.readingMore) {
        state.readingMore = true;
        process.nextTick(maybeReadMore_, stream, state);
      }
    }
    function maybeReadMore_(stream, state) {
      while (!state.reading && !state.ended && (state.length < state.highWaterMark || state.flowing && state.length === 0)) {
        var len = state.length;
        debug("maybeReadMore read 0");
        stream.read(0);
        if (len === state.length)
          break;
      }
      state.readingMore = false;
    }
    Readable.prototype._read = function(n) {
      errorOrDestroy(this, new ERR_METHOD_NOT_IMPLEMENTED("_read()"));
    };
    Readable.prototype.pipe = function(dest, pipeOpts) {
      var src = this;
      var state = this._readableState;
      switch (state.pipesCount) {
        case 0:
          state.pipes = dest;
          break;
        case 1:
          state.pipes = [state.pipes, dest];
          break;
        default:
          state.pipes.push(dest);
          break;
      }
      state.pipesCount += 1;
      debug("pipe count=%d opts=%j", state.pipesCount, pipeOpts);
      var doEnd = (!pipeOpts || pipeOpts.end !== false) && dest !== process.stdout && dest !== process.stderr;
      var endFn = doEnd ? onend : unpipe;
      if (state.endEmitted)
        process.nextTick(endFn);
      else
        src.once("end", endFn);
      dest.on("unpipe", onunpipe);
      function onunpipe(readable, unpipeInfo) {
        debug("onunpipe");
        if (readable === src) {
          if (unpipeInfo && unpipeInfo.hasUnpiped === false) {
            unpipeInfo.hasUnpiped = true;
            cleanup();
          }
        }
      }
      function onend() {
        debug("onend");
        dest.end();
      }
      var ondrain = pipeOnDrain(src);
      dest.on("drain", ondrain);
      var cleanedUp = false;
      function cleanup() {
        debug("cleanup");
        dest.removeListener("close", onclose);
        dest.removeListener("finish", onfinish);
        dest.removeListener("drain", ondrain);
        dest.removeListener("error", onerror);
        dest.removeListener("unpipe", onunpipe);
        src.removeListener("end", onend);
        src.removeListener("end", unpipe);
        src.removeListener("data", ondata);
        cleanedUp = true;
        if (state.awaitDrain && (!dest._writableState || dest._writableState.needDrain))
          ondrain();
      }
      src.on("data", ondata);
      function ondata(chunk) {
        debug("ondata");
        var ret2 = dest.write(chunk);
        debug("dest.write", ret2);
        if (ret2 === false) {
          if ((state.pipesCount === 1 && state.pipes === dest || state.pipesCount > 1 && indexOf(state.pipes, dest) !== -1) && !cleanedUp) {
            debug("false write response, pause", state.awaitDrain);
            state.awaitDrain++;
          }
          src.pause();
        }
      }
      function onerror(er) {
        debug("onerror", er);
        unpipe();
        dest.removeListener("error", onerror);
        if (EElistenerCount(dest, "error") === 0)
          errorOrDestroy(dest, er);
      }
      prependListener(dest, "error", onerror);
      function onclose() {
        dest.removeListener("finish", onfinish);
        unpipe();
      }
      dest.once("close", onclose);
      function onfinish() {
        debug("onfinish");
        dest.removeListener("close", onclose);
        unpipe();
      }
      dest.once("finish", onfinish);
      function unpipe() {
        debug("unpipe");
        src.unpipe(dest);
      }
      dest.emit("pipe", src);
      if (!state.flowing) {
        debug("pipe resume");
        src.resume();
      }
      return dest;
    };
    function pipeOnDrain(src) {
      return function pipeOnDrainFunctionResult() {
        var state = src._readableState;
        debug("pipeOnDrain", state.awaitDrain);
        if (state.awaitDrain)
          state.awaitDrain--;
        if (state.awaitDrain === 0 && EElistenerCount(src, "data")) {
          state.flowing = true;
          flow(src);
        }
      };
    }
    Readable.prototype.unpipe = function(dest) {
      var state = this._readableState;
      var unpipeInfo = {
        hasUnpiped: false
      };
      if (state.pipesCount === 0)
        return this;
      if (state.pipesCount === 1) {
        if (dest && dest !== state.pipes)
          return this;
        if (!dest)
          dest = state.pipes;
        state.pipes = null;
        state.pipesCount = 0;
        state.flowing = false;
        if (dest)
          dest.emit("unpipe", this, unpipeInfo);
        return this;
      }
      if (!dest) {
        var dests = state.pipes;
        var len = state.pipesCount;
        state.pipes = null;
        state.pipesCount = 0;
        state.flowing = false;
        for (var i = 0; i < len; i++)
          dests[i].emit("unpipe", this, {
            hasUnpiped: false
          });
        return this;
      }
      var index = indexOf(state.pipes, dest);
      if (index === -1)
        return this;
      state.pipes.splice(index, 1);
      state.pipesCount -= 1;
      if (state.pipesCount === 1)
        state.pipes = state.pipes[0];
      dest.emit("unpipe", this, unpipeInfo);
      return this;
    };
    Readable.prototype.on = function(ev, fn) {
      var res = Stream.prototype.on.call(this, ev, fn);
      var state = this._readableState;
      if (ev === "data") {
        state.readableListening = this.listenerCount("readable") > 0;
        if (state.flowing !== false)
          this.resume();
      } else if (ev === "readable") {
        if (!state.endEmitted && !state.readableListening) {
          state.readableListening = state.needReadable = true;
          state.flowing = false;
          state.emittedReadable = false;
          debug("on readable", state.length, state.reading);
          if (state.length) {
            emitReadable(this);
          } else if (!state.reading) {
            process.nextTick(nReadingNextTick, this);
          }
        }
      }
      return res;
    };
    Readable.prototype.addListener = Readable.prototype.on;
    Readable.prototype.removeListener = function(ev, fn) {
      var res = Stream.prototype.removeListener.call(this, ev, fn);
      if (ev === "readable") {
        process.nextTick(updateReadableListening, this);
      }
      return res;
    };
    Readable.prototype.removeAllListeners = function(ev) {
      var res = Stream.prototype.removeAllListeners.apply(this, arguments);
      if (ev === "readable" || ev === void 0) {
        process.nextTick(updateReadableListening, this);
      }
      return res;
    };
    function updateReadableListening(self2) {
      var state = self2._readableState;
      state.readableListening = self2.listenerCount("readable") > 0;
      if (state.resumeScheduled && !state.paused) {
        state.flowing = true;
      } else if (self2.listenerCount("data") > 0) {
        self2.resume();
      }
    }
    function nReadingNextTick(self2) {
      debug("readable nexttick read 0");
      self2.read(0);
    }
    Readable.prototype.resume = function() {
      var state = this._readableState;
      if (!state.flowing) {
        debug("resume");
        state.flowing = !state.readableListening;
        resume(this, state);
      }
      state.paused = false;
      return this;
    };
    function resume(stream, state) {
      if (!state.resumeScheduled) {
        state.resumeScheduled = true;
        process.nextTick(resume_, stream, state);
      }
    }
    function resume_(stream, state) {
      debug("resume", state.reading);
      if (!state.reading) {
        stream.read(0);
      }
      state.resumeScheduled = false;
      stream.emit("resume");
      flow(stream);
      if (state.flowing && !state.reading)
        stream.read(0);
    }
    Readable.prototype.pause = function() {
      debug("call pause flowing=%j", this._readableState.flowing);
      if (this._readableState.flowing !== false) {
        debug("pause");
        this._readableState.flowing = false;
        this.emit("pause");
      }
      this._readableState.paused = true;
      return this;
    };
    function flow(stream) {
      var state = stream._readableState;
      debug("flow", state.flowing);
      while (state.flowing && stream.read() !== null)
        ;
    }
    Readable.prototype.wrap = function(stream) {
      var _this = this;
      var state = this._readableState;
      var paused = false;
      stream.on("end", function() {
        debug("wrapped end");
        if (state.decoder && !state.ended) {
          var chunk = state.decoder.end();
          if (chunk && chunk.length)
            _this.push(chunk);
        }
        _this.push(null);
      });
      stream.on("data", function(chunk) {
        debug("wrapped data");
        if (state.decoder)
          chunk = state.decoder.write(chunk);
        if (state.objectMode && (chunk === null || chunk === void 0))
          return;
        else if (!state.objectMode && (!chunk || !chunk.length))
          return;
        var ret2 = _this.push(chunk);
        if (!ret2) {
          paused = true;
          stream.pause();
        }
      });
      for (var i in stream) {
        if (this[i] === void 0 && typeof stream[i] === "function") {
          this[i] = /* @__PURE__ */ function methodWrap(method) {
            return function methodWrapReturnFunction() {
              return stream[method].apply(stream, arguments);
            };
          }(i);
        }
      }
      for (var n = 0; n < kProxyEvents.length; n++) {
        stream.on(kProxyEvents[n], this.emit.bind(this, kProxyEvents[n]));
      }
      this._read = function(n2) {
        debug("wrapped _read", n2);
        if (paused) {
          paused = false;
          stream.resume();
        }
      };
      return this;
    };
    if (typeof Symbol === "function") {
      Readable.prototype[Symbol.asyncIterator] = function() {
        if (createReadableStreamAsyncIterator === void 0) {
          createReadableStreamAsyncIterator = require_async_iterator2();
        }
        return createReadableStreamAsyncIterator(this);
      };
    }
    Object.defineProperty(Readable.prototype, "readableHighWaterMark", {
      // making it explicit this property is not enumerable
      // because otherwise some prototype manipulation in
      // userland will fail
      enumerable: false,
      get: function get() {
        return this._readableState.highWaterMark;
      }
    });
    Object.defineProperty(Readable.prototype, "readableBuffer", {
      // making it explicit this property is not enumerable
      // because otherwise some prototype manipulation in
      // userland will fail
      enumerable: false,
      get: function get() {
        return this._readableState && this._readableState.buffer;
      }
    });
    Object.defineProperty(Readable.prototype, "readableFlowing", {
      // making it explicit this property is not enumerable
      // because otherwise some prototype manipulation in
      // userland will fail
      enumerable: false,
      get: function get() {
        return this._readableState.flowing;
      },
      set: function set(state) {
        if (this._readableState) {
          this._readableState.flowing = state;
        }
      }
    });
    Readable._fromList = fromList;
    Object.defineProperty(Readable.prototype, "readableLength", {
      // making it explicit this property is not enumerable
      // because otherwise some prototype manipulation in
      // userland will fail
      enumerable: false,
      get: function get() {
        return this._readableState.length;
      }
    });
    function fromList(n, state) {
      if (state.length === 0)
        return null;
      var ret2;
      if (state.objectMode)
        ret2 = state.buffer.shift();
      else if (!n || n >= state.length) {
        if (state.decoder)
          ret2 = state.buffer.join("");
        else if (state.buffer.length === 1)
          ret2 = state.buffer.first();
        else
          ret2 = state.buffer.concat(state.length);
        state.buffer.clear();
      } else {
        ret2 = state.buffer.consume(n, state.decoder);
      }
      return ret2;
    }
    function endReadable(stream) {
      var state = stream._readableState;
      debug("endReadable", state.endEmitted);
      if (!state.endEmitted) {
        state.ended = true;
        process.nextTick(endReadableNT, state, stream);
      }
    }
    function endReadableNT(state, stream) {
      debug("endReadableNT", state.endEmitted, state.length);
      if (!state.endEmitted && state.length === 0) {
        state.endEmitted = true;
        stream.readable = false;
        stream.emit("end");
        if (state.autoDestroy) {
          var wState = stream._writableState;
          if (!wState || wState.autoDestroy && wState.finished) {
            stream.destroy();
          }
        }
      }
    }
    if (typeof Symbol === "function") {
      Readable.from = function(iterable, opts) {
        if (from === void 0) {
          from = require_from2();
        }
        return from(Readable, iterable, opts);
      };
    }
    function indexOf(xs, x) {
      for (var i = 0, l2 = xs.length; i < l2; i++) {
        if (xs[i] === x)
          return i;
      }
      return -1;
    }
  }
});

// ../../../node_modules/archiver/node_modules/readable-stream/lib/_stream_transform.js
var require_stream_transform5 = __commonJS({
  "../../../node_modules/archiver/node_modules/readable-stream/lib/_stream_transform.js"(exports2, module2) {
    "use strict";
    module2.exports = Transform;
    var _require$codes = require_errors2().codes;
    var ERR_METHOD_NOT_IMPLEMENTED = _require$codes.ERR_METHOD_NOT_IMPLEMENTED;
    var ERR_MULTIPLE_CALLBACK = _require$codes.ERR_MULTIPLE_CALLBACK;
    var ERR_TRANSFORM_ALREADY_TRANSFORMING = _require$codes.ERR_TRANSFORM_ALREADY_TRANSFORMING;
    var ERR_TRANSFORM_WITH_LENGTH_0 = _require$codes.ERR_TRANSFORM_WITH_LENGTH_0;
    var Duplex = require_stream_duplex5();
    require_inherits()(Transform, Duplex);
    function afterTransform(er, data) {
      var ts = this._transformState;
      ts.transforming = false;
      var cb = ts.writecb;
      if (cb === null) {
        return this.emit("error", new ERR_MULTIPLE_CALLBACK());
      }
      ts.writechunk = null;
      ts.writecb = null;
      if (data != null)
        this.push(data);
      cb(er);
      var rs = this._readableState;
      rs.reading = false;
      if (rs.needReadable || rs.length < rs.highWaterMark) {
        this._read(rs.highWaterMark);
      }
    }
    function Transform(options) {
      if (!(this instanceof Transform))
        return new Transform(options);
      Duplex.call(this, options);
      this._transformState = {
        afterTransform: afterTransform.bind(this),
        needTransform: false,
        transforming: false,
        writecb: null,
        writechunk: null,
        writeencoding: null
      };
      this._readableState.needReadable = true;
      this._readableState.sync = false;
      if (options) {
        if (typeof options.transform === "function")
          this._transform = options.transform;
        if (typeof options.flush === "function")
          this._flush = options.flush;
      }
      this.on("prefinish", prefinish);
    }
    function prefinish() {
      var _this = this;
      if (typeof this._flush === "function" && !this._readableState.destroyed) {
        this._flush(function(er, data) {
          done(_this, er, data);
        });
      } else {
        done(this, null, null);
      }
    }
    Transform.prototype.push = function(chunk, encoding) {
      this._transformState.needTransform = false;
      return Duplex.prototype.push.call(this, chunk, encoding);
    };
    Transform.prototype._transform = function(chunk, encoding, cb) {
      cb(new ERR_METHOD_NOT_IMPLEMENTED("_transform()"));
    };
    Transform.prototype._write = function(chunk, encoding, cb) {
      var ts = this._transformState;
      ts.writecb = cb;
      ts.writechunk = chunk;
      ts.writeencoding = encoding;
      if (!ts.transforming) {
        var rs = this._readableState;
        if (ts.needTransform || rs.needReadable || rs.length < rs.highWaterMark)
          this._read(rs.highWaterMark);
      }
    };
    Transform.prototype._read = function(n) {
      var ts = this._transformState;
      if (ts.writechunk !== null && !ts.transforming) {
        ts.transforming = true;
        this._transform(ts.writechunk, ts.writeencoding, ts.afterTransform);
      } else {
        ts.needTransform = true;
      }
    };
    Transform.prototype._destroy = function(err, cb) {
      Duplex.prototype._destroy.call(this, err, function(err2) {
        cb(err2);
      });
    };
    function done(stream, er, data) {
      if (er)
        return stream.emit("error", er);
      if (data != null)
        stream.push(data);
      if (stream._writableState.length)
        throw new ERR_TRANSFORM_WITH_LENGTH_0();
      if (stream._transformState.transforming)
        throw new ERR_TRANSFORM_ALREADY_TRANSFORMING();
      return stream.push(null);
    }
  }
});

// ../../../node_modules/archiver/node_modules/readable-stream/lib/_stream_passthrough.js
var require_stream_passthrough5 = __commonJS({
  "../../../node_modules/archiver/node_modules/readable-stream/lib/_stream_passthrough.js"(exports2, module2) {
    "use strict";
    module2.exports = PassThrough;
    var Transform = require_stream_transform5();
    require_inherits()(PassThrough, Transform);
    function PassThrough(options) {
      if (!(this instanceof PassThrough))
        return new PassThrough(options);
      Transform.call(this, options);
    }
    PassThrough.prototype._transform = function(chunk, encoding, cb) {
      cb(null, chunk);
    };
  }
});

// ../../../node_modules/archiver/node_modules/readable-stream/lib/internal/streams/pipeline.js
var require_pipeline2 = __commonJS({
  "../../../node_modules/archiver/node_modules/readable-stream/lib/internal/streams/pipeline.js"(exports2, module2) {
    "use strict";
    var eos;
    function once(callback) {
      var called = false;
      return function() {
        if (called)
          return;
        called = true;
        callback.apply(void 0, arguments);
      };
    }
    var _require$codes = require_errors2().codes;
    var ERR_MISSING_ARGS = _require$codes.ERR_MISSING_ARGS;
    var ERR_STREAM_DESTROYED = _require$codes.ERR_STREAM_DESTROYED;
    function noop(err) {
      if (err)
        throw err;
    }
    function isRequest(stream) {
      return stream.setHeader && typeof stream.abort === "function";
    }
    function destroyer(stream, reading, writing, callback) {
      callback = once(callback);
      var closed = false;
      stream.on("close", function() {
        closed = true;
      });
      if (eos === void 0)
        eos = require_end_of_stream2();
      eos(stream, {
        readable: reading,
        writable: writing
      }, function(err) {
        if (err)
          return callback(err);
        closed = true;
        callback();
      });
      var destroyed = false;
      return function(err) {
        if (closed)
          return;
        if (destroyed)
          return;
        destroyed = true;
        if (isRequest(stream))
          return stream.abort();
        if (typeof stream.destroy === "function")
          return stream.destroy();
        callback(err || new ERR_STREAM_DESTROYED("pipe"));
      };
    }
    function call(fn) {
      fn();
    }
    function pipe(from, to) {
      return from.pipe(to);
    }
    function popCallback(streams) {
      if (!streams.length)
        return noop;
      if (typeof streams[streams.length - 1] !== "function")
        return noop;
      return streams.pop();
    }
    function pipeline() {
      for (var _len = arguments.length, streams = new Array(_len), _key = 0; _key < _len; _key++) {
        streams[_key] = arguments[_key];
      }
      var callback = popCallback(streams);
      if (Array.isArray(streams[0]))
        streams = streams[0];
      if (streams.length < 2) {
        throw new ERR_MISSING_ARGS("streams");
      }
      var error;
      var destroys = streams.map(function(stream, i) {
        var reading = i < streams.length - 1;
        var writing = i > 0;
        return destroyer(stream, reading, writing, function(err) {
          if (!error)
            error = err;
          if (err)
            destroys.forEach(call);
          if (reading)
            return;
          destroys.forEach(call);
          callback(error);
        });
      });
      return streams.reduce(pipe);
    }
    module2.exports = pipeline;
  }
});

// ../../../node_modules/archiver/node_modules/readable-stream/readable.js
var require_readable5 = __commonJS({
  "../../../node_modules/archiver/node_modules/readable-stream/readable.js"(exports2, module2) {
    var Stream = require("stream");
    if (process.env.READABLE_STREAM === "disable" && Stream) {
      module2.exports = Stream.Readable;
      Object.assign(module2.exports, Stream);
      module2.exports.Stream = Stream;
    } else {
      exports2 = module2.exports = require_stream_readable5();
      exports2.Stream = Stream || exports2;
      exports2.Readable = exports2;
      exports2.Writable = require_stream_writable5();
      exports2.Duplex = require_stream_duplex5();
      exports2.Transform = require_stream_transform5();
      exports2.PassThrough = require_stream_passthrough5();
      exports2.finished = require_end_of_stream2();
      exports2.pipeline = require_pipeline2();
    }
  }
});

// ../../../node_modules/archiver/lib/core.js
var require_core = __commonJS({
  "../../../node_modules/archiver/lib/core.js"(exports2, module2) {
    var fs = require("fs");
    var glob = require_readdir_glob();
    var async = require_async();
    var path = require("path");
    var util = require_archiver_utils();
    var inherits2 = require("util").inherits;
    var ArchiverError = require_error();
    var Transform = require_readable5().Transform;
    var win32 = process.platform === "win32";
    var Archiver = function(format, options) {
      if (!(this instanceof Archiver)) {
        return new Archiver(format, options);
      }
      if (typeof format !== "string") {
        options = format;
        format = "zip";
      }
      options = this.options = util.defaults(options, {
        highWaterMark: 1024 * 1024,
        statConcurrency: 4
      });
      Transform.call(this, options);
      this._format = false;
      this._module = false;
      this._pending = 0;
      this._pointer = 0;
      this._entriesCount = 0;
      this._entriesProcessedCount = 0;
      this._fsEntriesTotalBytes = 0;
      this._fsEntriesProcessedBytes = 0;
      this._queue = async.queue(this._onQueueTask.bind(this), 1);
      this._queue.drain(this._onQueueDrain.bind(this));
      this._statQueue = async.queue(this._onStatQueueTask.bind(this), options.statConcurrency);
      this._statQueue.drain(this._onQueueDrain.bind(this));
      this._state = {
        aborted: false,
        finalize: false,
        finalizing: false,
        finalized: false,
        modulePiped: false
      };
      this._streams = [];
    };
    inherits2(Archiver, Transform);
    Archiver.prototype._abort = function() {
      this._state.aborted = true;
      this._queue.kill();
      this._statQueue.kill();
      if (this._queue.idle()) {
        this._shutdown();
      }
    };
    Archiver.prototype._append = function(filepath, data) {
      data = data || {};
      var task = {
        source: null,
        filepath
      };
      if (!data.name) {
        data.name = filepath;
      }
      data.sourcePath = filepath;
      task.data = data;
      this._entriesCount++;
      if (data.stats && data.stats instanceof fs.Stats) {
        task = this._updateQueueTaskWithStats(task, data.stats);
        if (task) {
          if (data.stats.size) {
            this._fsEntriesTotalBytes += data.stats.size;
          }
          this._queue.push(task);
        }
      } else {
        this._statQueue.push(task);
      }
    };
    Archiver.prototype._finalize = function() {
      if (this._state.finalizing || this._state.finalized || this._state.aborted) {
        return;
      }
      this._state.finalizing = true;
      this._moduleFinalize();
      this._state.finalizing = false;
      this._state.finalized = true;
    };
    Archiver.prototype._maybeFinalize = function() {
      if (this._state.finalizing || this._state.finalized || this._state.aborted) {
        return false;
      }
      if (this._state.finalize && this._pending === 0 && this._queue.idle() && this._statQueue.idle()) {
        this._finalize();
        return true;
      }
      return false;
    };
    Archiver.prototype._moduleAppend = function(source, data, callback) {
      if (this._state.aborted) {
        callback();
        return;
      }
      this._module.append(source, data, function(err) {
        this._task = null;
        if (this._state.aborted) {
          this._shutdown();
          return;
        }
        if (err) {
          this.emit("error", err);
          setImmediate(callback);
          return;
        }
        this.emit("entry", data);
        this._entriesProcessedCount++;
        if (data.stats && data.stats.size) {
          this._fsEntriesProcessedBytes += data.stats.size;
        }
        this.emit("progress", {
          entries: {
            total: this._entriesCount,
            processed: this._entriesProcessedCount
          },
          fs: {
            totalBytes: this._fsEntriesTotalBytes,
            processedBytes: this._fsEntriesProcessedBytes
          }
        });
        setImmediate(callback);
      }.bind(this));
    };
    Archiver.prototype._moduleFinalize = function() {
      if (typeof this._module.finalize === "function") {
        this._module.finalize();
      } else if (typeof this._module.end === "function") {
        this._module.end();
      } else {
        this.emit("error", new ArchiverError("NOENDMETHOD"));
      }
    };
    Archiver.prototype._modulePipe = function() {
      this._module.on("error", this._onModuleError.bind(this));
      this._module.pipe(this);
      this._state.modulePiped = true;
    };
    Archiver.prototype._moduleSupports = function(key) {
      if (!this._module.supports || !this._module.supports[key]) {
        return false;
      }
      return this._module.supports[key];
    };
    Archiver.prototype._moduleUnpipe = function() {
      this._module.unpipe(this);
      this._state.modulePiped = false;
    };
    Archiver.prototype._normalizeEntryData = function(data, stats) {
      data = util.defaults(data, {
        type: "file",
        name: null,
        date: null,
        mode: null,
        prefix: null,
        sourcePath: null,
        stats: false
      });
      if (stats && data.stats === false) {
        data.stats = stats;
      }
      var isDir = data.type === "directory";
      if (data.name) {
        if (typeof data.prefix === "string" && "" !== data.prefix) {
          data.name = data.prefix + "/" + data.name;
          data.prefix = null;
        }
        data.name = util.sanitizePath(data.name);
        if (data.type !== "symlink" && data.name.slice(-1) === "/") {
          isDir = true;
          data.type = "directory";
        } else if (isDir) {
          data.name += "/";
        }
      }
      if (typeof data.mode === "number") {
        if (win32) {
          data.mode &= 511;
        } else {
          data.mode &= 4095;
        }
      } else if (data.stats && data.mode === null) {
        if (win32) {
          data.mode = data.stats.mode & 511;
        } else {
          data.mode = data.stats.mode & 4095;
        }
        if (win32 && isDir) {
          data.mode = 493;
        }
      } else if (data.mode === null) {
        data.mode = isDir ? 493 : 420;
      }
      if (data.stats && data.date === null) {
        data.date = data.stats.mtime;
      } else {
        data.date = util.dateify(data.date);
      }
      return data;
    };
    Archiver.prototype._onModuleError = function(err) {
      this.emit("error", err);
    };
    Archiver.prototype._onQueueDrain = function() {
      if (this._state.finalizing || this._state.finalized || this._state.aborted) {
        return;
      }
      if (this._state.finalize && this._pending === 0 && this._queue.idle() && this._statQueue.idle()) {
        this._finalize();
      }
    };
    Archiver.prototype._onQueueTask = function(task, callback) {
      var fullCallback = () => {
        if (task.data.callback) {
          task.data.callback();
        }
        callback();
      };
      if (this._state.finalizing || this._state.finalized || this._state.aborted) {
        fullCallback();
        return;
      }
      this._task = task;
      this._moduleAppend(task.source, task.data, fullCallback);
    };
    Archiver.prototype._onStatQueueTask = function(task, callback) {
      if (this._state.finalizing || this._state.finalized || this._state.aborted) {
        callback();
        return;
      }
      fs.lstat(task.filepath, function(err, stats) {
        if (this._state.aborted) {
          setImmediate(callback);
          return;
        }
        if (err) {
          this._entriesCount--;
          this.emit("warning", err);
          setImmediate(callback);
          return;
        }
        task = this._updateQueueTaskWithStats(task, stats);
        if (task) {
          if (stats.size) {
            this._fsEntriesTotalBytes += stats.size;
          }
          this._queue.push(task);
        }
        setImmediate(callback);
      }.bind(this));
    };
    Archiver.prototype._shutdown = function() {
      this._moduleUnpipe();
      this.end();
    };
    Archiver.prototype._transform = function(chunk, encoding, callback) {
      if (chunk) {
        this._pointer += chunk.length;
      }
      callback(null, chunk);
    };
    Archiver.prototype._updateQueueTaskWithStats = function(task, stats) {
      if (stats.isFile()) {
        task.data.type = "file";
        task.data.sourceType = "stream";
        task.source = util.lazyReadStream(task.filepath);
      } else if (stats.isDirectory() && this._moduleSupports("directory")) {
        task.data.name = util.trailingSlashIt(task.data.name);
        task.data.type = "directory";
        task.data.sourcePath = util.trailingSlashIt(task.filepath);
        task.data.sourceType = "buffer";
        task.source = Buffer.concat([]);
      } else if (stats.isSymbolicLink() && this._moduleSupports("symlink")) {
        var linkPath = fs.readlinkSync(task.filepath);
        var dirName = path.dirname(task.filepath);
        task.data.type = "symlink";
        task.data.linkname = path.relative(dirName, path.resolve(dirName, linkPath));
        task.data.sourceType = "buffer";
        task.source = Buffer.concat([]);
      } else {
        if (stats.isDirectory()) {
          this.emit("warning", new ArchiverError("DIRECTORYNOTSUPPORTED", task.data));
        } else if (stats.isSymbolicLink()) {
          this.emit("warning", new ArchiverError("SYMLINKNOTSUPPORTED", task.data));
        } else {
          this.emit("warning", new ArchiverError("ENTRYNOTSUPPORTED", task.data));
        }
        return null;
      }
      task.data = this._normalizeEntryData(task.data, stats);
      return task;
    };
    Archiver.prototype.abort = function() {
      if (this._state.aborted || this._state.finalized) {
        return this;
      }
      this._abort();
      return this;
    };
    Archiver.prototype.append = function(source, data) {
      if (this._state.finalize || this._state.aborted) {
        this.emit("error", new ArchiverError("QUEUECLOSED"));
        return this;
      }
      data = this._normalizeEntryData(data);
      if (typeof data.name !== "string" || data.name.length === 0) {
        this.emit("error", new ArchiverError("ENTRYNAMEREQUIRED"));
        return this;
      }
      if (data.type === "directory" && !this._moduleSupports("directory")) {
        this.emit("error", new ArchiverError("DIRECTORYNOTSUPPORTED", { name: data.name }));
        return this;
      }
      source = util.normalizeInputSource(source);
      if (Buffer.isBuffer(source)) {
        data.sourceType = "buffer";
      } else if (util.isStream(source)) {
        data.sourceType = "stream";
      } else {
        this.emit("error", new ArchiverError("INPUTSTEAMBUFFERREQUIRED", { name: data.name }));
        return this;
      }
      this._entriesCount++;
      this._queue.push({
        data,
        source
      });
      return this;
    };
    Archiver.prototype.directory = function(dirpath, destpath, data) {
      if (this._state.finalize || this._state.aborted) {
        this.emit("error", new ArchiverError("QUEUECLOSED"));
        return this;
      }
      if (typeof dirpath !== "string" || dirpath.length === 0) {
        this.emit("error", new ArchiverError("DIRECTORYDIRPATHREQUIRED"));
        return this;
      }
      this._pending++;
      if (destpath === false) {
        destpath = "";
      } else if (typeof destpath !== "string") {
        destpath = dirpath;
      }
      var dataFunction = false;
      if (typeof data === "function") {
        dataFunction = data;
        data = {};
      } else if (typeof data !== "object") {
        data = {};
      }
      var globOptions = {
        stat: true,
        dot: true
      };
      function onGlobEnd() {
        this._pending--;
        this._maybeFinalize();
      }
      function onGlobError(err) {
        this.emit("error", err);
      }
      function onGlobMatch(match) {
        globber.pause();
        var ignoreMatch = false;
        var entryData = Object.assign({}, data);
        entryData.name = match.relative;
        entryData.prefix = destpath;
        entryData.stats = match.stat;
        entryData.callback = globber.resume.bind(globber);
        try {
          if (dataFunction) {
            entryData = dataFunction(entryData);
            if (entryData === false) {
              ignoreMatch = true;
            } else if (typeof entryData !== "object") {
              throw new ArchiverError("DIRECTORYFUNCTIONINVALIDDATA", { dirpath });
            }
          }
        } catch (e) {
          this.emit("error", e);
          return;
        }
        if (ignoreMatch) {
          globber.resume();
          return;
        }
        this._append(match.absolute, entryData);
      }
      var globber = glob(dirpath, globOptions);
      globber.on("error", onGlobError.bind(this));
      globber.on("match", onGlobMatch.bind(this));
      globber.on("end", onGlobEnd.bind(this));
      return this;
    };
    Archiver.prototype.file = function(filepath, data) {
      if (this._state.finalize || this._state.aborted) {
        this.emit("error", new ArchiverError("QUEUECLOSED"));
        return this;
      }
      if (typeof filepath !== "string" || filepath.length === 0) {
        this.emit("error", new ArchiverError("FILEFILEPATHREQUIRED"));
        return this;
      }
      this._append(filepath, data);
      return this;
    };
    Archiver.prototype.glob = function(pattern, options, data) {
      this._pending++;
      options = util.defaults(options, {
        stat: true,
        pattern
      });
      function onGlobEnd() {
        this._pending--;
        this._maybeFinalize();
      }
      function onGlobError(err) {
        this.emit("error", err);
      }
      function onGlobMatch(match) {
        globber.pause();
        var entryData = Object.assign({}, data);
        entryData.callback = globber.resume.bind(globber);
        entryData.stats = match.stat;
        entryData.name = match.relative;
        this._append(match.absolute, entryData);
      }
      var globber = glob(options.cwd || ".", options);
      globber.on("error", onGlobError.bind(this));
      globber.on("match", onGlobMatch.bind(this));
      globber.on("end", onGlobEnd.bind(this));
      return this;
    };
    Archiver.prototype.finalize = function() {
      if (this._state.aborted) {
        var abortedError = new ArchiverError("ABORTED");
        this.emit("error", abortedError);
        return Promise.reject(abortedError);
      }
      if (this._state.finalize) {
        var finalizingError = new ArchiverError("FINALIZING");
        this.emit("error", finalizingError);
        return Promise.reject(finalizingError);
      }
      this._state.finalize = true;
      if (this._pending === 0 && this._queue.idle() && this._statQueue.idle()) {
        this._finalize();
      }
      var self2 = this;
      return new Promise(function(resolve, reject) {
        var errored;
        self2._module.on("end", function() {
          if (!errored) {
            resolve();
          }
        });
        self2._module.on("error", function(err) {
          errored = true;
          reject(err);
        });
      });
    };
    Archiver.prototype.setFormat = function(format) {
      if (this._format) {
        this.emit("error", new ArchiverError("FORMATSET"));
        return this;
      }
      this._format = format;
      return this;
    };
    Archiver.prototype.setModule = function(module3) {
      if (this._state.aborted) {
        this.emit("error", new ArchiverError("ABORTED"));
        return this;
      }
      if (this._state.module) {
        this.emit("error", new ArchiverError("MODULESET"));
        return this;
      }
      this._module = module3;
      this._modulePipe();
      return this;
    };
    Archiver.prototype.symlink = function(filepath, target, mode) {
      if (this._state.finalize || this._state.aborted) {
        this.emit("error", new ArchiverError("QUEUECLOSED"));
        return this;
      }
      if (typeof filepath !== "string" || filepath.length === 0) {
        this.emit("error", new ArchiverError("SYMLINKFILEPATHREQUIRED"));
        return this;
      }
      if (typeof target !== "string" || target.length === 0) {
        this.emit("error", new ArchiverError("SYMLINKTARGETREQUIRED", { filepath }));
        return this;
      }
      if (!this._moduleSupports("symlink")) {
        this.emit("error", new ArchiverError("SYMLINKNOTSUPPORTED", { filepath }));
        return this;
      }
      var data = {};
      data.type = "symlink";
      data.name = filepath.replace(/\\/g, "/");
      data.linkname = target.replace(/\\/g, "/");
      data.sourceType = "buffer";
      if (typeof mode === "number") {
        data.mode = mode;
      }
      this._entriesCount++;
      this._queue.push({
        data,
        source: Buffer.concat([])
      });
      return this;
    };
    Archiver.prototype.pointer = function() {
      return this._pointer;
    };
    Archiver.prototype.use = function(plugin) {
      this._streams.push(plugin);
      return this;
    };
    module2.exports = Archiver;
  }
});

// ../../../node_modules/compress-commons/lib/archivers/archive-entry.js
var require_archive_entry = __commonJS({
  "../../../node_modules/compress-commons/lib/archivers/archive-entry.js"(exports2, module2) {
    var ArchiveEntry = module2.exports = function() {
    };
    ArchiveEntry.prototype.getName = function() {
    };
    ArchiveEntry.prototype.getSize = function() {
    };
    ArchiveEntry.prototype.getLastModifiedDate = function() {
    };
    ArchiveEntry.prototype.isDirectory = function() {
    };
  }
});

// ../../../node_modules/compress-commons/lib/archivers/zip/util.js
var require_util2 = __commonJS({
  "../../../node_modules/compress-commons/lib/archivers/zip/util.js"(exports2, module2) {
    var util = module2.exports = {};
    util.dateToDos = function(d, forceLocalTime) {
      forceLocalTime = forceLocalTime || false;
      var year = forceLocalTime ? d.getFullYear() : d.getUTCFullYear();
      if (year < 1980) {
        return 2162688;
      } else if (year >= 2044) {
        return 2141175677;
      }
      var val = {
        year,
        month: forceLocalTime ? d.getMonth() : d.getUTCMonth(),
        date: forceLocalTime ? d.getDate() : d.getUTCDate(),
        hours: forceLocalTime ? d.getHours() : d.getUTCHours(),
        minutes: forceLocalTime ? d.getMinutes() : d.getUTCMinutes(),
        seconds: forceLocalTime ? d.getSeconds() : d.getUTCSeconds()
      };
      return val.year - 1980 << 25 | val.month + 1 << 21 | val.date << 16 | val.hours << 11 | val.minutes << 5 | val.seconds / 2;
    };
    util.dosToDate = function(dos) {
      return new Date((dos >> 25 & 127) + 1980, (dos >> 21 & 15) - 1, dos >> 16 & 31, dos >> 11 & 31, dos >> 5 & 63, (dos & 31) << 1);
    };
    util.fromDosTime = function(buf) {
      return util.dosToDate(buf.readUInt32LE(0));
    };
    util.getEightBytes = function(v) {
      var buf = Buffer.alloc(8);
      buf.writeUInt32LE(v % 4294967296, 0);
      buf.writeUInt32LE(v / 4294967296 | 0, 4);
      return buf;
    };
    util.getShortBytes = function(v) {
      var buf = Buffer.alloc(2);
      buf.writeUInt16LE((v & 65535) >>> 0, 0);
      return buf;
    };
    util.getShortBytesValue = function(buf, offset) {
      return buf.readUInt16LE(offset);
    };
    util.getLongBytes = function(v) {
      var buf = Buffer.alloc(4);
      buf.writeUInt32LE((v & 4294967295) >>> 0, 0);
      return buf;
    };
    util.getLongBytesValue = function(buf, offset) {
      return buf.readUInt32LE(offset);
    };
    util.toDosTime = function(d) {
      return util.getLongBytes(util.dateToDos(d));
    };
  }
});

// ../../../node_modules/compress-commons/lib/archivers/zip/general-purpose-bit.js
var require_general_purpose_bit = __commonJS({
  "../../../node_modules/compress-commons/lib/archivers/zip/general-purpose-bit.js"(exports2, module2) {
    var zipUtil = require_util2();
    var DATA_DESCRIPTOR_FLAG = 1 << 3;
    var ENCRYPTION_FLAG = 1 << 0;
    var NUMBER_OF_SHANNON_FANO_TREES_FLAG = 1 << 2;
    var SLIDING_DICTIONARY_SIZE_FLAG = 1 << 1;
    var STRONG_ENCRYPTION_FLAG = 1 << 6;
    var UFT8_NAMES_FLAG = 1 << 11;
    var GeneralPurposeBit = module2.exports = function() {
      if (!(this instanceof GeneralPurposeBit)) {
        return new GeneralPurposeBit();
      }
      this.descriptor = false;
      this.encryption = false;
      this.utf8 = false;
      this.numberOfShannonFanoTrees = 0;
      this.strongEncryption = false;
      this.slidingDictionarySize = 0;
      return this;
    };
    GeneralPurposeBit.prototype.encode = function() {
      return zipUtil.getShortBytes(
        (this.descriptor ? DATA_DESCRIPTOR_FLAG : 0) | (this.utf8 ? UFT8_NAMES_FLAG : 0) | (this.encryption ? ENCRYPTION_FLAG : 0) | (this.strongEncryption ? STRONG_ENCRYPTION_FLAG : 0)
      );
    };
    GeneralPurposeBit.prototype.parse = function(buf, offset) {
      var flag = zipUtil.getShortBytesValue(buf, offset);
      var gbp = new GeneralPurposeBit();
      gbp.useDataDescriptor((flag & DATA_DESCRIPTOR_FLAG) !== 0);
      gbp.useUTF8ForNames((flag & UFT8_NAMES_FLAG) !== 0);
      gbp.useStrongEncryption((flag & STRONG_ENCRYPTION_FLAG) !== 0);
      gbp.useEncryption((flag & ENCRYPTION_FLAG) !== 0);
      gbp.setSlidingDictionarySize((flag & SLIDING_DICTIONARY_SIZE_FLAG) !== 0 ? 8192 : 4096);
      gbp.setNumberOfShannonFanoTrees((flag & NUMBER_OF_SHANNON_FANO_TREES_FLAG) !== 0 ? 3 : 2);
      return gbp;
    };
    GeneralPurposeBit.prototype.setNumberOfShannonFanoTrees = function(n) {
      this.numberOfShannonFanoTrees = n;
    };
    GeneralPurposeBit.prototype.getNumberOfShannonFanoTrees = function() {
      return this.numberOfShannonFanoTrees;
    };
    GeneralPurposeBit.prototype.setSlidingDictionarySize = function(n) {
      this.slidingDictionarySize = n;
    };
    GeneralPurposeBit.prototype.getSlidingDictionarySize = function() {
      return this.slidingDictionarySize;
    };
    GeneralPurposeBit.prototype.useDataDescriptor = function(b) {
      this.descriptor = b;
    };
    GeneralPurposeBit.prototype.usesDataDescriptor = function() {
      return this.descriptor;
    };
    GeneralPurposeBit.prototype.useEncryption = function(b) {
      this.encryption = b;
    };
    GeneralPurposeBit.prototype.usesEncryption = function() {
      return this.encryption;
    };
    GeneralPurposeBit.prototype.useStrongEncryption = function(b) {
      this.strongEncryption = b;
    };
    GeneralPurposeBit.prototype.usesStrongEncryption = function() {
      return this.strongEncryption;
    };
    GeneralPurposeBit.prototype.useUTF8ForNames = function(b) {
      this.utf8 = b;
    };
    GeneralPurposeBit.prototype.usesUTF8ForNames = function() {
      return this.utf8;
    };
  }
});

// ../../../node_modules/compress-commons/lib/archivers/zip/unix-stat.js
var require_unix_stat = __commonJS({
  "../../../node_modules/compress-commons/lib/archivers/zip/unix-stat.js"(exports2, module2) {
    module2.exports = {
      /**
       * Bits used for permissions (and sticky bit)
       */
      PERM_MASK: 4095,
      // 07777
      /**
       * Bits used to indicate the filesystem object type.
       */
      FILE_TYPE_FLAG: 61440,
      // 0170000
      /**
       * Indicates symbolic links.
       */
      LINK_FLAG: 40960,
      // 0120000
      /**
       * Indicates plain files.
       */
      FILE_FLAG: 32768,
      // 0100000
      /**
       * Indicates directories.
       */
      DIR_FLAG: 16384,
      // 040000
      // ----------------------------------------------------------
      // somewhat arbitrary choices that are quite common for shared
      // installations
      // -----------------------------------------------------------
      /**
       * Default permissions for symbolic links.
       */
      DEFAULT_LINK_PERM: 511,
      // 0777
      /**
       * Default permissions for directories.
       */
      DEFAULT_DIR_PERM: 493,
      // 0755
      /**
       * Default permissions for plain files.
       */
      DEFAULT_FILE_PERM: 420
      // 0644
    };
  }
});

// ../../../node_modules/compress-commons/lib/archivers/zip/constants.js
var require_constants2 = __commonJS({
  "../../../node_modules/compress-commons/lib/archivers/zip/constants.js"(exports2, module2) {
    module2.exports = {
      WORD: 4,
      DWORD: 8,
      EMPTY: Buffer.alloc(0),
      SHORT: 2,
      SHORT_MASK: 65535,
      SHORT_SHIFT: 16,
      SHORT_ZERO: Buffer.from(Array(2)),
      LONG: 4,
      LONG_ZERO: Buffer.from(Array(4)),
      MIN_VERSION_INITIAL: 10,
      MIN_VERSION_DATA_DESCRIPTOR: 20,
      MIN_VERSION_ZIP64: 45,
      VERSION_MADEBY: 45,
      METHOD_STORED: 0,
      METHOD_DEFLATED: 8,
      PLATFORM_UNIX: 3,
      PLATFORM_FAT: 0,
      SIG_LFH: 67324752,
      SIG_DD: 134695760,
      SIG_CFH: 33639248,
      SIG_EOCD: 101010256,
      SIG_ZIP64_EOCD: 101075792,
      SIG_ZIP64_EOCD_LOC: 117853008,
      ZIP64_MAGIC_SHORT: 65535,
      ZIP64_MAGIC: 4294967295,
      ZIP64_EXTRA_ID: 1,
      ZLIB_NO_COMPRESSION: 0,
      ZLIB_BEST_SPEED: 1,
      ZLIB_BEST_COMPRESSION: 9,
      ZLIB_DEFAULT_COMPRESSION: -1,
      MODE_MASK: 4095,
      DEFAULT_FILE_MODE: 33188,
      // 010644 = -rw-r--r-- = S_IFREG | S_IRUSR | S_IWUSR | S_IRGRP | S_IROTH
      DEFAULT_DIR_MODE: 16877,
      // 040755 = drwxr-xr-x = S_IFDIR | S_IRWXU | S_IRGRP | S_IXGRP | S_IROTH | S_IXOTH
      EXT_FILE_ATTR_DIR: 1106051088,
      // 010173200020 = drwxr-xr-x = (((S_IFDIR | 0755) << 16) | S_DOS_D)
      EXT_FILE_ATTR_FILE: 2175008800,
      // 020151000040 = -rw-r--r-- = (((S_IFREG | 0644) << 16) | S_DOS_A) >>> 0
      // Unix file types
      S_IFMT: 61440,
      // 0170000 type of file mask
      S_IFIFO: 4096,
      // 010000 named pipe (fifo)
      S_IFCHR: 8192,
      // 020000 character special
      S_IFDIR: 16384,
      // 040000 directory
      S_IFBLK: 24576,
      // 060000 block special
      S_IFREG: 32768,
      // 0100000 regular
      S_IFLNK: 40960,
      // 0120000 symbolic link
      S_IFSOCK: 49152,
      // 0140000 socket
      // DOS file type flags
      S_DOS_A: 32,
      // 040 Archive
      S_DOS_D: 16,
      // 020 Directory
      S_DOS_V: 8,
      // 010 Volume
      S_DOS_S: 4,
      // 04 System
      S_DOS_H: 2,
      // 02 Hidden
      S_DOS_R: 1
      // 01 Read Only
    };
  }
});

// ../../../node_modules/compress-commons/lib/archivers/zip/zip-archive-entry.js
var require_zip_archive_entry = __commonJS({
  "../../../node_modules/compress-commons/lib/archivers/zip/zip-archive-entry.js"(exports2, module2) {
    var inherits2 = require("util").inherits;
    var normalizePath = require_normalize_path();
    var ArchiveEntry = require_archive_entry();
    var GeneralPurposeBit = require_general_purpose_bit();
    var UnixStat = require_unix_stat();
    var constants = require_constants2();
    var zipUtil = require_util2();
    var ZipArchiveEntry = module2.exports = function(name) {
      if (!(this instanceof ZipArchiveEntry)) {
        return new ZipArchiveEntry(name);
      }
      ArchiveEntry.call(this);
      this.platform = constants.PLATFORM_FAT;
      this.method = -1;
      this.name = null;
      this.size = 0;
      this.csize = 0;
      this.gpb = new GeneralPurposeBit();
      this.crc = 0;
      this.time = -1;
      this.minver = constants.MIN_VERSION_INITIAL;
      this.mode = -1;
      this.extra = null;
      this.exattr = 0;
      this.inattr = 0;
      this.comment = null;
      if (name) {
        this.setName(name);
      }
    };
    inherits2(ZipArchiveEntry, ArchiveEntry);
    ZipArchiveEntry.prototype.getCentralDirectoryExtra = function() {
      return this.getExtra();
    };
    ZipArchiveEntry.prototype.getComment = function() {
      return this.comment !== null ? this.comment : "";
    };
    ZipArchiveEntry.prototype.getCompressedSize = function() {
      return this.csize;
    };
    ZipArchiveEntry.prototype.getCrc = function() {
      return this.crc;
    };
    ZipArchiveEntry.prototype.getExternalAttributes = function() {
      return this.exattr;
    };
    ZipArchiveEntry.prototype.getExtra = function() {
      return this.extra !== null ? this.extra : constants.EMPTY;
    };
    ZipArchiveEntry.prototype.getGeneralPurposeBit = function() {
      return this.gpb;
    };
    ZipArchiveEntry.prototype.getInternalAttributes = function() {
      return this.inattr;
    };
    ZipArchiveEntry.prototype.getLastModifiedDate = function() {
      return this.getTime();
    };
    ZipArchiveEntry.prototype.getLocalFileDataExtra = function() {
      return this.getExtra();
    };
    ZipArchiveEntry.prototype.getMethod = function() {
      return this.method;
    };
    ZipArchiveEntry.prototype.getName = function() {
      return this.name;
    };
    ZipArchiveEntry.prototype.getPlatform = function() {
      return this.platform;
    };
    ZipArchiveEntry.prototype.getSize = function() {
      return this.size;
    };
    ZipArchiveEntry.prototype.getTime = function() {
      return this.time !== -1 ? zipUtil.dosToDate(this.time) : -1;
    };
    ZipArchiveEntry.prototype.getTimeDos = function() {
      return this.time !== -1 ? this.time : 0;
    };
    ZipArchiveEntry.prototype.getUnixMode = function() {
      return this.platform !== constants.PLATFORM_UNIX ? 0 : this.getExternalAttributes() >> constants.SHORT_SHIFT & constants.SHORT_MASK;
    };
    ZipArchiveEntry.prototype.getVersionNeededToExtract = function() {
      return this.minver;
    };
    ZipArchiveEntry.prototype.setComment = function(comment) {
      if (Buffer.byteLength(comment) !== comment.length) {
        this.getGeneralPurposeBit().useUTF8ForNames(true);
      }
      this.comment = comment;
    };
    ZipArchiveEntry.prototype.setCompressedSize = function(size) {
      if (size < 0) {
        throw new Error("invalid entry compressed size");
      }
      this.csize = size;
    };
    ZipArchiveEntry.prototype.setCrc = function(crc) {
      if (crc < 0) {
        throw new Error("invalid entry crc32");
      }
      this.crc = crc;
    };
    ZipArchiveEntry.prototype.setExternalAttributes = function(attr) {
      this.exattr = attr >>> 0;
    };
    ZipArchiveEntry.prototype.setExtra = function(extra) {
      this.extra = extra;
    };
    ZipArchiveEntry.prototype.setGeneralPurposeBit = function(gpb) {
      if (!(gpb instanceof GeneralPurposeBit)) {
        throw new Error("invalid entry GeneralPurposeBit");
      }
      this.gpb = gpb;
    };
    ZipArchiveEntry.prototype.setInternalAttributes = function(attr) {
      this.inattr = attr;
    };
    ZipArchiveEntry.prototype.setMethod = function(method) {
      if (method < 0) {
        throw new Error("invalid entry compression method");
      }
      this.method = method;
    };
    ZipArchiveEntry.prototype.setName = function(name, prependSlash = false) {
      name = normalizePath(name, false).replace(/^\w+:/, "").replace(/^(\.\.\/|\/)+/, "");
      if (prependSlash) {
        name = `/${name}`;
      }
      if (Buffer.byteLength(name) !== name.length) {
        this.getGeneralPurposeBit().useUTF8ForNames(true);
      }
      this.name = name;
    };
    ZipArchiveEntry.prototype.setPlatform = function(platform) {
      this.platform = platform;
    };
    ZipArchiveEntry.prototype.setSize = function(size) {
      if (size < 0) {
        throw new Error("invalid entry size");
      }
      this.size = size;
    };
    ZipArchiveEntry.prototype.setTime = function(time, forceLocalTime) {
      if (!(time instanceof Date)) {
        throw new Error("invalid entry time");
      }
      this.time = zipUtil.dateToDos(time, forceLocalTime);
    };
    ZipArchiveEntry.prototype.setUnixMode = function(mode) {
      mode |= this.isDirectory() ? constants.S_IFDIR : constants.S_IFREG;
      var extattr = 0;
      extattr |= mode << constants.SHORT_SHIFT | (this.isDirectory() ? constants.S_DOS_D : constants.S_DOS_A);
      this.setExternalAttributes(extattr);
      this.mode = mode & constants.MODE_MASK;
      this.platform = constants.PLATFORM_UNIX;
    };
    ZipArchiveEntry.prototype.setVersionNeededToExtract = function(minver) {
      this.minver = minver;
    };
    ZipArchiveEntry.prototype.isDirectory = function() {
      return this.getName().slice(-1) === "/";
    };
    ZipArchiveEntry.prototype.isUnixSymlink = function() {
      return (this.getUnixMode() & UnixStat.FILE_TYPE_FLAG) === UnixStat.LINK_FLAG;
    };
    ZipArchiveEntry.prototype.isZip64 = function() {
      return this.csize > constants.ZIP64_MAGIC || this.size > constants.ZIP64_MAGIC;
    };
  }
});

// ../../../node_modules/compress-commons/node_modules/readable-stream/lib/internal/streams/stream.js
var require_stream6 = __commonJS({
  "../../../node_modules/compress-commons/node_modules/readable-stream/lib/internal/streams/stream.js"(exports2, module2) {
    module2.exports = require("stream");
  }
});

// ../../../node_modules/compress-commons/node_modules/readable-stream/lib/internal/streams/buffer_list.js
var require_buffer_list3 = __commonJS({
  "../../../node_modules/compress-commons/node_modules/readable-stream/lib/internal/streams/buffer_list.js"(exports2, module2) {
    "use strict";
    function ownKeys(object, enumerableOnly) {
      var keys = Object.keys(object);
      if (Object.getOwnPropertySymbols) {
        var symbols = Object.getOwnPropertySymbols(object);
        enumerableOnly && (symbols = symbols.filter(function(sym) {
          return Object.getOwnPropertyDescriptor(object, sym).enumerable;
        })), keys.push.apply(keys, symbols);
      }
      return keys;
    }
    function _objectSpread(target) {
      for (var i = 1; i < arguments.length; i++) {
        var source = null != arguments[i] ? arguments[i] : {};
        i % 2 ? ownKeys(Object(source), true).forEach(function(key) {
          _defineProperty(target, key, source[key]);
        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function(key) {
          Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
        });
      }
      return target;
    }
    function _defineProperty(obj2, key, value) {
      key = _toPropertyKey(key);
      if (key in obj2) {
        Object.defineProperty(obj2, key, { value, enumerable: true, configurable: true, writable: true });
      } else {
        obj2[key] = value;
      }
      return obj2;
    }
    function _classCallCheck(instance, Constructor) {
      if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
      }
    }
    function _defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor)
          descriptor.writable = true;
        Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor);
      }
    }
    function _createClass(Constructor, protoProps, staticProps) {
      if (protoProps)
        _defineProperties(Constructor.prototype, protoProps);
      if (staticProps)
        _defineProperties(Constructor, staticProps);
      Object.defineProperty(Constructor, "prototype", { writable: false });
      return Constructor;
    }
    function _toPropertyKey(arg) {
      var key = _toPrimitive(arg, "string");
      return typeof key === "symbol" ? key : String(key);
    }
    function _toPrimitive(input, hint) {
      if (typeof input !== "object" || input === null)
        return input;
      var prim = input[Symbol.toPrimitive];
      if (prim !== void 0) {
        var res = prim.call(input, hint || "default");
        if (typeof res !== "object")
          return res;
        throw new TypeError("@@toPrimitive must return a primitive value.");
      }
      return (hint === "string" ? String : Number)(input);
    }
    var _require = require("buffer");
    var Buffer2 = _require.Buffer;
    var _require2 = require("util");
    var inspect = _require2.inspect;
    var custom = inspect && inspect.custom || "inspect";
    function copyBuffer(src, target, offset) {
      Buffer2.prototype.copy.call(src, target, offset);
    }
    module2.exports = /* @__PURE__ */ function() {
      function BufferList() {
        _classCallCheck(this, BufferList);
        this.head = null;
        this.tail = null;
        this.length = 0;
      }
      _createClass(BufferList, [{
        key: "push",
        value: function push(v) {
          var entry = {
            data: v,
            next: null
          };
          if (this.length > 0)
            this.tail.next = entry;
          else
            this.head = entry;
          this.tail = entry;
          ++this.length;
        }
      }, {
        key: "unshift",
        value: function unshift(v) {
          var entry = {
            data: v,
            next: this.head
          };
          if (this.length === 0)
            this.tail = entry;
          this.head = entry;
          ++this.length;
        }
      }, {
        key: "shift",
        value: function shift() {
          if (this.length === 0)
            return;
          var ret2 = this.head.data;
          if (this.length === 1)
            this.head = this.tail = null;
          else
            this.head = this.head.next;
          --this.length;
          return ret2;
        }
      }, {
        key: "clear",
        value: function clear() {
          this.head = this.tail = null;
          this.length = 0;
        }
      }, {
        key: "join",
        value: function join(s) {
          if (this.length === 0)
            return "";
          var p = this.head;
          var ret2 = "" + p.data;
          while (p = p.next)
            ret2 += s + p.data;
          return ret2;
        }
      }, {
        key: "concat",
        value: function concat(n) {
          if (this.length === 0)
            return Buffer2.alloc(0);
          var ret2 = Buffer2.allocUnsafe(n >>> 0);
          var p = this.head;
          var i = 0;
          while (p) {
            copyBuffer(p.data, ret2, i);
            i += p.data.length;
            p = p.next;
          }
          return ret2;
        }
        // Consumes a specified amount of bytes or characters from the buffered data.
      }, {
        key: "consume",
        value: function consume(n, hasStrings) {
          var ret2;
          if (n < this.head.data.length) {
            ret2 = this.head.data.slice(0, n);
            this.head.data = this.head.data.slice(n);
          } else if (n === this.head.data.length) {
            ret2 = this.shift();
          } else {
            ret2 = hasStrings ? this._getString(n) : this._getBuffer(n);
          }
          return ret2;
        }
      }, {
        key: "first",
        value: function first() {
          return this.head.data;
        }
        // Consumes a specified amount of characters from the buffered data.
      }, {
        key: "_getString",
        value: function _getString(n) {
          var p = this.head;
          var c = 1;
          var ret2 = p.data;
          n -= ret2.length;
          while (p = p.next) {
            var str = p.data;
            var nb = n > str.length ? str.length : n;
            if (nb === str.length)
              ret2 += str;
            else
              ret2 += str.slice(0, n);
            n -= nb;
            if (n === 0) {
              if (nb === str.length) {
                ++c;
                if (p.next)
                  this.head = p.next;
                else
                  this.head = this.tail = null;
              } else {
                this.head = p;
                p.data = str.slice(nb);
              }
              break;
            }
            ++c;
          }
          this.length -= c;
          return ret2;
        }
        // Consumes a specified amount of bytes from the buffered data.
      }, {
        key: "_getBuffer",
        value: function _getBuffer(n) {
          var ret2 = Buffer2.allocUnsafe(n);
          var p = this.head;
          var c = 1;
          p.data.copy(ret2);
          n -= p.data.length;
          while (p = p.next) {
            var buf = p.data;
            var nb = n > buf.length ? buf.length : n;
            buf.copy(ret2, ret2.length - n, 0, nb);
            n -= nb;
            if (n === 0) {
              if (nb === buf.length) {
                ++c;
                if (p.next)
                  this.head = p.next;
                else
                  this.head = this.tail = null;
              } else {
                this.head = p;
                p.data = buf.slice(nb);
              }
              break;
            }
            ++c;
          }
          this.length -= c;
          return ret2;
        }
        // Make sure the linked list only shows the minimal necessary information.
      }, {
        key: custom,
        value: function value(_2, options) {
          return inspect(this, _objectSpread(_objectSpread({}, options), {}, {
            // Only inspect one level.
            depth: 0,
            // It should not recurse.
            customInspect: false
          }));
        }
      }]);
      return BufferList;
    }();
  }
});

// ../../../node_modules/compress-commons/node_modules/readable-stream/lib/internal/streams/destroy.js
var require_destroy6 = __commonJS({
  "../../../node_modules/compress-commons/node_modules/readable-stream/lib/internal/streams/destroy.js"(exports2, module2) {
    "use strict";
    function destroy(err, cb) {
      var _this = this;
      var readableDestroyed = this._readableState && this._readableState.destroyed;
      var writableDestroyed = this._writableState && this._writableState.destroyed;
      if (readableDestroyed || writableDestroyed) {
        if (cb) {
          cb(err);
        } else if (err) {
          if (!this._writableState) {
            process.nextTick(emitErrorNT, this, err);
          } else if (!this._writableState.errorEmitted) {
            this._writableState.errorEmitted = true;
            process.nextTick(emitErrorNT, this, err);
          }
        }
        return this;
      }
      if (this._readableState) {
        this._readableState.destroyed = true;
      }
      if (this._writableState) {
        this._writableState.destroyed = true;
      }
      this._destroy(err || null, function(err2) {
        if (!cb && err2) {
          if (!_this._writableState) {
            process.nextTick(emitErrorAndCloseNT, _this, err2);
          } else if (!_this._writableState.errorEmitted) {
            _this._writableState.errorEmitted = true;
            process.nextTick(emitErrorAndCloseNT, _this, err2);
          } else {
            process.nextTick(emitCloseNT, _this);
          }
        } else if (cb) {
          process.nextTick(emitCloseNT, _this);
          cb(err2);
        } else {
          process.nextTick(emitCloseNT, _this);
        }
      });
      return this;
    }
    function emitErrorAndCloseNT(self2, err) {
      emitErrorNT(self2, err);
      emitCloseNT(self2);
    }
    function emitCloseNT(self2) {
      if (self2._writableState && !self2._writableState.emitClose)
        return;
      if (self2._readableState && !self2._readableState.emitClose)
        return;
      self2.emit("close");
    }
    function undestroy() {
      if (this._readableState) {
        this._readableState.destroyed = false;
        this._readableState.reading = false;
        this._readableState.ended = false;
        this._readableState.endEmitted = false;
      }
      if (this._writableState) {
        this._writableState.destroyed = false;
        this._writableState.ended = false;
        this._writableState.ending = false;
        this._writableState.finalCalled = false;
        this._writableState.prefinished = false;
        this._writableState.finished = false;
        this._writableState.errorEmitted = false;
      }
    }
    function emitErrorNT(self2, err) {
      self2.emit("error", err);
    }
    function errorOrDestroy(stream, err) {
      var rState = stream._readableState;
      var wState = stream._writableState;
      if (rState && rState.autoDestroy || wState && wState.autoDestroy)
        stream.destroy(err);
      else
        stream.emit("error", err);
    }
    module2.exports = {
      destroy,
      undestroy,
      errorOrDestroy
    };
  }
});

// ../../../node_modules/compress-commons/node_modules/readable-stream/errors.js
var require_errors3 = __commonJS({
  "../../../node_modules/compress-commons/node_modules/readable-stream/errors.js"(exports2, module2) {
    "use strict";
    var codes = {};
    function createErrorType(code, message, Base) {
      if (!Base) {
        Base = Error;
      }
      function getMessage(arg1, arg2, arg3) {
        if (typeof message === "string") {
          return message;
        } else {
          return message(arg1, arg2, arg3);
        }
      }
      class NodeError extends Base {
        constructor(arg1, arg2, arg3) {
          super(getMessage(arg1, arg2, arg3));
        }
      }
      NodeError.prototype.name = Base.name;
      NodeError.prototype.code = code;
      codes[code] = NodeError;
    }
    function oneOf(expected, thing) {
      if (Array.isArray(expected)) {
        const len = expected.length;
        expected = expected.map((i) => String(i));
        if (len > 2) {
          return `one of ${thing} ${expected.slice(0, len - 1).join(", ")}, or ` + expected[len - 1];
        } else if (len === 2) {
          return `one of ${thing} ${expected[0]} or ${expected[1]}`;
        } else {
          return `of ${thing} ${expected[0]}`;
        }
      } else {
        return `of ${thing} ${String(expected)}`;
      }
    }
    function startsWith(str, search, pos) {
      return str.substr(!pos || pos < 0 ? 0 : +pos, search.length) === search;
    }
    function endsWith(str, search, this_len) {
      if (this_len === void 0 || this_len > str.length) {
        this_len = str.length;
      }
      return str.substring(this_len - search.length, this_len) === search;
    }
    function includes(str, search, start) {
      if (typeof start !== "number") {
        start = 0;
      }
      if (start + search.length > str.length) {
        return false;
      } else {
        return str.indexOf(search, start) !== -1;
      }
    }
    createErrorType("ERR_INVALID_OPT_VALUE", function(name, value) {
      return 'The value "' + value + '" is invalid for option "' + name + '"';
    }, TypeError);
    createErrorType("ERR_INVALID_ARG_TYPE", function(name, expected, actual) {
      let determiner;
      if (typeof expected === "string" && startsWith(expected, "not ")) {
        determiner = "must not be";
        expected = expected.replace(/^not /, "");
      } else {
        determiner = "must be";
      }
      let msg;
      if (endsWith(name, " argument")) {
        msg = `The ${name} ${determiner} ${oneOf(expected, "type")}`;
      } else {
        const type = includes(name, ".") ? "property" : "argument";
        msg = `The "${name}" ${type} ${determiner} ${oneOf(expected, "type")}`;
      }
      msg += `. Received type ${typeof actual}`;
      return msg;
    }, TypeError);
    createErrorType("ERR_STREAM_PUSH_AFTER_EOF", "stream.push() after EOF");
    createErrorType("ERR_METHOD_NOT_IMPLEMENTED", function(name) {
      return "The " + name + " method is not implemented";
    });
    createErrorType("ERR_STREAM_PREMATURE_CLOSE", "Premature close");
    createErrorType("ERR_STREAM_DESTROYED", function(name) {
      return "Cannot call " + name + " after a stream was destroyed";
    });
    createErrorType("ERR_MULTIPLE_CALLBACK", "Callback called multiple times");
    createErrorType("ERR_STREAM_CANNOT_PIPE", "Cannot pipe, not readable");
    createErrorType("ERR_STREAM_WRITE_AFTER_END", "write after end");
    createErrorType("ERR_STREAM_NULL_VALUES", "May not write null values to stream", TypeError);
    createErrorType("ERR_UNKNOWN_ENCODING", function(arg) {
      return "Unknown encoding: " + arg;
    }, TypeError);
    createErrorType("ERR_STREAM_UNSHIFT_AFTER_END_EVENT", "stream.unshift() after end event");
    module2.exports.codes = codes;
  }
});

// ../../../node_modules/compress-commons/node_modules/readable-stream/lib/internal/streams/state.js
var require_state3 = __commonJS({
  "../../../node_modules/compress-commons/node_modules/readable-stream/lib/internal/streams/state.js"(exports2, module2) {
    "use strict";
    var ERR_INVALID_OPT_VALUE = require_errors3().codes.ERR_INVALID_OPT_VALUE;
    function highWaterMarkFrom(options, isDuplex, duplexKey) {
      return options.highWaterMark != null ? options.highWaterMark : isDuplex ? options[duplexKey] : null;
    }
    function getHighWaterMark(state, options, duplexKey, isDuplex) {
      var hwm = highWaterMarkFrom(options, isDuplex, duplexKey);
      if (hwm != null) {
        if (!(isFinite(hwm) && Math.floor(hwm) === hwm) || hwm < 0) {
          var name = isDuplex ? duplexKey : "highWaterMark";
          throw new ERR_INVALID_OPT_VALUE(name, hwm);
        }
        return Math.floor(hwm);
      }
      return state.objectMode ? 16 : 16 * 1024;
    }
    module2.exports = {
      getHighWaterMark
    };
  }
});

// ../../../node_modules/compress-commons/node_modules/readable-stream/lib/_stream_writable.js
var require_stream_writable6 = __commonJS({
  "../../../node_modules/compress-commons/node_modules/readable-stream/lib/_stream_writable.js"(exports2, module2) {
    "use strict";
    module2.exports = Writable;
    function CorkedRequest(state) {
      var _this = this;
      this.next = null;
      this.entry = null;
      this.finish = function() {
        onCorkedFinish(_this, state);
      };
    }
    var Duplex;
    Writable.WritableState = WritableState;
    var internalUtil = {
      deprecate: require_node()
    };
    var Stream = require_stream6();
    var Buffer2 = require("buffer").Buffer;
    var OurUint8Array = (typeof global !== "undefined" ? global : typeof window !== "undefined" ? window : typeof self !== "undefined" ? self : {}).Uint8Array || function() {
    };
    function _uint8ArrayToBuffer(chunk) {
      return Buffer2.from(chunk);
    }
    function _isUint8Array(obj2) {
      return Buffer2.isBuffer(obj2) || obj2 instanceof OurUint8Array;
    }
    var destroyImpl = require_destroy6();
    var _require = require_state3();
    var getHighWaterMark = _require.getHighWaterMark;
    var _require$codes = require_errors3().codes;
    var ERR_INVALID_ARG_TYPE = _require$codes.ERR_INVALID_ARG_TYPE;
    var ERR_METHOD_NOT_IMPLEMENTED = _require$codes.ERR_METHOD_NOT_IMPLEMENTED;
    var ERR_MULTIPLE_CALLBACK = _require$codes.ERR_MULTIPLE_CALLBACK;
    var ERR_STREAM_CANNOT_PIPE = _require$codes.ERR_STREAM_CANNOT_PIPE;
    var ERR_STREAM_DESTROYED = _require$codes.ERR_STREAM_DESTROYED;
    var ERR_STREAM_NULL_VALUES = _require$codes.ERR_STREAM_NULL_VALUES;
    var ERR_STREAM_WRITE_AFTER_END = _require$codes.ERR_STREAM_WRITE_AFTER_END;
    var ERR_UNKNOWN_ENCODING = _require$codes.ERR_UNKNOWN_ENCODING;
    var errorOrDestroy = destroyImpl.errorOrDestroy;
    require_inherits()(Writable, Stream);
    function nop() {
    }
    function WritableState(options, stream, isDuplex) {
      Duplex = Duplex || require_stream_duplex6();
      options = options || {};
      if (typeof isDuplex !== "boolean")
        isDuplex = stream instanceof Duplex;
      this.objectMode = !!options.objectMode;
      if (isDuplex)
        this.objectMode = this.objectMode || !!options.writableObjectMode;
      this.highWaterMark = getHighWaterMark(this, options, "writableHighWaterMark", isDuplex);
      this.finalCalled = false;
      this.needDrain = false;
      this.ending = false;
      this.ended = false;
      this.finished = false;
      this.destroyed = false;
      var noDecode = options.decodeStrings === false;
      this.decodeStrings = !noDecode;
      this.defaultEncoding = options.defaultEncoding || "utf8";
      this.length = 0;
      this.writing = false;
      this.corked = 0;
      this.sync = true;
      this.bufferProcessing = false;
      this.onwrite = function(er) {
        onwrite(stream, er);
      };
      this.writecb = null;
      this.writelen = 0;
      this.bufferedRequest = null;
      this.lastBufferedRequest = null;
      this.pendingcb = 0;
      this.prefinished = false;
      this.errorEmitted = false;
      this.emitClose = options.emitClose !== false;
      this.autoDestroy = !!options.autoDestroy;
      this.bufferedRequestCount = 0;
      this.corkedRequestsFree = new CorkedRequest(this);
    }
    WritableState.prototype.getBuffer = function getBuffer() {
      var current = this.bufferedRequest;
      var out = [];
      while (current) {
        out.push(current);
        current = current.next;
      }
      return out;
    };
    (function() {
      try {
        Object.defineProperty(WritableState.prototype, "buffer", {
          get: internalUtil.deprecate(function writableStateBufferGetter() {
            return this.getBuffer();
          }, "_writableState.buffer is deprecated. Use _writableState.getBuffer instead.", "DEP0003")
        });
      } catch (_2) {
      }
    })();
    var realHasInstance;
    if (typeof Symbol === "function" && Symbol.hasInstance && typeof Function.prototype[Symbol.hasInstance] === "function") {
      realHasInstance = Function.prototype[Symbol.hasInstance];
      Object.defineProperty(Writable, Symbol.hasInstance, {
        value: function value(object) {
          if (realHasInstance.call(this, object))
            return true;
          if (this !== Writable)
            return false;
          return object && object._writableState instanceof WritableState;
        }
      });
    } else {
      realHasInstance = function realHasInstance2(object) {
        return object instanceof this;
      };
    }
    function Writable(options) {
      Duplex = Duplex || require_stream_duplex6();
      var isDuplex = this instanceof Duplex;
      if (!isDuplex && !realHasInstance.call(Writable, this))
        return new Writable(options);
      this._writableState = new WritableState(options, this, isDuplex);
      this.writable = true;
      if (options) {
        if (typeof options.write === "function")
          this._write = options.write;
        if (typeof options.writev === "function")
          this._writev = options.writev;
        if (typeof options.destroy === "function")
          this._destroy = options.destroy;
        if (typeof options.final === "function")
          this._final = options.final;
      }
      Stream.call(this);
    }
    Writable.prototype.pipe = function() {
      errorOrDestroy(this, new ERR_STREAM_CANNOT_PIPE());
    };
    function writeAfterEnd(stream, cb) {
      var er = new ERR_STREAM_WRITE_AFTER_END();
      errorOrDestroy(stream, er);
      process.nextTick(cb, er);
    }
    function validChunk(stream, state, chunk, cb) {
      var er;
      if (chunk === null) {
        er = new ERR_STREAM_NULL_VALUES();
      } else if (typeof chunk !== "string" && !state.objectMode) {
        er = new ERR_INVALID_ARG_TYPE("chunk", ["string", "Buffer"], chunk);
      }
      if (er) {
        errorOrDestroy(stream, er);
        process.nextTick(cb, er);
        return false;
      }
      return true;
    }
    Writable.prototype.write = function(chunk, encoding, cb) {
      var state = this._writableState;
      var ret2 = false;
      var isBuf = !state.objectMode && _isUint8Array(chunk);
      if (isBuf && !Buffer2.isBuffer(chunk)) {
        chunk = _uint8ArrayToBuffer(chunk);
      }
      if (typeof encoding === "function") {
        cb = encoding;
        encoding = null;
      }
      if (isBuf)
        encoding = "buffer";
      else if (!encoding)
        encoding = state.defaultEncoding;
      if (typeof cb !== "function")
        cb = nop;
      if (state.ending)
        writeAfterEnd(this, cb);
      else if (isBuf || validChunk(this, state, chunk, cb)) {
        state.pendingcb++;
        ret2 = writeOrBuffer(this, state, isBuf, chunk, encoding, cb);
      }
      return ret2;
    };
    Writable.prototype.cork = function() {
      this._writableState.corked++;
    };
    Writable.prototype.uncork = function() {
      var state = this._writableState;
      if (state.corked) {
        state.corked--;
        if (!state.writing && !state.corked && !state.bufferProcessing && state.bufferedRequest)
          clearBuffer(this, state);
      }
    };
    Writable.prototype.setDefaultEncoding = function setDefaultEncoding(encoding) {
      if (typeof encoding === "string")
        encoding = encoding.toLowerCase();
      if (!(["hex", "utf8", "utf-8", "ascii", "binary", "base64", "ucs2", "ucs-2", "utf16le", "utf-16le", "raw"].indexOf((encoding + "").toLowerCase()) > -1))
        throw new ERR_UNKNOWN_ENCODING(encoding);
      this._writableState.defaultEncoding = encoding;
      return this;
    };
    Object.defineProperty(Writable.prototype, "writableBuffer", {
      // making it explicit this property is not enumerable
      // because otherwise some prototype manipulation in
      // userland will fail
      enumerable: false,
      get: function get() {
        return this._writableState && this._writableState.getBuffer();
      }
    });
    function decodeChunk(state, chunk, encoding) {
      if (!state.objectMode && state.decodeStrings !== false && typeof chunk === "string") {
        chunk = Buffer2.from(chunk, encoding);
      }
      return chunk;
    }
    Object.defineProperty(Writable.prototype, "writableHighWaterMark", {
      // making it explicit this property is not enumerable
      // because otherwise some prototype manipulation in
      // userland will fail
      enumerable: false,
      get: function get() {
        return this._writableState.highWaterMark;
      }
    });
    function writeOrBuffer(stream, state, isBuf, chunk, encoding, cb) {
      if (!isBuf) {
        var newChunk = decodeChunk(state, chunk, encoding);
        if (chunk !== newChunk) {
          isBuf = true;
          encoding = "buffer";
          chunk = newChunk;
        }
      }
      var len = state.objectMode ? 1 : chunk.length;
      state.length += len;
      var ret2 = state.length < state.highWaterMark;
      if (!ret2)
        state.needDrain = true;
      if (state.writing || state.corked) {
        var last = state.lastBufferedRequest;
        state.lastBufferedRequest = {
          chunk,
          encoding,
          isBuf,
          callback: cb,
          next: null
        };
        if (last) {
          last.next = state.lastBufferedRequest;
        } else {
          state.bufferedRequest = state.lastBufferedRequest;
        }
        state.bufferedRequestCount += 1;
      } else {
        doWrite(stream, state, false, len, chunk, encoding, cb);
      }
      return ret2;
    }
    function doWrite(stream, state, writev, len, chunk, encoding, cb) {
      state.writelen = len;
      state.writecb = cb;
      state.writing = true;
      state.sync = true;
      if (state.destroyed)
        state.onwrite(new ERR_STREAM_DESTROYED("write"));
      else if (writev)
        stream._writev(chunk, state.onwrite);
      else
        stream._write(chunk, encoding, state.onwrite);
      state.sync = false;
    }
    function onwriteError(stream, state, sync, er, cb) {
      --state.pendingcb;
      if (sync) {
        process.nextTick(cb, er);
        process.nextTick(finishMaybe, stream, state);
        stream._writableState.errorEmitted = true;
        errorOrDestroy(stream, er);
      } else {
        cb(er);
        stream._writableState.errorEmitted = true;
        errorOrDestroy(stream, er);
        finishMaybe(stream, state);
      }
    }
    function onwriteStateUpdate(state) {
      state.writing = false;
      state.writecb = null;
      state.length -= state.writelen;
      state.writelen = 0;
    }
    function onwrite(stream, er) {
      var state = stream._writableState;
      var sync = state.sync;
      var cb = state.writecb;
      if (typeof cb !== "function")
        throw new ERR_MULTIPLE_CALLBACK();
      onwriteStateUpdate(state);
      if (er)
        onwriteError(stream, state, sync, er, cb);
      else {
        var finished = needFinish(state) || stream.destroyed;
        if (!finished && !state.corked && !state.bufferProcessing && state.bufferedRequest) {
          clearBuffer(stream, state);
        }
        if (sync) {
          process.nextTick(afterWrite, stream, state, finished, cb);
        } else {
          afterWrite(stream, state, finished, cb);
        }
      }
    }
    function afterWrite(stream, state, finished, cb) {
      if (!finished)
        onwriteDrain(stream, state);
      state.pendingcb--;
      cb();
      finishMaybe(stream, state);
    }
    function onwriteDrain(stream, state) {
      if (state.length === 0 && state.needDrain) {
        state.needDrain = false;
        stream.emit("drain");
      }
    }
    function clearBuffer(stream, state) {
      state.bufferProcessing = true;
      var entry = state.bufferedRequest;
      if (stream._writev && entry && entry.next) {
        var l2 = state.bufferedRequestCount;
        var buffer = new Array(l2);
        var holder = state.corkedRequestsFree;
        holder.entry = entry;
        var count = 0;
        var allBuffers = true;
        while (entry) {
          buffer[count] = entry;
          if (!entry.isBuf)
            allBuffers = false;
          entry = entry.next;
          count += 1;
        }
        buffer.allBuffers = allBuffers;
        doWrite(stream, state, true, state.length, buffer, "", holder.finish);
        state.pendingcb++;
        state.lastBufferedRequest = null;
        if (holder.next) {
          state.corkedRequestsFree = holder.next;
          holder.next = null;
        } else {
          state.corkedRequestsFree = new CorkedRequest(state);
        }
        state.bufferedRequestCount = 0;
      } else {
        while (entry) {
          var chunk = entry.chunk;
          var encoding = entry.encoding;
          var cb = entry.callback;
          var len = state.objectMode ? 1 : chunk.length;
          doWrite(stream, state, false, len, chunk, encoding, cb);
          entry = entry.next;
          state.bufferedRequestCount--;
          if (state.writing) {
            break;
          }
        }
        if (entry === null)
          state.lastBufferedRequest = null;
      }
      state.bufferedRequest = entry;
      state.bufferProcessing = false;
    }
    Writable.prototype._write = function(chunk, encoding, cb) {
      cb(new ERR_METHOD_NOT_IMPLEMENTED("_write()"));
    };
    Writable.prototype._writev = null;
    Writable.prototype.end = function(chunk, encoding, cb) {
      var state = this._writableState;
      if (typeof chunk === "function") {
        cb = chunk;
        chunk = null;
        encoding = null;
      } else if (typeof encoding === "function") {
        cb = encoding;
        encoding = null;
      }
      if (chunk !== null && chunk !== void 0)
        this.write(chunk, encoding);
      if (state.corked) {
        state.corked = 1;
        this.uncork();
      }
      if (!state.ending)
        endWritable(this, state, cb);
      return this;
    };
    Object.defineProperty(Writable.prototype, "writableLength", {
      // making it explicit this property is not enumerable
      // because otherwise some prototype manipulation in
      // userland will fail
      enumerable: false,
      get: function get() {
        return this._writableState.length;
      }
    });
    function needFinish(state) {
      return state.ending && state.length === 0 && state.bufferedRequest === null && !state.finished && !state.writing;
    }
    function callFinal(stream, state) {
      stream._final(function(err) {
        state.pendingcb--;
        if (err) {
          errorOrDestroy(stream, err);
        }
        state.prefinished = true;
        stream.emit("prefinish");
        finishMaybe(stream, state);
      });
    }
    function prefinish(stream, state) {
      if (!state.prefinished && !state.finalCalled) {
        if (typeof stream._final === "function" && !state.destroyed) {
          state.pendingcb++;
          state.finalCalled = true;
          process.nextTick(callFinal, stream, state);
        } else {
          state.prefinished = true;
          stream.emit("prefinish");
        }
      }
    }
    function finishMaybe(stream, state) {
      var need = needFinish(state);
      if (need) {
        prefinish(stream, state);
        if (state.pendingcb === 0) {
          state.finished = true;
          stream.emit("finish");
          if (state.autoDestroy) {
            var rState = stream._readableState;
            if (!rState || rState.autoDestroy && rState.endEmitted) {
              stream.destroy();
            }
          }
        }
      }
      return need;
    }
    function endWritable(stream, state, cb) {
      state.ending = true;
      finishMaybe(stream, state);
      if (cb) {
        if (state.finished)
          process.nextTick(cb);
        else
          stream.once("finish", cb);
      }
      state.ended = true;
      stream.writable = false;
    }
    function onCorkedFinish(corkReq, state, err) {
      var entry = corkReq.entry;
      corkReq.entry = null;
      while (entry) {
        var cb = entry.callback;
        state.pendingcb--;
        cb(err);
        entry = entry.next;
      }
      state.corkedRequestsFree.next = corkReq;
    }
    Object.defineProperty(Writable.prototype, "destroyed", {
      // making it explicit this property is not enumerable
      // because otherwise some prototype manipulation in
      // userland will fail
      enumerable: false,
      get: function get() {
        if (this._writableState === void 0) {
          return false;
        }
        return this._writableState.destroyed;
      },
      set: function set(value) {
        if (!this._writableState) {
          return;
        }
        this._writableState.destroyed = value;
      }
    });
    Writable.prototype.destroy = destroyImpl.destroy;
    Writable.prototype._undestroy = destroyImpl.undestroy;
    Writable.prototype._destroy = function(err, cb) {
      cb(err);
    };
  }
});

// ../../../node_modules/compress-commons/node_modules/readable-stream/lib/_stream_duplex.js
var require_stream_duplex6 = __commonJS({
  "../../../node_modules/compress-commons/node_modules/readable-stream/lib/_stream_duplex.js"(exports2, module2) {
    "use strict";
    var objectKeys = Object.keys || function(obj2) {
      var keys2 = [];
      for (var key in obj2)
        keys2.push(key);
      return keys2;
    };
    module2.exports = Duplex;
    var Readable = require_stream_readable6();
    var Writable = require_stream_writable6();
    require_inherits()(Duplex, Readable);
    {
      keys = objectKeys(Writable.prototype);
      for (v = 0; v < keys.length; v++) {
        method = keys[v];
        if (!Duplex.prototype[method])
          Duplex.prototype[method] = Writable.prototype[method];
      }
    }
    var keys;
    var method;
    var v;
    function Duplex(options) {
      if (!(this instanceof Duplex))
        return new Duplex(options);
      Readable.call(this, options);
      Writable.call(this, options);
      this.allowHalfOpen = true;
      if (options) {
        if (options.readable === false)
          this.readable = false;
        if (options.writable === false)
          this.writable = false;
        if (options.allowHalfOpen === false) {
          this.allowHalfOpen = false;
          this.once("end", onend);
        }
      }
    }
    Object.defineProperty(Duplex.prototype, "writableHighWaterMark", {
      // making it explicit this property is not enumerable
      // because otherwise some prototype manipulation in
      // userland will fail
      enumerable: false,
      get: function get() {
        return this._writableState.highWaterMark;
      }
    });
    Object.defineProperty(Duplex.prototype, "writableBuffer", {
      // making it explicit this property is not enumerable
      // because otherwise some prototype manipulation in
      // userland will fail
      enumerable: false,
      get: function get() {
        return this._writableState && this._writableState.getBuffer();
      }
    });
    Object.defineProperty(Duplex.prototype, "writableLength", {
      // making it explicit this property is not enumerable
      // because otherwise some prototype manipulation in
      // userland will fail
      enumerable: false,
      get: function get() {
        return this._writableState.length;
      }
    });
    function onend() {
      if (this._writableState.ended)
        return;
      process.nextTick(onEndNT, this);
    }
    function onEndNT(self2) {
      self2.end();
    }
    Object.defineProperty(Duplex.prototype, "destroyed", {
      // making it explicit this property is not enumerable
      // because otherwise some prototype manipulation in
      // userland will fail
      enumerable: false,
      get: function get() {
        if (this._readableState === void 0 || this._writableState === void 0) {
          return false;
        }
        return this._readableState.destroyed && this._writableState.destroyed;
      },
      set: function set(value) {
        if (this._readableState === void 0 || this._writableState === void 0) {
          return;
        }
        this._readableState.destroyed = value;
        this._writableState.destroyed = value;
      }
    });
  }
});

// ../../../node_modules/compress-commons/node_modules/string_decoder/lib/string_decoder.js
var require_string_decoder6 = __commonJS({
  "../../../node_modules/compress-commons/node_modules/string_decoder/lib/string_decoder.js"(exports2) {
    "use strict";
    var Buffer2 = require_safe_buffer2().Buffer;
    var isEncoding = Buffer2.isEncoding || function(encoding) {
      encoding = "" + encoding;
      switch (encoding && encoding.toLowerCase()) {
        case "hex":
        case "utf8":
        case "utf-8":
        case "ascii":
        case "binary":
        case "base64":
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
        case "raw":
          return true;
        default:
          return false;
      }
    };
    function _normalizeEncoding(enc) {
      if (!enc)
        return "utf8";
      var retried;
      while (true) {
        switch (enc) {
          case "utf8":
          case "utf-8":
            return "utf8";
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
            return "utf16le";
          case "latin1":
          case "binary":
            return "latin1";
          case "base64":
          case "ascii":
          case "hex":
            return enc;
          default:
            if (retried)
              return;
            enc = ("" + enc).toLowerCase();
            retried = true;
        }
      }
    }
    function normalizeEncoding(enc) {
      var nenc = _normalizeEncoding(enc);
      if (typeof nenc !== "string" && (Buffer2.isEncoding === isEncoding || !isEncoding(enc)))
        throw new Error("Unknown encoding: " + enc);
      return nenc || enc;
    }
    exports2.StringDecoder = StringDecoder;
    function StringDecoder(encoding) {
      this.encoding = normalizeEncoding(encoding);
      var nb;
      switch (this.encoding) {
        case "utf16le":
          this.text = utf16Text;
          this.end = utf16End;
          nb = 4;
          break;
        case "utf8":
          this.fillLast = utf8FillLast;
          nb = 4;
          break;
        case "base64":
          this.text = base64Text;
          this.end = base64End;
          nb = 3;
          break;
        default:
          this.write = simpleWrite;
          this.end = simpleEnd;
          return;
      }
      this.lastNeed = 0;
      this.lastTotal = 0;
      this.lastChar = Buffer2.allocUnsafe(nb);
    }
    StringDecoder.prototype.write = function(buf) {
      if (buf.length === 0)
        return "";
      var r;
      var i;
      if (this.lastNeed) {
        r = this.fillLast(buf);
        if (r === void 0)
          return "";
        i = this.lastNeed;
        this.lastNeed = 0;
      } else {
        i = 0;
      }
      if (i < buf.length)
        return r ? r + this.text(buf, i) : this.text(buf, i);
      return r || "";
    };
    StringDecoder.prototype.end = utf8End;
    StringDecoder.prototype.text = utf8Text;
    StringDecoder.prototype.fillLast = function(buf) {
      if (this.lastNeed <= buf.length) {
        buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, this.lastNeed);
        return this.lastChar.toString(this.encoding, 0, this.lastTotal);
      }
      buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, buf.length);
      this.lastNeed -= buf.length;
    };
    function utf8CheckByte(byte) {
      if (byte <= 127)
        return 0;
      else if (byte >> 5 === 6)
        return 2;
      else if (byte >> 4 === 14)
        return 3;
      else if (byte >> 3 === 30)
        return 4;
      return byte >> 6 === 2 ? -1 : -2;
    }
    function utf8CheckIncomplete(self2, buf, i) {
      var j = buf.length - 1;
      if (j < i)
        return 0;
      var nb = utf8CheckByte(buf[j]);
      if (nb >= 0) {
        if (nb > 0)
          self2.lastNeed = nb - 1;
        return nb;
      }
      if (--j < i || nb === -2)
        return 0;
      nb = utf8CheckByte(buf[j]);
      if (nb >= 0) {
        if (nb > 0)
          self2.lastNeed = nb - 2;
        return nb;
      }
      if (--j < i || nb === -2)
        return 0;
      nb = utf8CheckByte(buf[j]);
      if (nb >= 0) {
        if (nb > 0) {
          if (nb === 2)
            nb = 0;
          else
            self2.lastNeed = nb - 3;
        }
        return nb;
      }
      return 0;
    }
    function utf8CheckExtraBytes(self2, buf, p) {
      if ((buf[0] & 192) !== 128) {
        self2.lastNeed = 0;
        return "\uFFFD";
      }
      if (self2.lastNeed > 1 && buf.length > 1) {
        if ((buf[1] & 192) !== 128) {
          self2.lastNeed = 1;
          return "\uFFFD";
        }
        if (self2.lastNeed > 2 && buf.length > 2) {
          if ((buf[2] & 192) !== 128) {
            self2.lastNeed = 2;
            return "\uFFFD";
          }
        }
      }
    }
    function utf8FillLast(buf) {
      var p = this.lastTotal - this.lastNeed;
      var r = utf8CheckExtraBytes(this, buf, p);
      if (r !== void 0)
        return r;
      if (this.lastNeed <= buf.length) {
        buf.copy(this.lastChar, p, 0, this.lastNeed);
        return this.lastChar.toString(this.encoding, 0, this.lastTotal);
      }
      buf.copy(this.lastChar, p, 0, buf.length);
      this.lastNeed -= buf.length;
    }
    function utf8Text(buf, i) {
      var total = utf8CheckIncomplete(this, buf, i);
      if (!this.lastNeed)
        return buf.toString("utf8", i);
      this.lastTotal = total;
      var end = buf.length - (total - this.lastNeed);
      buf.copy(this.lastChar, 0, end);
      return buf.toString("utf8", i, end);
    }
    function utf8End(buf) {
      var r = buf && buf.length ? this.write(buf) : "";
      if (this.lastNeed)
        return r + "\uFFFD";
      return r;
    }
    function utf16Text(buf, i) {
      if ((buf.length - i) % 2 === 0) {
        var r = buf.toString("utf16le", i);
        if (r) {
          var c = r.charCodeAt(r.length - 1);
          if (c >= 55296 && c <= 56319) {
            this.lastNeed = 2;
            this.lastTotal = 4;
            this.lastChar[0] = buf[buf.length - 2];
            this.lastChar[1] = buf[buf.length - 1];
            return r.slice(0, -1);
          }
        }
        return r;
      }
      this.lastNeed = 1;
      this.lastTotal = 2;
      this.lastChar[0] = buf[buf.length - 1];
      return buf.toString("utf16le", i, buf.length - 1);
    }
    function utf16End(buf) {
      var r = buf && buf.length ? this.write(buf) : "";
      if (this.lastNeed) {
        var end = this.lastTotal - this.lastNeed;
        return r + this.lastChar.toString("utf16le", 0, end);
      }
      return r;
    }
    function base64Text(buf, i) {
      var n = (buf.length - i) % 3;
      if (n === 0)
        return buf.toString("base64", i);
      this.lastNeed = 3 - n;
      this.lastTotal = 3;
      if (n === 1) {
        this.lastChar[0] = buf[buf.length - 1];
      } else {
        this.lastChar[0] = buf[buf.length - 2];
        this.lastChar[1] = buf[buf.length - 1];
      }
      return buf.toString("base64", i, buf.length - n);
    }
    function base64End(buf) {
      var r = buf && buf.length ? this.write(buf) : "";
      if (this.lastNeed)
        return r + this.lastChar.toString("base64", 0, 3 - this.lastNeed);
      return r;
    }
    function simpleWrite(buf) {
      return buf.toString(this.encoding);
    }
    function simpleEnd(buf) {
      return buf && buf.length ? this.write(buf) : "";
    }
  }
});

// ../../../node_modules/compress-commons/node_modules/readable-stream/lib/internal/streams/end-of-stream.js
var require_end_of_stream3 = __commonJS({
  "../../../node_modules/compress-commons/node_modules/readable-stream/lib/internal/streams/end-of-stream.js"(exports2, module2) {
    "use strict";
    var ERR_STREAM_PREMATURE_CLOSE = require_errors3().codes.ERR_STREAM_PREMATURE_CLOSE;
    function once(callback) {
      var called = false;
      return function() {
        if (called)
          return;
        called = true;
        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }
        callback.apply(this, args);
      };
    }
    function noop() {
    }
    function isRequest(stream) {
      return stream.setHeader && typeof stream.abort === "function";
    }
    function eos(stream, opts, callback) {
      if (typeof opts === "function")
        return eos(stream, null, opts);
      if (!opts)
        opts = {};
      callback = once(callback || noop);
      var readable = opts.readable || opts.readable !== false && stream.readable;
      var writable = opts.writable || opts.writable !== false && stream.writable;
      var onlegacyfinish = function onlegacyfinish2() {
        if (!stream.writable)
          onfinish();
      };
      var writableEnded = stream._writableState && stream._writableState.finished;
      var onfinish = function onfinish2() {
        writable = false;
        writableEnded = true;
        if (!readable)
          callback.call(stream);
      };
      var readableEnded = stream._readableState && stream._readableState.endEmitted;
      var onend = function onend2() {
        readable = false;
        readableEnded = true;
        if (!writable)
          callback.call(stream);
      };
      var onerror = function onerror2(err) {
        callback.call(stream, err);
      };
      var onclose = function onclose2() {
        var err;
        if (readable && !readableEnded) {
          if (!stream._readableState || !stream._readableState.ended)
            err = new ERR_STREAM_PREMATURE_CLOSE();
          return callback.call(stream, err);
        }
        if (writable && !writableEnded) {
          if (!stream._writableState || !stream._writableState.ended)
            err = new ERR_STREAM_PREMATURE_CLOSE();
          return callback.call(stream, err);
        }
      };
      var onrequest = function onrequest2() {
        stream.req.on("finish", onfinish);
      };
      if (isRequest(stream)) {
        stream.on("complete", onfinish);
        stream.on("abort", onclose);
        if (stream.req)
          onrequest();
        else
          stream.on("request", onrequest);
      } else if (writable && !stream._writableState) {
        stream.on("end", onlegacyfinish);
        stream.on("close", onlegacyfinish);
      }
      stream.on("end", onend);
      stream.on("finish", onfinish);
      if (opts.error !== false)
        stream.on("error", onerror);
      stream.on("close", onclose);
      return function() {
        stream.removeListener("complete", onfinish);
        stream.removeListener("abort", onclose);
        stream.removeListener("request", onrequest);
        if (stream.req)
          stream.req.removeListener("finish", onfinish);
        stream.removeListener("end", onlegacyfinish);
        stream.removeListener("close", onlegacyfinish);
        stream.removeListener("finish", onfinish);
        stream.removeListener("end", onend);
        stream.removeListener("error", onerror);
        stream.removeListener("close", onclose);
      };
    }
    module2.exports = eos;
  }
});

// ../../../node_modules/compress-commons/node_modules/readable-stream/lib/internal/streams/async_iterator.js
var require_async_iterator3 = __commonJS({
  "../../../node_modules/compress-commons/node_modules/readable-stream/lib/internal/streams/async_iterator.js"(exports2, module2) {
    "use strict";
    var _Object$setPrototypeO;
    function _defineProperty(obj2, key, value) {
      key = _toPropertyKey(key);
      if (key in obj2) {
        Object.defineProperty(obj2, key, { value, enumerable: true, configurable: true, writable: true });
      } else {
        obj2[key] = value;
      }
      return obj2;
    }
    function _toPropertyKey(arg) {
      var key = _toPrimitive(arg, "string");
      return typeof key === "symbol" ? key : String(key);
    }
    function _toPrimitive(input, hint) {
      if (typeof input !== "object" || input === null)
        return input;
      var prim = input[Symbol.toPrimitive];
      if (prim !== void 0) {
        var res = prim.call(input, hint || "default");
        if (typeof res !== "object")
          return res;
        throw new TypeError("@@toPrimitive must return a primitive value.");
      }
      return (hint === "string" ? String : Number)(input);
    }
    var finished = require_end_of_stream3();
    var kLastResolve = Symbol("lastResolve");
    var kLastReject = Symbol("lastReject");
    var kError = Symbol("error");
    var kEnded = Symbol("ended");
    var kLastPromise = Symbol("lastPromise");
    var kHandlePromise = Symbol("handlePromise");
    var kStream = Symbol("stream");
    function createIterResult(value, done) {
      return {
        value,
        done
      };
    }
    function readAndResolve(iter) {
      var resolve = iter[kLastResolve];
      if (resolve !== null) {
        var data = iter[kStream].read();
        if (data !== null) {
          iter[kLastPromise] = null;
          iter[kLastResolve] = null;
          iter[kLastReject] = null;
          resolve(createIterResult(data, false));
        }
      }
    }
    function onReadable(iter) {
      process.nextTick(readAndResolve, iter);
    }
    function wrapForNext(lastPromise, iter) {
      return function(resolve, reject) {
        lastPromise.then(function() {
          if (iter[kEnded]) {
            resolve(createIterResult(void 0, true));
            return;
          }
          iter[kHandlePromise](resolve, reject);
        }, reject);
      };
    }
    var AsyncIteratorPrototype = Object.getPrototypeOf(function() {
    });
    var ReadableStreamAsyncIteratorPrototype = Object.setPrototypeOf((_Object$setPrototypeO = {
      get stream() {
        return this[kStream];
      },
      next: function next() {
        var _this = this;
        var error = this[kError];
        if (error !== null) {
          return Promise.reject(error);
        }
        if (this[kEnded]) {
          return Promise.resolve(createIterResult(void 0, true));
        }
        if (this[kStream].destroyed) {
          return new Promise(function(resolve, reject) {
            process.nextTick(function() {
              if (_this[kError]) {
                reject(_this[kError]);
              } else {
                resolve(createIterResult(void 0, true));
              }
            });
          });
        }
        var lastPromise = this[kLastPromise];
        var promise;
        if (lastPromise) {
          promise = new Promise(wrapForNext(lastPromise, this));
        } else {
          var data = this[kStream].read();
          if (data !== null) {
            return Promise.resolve(createIterResult(data, false));
          }
          promise = new Promise(this[kHandlePromise]);
        }
        this[kLastPromise] = promise;
        return promise;
      }
    }, _defineProperty(_Object$setPrototypeO, Symbol.asyncIterator, function() {
      return this;
    }), _defineProperty(_Object$setPrototypeO, "return", function _return() {
      var _this2 = this;
      return new Promise(function(resolve, reject) {
        _this2[kStream].destroy(null, function(err) {
          if (err) {
            reject(err);
            return;
          }
          resolve(createIterResult(void 0, true));
        });
      });
    }), _Object$setPrototypeO), AsyncIteratorPrototype);
    var createReadableStreamAsyncIterator = function createReadableStreamAsyncIterator2(stream) {
      var _Object$create;
      var iterator = Object.create(ReadableStreamAsyncIteratorPrototype, (_Object$create = {}, _defineProperty(_Object$create, kStream, {
        value: stream,
        writable: true
      }), _defineProperty(_Object$create, kLastResolve, {
        value: null,
        writable: true
      }), _defineProperty(_Object$create, kLastReject, {
        value: null,
        writable: true
      }), _defineProperty(_Object$create, kError, {
        value: null,
        writable: true
      }), _defineProperty(_Object$create, kEnded, {
        value: stream._readableState.endEmitted,
        writable: true
      }), _defineProperty(_Object$create, kHandlePromise, {
        value: function value(resolve, reject) {
          var data = iterator[kStream].read();
          if (data) {
            iterator[kLastPromise] = null;
            iterator[kLastResolve] = null;
            iterator[kLastReject] = null;
            resolve(createIterResult(data, false));
          } else {
            iterator[kLastResolve] = resolve;
            iterator[kLastReject] = reject;
          }
        },
        writable: true
      }), _Object$create));
      iterator[kLastPromise] = null;
      finished(stream, function(err) {
        if (err && err.code !== "ERR_STREAM_PREMATURE_CLOSE") {
          var reject = iterator[kLastReject];
          if (reject !== null) {
            iterator[kLastPromise] = null;
            iterator[kLastResolve] = null;
            iterator[kLastReject] = null;
            reject(err);
          }
          iterator[kError] = err;
          return;
        }
        var resolve = iterator[kLastResolve];
        if (resolve !== null) {
          iterator[kLastPromise] = null;
          iterator[kLastResolve] = null;
          iterator[kLastReject] = null;
          resolve(createIterResult(void 0, true));
        }
        iterator[kEnded] = true;
      });
      stream.on("readable", onReadable.bind(null, iterator));
      return iterator;
    };
    module2.exports = createReadableStreamAsyncIterator;
  }
});

// ../../../node_modules/compress-commons/node_modules/readable-stream/lib/internal/streams/from.js
var require_from3 = __commonJS({
  "../../../node_modules/compress-commons/node_modules/readable-stream/lib/internal/streams/from.js"(exports2, module2) {
    "use strict";
    function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {
      try {
        var info = gen[key](arg);
        var value = info.value;
      } catch (error) {
        reject(error);
        return;
      }
      if (info.done) {
        resolve(value);
      } else {
        Promise.resolve(value).then(_next, _throw);
      }
    }
    function _asyncToGenerator(fn) {
      return function() {
        var self2 = this, args = arguments;
        return new Promise(function(resolve, reject) {
          var gen = fn.apply(self2, args);
          function _next(value) {
            asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value);
          }
          function _throw(err) {
            asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err);
          }
          _next(void 0);
        });
      };
    }
    function ownKeys(object, enumerableOnly) {
      var keys = Object.keys(object);
      if (Object.getOwnPropertySymbols) {
        var symbols = Object.getOwnPropertySymbols(object);
        enumerableOnly && (symbols = symbols.filter(function(sym) {
          return Object.getOwnPropertyDescriptor(object, sym).enumerable;
        })), keys.push.apply(keys, symbols);
      }
      return keys;
    }
    function _objectSpread(target) {
      for (var i = 1; i < arguments.length; i++) {
        var source = null != arguments[i] ? arguments[i] : {};
        i % 2 ? ownKeys(Object(source), true).forEach(function(key) {
          _defineProperty(target, key, source[key]);
        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function(key) {
          Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
        });
      }
      return target;
    }
    function _defineProperty(obj2, key, value) {
      key = _toPropertyKey(key);
      if (key in obj2) {
        Object.defineProperty(obj2, key, { value, enumerable: true, configurable: true, writable: true });
      } else {
        obj2[key] = value;
      }
      return obj2;
    }
    function _toPropertyKey(arg) {
      var key = _toPrimitive(arg, "string");
      return typeof key === "symbol" ? key : String(key);
    }
    function _toPrimitive(input, hint) {
      if (typeof input !== "object" || input === null)
        return input;
      var prim = input[Symbol.toPrimitive];
      if (prim !== void 0) {
        var res = prim.call(input, hint || "default");
        if (typeof res !== "object")
          return res;
        throw new TypeError("@@toPrimitive must return a primitive value.");
      }
      return (hint === "string" ? String : Number)(input);
    }
    var ERR_INVALID_ARG_TYPE = require_errors3().codes.ERR_INVALID_ARG_TYPE;
    function from(Readable, iterable, opts) {
      var iterator;
      if (iterable && typeof iterable.next === "function") {
        iterator = iterable;
      } else if (iterable && iterable[Symbol.asyncIterator])
        iterator = iterable[Symbol.asyncIterator]();
      else if (iterable && iterable[Symbol.iterator])
        iterator = iterable[Symbol.iterator]();
      else
        throw new ERR_INVALID_ARG_TYPE("iterable", ["Iterable"], iterable);
      var readable = new Readable(_objectSpread({
        objectMode: true
      }, opts));
      var reading = false;
      readable._read = function() {
        if (!reading) {
          reading = true;
          next();
        }
      };
      function next() {
        return _next2.apply(this, arguments);
      }
      function _next2() {
        _next2 = _asyncToGenerator(function* () {
          try {
            var _yield$iterator$next = yield iterator.next(), value = _yield$iterator$next.value, done = _yield$iterator$next.done;
            if (done) {
              readable.push(null);
            } else if (readable.push(yield value)) {
              next();
            } else {
              reading = false;
            }
          } catch (err) {
            readable.destroy(err);
          }
        });
        return _next2.apply(this, arguments);
      }
      return readable;
    }
    module2.exports = from;
  }
});

// ../../../node_modules/compress-commons/node_modules/readable-stream/lib/_stream_readable.js
var require_stream_readable6 = __commonJS({
  "../../../node_modules/compress-commons/node_modules/readable-stream/lib/_stream_readable.js"(exports2, module2) {
    "use strict";
    module2.exports = Readable;
    var Duplex;
    Readable.ReadableState = ReadableState;
    var EE = require("events").EventEmitter;
    var EElistenerCount = function EElistenerCount2(emitter, type) {
      return emitter.listeners(type).length;
    };
    var Stream = require_stream6();
    var Buffer2 = require("buffer").Buffer;
    var OurUint8Array = (typeof global !== "undefined" ? global : typeof window !== "undefined" ? window : typeof self !== "undefined" ? self : {}).Uint8Array || function() {
    };
    function _uint8ArrayToBuffer(chunk) {
      return Buffer2.from(chunk);
    }
    function _isUint8Array(obj2) {
      return Buffer2.isBuffer(obj2) || obj2 instanceof OurUint8Array;
    }
    var debugUtil = require("util");
    var debug;
    if (debugUtil && debugUtil.debuglog) {
      debug = debugUtil.debuglog("stream");
    } else {
      debug = function debug2() {
      };
    }
    var BufferList = require_buffer_list3();
    var destroyImpl = require_destroy6();
    var _require = require_state3();
    var getHighWaterMark = _require.getHighWaterMark;
    var _require$codes = require_errors3().codes;
    var ERR_INVALID_ARG_TYPE = _require$codes.ERR_INVALID_ARG_TYPE;
    var ERR_STREAM_PUSH_AFTER_EOF = _require$codes.ERR_STREAM_PUSH_AFTER_EOF;
    var ERR_METHOD_NOT_IMPLEMENTED = _require$codes.ERR_METHOD_NOT_IMPLEMENTED;
    var ERR_STREAM_UNSHIFT_AFTER_END_EVENT = _require$codes.ERR_STREAM_UNSHIFT_AFTER_END_EVENT;
    var StringDecoder;
    var createReadableStreamAsyncIterator;
    var from;
    require_inherits()(Readable, Stream);
    var errorOrDestroy = destroyImpl.errorOrDestroy;
    var kProxyEvents = ["error", "close", "destroy", "pause", "resume"];
    function prependListener(emitter, event, fn) {
      if (typeof emitter.prependListener === "function")
        return emitter.prependListener(event, fn);
      if (!emitter._events || !emitter._events[event])
        emitter.on(event, fn);
      else if (Array.isArray(emitter._events[event]))
        emitter._events[event].unshift(fn);
      else
        emitter._events[event] = [fn, emitter._events[event]];
    }
    function ReadableState(options, stream, isDuplex) {
      Duplex = Duplex || require_stream_duplex6();
      options = options || {};
      if (typeof isDuplex !== "boolean")
        isDuplex = stream instanceof Duplex;
      this.objectMode = !!options.objectMode;
      if (isDuplex)
        this.objectMode = this.objectMode || !!options.readableObjectMode;
      this.highWaterMark = getHighWaterMark(this, options, "readableHighWaterMark", isDuplex);
      this.buffer = new BufferList();
      this.length = 0;
      this.pipes = null;
      this.pipesCount = 0;
      this.flowing = null;
      this.ended = false;
      this.endEmitted = false;
      this.reading = false;
      this.sync = true;
      this.needReadable = false;
      this.emittedReadable = false;
      this.readableListening = false;
      this.resumeScheduled = false;
      this.paused = true;
      this.emitClose = options.emitClose !== false;
      this.autoDestroy = !!options.autoDestroy;
      this.destroyed = false;
      this.defaultEncoding = options.defaultEncoding || "utf8";
      this.awaitDrain = 0;
      this.readingMore = false;
      this.decoder = null;
      this.encoding = null;
      if (options.encoding) {
        if (!StringDecoder)
          StringDecoder = require_string_decoder6().StringDecoder;
        this.decoder = new StringDecoder(options.encoding);
        this.encoding = options.encoding;
      }
    }
    function Readable(options) {
      Duplex = Duplex || require_stream_duplex6();
      if (!(this instanceof Readable))
        return new Readable(options);
      var isDuplex = this instanceof Duplex;
      this._readableState = new ReadableState(options, this, isDuplex);
      this.readable = true;
      if (options) {
        if (typeof options.read === "function")
          this._read = options.read;
        if (typeof options.destroy === "function")
          this._destroy = options.destroy;
      }
      Stream.call(this);
    }
    Object.defineProperty(Readable.prototype, "destroyed", {
      // making it explicit this property is not enumerable
      // because otherwise some prototype manipulation in
      // userland will fail
      enumerable: false,
      get: function get() {
        if (this._readableState === void 0) {
          return false;
        }
        return this._readableState.destroyed;
      },
      set: function set(value) {
        if (!this._readableState) {
          return;
        }
        this._readableState.destroyed = value;
      }
    });
    Readable.prototype.destroy = destroyImpl.destroy;
    Readable.prototype._undestroy = destroyImpl.undestroy;
    Readable.prototype._destroy = function(err, cb) {
      cb(err);
    };
    Readable.prototype.push = function(chunk, encoding) {
      var state = this._readableState;
      var skipChunkCheck;
      if (!state.objectMode) {
        if (typeof chunk === "string") {
          encoding = encoding || state.defaultEncoding;
          if (encoding !== state.encoding) {
            chunk = Buffer2.from(chunk, encoding);
            encoding = "";
          }
          skipChunkCheck = true;
        }
      } else {
        skipChunkCheck = true;
      }
      return readableAddChunk(this, chunk, encoding, false, skipChunkCheck);
    };
    Readable.prototype.unshift = function(chunk) {
      return readableAddChunk(this, chunk, null, true, false);
    };
    function readableAddChunk(stream, chunk, encoding, addToFront, skipChunkCheck) {
      debug("readableAddChunk", chunk);
      var state = stream._readableState;
      if (chunk === null) {
        state.reading = false;
        onEofChunk(stream, state);
      } else {
        var er;
        if (!skipChunkCheck)
          er = chunkInvalid(state, chunk);
        if (er) {
          errorOrDestroy(stream, er);
        } else if (state.objectMode || chunk && chunk.length > 0) {
          if (typeof chunk !== "string" && !state.objectMode && Object.getPrototypeOf(chunk) !== Buffer2.prototype) {
            chunk = _uint8ArrayToBuffer(chunk);
          }
          if (addToFront) {
            if (state.endEmitted)
              errorOrDestroy(stream, new ERR_STREAM_UNSHIFT_AFTER_END_EVENT());
            else
              addChunk(stream, state, chunk, true);
          } else if (state.ended) {
            errorOrDestroy(stream, new ERR_STREAM_PUSH_AFTER_EOF());
          } else if (state.destroyed) {
            return false;
          } else {
            state.reading = false;
            if (state.decoder && !encoding) {
              chunk = state.decoder.write(chunk);
              if (state.objectMode || chunk.length !== 0)
                addChunk(stream, state, chunk, false);
              else
                maybeReadMore(stream, state);
            } else {
              addChunk(stream, state, chunk, false);
            }
          }
        } else if (!addToFront) {
          state.reading = false;
          maybeReadMore(stream, state);
        }
      }
      return !state.ended && (state.length < state.highWaterMark || state.length === 0);
    }
    function addChunk(stream, state, chunk, addToFront) {
      if (state.flowing && state.length === 0 && !state.sync) {
        state.awaitDrain = 0;
        stream.emit("data", chunk);
      } else {
        state.length += state.objectMode ? 1 : chunk.length;
        if (addToFront)
          state.buffer.unshift(chunk);
        else
          state.buffer.push(chunk);
        if (state.needReadable)
          emitReadable(stream);
      }
      maybeReadMore(stream, state);
    }
    function chunkInvalid(state, chunk) {
      var er;
      if (!_isUint8Array(chunk) && typeof chunk !== "string" && chunk !== void 0 && !state.objectMode) {
        er = new ERR_INVALID_ARG_TYPE("chunk", ["string", "Buffer", "Uint8Array"], chunk);
      }
      return er;
    }
    Readable.prototype.isPaused = function() {
      return this._readableState.flowing === false;
    };
    Readable.prototype.setEncoding = function(enc) {
      if (!StringDecoder)
        StringDecoder = require_string_decoder6().StringDecoder;
      var decoder = new StringDecoder(enc);
      this._readableState.decoder = decoder;
      this._readableState.encoding = this._readableState.decoder.encoding;
      var p = this._readableState.buffer.head;
      var content = "";
      while (p !== null) {
        content += decoder.write(p.data);
        p = p.next;
      }
      this._readableState.buffer.clear();
      if (content !== "")
        this._readableState.buffer.push(content);
      this._readableState.length = content.length;
      return this;
    };
    var MAX_HWM = 1073741824;
    function computeNewHighWaterMark(n) {
      if (n >= MAX_HWM) {
        n = MAX_HWM;
      } else {
        n--;
        n |= n >>> 1;
        n |= n >>> 2;
        n |= n >>> 4;
        n |= n >>> 8;
        n |= n >>> 16;
        n++;
      }
      return n;
    }
    function howMuchToRead(n, state) {
      if (n <= 0 || state.length === 0 && state.ended)
        return 0;
      if (state.objectMode)
        return 1;
      if (n !== n) {
        if (state.flowing && state.length)
          return state.buffer.head.data.length;
        else
          return state.length;
      }
      if (n > state.highWaterMark)
        state.highWaterMark = computeNewHighWaterMark(n);
      if (n <= state.length)
        return n;
      if (!state.ended) {
        state.needReadable = true;
        return 0;
      }
      return state.length;
    }
    Readable.prototype.read = function(n) {
      debug("read", n);
      n = parseInt(n, 10);
      var state = this._readableState;
      var nOrig = n;
      if (n !== 0)
        state.emittedReadable = false;
      if (n === 0 && state.needReadable && ((state.highWaterMark !== 0 ? state.length >= state.highWaterMark : state.length > 0) || state.ended)) {
        debug("read: emitReadable", state.length, state.ended);
        if (state.length === 0 && state.ended)
          endReadable(this);
        else
          emitReadable(this);
        return null;
      }
      n = howMuchToRead(n, state);
      if (n === 0 && state.ended) {
        if (state.length === 0)
          endReadable(this);
        return null;
      }
      var doRead = state.needReadable;
      debug("need readable", doRead);
      if (state.length === 0 || state.length - n < state.highWaterMark) {
        doRead = true;
        debug("length less than watermark", doRead);
      }
      if (state.ended || state.reading) {
        doRead = false;
        debug("reading or ended", doRead);
      } else if (doRead) {
        debug("do read");
        state.reading = true;
        state.sync = true;
        if (state.length === 0)
          state.needReadable = true;
        this._read(state.highWaterMark);
        state.sync = false;
        if (!state.reading)
          n = howMuchToRead(nOrig, state);
      }
      var ret2;
      if (n > 0)
        ret2 = fromList(n, state);
      else
        ret2 = null;
      if (ret2 === null) {
        state.needReadable = state.length <= state.highWaterMark;
        n = 0;
      } else {
        state.length -= n;
        state.awaitDrain = 0;
      }
      if (state.length === 0) {
        if (!state.ended)
          state.needReadable = true;
        if (nOrig !== n && state.ended)
          endReadable(this);
      }
      if (ret2 !== null)
        this.emit("data", ret2);
      return ret2;
    };
    function onEofChunk(stream, state) {
      debug("onEofChunk");
      if (state.ended)
        return;
      if (state.decoder) {
        var chunk = state.decoder.end();
        if (chunk && chunk.length) {
          state.buffer.push(chunk);
          state.length += state.objectMode ? 1 : chunk.length;
        }
      }
      state.ended = true;
      if (state.sync) {
        emitReadable(stream);
      } else {
        state.needReadable = false;
        if (!state.emittedReadable) {
          state.emittedReadable = true;
          emitReadable_(stream);
        }
      }
    }
    function emitReadable(stream) {
      var state = stream._readableState;
      debug("emitReadable", state.needReadable, state.emittedReadable);
      state.needReadable = false;
      if (!state.emittedReadable) {
        debug("emitReadable", state.flowing);
        state.emittedReadable = true;
        process.nextTick(emitReadable_, stream);
      }
    }
    function emitReadable_(stream) {
      var state = stream._readableState;
      debug("emitReadable_", state.destroyed, state.length, state.ended);
      if (!state.destroyed && (state.length || state.ended)) {
        stream.emit("readable");
        state.emittedReadable = false;
      }
      state.needReadable = !state.flowing && !state.ended && state.length <= state.highWaterMark;
      flow(stream);
    }
    function maybeReadMore(stream, state) {
      if (!state.readingMore) {
        state.readingMore = true;
        process.nextTick(maybeReadMore_, stream, state);
      }
    }
    function maybeReadMore_(stream, state) {
      while (!state.reading && !state.ended && (state.length < state.highWaterMark || state.flowing && state.length === 0)) {
        var len = state.length;
        debug("maybeReadMore read 0");
        stream.read(0);
        if (len === state.length)
          break;
      }
      state.readingMore = false;
    }
    Readable.prototype._read = function(n) {
      errorOrDestroy(this, new ERR_METHOD_NOT_IMPLEMENTED("_read()"));
    };
    Readable.prototype.pipe = function(dest, pipeOpts) {
      var src = this;
      var state = this._readableState;
      switch (state.pipesCount) {
        case 0:
          state.pipes = dest;
          break;
        case 1:
          state.pipes = [state.pipes, dest];
          break;
        default:
          state.pipes.push(dest);
          break;
      }
      state.pipesCount += 1;
      debug("pipe count=%d opts=%j", state.pipesCount, pipeOpts);
      var doEnd = (!pipeOpts || pipeOpts.end !== false) && dest !== process.stdout && dest !== process.stderr;
      var endFn = doEnd ? onend : unpipe;
      if (state.endEmitted)
        process.nextTick(endFn);
      else
        src.once("end", endFn);
      dest.on("unpipe", onunpipe);
      function onunpipe(readable, unpipeInfo) {
        debug("onunpipe");
        if (readable === src) {
          if (unpipeInfo && unpipeInfo.hasUnpiped === false) {
            unpipeInfo.hasUnpiped = true;
            cleanup();
          }
        }
      }
      function onend() {
        debug("onend");
        dest.end();
      }
      var ondrain = pipeOnDrain(src);
      dest.on("drain", ondrain);
      var cleanedUp = false;
      function cleanup() {
        debug("cleanup");
        dest.removeListener("close", onclose);
        dest.removeListener("finish", onfinish);
        dest.removeListener("drain", ondrain);
        dest.removeListener("error", onerror);
        dest.removeListener("unpipe", onunpipe);
        src.removeListener("end", onend);
        src.removeListener("end", unpipe);
        src.removeListener("data", ondata);
        cleanedUp = true;
        if (state.awaitDrain && (!dest._writableState || dest._writableState.needDrain))
          ondrain();
      }
      src.on("data", ondata);
      function ondata(chunk) {
        debug("ondata");
        var ret2 = dest.write(chunk);
        debug("dest.write", ret2);
        if (ret2 === false) {
          if ((state.pipesCount === 1 && state.pipes === dest || state.pipesCount > 1 && indexOf(state.pipes, dest) !== -1) && !cleanedUp) {
            debug("false write response, pause", state.awaitDrain);
            state.awaitDrain++;
          }
          src.pause();
        }
      }
      function onerror(er) {
        debug("onerror", er);
        unpipe();
        dest.removeListener("error", onerror);
        if (EElistenerCount(dest, "error") === 0)
          errorOrDestroy(dest, er);
      }
      prependListener(dest, "error", onerror);
      function onclose() {
        dest.removeListener("finish", onfinish);
        unpipe();
      }
      dest.once("close", onclose);
      function onfinish() {
        debug("onfinish");
        dest.removeListener("close", onclose);
        unpipe();
      }
      dest.once("finish", onfinish);
      function unpipe() {
        debug("unpipe");
        src.unpipe(dest);
      }
      dest.emit("pipe", src);
      if (!state.flowing) {
        debug("pipe resume");
        src.resume();
      }
      return dest;
    };
    function pipeOnDrain(src) {
      return function pipeOnDrainFunctionResult() {
        var state = src._readableState;
        debug("pipeOnDrain", state.awaitDrain);
        if (state.awaitDrain)
          state.awaitDrain--;
        if (state.awaitDrain === 0 && EElistenerCount(src, "data")) {
          state.flowing = true;
          flow(src);
        }
      };
    }
    Readable.prototype.unpipe = function(dest) {
      var state = this._readableState;
      var unpipeInfo = {
        hasUnpiped: false
      };
      if (state.pipesCount === 0)
        return this;
      if (state.pipesCount === 1) {
        if (dest && dest !== state.pipes)
          return this;
        if (!dest)
          dest = state.pipes;
        state.pipes = null;
        state.pipesCount = 0;
        state.flowing = false;
        if (dest)
          dest.emit("unpipe", this, unpipeInfo);
        return this;
      }
      if (!dest) {
        var dests = state.pipes;
        var len = state.pipesCount;
        state.pipes = null;
        state.pipesCount = 0;
        state.flowing = false;
        for (var i = 0; i < len; i++)
          dests[i].emit("unpipe", this, {
            hasUnpiped: false
          });
        return this;
      }
      var index = indexOf(state.pipes, dest);
      if (index === -1)
        return this;
      state.pipes.splice(index, 1);
      state.pipesCount -= 1;
      if (state.pipesCount === 1)
        state.pipes = state.pipes[0];
      dest.emit("unpipe", this, unpipeInfo);
      return this;
    };
    Readable.prototype.on = function(ev, fn) {
      var res = Stream.prototype.on.call(this, ev, fn);
      var state = this._readableState;
      if (ev === "data") {
        state.readableListening = this.listenerCount("readable") > 0;
        if (state.flowing !== false)
          this.resume();
      } else if (ev === "readable") {
        if (!state.endEmitted && !state.readableListening) {
          state.readableListening = state.needReadable = true;
          state.flowing = false;
          state.emittedReadable = false;
          debug("on readable", state.length, state.reading);
          if (state.length) {
            emitReadable(this);
          } else if (!state.reading) {
            process.nextTick(nReadingNextTick, this);
          }
        }
      }
      return res;
    };
    Readable.prototype.addListener = Readable.prototype.on;
    Readable.prototype.removeListener = function(ev, fn) {
      var res = Stream.prototype.removeListener.call(this, ev, fn);
      if (ev === "readable") {
        process.nextTick(updateReadableListening, this);
      }
      return res;
    };
    Readable.prototype.removeAllListeners = function(ev) {
      var res = Stream.prototype.removeAllListeners.apply(this, arguments);
      if (ev === "readable" || ev === void 0) {
        process.nextTick(updateReadableListening, this);
      }
      return res;
    };
    function updateReadableListening(self2) {
      var state = self2._readableState;
      state.readableListening = self2.listenerCount("readable") > 0;
      if (state.resumeScheduled && !state.paused) {
        state.flowing = true;
      } else if (self2.listenerCount("data") > 0) {
        self2.resume();
      }
    }
    function nReadingNextTick(self2) {
      debug("readable nexttick read 0");
      self2.read(0);
    }
    Readable.prototype.resume = function() {
      var state = this._readableState;
      if (!state.flowing) {
        debug("resume");
        state.flowing = !state.readableListening;
        resume(this, state);
      }
      state.paused = false;
      return this;
    };
    function resume(stream, state) {
      if (!state.resumeScheduled) {
        state.resumeScheduled = true;
        process.nextTick(resume_, stream, state);
      }
    }
    function resume_(stream, state) {
      debug("resume", state.reading);
      if (!state.reading) {
        stream.read(0);
      }
      state.resumeScheduled = false;
      stream.emit("resume");
      flow(stream);
      if (state.flowing && !state.reading)
        stream.read(0);
    }
    Readable.prototype.pause = function() {
      debug("call pause flowing=%j", this._readableState.flowing);
      if (this._readableState.flowing !== false) {
        debug("pause");
        this._readableState.flowing = false;
        this.emit("pause");
      }
      this._readableState.paused = true;
      return this;
    };
    function flow(stream) {
      var state = stream._readableState;
      debug("flow", state.flowing);
      while (state.flowing && stream.read() !== null)
        ;
    }
    Readable.prototype.wrap = function(stream) {
      var _this = this;
      var state = this._readableState;
      var paused = false;
      stream.on("end", function() {
        debug("wrapped end");
        if (state.decoder && !state.ended) {
          var chunk = state.decoder.end();
          if (chunk && chunk.length)
            _this.push(chunk);
        }
        _this.push(null);
      });
      stream.on("data", function(chunk) {
        debug("wrapped data");
        if (state.decoder)
          chunk = state.decoder.write(chunk);
        if (state.objectMode && (chunk === null || chunk === void 0))
          return;
        else if (!state.objectMode && (!chunk || !chunk.length))
          return;
        var ret2 = _this.push(chunk);
        if (!ret2) {
          paused = true;
          stream.pause();
        }
      });
      for (var i in stream) {
        if (this[i] === void 0 && typeof stream[i] === "function") {
          this[i] = /* @__PURE__ */ function methodWrap(method) {
            return function methodWrapReturnFunction() {
              return stream[method].apply(stream, arguments);
            };
          }(i);
        }
      }
      for (var n = 0; n < kProxyEvents.length; n++) {
        stream.on(kProxyEvents[n], this.emit.bind(this, kProxyEvents[n]));
      }
      this._read = function(n2) {
        debug("wrapped _read", n2);
        if (paused) {
          paused = false;
          stream.resume();
        }
      };
      return this;
    };
    if (typeof Symbol === "function") {
      Readable.prototype[Symbol.asyncIterator] = function() {
        if (createReadableStreamAsyncIterator === void 0) {
          createReadableStreamAsyncIterator = require_async_iterator3();
        }
        return createReadableStreamAsyncIterator(this);
      };
    }
    Object.defineProperty(Readable.prototype, "readableHighWaterMark", {
      // making it explicit this property is not enumerable
      // because otherwise some prototype manipulation in
      // userland will fail
      enumerable: false,
      get: function get() {
        return this._readableState.highWaterMark;
      }
    });
    Object.defineProperty(Readable.prototype, "readableBuffer", {
      // making it explicit this property is not enumerable
      // because otherwise some prototype manipulation in
      // userland will fail
      enumerable: false,
      get: function get() {
        return this._readableState && this._readableState.buffer;
      }
    });
    Object.defineProperty(Readable.prototype, "readableFlowing", {
      // making it explicit this property is not enumerable
      // because otherwise some prototype manipulation in
      // userland will fail
      enumerable: false,
      get: function get() {
        return this._readableState.flowing;
      },
      set: function set(state) {
        if (this._readableState) {
          this._readableState.flowing = state;
        }
      }
    });
    Readable._fromList = fromList;
    Object.defineProperty(Readable.prototype, "readableLength", {
      // making it explicit this property is not enumerable
      // because otherwise some prototype manipulation in
      // userland will fail
      enumerable: false,
      get: function get() {
        return this._readableState.length;
      }
    });
    function fromList(n, state) {
      if (state.length === 0)
        return null;
      var ret2;
      if (state.objectMode)
        ret2 = state.buffer.shift();
      else if (!n || n >= state.length) {
        if (state.decoder)
          ret2 = state.buffer.join("");
        else if (state.buffer.length === 1)
          ret2 = state.buffer.first();
        else
          ret2 = state.buffer.concat(state.length);
        state.buffer.clear();
      } else {
        ret2 = state.buffer.consume(n, state.decoder);
      }
      return ret2;
    }
    function endReadable(stream) {
      var state = stream._readableState;
      debug("endReadable", state.endEmitted);
      if (!state.endEmitted) {
        state.ended = true;
        process.nextTick(endReadableNT, state, stream);
      }
    }
    function endReadableNT(state, stream) {
      debug("endReadableNT", state.endEmitted, state.length);
      if (!state.endEmitted && state.length === 0) {
        state.endEmitted = true;
        stream.readable = false;
        stream.emit("end");
        if (state.autoDestroy) {
          var wState = stream._writableState;
          if (!wState || wState.autoDestroy && wState.finished) {
            stream.destroy();
          }
        }
      }
    }
    if (typeof Symbol === "function") {
      Readable.from = function(iterable, opts) {
        if (from === void 0) {
          from = require_from3();
        }
        return from(Readable, iterable, opts);
      };
    }
    function indexOf(xs, x) {
      for (var i = 0, l2 = xs.length; i < l2; i++) {
        if (xs[i] === x)
          return i;
      }
      return -1;
    }
  }
});

// ../../../node_modules/compress-commons/node_modules/readable-stream/lib/_stream_transform.js
var require_stream_transform6 = __commonJS({
  "../../../node_modules/compress-commons/node_modules/readable-stream/lib/_stream_transform.js"(exports2, module2) {
    "use strict";
    module2.exports = Transform;
    var _require$codes = require_errors3().codes;
    var ERR_METHOD_NOT_IMPLEMENTED = _require$codes.ERR_METHOD_NOT_IMPLEMENTED;
    var ERR_MULTIPLE_CALLBACK = _require$codes.ERR_MULTIPLE_CALLBACK;
    var ERR_TRANSFORM_ALREADY_TRANSFORMING = _require$codes.ERR_TRANSFORM_ALREADY_TRANSFORMING;
    var ERR_TRANSFORM_WITH_LENGTH_0 = _require$codes.ERR_TRANSFORM_WITH_LENGTH_0;
    var Duplex = require_stream_duplex6();
    require_inherits()(Transform, Duplex);
    function afterTransform(er, data) {
      var ts = this._transformState;
      ts.transforming = false;
      var cb = ts.writecb;
      if (cb === null) {
        return this.emit("error", new ERR_MULTIPLE_CALLBACK());
      }
      ts.writechunk = null;
      ts.writecb = null;
      if (data != null)
        this.push(data);
      cb(er);
      var rs = this._readableState;
      rs.reading = false;
      if (rs.needReadable || rs.length < rs.highWaterMark) {
        this._read(rs.highWaterMark);
      }
    }
    function Transform(options) {
      if (!(this instanceof Transform))
        return new Transform(options);
      Duplex.call(this, options);
      this._transformState = {
        afterTransform: afterTransform.bind(this),
        needTransform: false,
        transforming: false,
        writecb: null,
        writechunk: null,
        writeencoding: null
      };
      this._readableState.needReadable = true;
      this._readableState.sync = false;
      if (options) {
        if (typeof options.transform === "function")
          this._transform = options.transform;
        if (typeof options.flush === "function")
          this._flush = options.flush;
      }
      this.on("prefinish", prefinish);
    }
    function prefinish() {
      var _this = this;
      if (typeof this._flush === "function" && !this._readableState.destroyed) {
        this._flush(function(er, data) {
          done(_this, er, data);
        });
      } else {
        done(this, null, null);
      }
    }
    Transform.prototype.push = function(chunk, encoding) {
      this._transformState.needTransform = false;
      return Duplex.prototype.push.call(this, chunk, encoding);
    };
    Transform.prototype._transform = function(chunk, encoding, cb) {
      cb(new ERR_METHOD_NOT_IMPLEMENTED("_transform()"));
    };
    Transform.prototype._write = function(chunk, encoding, cb) {
      var ts = this._transformState;
      ts.writecb = cb;
      ts.writechunk = chunk;
      ts.writeencoding = encoding;
      if (!ts.transforming) {
        var rs = this._readableState;
        if (ts.needTransform || rs.needReadable || rs.length < rs.highWaterMark)
          this._read(rs.highWaterMark);
      }
    };
    Transform.prototype._read = function(n) {
      var ts = this._transformState;
      if (ts.writechunk !== null && !ts.transforming) {
        ts.transforming = true;
        this._transform(ts.writechunk, ts.writeencoding, ts.afterTransform);
      } else {
        ts.needTransform = true;
      }
    };
    Transform.prototype._destroy = function(err, cb) {
      Duplex.prototype._destroy.call(this, err, function(err2) {
        cb(err2);
      });
    };
    function done(stream, er, data) {
      if (er)
        return stream.emit("error", er);
      if (data != null)
        stream.push(data);
      if (stream._writableState.length)
        throw new ERR_TRANSFORM_WITH_LENGTH_0();
      if (stream._transformState.transforming)
        throw new ERR_TRANSFORM_ALREADY_TRANSFORMING();
      return stream.push(null);
    }
  }
});

// ../../../node_modules/compress-commons/node_modules/readable-stream/lib/_stream_passthrough.js
var require_stream_passthrough6 = __commonJS({
  "../../../node_modules/compress-commons/node_modules/readable-stream/lib/_stream_passthrough.js"(exports2, module2) {
    "use strict";
    module2.exports = PassThrough;
    var Transform = require_stream_transform6();
    require_inherits()(PassThrough, Transform);
    function PassThrough(options) {
      if (!(this instanceof PassThrough))
        return new PassThrough(options);
      Transform.call(this, options);
    }
    PassThrough.prototype._transform = function(chunk, encoding, cb) {
      cb(null, chunk);
    };
  }
});

// ../../../node_modules/compress-commons/node_modules/readable-stream/lib/internal/streams/pipeline.js
var require_pipeline3 = __commonJS({
  "../../../node_modules/compress-commons/node_modules/readable-stream/lib/internal/streams/pipeline.js"(exports2, module2) {
    "use strict";
    var eos;
    function once(callback) {
      var called = false;
      return function() {
        if (called)
          return;
        called = true;
        callback.apply(void 0, arguments);
      };
    }
    var _require$codes = require_errors3().codes;
    var ERR_MISSING_ARGS = _require$codes.ERR_MISSING_ARGS;
    var ERR_STREAM_DESTROYED = _require$codes.ERR_STREAM_DESTROYED;
    function noop(err) {
      if (err)
        throw err;
    }
    function isRequest(stream) {
      return stream.setHeader && typeof stream.abort === "function";
    }
    function destroyer(stream, reading, writing, callback) {
      callback = once(callback);
      var closed = false;
      stream.on("close", function() {
        closed = true;
      });
      if (eos === void 0)
        eos = require_end_of_stream3();
      eos(stream, {
        readable: reading,
        writable: writing
      }, function(err) {
        if (err)
          return callback(err);
        closed = true;
        callback();
      });
      var destroyed = false;
      return function(err) {
        if (closed)
          return;
        if (destroyed)
          return;
        destroyed = true;
        if (isRequest(stream))
          return stream.abort();
        if (typeof stream.destroy === "function")
          return stream.destroy();
        callback(err || new ERR_STREAM_DESTROYED("pipe"));
      };
    }
    function call(fn) {
      fn();
    }
    function pipe(from, to) {
      return from.pipe(to);
    }
    function popCallback(streams) {
      if (!streams.length)
        return noop;
      if (typeof streams[streams.length - 1] !== "function")
        return noop;
      return streams.pop();
    }
    function pipeline() {
      for (var _len = arguments.length, streams = new Array(_len), _key = 0; _key < _len; _key++) {
        streams[_key] = arguments[_key];
      }
      var callback = popCallback(streams);
      if (Array.isArray(streams[0]))
        streams = streams[0];
      if (streams.length < 2) {
        throw new ERR_MISSING_ARGS("streams");
      }
      var error;
      var destroys = streams.map(function(stream, i) {
        var reading = i < streams.length - 1;
        var writing = i > 0;
        return destroyer(stream, reading, writing, function(err) {
          if (!error)
            error = err;
          if (err)
            destroys.forEach(call);
          if (reading)
            return;
          destroys.forEach(call);
          callback(error);
        });
      });
      return streams.reduce(pipe);
    }
    module2.exports = pipeline;
  }
});

// ../../../node_modules/compress-commons/node_modules/readable-stream/readable.js
var require_readable6 = __commonJS({
  "../../../node_modules/compress-commons/node_modules/readable-stream/readable.js"(exports2, module2) {
    var Stream = require("stream");
    if (process.env.READABLE_STREAM === "disable" && Stream) {
      module2.exports = Stream.Readable;
      Object.assign(module2.exports, Stream);
      module2.exports.Stream = Stream;
    } else {
      exports2 = module2.exports = require_stream_readable6();
      exports2.Stream = Stream || exports2;
      exports2.Readable = exports2;
      exports2.Writable = require_stream_writable6();
      exports2.Duplex = require_stream_duplex6();
      exports2.Transform = require_stream_transform6();
      exports2.PassThrough = require_stream_passthrough6();
      exports2.finished = require_end_of_stream3();
      exports2.pipeline = require_pipeline3();
    }
  }
});

// ../../../node_modules/compress-commons/lib/util/index.js
var require_util3 = __commonJS({
  "../../../node_modules/compress-commons/lib/util/index.js"(exports2, module2) {
    var Stream = require("stream").Stream;
    var PassThrough = require_readable6().PassThrough;
    var util = module2.exports = {};
    util.isStream = function(source) {
      return source instanceof Stream;
    };
    util.normalizeInputSource = function(source) {
      if (source === null) {
        return Buffer.alloc(0);
      } else if (typeof source === "string") {
        return Buffer.from(source);
      } else if (util.isStream(source) && !source._readableState) {
        var normalized = new PassThrough();
        source.pipe(normalized);
        return normalized;
      }
      return source;
    };
  }
});

// ../../../node_modules/compress-commons/lib/archivers/archive-output-stream.js
var require_archive_output_stream = __commonJS({
  "../../../node_modules/compress-commons/lib/archivers/archive-output-stream.js"(exports2, module2) {
    var inherits2 = require("util").inherits;
    var Transform = require_readable6().Transform;
    var ArchiveEntry = require_archive_entry();
    var util = require_util3();
    var ArchiveOutputStream = module2.exports = function(options) {
      if (!(this instanceof ArchiveOutputStream)) {
        return new ArchiveOutputStream(options);
      }
      Transform.call(this, options);
      this.offset = 0;
      this._archive = {
        finish: false,
        finished: false,
        processing: false
      };
    };
    inherits2(ArchiveOutputStream, Transform);
    ArchiveOutputStream.prototype._appendBuffer = function(zae, source, callback) {
    };
    ArchiveOutputStream.prototype._appendStream = function(zae, source, callback) {
    };
    ArchiveOutputStream.prototype._emitErrorCallback = function(err) {
      if (err) {
        this.emit("error", err);
      }
    };
    ArchiveOutputStream.prototype._finish = function(ae) {
    };
    ArchiveOutputStream.prototype._normalizeEntry = function(ae) {
    };
    ArchiveOutputStream.prototype._transform = function(chunk, encoding, callback) {
      callback(null, chunk);
    };
    ArchiveOutputStream.prototype.entry = function(ae, source, callback) {
      source = source || null;
      if (typeof callback !== "function") {
        callback = this._emitErrorCallback.bind(this);
      }
      if (!(ae instanceof ArchiveEntry)) {
        callback(new Error("not a valid instance of ArchiveEntry"));
        return;
      }
      if (this._archive.finish || this._archive.finished) {
        callback(new Error("unacceptable entry after finish"));
        return;
      }
      if (this._archive.processing) {
        callback(new Error("already processing an entry"));
        return;
      }
      this._archive.processing = true;
      this._normalizeEntry(ae);
      this._entry = ae;
      source = util.normalizeInputSource(source);
      if (Buffer.isBuffer(source)) {
        this._appendBuffer(ae, source, callback);
      } else if (util.isStream(source)) {
        this._appendStream(ae, source, callback);
      } else {
        this._archive.processing = false;
        callback(new Error("input source must be valid Stream or Buffer instance"));
        return;
      }
      return this;
    };
    ArchiveOutputStream.prototype.finish = function() {
      if (this._archive.processing) {
        this._archive.finish = true;
        return;
      }
      this._finish();
    };
    ArchiveOutputStream.prototype.getBytesWritten = function() {
      return this.offset;
    };
    ArchiveOutputStream.prototype.write = function(chunk, cb) {
      if (chunk) {
        this.offset += chunk.length;
      }
      return Transform.prototype.write.call(this, chunk, cb);
    };
  }
});

// ../../../node_modules/buffer-crc32/index.js
var require_buffer_crc32 = __commonJS({
  "../../../node_modules/buffer-crc32/index.js"(exports2, module2) {
    var Buffer2 = require("buffer").Buffer;
    var CRC_TABLE = [
      0,
      1996959894,
      3993919788,
      2567524794,
      124634137,
      1886057615,
      3915621685,
      2657392035,
      249268274,
      2044508324,
      3772115230,
      2547177864,
      162941995,
      2125561021,
      3887607047,
      2428444049,
      498536548,
      1789927666,
      4089016648,
      2227061214,
      450548861,
      1843258603,
      4107580753,
      2211677639,
      325883990,
      1684777152,
      4251122042,
      2321926636,
      335633487,
      1661365465,
      4195302755,
      2366115317,
      997073096,
      1281953886,
      3579855332,
      2724688242,
      1006888145,
      1258607687,
      3524101629,
      2768942443,
      901097722,
      1119000684,
      3686517206,
      2898065728,
      853044451,
      1172266101,
      3705015759,
      2882616665,
      651767980,
      1373503546,
      3369554304,
      3218104598,
      565507253,
      1454621731,
      3485111705,
      3099436303,
      671266974,
      1594198024,
      3322730930,
      2970347812,
      795835527,
      1483230225,
      3244367275,
      3060149565,
      1994146192,
      31158534,
      2563907772,
      4023717930,
      1907459465,
      112637215,
      2680153253,
      3904427059,
      2013776290,
      251722036,
      2517215374,
      3775830040,
      2137656763,
      141376813,
      2439277719,
      3865271297,
      1802195444,
      476864866,
      2238001368,
      4066508878,
      1812370925,
      453092731,
      2181625025,
      4111451223,
      1706088902,
      314042704,
      2344532202,
      4240017532,
      1658658271,
      366619977,
      2362670323,
      4224994405,
      1303535960,
      984961486,
      2747007092,
      3569037538,
      1256170817,
      1037604311,
      2765210733,
      3554079995,
      1131014506,
      879679996,
      2909243462,
      3663771856,
      1141124467,
      855842277,
      2852801631,
      3708648649,
      1342533948,
      654459306,
      3188396048,
      3373015174,
      1466479909,
      544179635,
      3110523913,
      3462522015,
      1591671054,
      702138776,
      2966460450,
      3352799412,
      1504918807,
      783551873,
      3082640443,
      3233442989,
      3988292384,
      2596254646,
      62317068,
      1957810842,
      3939845945,
      2647816111,
      81470997,
      1943803523,
      3814918930,
      2489596804,
      225274430,
      2053790376,
      3826175755,
      2466906013,
      167816743,
      2097651377,
      4027552580,
      2265490386,
      503444072,
      1762050814,
      4150417245,
      2154129355,
      426522225,
      1852507879,
      4275313526,
      2312317920,
      282753626,
      1742555852,
      4189708143,
      2394877945,
      397917763,
      1622183637,
      3604390888,
      2714866558,
      953729732,
      1340076626,
      3518719985,
      2797360999,
      1068828381,
      1219638859,
      3624741850,
      2936675148,
      906185462,
      1090812512,
      3747672003,
      2825379669,
      829329135,
      1181335161,
      3412177804,
      3160834842,
      628085408,
      1382605366,
      3423369109,
      3138078467,
      570562233,
      1426400815,
      3317316542,
      2998733608,
      733239954,
      1555261956,
      3268935591,
      3050360625,
      752459403,
      1541320221,
      2607071920,
      3965973030,
      1969922972,
      40735498,
      2617837225,
      3943577151,
      1913087877,
      83908371,
      2512341634,
      3803740692,
      2075208622,
      213261112,
      2463272603,
      3855990285,
      2094854071,
      198958881,
      2262029012,
      4057260610,
      1759359992,
      534414190,
      2176718541,
      4139329115,
      1873836001,
      414664567,
      2282248934,
      4279200368,
      1711684554,
      285281116,
      2405801727,
      4167216745,
      1634467795,
      376229701,
      2685067896,
      3608007406,
      1308918612,
      956543938,
      2808555105,
      3495958263,
      1231636301,
      1047427035,
      2932959818,
      3654703836,
      1088359270,
      936918e3,
      2847714899,
      3736837829,
      1202900863,
      817233897,
      3183342108,
      3401237130,
      1404277552,
      615818150,
      3134207493,
      3453421203,
      1423857449,
      601450431,
      3009837614,
      3294710456,
      1567103746,
      711928724,
      3020668471,
      3272380065,
      1510334235,
      755167117
    ];
    if (typeof Int32Array !== "undefined") {
      CRC_TABLE = new Int32Array(CRC_TABLE);
    }
    function ensureBuffer(input) {
      if (Buffer2.isBuffer(input)) {
        return input;
      }
      var hasNewBufferAPI = typeof Buffer2.alloc === "function" && typeof Buffer2.from === "function";
      if (typeof input === "number") {
        return hasNewBufferAPI ? Buffer2.alloc(input) : new Buffer2(input);
      } else if (typeof input === "string") {
        return hasNewBufferAPI ? Buffer2.from(input) : new Buffer2(input);
      } else {
        throw new Error("input must be buffer, number, or string, received " + typeof input);
      }
    }
    function bufferizeInt(num) {
      var tmp = ensureBuffer(4);
      tmp.writeInt32BE(num, 0);
      return tmp;
    }
    function _crc32(buf, previous) {
      buf = ensureBuffer(buf);
      if (Buffer2.isBuffer(previous)) {
        previous = previous.readUInt32BE(0);
      }
      var crc = ~~previous ^ -1;
      for (var n = 0; n < buf.length; n++) {
        crc = CRC_TABLE[(crc ^ buf[n]) & 255] ^ crc >>> 8;
      }
      return crc ^ -1;
    }
    function crc32() {
      return bufferizeInt(_crc32.apply(null, arguments));
    }
    crc32.signed = function() {
      return _crc32.apply(null, arguments);
    };
    crc32.unsigned = function() {
      return _crc32.apply(null, arguments) >>> 0;
    };
    module2.exports = crc32;
  }
});

// ../../../node_modules/crc32-stream/node_modules/readable-stream/lib/internal/streams/stream.js
var require_stream7 = __commonJS({
  "../../../node_modules/crc32-stream/node_modules/readable-stream/lib/internal/streams/stream.js"(exports2, module2) {
    module2.exports = require("stream");
  }
});

// ../../../node_modules/crc32-stream/node_modules/readable-stream/lib/internal/streams/buffer_list.js
var require_buffer_list4 = __commonJS({
  "../../../node_modules/crc32-stream/node_modules/readable-stream/lib/internal/streams/buffer_list.js"(exports2, module2) {
    "use strict";
    function ownKeys(object, enumerableOnly) {
      var keys = Object.keys(object);
      if (Object.getOwnPropertySymbols) {
        var symbols = Object.getOwnPropertySymbols(object);
        enumerableOnly && (symbols = symbols.filter(function(sym) {
          return Object.getOwnPropertyDescriptor(object, sym).enumerable;
        })), keys.push.apply(keys, symbols);
      }
      return keys;
    }
    function _objectSpread(target) {
      for (var i = 1; i < arguments.length; i++) {
        var source = null != arguments[i] ? arguments[i] : {};
        i % 2 ? ownKeys(Object(source), true).forEach(function(key) {
          _defineProperty(target, key, source[key]);
        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function(key) {
          Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
        });
      }
      return target;
    }
    function _defineProperty(obj2, key, value) {
      key = _toPropertyKey(key);
      if (key in obj2) {
        Object.defineProperty(obj2, key, { value, enumerable: true, configurable: true, writable: true });
      } else {
        obj2[key] = value;
      }
      return obj2;
    }
    function _classCallCheck(instance, Constructor) {
      if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
      }
    }
    function _defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor)
          descriptor.writable = true;
        Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor);
      }
    }
    function _createClass(Constructor, protoProps, staticProps) {
      if (protoProps)
        _defineProperties(Constructor.prototype, protoProps);
      if (staticProps)
        _defineProperties(Constructor, staticProps);
      Object.defineProperty(Constructor, "prototype", { writable: false });
      return Constructor;
    }
    function _toPropertyKey(arg) {
      var key = _toPrimitive(arg, "string");
      return typeof key === "symbol" ? key : String(key);
    }
    function _toPrimitive(input, hint) {
      if (typeof input !== "object" || input === null)
        return input;
      var prim = input[Symbol.toPrimitive];
      if (prim !== void 0) {
        var res = prim.call(input, hint || "default");
        if (typeof res !== "object")
          return res;
        throw new TypeError("@@toPrimitive must return a primitive value.");
      }
      return (hint === "string" ? String : Number)(input);
    }
    var _require = require("buffer");
    var Buffer2 = _require.Buffer;
    var _require2 = require("util");
    var inspect = _require2.inspect;
    var custom = inspect && inspect.custom || "inspect";
    function copyBuffer(src, target, offset) {
      Buffer2.prototype.copy.call(src, target, offset);
    }
    module2.exports = /* @__PURE__ */ function() {
      function BufferList() {
        _classCallCheck(this, BufferList);
        this.head = null;
        this.tail = null;
        this.length = 0;
      }
      _createClass(BufferList, [{
        key: "push",
        value: function push(v) {
          var entry = {
            data: v,
            next: null
          };
          if (this.length > 0)
            this.tail.next = entry;
          else
            this.head = entry;
          this.tail = entry;
          ++this.length;
        }
      }, {
        key: "unshift",
        value: function unshift(v) {
          var entry = {
            data: v,
            next: this.head
          };
          if (this.length === 0)
            this.tail = entry;
          this.head = entry;
          ++this.length;
        }
      }, {
        key: "shift",
        value: function shift() {
          if (this.length === 0)
            return;
          var ret2 = this.head.data;
          if (this.length === 1)
            this.head = this.tail = null;
          else
            this.head = this.head.next;
          --this.length;
          return ret2;
        }
      }, {
        key: "clear",
        value: function clear() {
          this.head = this.tail = null;
          this.length = 0;
        }
      }, {
        key: "join",
        value: function join(s) {
          if (this.length === 0)
            return "";
          var p = this.head;
          var ret2 = "" + p.data;
          while (p = p.next)
            ret2 += s + p.data;
          return ret2;
        }
      }, {
        key: "concat",
        value: function concat(n) {
          if (this.length === 0)
            return Buffer2.alloc(0);
          var ret2 = Buffer2.allocUnsafe(n >>> 0);
          var p = this.head;
          var i = 0;
          while (p) {
            copyBuffer(p.data, ret2, i);
            i += p.data.length;
            p = p.next;
          }
          return ret2;
        }
        // Consumes a specified amount of bytes or characters from the buffered data.
      }, {
        key: "consume",
        value: function consume(n, hasStrings) {
          var ret2;
          if (n < this.head.data.length) {
            ret2 = this.head.data.slice(0, n);
            this.head.data = this.head.data.slice(n);
          } else if (n === this.head.data.length) {
            ret2 = this.shift();
          } else {
            ret2 = hasStrings ? this._getString(n) : this._getBuffer(n);
          }
          return ret2;
        }
      }, {
        key: "first",
        value: function first() {
          return this.head.data;
        }
        // Consumes a specified amount of characters from the buffered data.
      }, {
        key: "_getString",
        value: function _getString(n) {
          var p = this.head;
          var c = 1;
          var ret2 = p.data;
          n -= ret2.length;
          while (p = p.next) {
            var str = p.data;
            var nb = n > str.length ? str.length : n;
            if (nb === str.length)
              ret2 += str;
            else
              ret2 += str.slice(0, n);
            n -= nb;
            if (n === 0) {
              if (nb === str.length) {
                ++c;
                if (p.next)
                  this.head = p.next;
                else
                  this.head = this.tail = null;
              } else {
                this.head = p;
                p.data = str.slice(nb);
              }
              break;
            }
            ++c;
          }
          this.length -= c;
          return ret2;
        }
        // Consumes a specified amount of bytes from the buffered data.
      }, {
        key: "_getBuffer",
        value: function _getBuffer(n) {
          var ret2 = Buffer2.allocUnsafe(n);
          var p = this.head;
          var c = 1;
          p.data.copy(ret2);
          n -= p.data.length;
          while (p = p.next) {
            var buf = p.data;
            var nb = n > buf.length ? buf.length : n;
            buf.copy(ret2, ret2.length - n, 0, nb);
            n -= nb;
            if (n === 0) {
              if (nb === buf.length) {
                ++c;
                if (p.next)
                  this.head = p.next;
                else
                  this.head = this.tail = null;
              } else {
                this.head = p;
                p.data = buf.slice(nb);
              }
              break;
            }
            ++c;
          }
          this.length -= c;
          return ret2;
        }
        // Make sure the linked list only shows the minimal necessary information.
      }, {
        key: custom,
        value: function value(_2, options) {
          return inspect(this, _objectSpread(_objectSpread({}, options), {}, {
            // Only inspect one level.
            depth: 0,
            // It should not recurse.
            customInspect: false
          }));
        }
      }]);
      return BufferList;
    }();
  }
});

// ../../../node_modules/crc32-stream/node_modules/readable-stream/lib/internal/streams/destroy.js
var require_destroy7 = __commonJS({
  "../../../node_modules/crc32-stream/node_modules/readable-stream/lib/internal/streams/destroy.js"(exports2, module2) {
    "use strict";
    function destroy(err, cb) {
      var _this = this;
      var readableDestroyed = this._readableState && this._readableState.destroyed;
      var writableDestroyed = this._writableState && this._writableState.destroyed;
      if (readableDestroyed || writableDestroyed) {
        if (cb) {
          cb(err);
        } else if (err) {
          if (!this._writableState) {
            process.nextTick(emitErrorNT, this, err);
          } else if (!this._writableState.errorEmitted) {
            this._writableState.errorEmitted = true;
            process.nextTick(emitErrorNT, this, err);
          }
        }
        return this;
      }
      if (this._readableState) {
        this._readableState.destroyed = true;
      }
      if (this._writableState) {
        this._writableState.destroyed = true;
      }
      this._destroy(err || null, function(err2) {
        if (!cb && err2) {
          if (!_this._writableState) {
            process.nextTick(emitErrorAndCloseNT, _this, err2);
          } else if (!_this._writableState.errorEmitted) {
            _this._writableState.errorEmitted = true;
            process.nextTick(emitErrorAndCloseNT, _this, err2);
          } else {
            process.nextTick(emitCloseNT, _this);
          }
        } else if (cb) {
          process.nextTick(emitCloseNT, _this);
          cb(err2);
        } else {
          process.nextTick(emitCloseNT, _this);
        }
      });
      return this;
    }
    function emitErrorAndCloseNT(self2, err) {
      emitErrorNT(self2, err);
      emitCloseNT(self2);
    }
    function emitCloseNT(self2) {
      if (self2._writableState && !self2._writableState.emitClose)
        return;
      if (self2._readableState && !self2._readableState.emitClose)
        return;
      self2.emit("close");
    }
    function undestroy() {
      if (this._readableState) {
        this._readableState.destroyed = false;
        this._readableState.reading = false;
        this._readableState.ended = false;
        this._readableState.endEmitted = false;
      }
      if (this._writableState) {
        this._writableState.destroyed = false;
        this._writableState.ended = false;
        this._writableState.ending = false;
        this._writableState.finalCalled = false;
        this._writableState.prefinished = false;
        this._writableState.finished = false;
        this._writableState.errorEmitted = false;
      }
    }
    function emitErrorNT(self2, err) {
      self2.emit("error", err);
    }
    function errorOrDestroy(stream, err) {
      var rState = stream._readableState;
      var wState = stream._writableState;
      if (rState && rState.autoDestroy || wState && wState.autoDestroy)
        stream.destroy(err);
      else
        stream.emit("error", err);
    }
    module2.exports = {
      destroy,
      undestroy,
      errorOrDestroy
    };
  }
});

// ../../../node_modules/crc32-stream/node_modules/readable-stream/errors.js
var require_errors4 = __commonJS({
  "../../../node_modules/crc32-stream/node_modules/readable-stream/errors.js"(exports2, module2) {
    "use strict";
    var codes = {};
    function createErrorType(code, message, Base) {
      if (!Base) {
        Base = Error;
      }
      function getMessage(arg1, arg2, arg3) {
        if (typeof message === "string") {
          return message;
        } else {
          return message(arg1, arg2, arg3);
        }
      }
      class NodeError extends Base {
        constructor(arg1, arg2, arg3) {
          super(getMessage(arg1, arg2, arg3));
        }
      }
      NodeError.prototype.name = Base.name;
      NodeError.prototype.code = code;
      codes[code] = NodeError;
    }
    function oneOf(expected, thing) {
      if (Array.isArray(expected)) {
        const len = expected.length;
        expected = expected.map((i) => String(i));
        if (len > 2) {
          return `one of ${thing} ${expected.slice(0, len - 1).join(", ")}, or ` + expected[len - 1];
        } else if (len === 2) {
          return `one of ${thing} ${expected[0]} or ${expected[1]}`;
        } else {
          return `of ${thing} ${expected[0]}`;
        }
      } else {
        return `of ${thing} ${String(expected)}`;
      }
    }
    function startsWith(str, search, pos) {
      return str.substr(!pos || pos < 0 ? 0 : +pos, search.length) === search;
    }
    function endsWith(str, search, this_len) {
      if (this_len === void 0 || this_len > str.length) {
        this_len = str.length;
      }
      return str.substring(this_len - search.length, this_len) === search;
    }
    function includes(str, search, start) {
      if (typeof start !== "number") {
        start = 0;
      }
      if (start + search.length > str.length) {
        return false;
      } else {
        return str.indexOf(search, start) !== -1;
      }
    }
    createErrorType("ERR_INVALID_OPT_VALUE", function(name, value) {
      return 'The value "' + value + '" is invalid for option "' + name + '"';
    }, TypeError);
    createErrorType("ERR_INVALID_ARG_TYPE", function(name, expected, actual) {
      let determiner;
      if (typeof expected === "string" && startsWith(expected, "not ")) {
        determiner = "must not be";
        expected = expected.replace(/^not /, "");
      } else {
        determiner = "must be";
      }
      let msg;
      if (endsWith(name, " argument")) {
        msg = `The ${name} ${determiner} ${oneOf(expected, "type")}`;
      } else {
        const type = includes(name, ".") ? "property" : "argument";
        msg = `The "${name}" ${type} ${determiner} ${oneOf(expected, "type")}`;
      }
      msg += `. Received type ${typeof actual}`;
      return msg;
    }, TypeError);
    createErrorType("ERR_STREAM_PUSH_AFTER_EOF", "stream.push() after EOF");
    createErrorType("ERR_METHOD_NOT_IMPLEMENTED", function(name) {
      return "The " + name + " method is not implemented";
    });
    createErrorType("ERR_STREAM_PREMATURE_CLOSE", "Premature close");
    createErrorType("ERR_STREAM_DESTROYED", function(name) {
      return "Cannot call " + name + " after a stream was destroyed";
    });
    createErrorType("ERR_MULTIPLE_CALLBACK", "Callback called multiple times");
    createErrorType("ERR_STREAM_CANNOT_PIPE", "Cannot pipe, not readable");
    createErrorType("ERR_STREAM_WRITE_AFTER_END", "write after end");
    createErrorType("ERR_STREAM_NULL_VALUES", "May not write null values to stream", TypeError);
    createErrorType("ERR_UNKNOWN_ENCODING", function(arg) {
      return "Unknown encoding: " + arg;
    }, TypeError);
    createErrorType("ERR_STREAM_UNSHIFT_AFTER_END_EVENT", "stream.unshift() after end event");
    module2.exports.codes = codes;
  }
});

// ../../../node_modules/crc32-stream/node_modules/readable-stream/lib/internal/streams/state.js
var require_state4 = __commonJS({
  "../../../node_modules/crc32-stream/node_modules/readable-stream/lib/internal/streams/state.js"(exports2, module2) {
    "use strict";
    var ERR_INVALID_OPT_VALUE = require_errors4().codes.ERR_INVALID_OPT_VALUE;
    function highWaterMarkFrom(options, isDuplex, duplexKey) {
      return options.highWaterMark != null ? options.highWaterMark : isDuplex ? options[duplexKey] : null;
    }
    function getHighWaterMark(state, options, duplexKey, isDuplex) {
      var hwm = highWaterMarkFrom(options, isDuplex, duplexKey);
      if (hwm != null) {
        if (!(isFinite(hwm) && Math.floor(hwm) === hwm) || hwm < 0) {
          var name = isDuplex ? duplexKey : "highWaterMark";
          throw new ERR_INVALID_OPT_VALUE(name, hwm);
        }
        return Math.floor(hwm);
      }
      return state.objectMode ? 16 : 16 * 1024;
    }
    module2.exports = {
      getHighWaterMark
    };
  }
});

// ../../../node_modules/crc32-stream/node_modules/readable-stream/lib/_stream_writable.js
var require_stream_writable7 = __commonJS({
  "../../../node_modules/crc32-stream/node_modules/readable-stream/lib/_stream_writable.js"(exports2, module2) {
    "use strict";
    module2.exports = Writable;
    function CorkedRequest(state) {
      var _this = this;
      this.next = null;
      this.entry = null;
      this.finish = function() {
        onCorkedFinish(_this, state);
      };
    }
    var Duplex;
    Writable.WritableState = WritableState;
    var internalUtil = {
      deprecate: require_node()
    };
    var Stream = require_stream7();
    var Buffer2 = require("buffer").Buffer;
    var OurUint8Array = (typeof global !== "undefined" ? global : typeof window !== "undefined" ? window : typeof self !== "undefined" ? self : {}).Uint8Array || function() {
    };
    function _uint8ArrayToBuffer(chunk) {
      return Buffer2.from(chunk);
    }
    function _isUint8Array(obj2) {
      return Buffer2.isBuffer(obj2) || obj2 instanceof OurUint8Array;
    }
    var destroyImpl = require_destroy7();
    var _require = require_state4();
    var getHighWaterMark = _require.getHighWaterMark;
    var _require$codes = require_errors4().codes;
    var ERR_INVALID_ARG_TYPE = _require$codes.ERR_INVALID_ARG_TYPE;
    var ERR_METHOD_NOT_IMPLEMENTED = _require$codes.ERR_METHOD_NOT_IMPLEMENTED;
    var ERR_MULTIPLE_CALLBACK = _require$codes.ERR_MULTIPLE_CALLBACK;
    var ERR_STREAM_CANNOT_PIPE = _require$codes.ERR_STREAM_CANNOT_PIPE;
    var ERR_STREAM_DESTROYED = _require$codes.ERR_STREAM_DESTROYED;
    var ERR_STREAM_NULL_VALUES = _require$codes.ERR_STREAM_NULL_VALUES;
    var ERR_STREAM_WRITE_AFTER_END = _require$codes.ERR_STREAM_WRITE_AFTER_END;
    var ERR_UNKNOWN_ENCODING = _require$codes.ERR_UNKNOWN_ENCODING;
    var errorOrDestroy = destroyImpl.errorOrDestroy;
    require_inherits()(Writable, Stream);
    function nop() {
    }
    function WritableState(options, stream, isDuplex) {
      Duplex = Duplex || require_stream_duplex7();
      options = options || {};
      if (typeof isDuplex !== "boolean")
        isDuplex = stream instanceof Duplex;
      this.objectMode = !!options.objectMode;
      if (isDuplex)
        this.objectMode = this.objectMode || !!options.writableObjectMode;
      this.highWaterMark = getHighWaterMark(this, options, "writableHighWaterMark", isDuplex);
      this.finalCalled = false;
      this.needDrain = false;
      this.ending = false;
      this.ended = false;
      this.finished = false;
      this.destroyed = false;
      var noDecode = options.decodeStrings === false;
      this.decodeStrings = !noDecode;
      this.defaultEncoding = options.defaultEncoding || "utf8";
      this.length = 0;
      this.writing = false;
      this.corked = 0;
      this.sync = true;
      this.bufferProcessing = false;
      this.onwrite = function(er) {
        onwrite(stream, er);
      };
      this.writecb = null;
      this.writelen = 0;
      this.bufferedRequest = null;
      this.lastBufferedRequest = null;
      this.pendingcb = 0;
      this.prefinished = false;
      this.errorEmitted = false;
      this.emitClose = options.emitClose !== false;
      this.autoDestroy = !!options.autoDestroy;
      this.bufferedRequestCount = 0;
      this.corkedRequestsFree = new CorkedRequest(this);
    }
    WritableState.prototype.getBuffer = function getBuffer() {
      var current = this.bufferedRequest;
      var out = [];
      while (current) {
        out.push(current);
        current = current.next;
      }
      return out;
    };
    (function() {
      try {
        Object.defineProperty(WritableState.prototype, "buffer", {
          get: internalUtil.deprecate(function writableStateBufferGetter() {
            return this.getBuffer();
          }, "_writableState.buffer is deprecated. Use _writableState.getBuffer instead.", "DEP0003")
        });
      } catch (_2) {
      }
    })();
    var realHasInstance;
    if (typeof Symbol === "function" && Symbol.hasInstance && typeof Function.prototype[Symbol.hasInstance] === "function") {
      realHasInstance = Function.prototype[Symbol.hasInstance];
      Object.defineProperty(Writable, Symbol.hasInstance, {
        value: function value(object) {
          if (realHasInstance.call(this, object))
            return true;
          if (this !== Writable)
            return false;
          return object && object._writableState instanceof WritableState;
        }
      });
    } else {
      realHasInstance = function realHasInstance2(object) {
        return object instanceof this;
      };
    }
    function Writable(options) {
      Duplex = Duplex || require_stream_duplex7();
      var isDuplex = this instanceof Duplex;
      if (!isDuplex && !realHasInstance.call(Writable, this))
        return new Writable(options);
      this._writableState = new WritableState(options, this, isDuplex);
      this.writable = true;
      if (options) {
        if (typeof options.write === "function")
          this._write = options.write;
        if (typeof options.writev === "function")
          this._writev = options.writev;
        if (typeof options.destroy === "function")
          this._destroy = options.destroy;
        if (typeof options.final === "function")
          this._final = options.final;
      }
      Stream.call(this);
    }
    Writable.prototype.pipe = function() {
      errorOrDestroy(this, new ERR_STREAM_CANNOT_PIPE());
    };
    function writeAfterEnd(stream, cb) {
      var er = new ERR_STREAM_WRITE_AFTER_END();
      errorOrDestroy(stream, er);
      process.nextTick(cb, er);
    }
    function validChunk(stream, state, chunk, cb) {
      var er;
      if (chunk === null) {
        er = new ERR_STREAM_NULL_VALUES();
      } else if (typeof chunk !== "string" && !state.objectMode) {
        er = new ERR_INVALID_ARG_TYPE("chunk", ["string", "Buffer"], chunk);
      }
      if (er) {
        errorOrDestroy(stream, er);
        process.nextTick(cb, er);
        return false;
      }
      return true;
    }
    Writable.prototype.write = function(chunk, encoding, cb) {
      var state = this._writableState;
      var ret2 = false;
      var isBuf = !state.objectMode && _isUint8Array(chunk);
      if (isBuf && !Buffer2.isBuffer(chunk)) {
        chunk = _uint8ArrayToBuffer(chunk);
      }
      if (typeof encoding === "function") {
        cb = encoding;
        encoding = null;
      }
      if (isBuf)
        encoding = "buffer";
      else if (!encoding)
        encoding = state.defaultEncoding;
      if (typeof cb !== "function")
        cb = nop;
      if (state.ending)
        writeAfterEnd(this, cb);
      else if (isBuf || validChunk(this, state, chunk, cb)) {
        state.pendingcb++;
        ret2 = writeOrBuffer(this, state, isBuf, chunk, encoding, cb);
      }
      return ret2;
    };
    Writable.prototype.cork = function() {
      this._writableState.corked++;
    };
    Writable.prototype.uncork = function() {
      var state = this._writableState;
      if (state.corked) {
        state.corked--;
        if (!state.writing && !state.corked && !state.bufferProcessing && state.bufferedRequest)
          clearBuffer(this, state);
      }
    };
    Writable.prototype.setDefaultEncoding = function setDefaultEncoding(encoding) {
      if (typeof encoding === "string")
        encoding = encoding.toLowerCase();
      if (!(["hex", "utf8", "utf-8", "ascii", "binary", "base64", "ucs2", "ucs-2", "utf16le", "utf-16le", "raw"].indexOf((encoding + "").toLowerCase()) > -1))
        throw new ERR_UNKNOWN_ENCODING(encoding);
      this._writableState.defaultEncoding = encoding;
      return this;
    };
    Object.defineProperty(Writable.prototype, "writableBuffer", {
      // making it explicit this property is not enumerable
      // because otherwise some prototype manipulation in
      // userland will fail
      enumerable: false,
      get: function get() {
        return this._writableState && this._writableState.getBuffer();
      }
    });
    function decodeChunk(state, chunk, encoding) {
      if (!state.objectMode && state.decodeStrings !== false && typeof chunk === "string") {
        chunk = Buffer2.from(chunk, encoding);
      }
      return chunk;
    }
    Object.defineProperty(Writable.prototype, "writableHighWaterMark", {
      // making it explicit this property is not enumerable
      // because otherwise some prototype manipulation in
      // userland will fail
      enumerable: false,
      get: function get() {
        return this._writableState.highWaterMark;
      }
    });
    function writeOrBuffer(stream, state, isBuf, chunk, encoding, cb) {
      if (!isBuf) {
        var newChunk = decodeChunk(state, chunk, encoding);
        if (chunk !== newChunk) {
          isBuf = true;
          encoding = "buffer";
          chunk = newChunk;
        }
      }
      var len = state.objectMode ? 1 : chunk.length;
      state.length += len;
      var ret2 = state.length < state.highWaterMark;
      if (!ret2)
        state.needDrain = true;
      if (state.writing || state.corked) {
        var last = state.lastBufferedRequest;
        state.lastBufferedRequest = {
          chunk,
          encoding,
          isBuf,
          callback: cb,
          next: null
        };
        if (last) {
          last.next = state.lastBufferedRequest;
        } else {
          state.bufferedRequest = state.lastBufferedRequest;
        }
        state.bufferedRequestCount += 1;
      } else {
        doWrite(stream, state, false, len, chunk, encoding, cb);
      }
      return ret2;
    }
    function doWrite(stream, state, writev, len, chunk, encoding, cb) {
      state.writelen = len;
      state.writecb = cb;
      state.writing = true;
      state.sync = true;
      if (state.destroyed)
        state.onwrite(new ERR_STREAM_DESTROYED("write"));
      else if (writev)
        stream._writev(chunk, state.onwrite);
      else
        stream._write(chunk, encoding, state.onwrite);
      state.sync = false;
    }
    function onwriteError(stream, state, sync, er, cb) {
      --state.pendingcb;
      if (sync) {
        process.nextTick(cb, er);
        process.nextTick(finishMaybe, stream, state);
        stream._writableState.errorEmitted = true;
        errorOrDestroy(stream, er);
      } else {
        cb(er);
        stream._writableState.errorEmitted = true;
        errorOrDestroy(stream, er);
        finishMaybe(stream, state);
      }
    }
    function onwriteStateUpdate(state) {
      state.writing = false;
      state.writecb = null;
      state.length -= state.writelen;
      state.writelen = 0;
    }
    function onwrite(stream, er) {
      var state = stream._writableState;
      var sync = state.sync;
      var cb = state.writecb;
      if (typeof cb !== "function")
        throw new ERR_MULTIPLE_CALLBACK();
      onwriteStateUpdate(state);
      if (er)
        onwriteError(stream, state, sync, er, cb);
      else {
        var finished = needFinish(state) || stream.destroyed;
        if (!finished && !state.corked && !state.bufferProcessing && state.bufferedRequest) {
          clearBuffer(stream, state);
        }
        if (sync) {
          process.nextTick(afterWrite, stream, state, finished, cb);
        } else {
          afterWrite(stream, state, finished, cb);
        }
      }
    }
    function afterWrite(stream, state, finished, cb) {
      if (!finished)
        onwriteDrain(stream, state);
      state.pendingcb--;
      cb();
      finishMaybe(stream, state);
    }
    function onwriteDrain(stream, state) {
      if (state.length === 0 && state.needDrain) {
        state.needDrain = false;
        stream.emit("drain");
      }
    }
    function clearBuffer(stream, state) {
      state.bufferProcessing = true;
      var entry = state.bufferedRequest;
      if (stream._writev && entry && entry.next) {
        var l2 = state.bufferedRequestCount;
        var buffer = new Array(l2);
        var holder = state.corkedRequestsFree;
        holder.entry = entry;
        var count = 0;
        var allBuffers = true;
        while (entry) {
          buffer[count] = entry;
          if (!entry.isBuf)
            allBuffers = false;
          entry = entry.next;
          count += 1;
        }
        buffer.allBuffers = allBuffers;
        doWrite(stream, state, true, state.length, buffer, "", holder.finish);
        state.pendingcb++;
        state.lastBufferedRequest = null;
        if (holder.next) {
          state.corkedRequestsFree = holder.next;
          holder.next = null;
        } else {
          state.corkedRequestsFree = new CorkedRequest(state);
        }
        state.bufferedRequestCount = 0;
      } else {
        while (entry) {
          var chunk = entry.chunk;
          var encoding = entry.encoding;
          var cb = entry.callback;
          var len = state.objectMode ? 1 : chunk.length;
          doWrite(stream, state, false, len, chunk, encoding, cb);
          entry = entry.next;
          state.bufferedRequestCount--;
          if (state.writing) {
            break;
          }
        }
        if (entry === null)
          state.lastBufferedRequest = null;
      }
      state.bufferedRequest = entry;
      state.bufferProcessing = false;
    }
    Writable.prototype._write = function(chunk, encoding, cb) {
      cb(new ERR_METHOD_NOT_IMPLEMENTED("_write()"));
    };
    Writable.prototype._writev = null;
    Writable.prototype.end = function(chunk, encoding, cb) {
      var state = this._writableState;
      if (typeof chunk === "function") {
        cb = chunk;
        chunk = null;
        encoding = null;
      } else if (typeof encoding === "function") {
        cb = encoding;
        encoding = null;
      }
      if (chunk !== null && chunk !== void 0)
        this.write(chunk, encoding);
      if (state.corked) {
        state.corked = 1;
        this.uncork();
      }
      if (!state.ending)
        endWritable(this, state, cb);
      return this;
    };
    Object.defineProperty(Writable.prototype, "writableLength", {
      // making it explicit this property is not enumerable
      // because otherwise some prototype manipulation in
      // userland will fail
      enumerable: false,
      get: function get() {
        return this._writableState.length;
      }
    });
    function needFinish(state) {
      return state.ending && state.length === 0 && state.bufferedRequest === null && !state.finished && !state.writing;
    }
    function callFinal(stream, state) {
      stream._final(function(err) {
        state.pendingcb--;
        if (err) {
          errorOrDestroy(stream, err);
        }
        state.prefinished = true;
        stream.emit("prefinish");
        finishMaybe(stream, state);
      });
    }
    function prefinish(stream, state) {
      if (!state.prefinished && !state.finalCalled) {
        if (typeof stream._final === "function" && !state.destroyed) {
          state.pendingcb++;
          state.finalCalled = true;
          process.nextTick(callFinal, stream, state);
        } else {
          state.prefinished = true;
          stream.emit("prefinish");
        }
      }
    }
    function finishMaybe(stream, state) {
      var need = needFinish(state);
      if (need) {
        prefinish(stream, state);
        if (state.pendingcb === 0) {
          state.finished = true;
          stream.emit("finish");
          if (state.autoDestroy) {
            var rState = stream._readableState;
            if (!rState || rState.autoDestroy && rState.endEmitted) {
              stream.destroy();
            }
          }
        }
      }
      return need;
    }
    function endWritable(stream, state, cb) {
      state.ending = true;
      finishMaybe(stream, state);
      if (cb) {
        if (state.finished)
          process.nextTick(cb);
        else
          stream.once("finish", cb);
      }
      state.ended = true;
      stream.writable = false;
    }
    function onCorkedFinish(corkReq, state, err) {
      var entry = corkReq.entry;
      corkReq.entry = null;
      while (entry) {
        var cb = entry.callback;
        state.pendingcb--;
        cb(err);
        entry = entry.next;
      }
      state.corkedRequestsFree.next = corkReq;
    }
    Object.defineProperty(Writable.prototype, "destroyed", {
      // making it explicit this property is not enumerable
      // because otherwise some prototype manipulation in
      // userland will fail
      enumerable: false,
      get: function get() {
        if (this._writableState === void 0) {
          return false;
        }
        return this._writableState.destroyed;
      },
      set: function set(value) {
        if (!this._writableState) {
          return;
        }
        this._writableState.destroyed = value;
      }
    });
    Writable.prototype.destroy = destroyImpl.destroy;
    Writable.prototype._undestroy = destroyImpl.undestroy;
    Writable.prototype._destroy = function(err, cb) {
      cb(err);
    };
  }
});

// ../../../node_modules/crc32-stream/node_modules/readable-stream/lib/_stream_duplex.js
var require_stream_duplex7 = __commonJS({
  "../../../node_modules/crc32-stream/node_modules/readable-stream/lib/_stream_duplex.js"(exports2, module2) {
    "use strict";
    var objectKeys = Object.keys || function(obj2) {
      var keys2 = [];
      for (var key in obj2)
        keys2.push(key);
      return keys2;
    };
    module2.exports = Duplex;
    var Readable = require_stream_readable7();
    var Writable = require_stream_writable7();
    require_inherits()(Duplex, Readable);
    {
      keys = objectKeys(Writable.prototype);
      for (v = 0; v < keys.length; v++) {
        method = keys[v];
        if (!Duplex.prototype[method])
          Duplex.prototype[method] = Writable.prototype[method];
      }
    }
    var keys;
    var method;
    var v;
    function Duplex(options) {
      if (!(this instanceof Duplex))
        return new Duplex(options);
      Readable.call(this, options);
      Writable.call(this, options);
      this.allowHalfOpen = true;
      if (options) {
        if (options.readable === false)
          this.readable = false;
        if (options.writable === false)
          this.writable = false;
        if (options.allowHalfOpen === false) {
          this.allowHalfOpen = false;
          this.once("end", onend);
        }
      }
    }
    Object.defineProperty(Duplex.prototype, "writableHighWaterMark", {
      // making it explicit this property is not enumerable
      // because otherwise some prototype manipulation in
      // userland will fail
      enumerable: false,
      get: function get() {
        return this._writableState.highWaterMark;
      }
    });
    Object.defineProperty(Duplex.prototype, "writableBuffer", {
      // making it explicit this property is not enumerable
      // because otherwise some prototype manipulation in
      // userland will fail
      enumerable: false,
      get: function get() {
        return this._writableState && this._writableState.getBuffer();
      }
    });
    Object.defineProperty(Duplex.prototype, "writableLength", {
      // making it explicit this property is not enumerable
      // because otherwise some prototype manipulation in
      // userland will fail
      enumerable: false,
      get: function get() {
        return this._writableState.length;
      }
    });
    function onend() {
      if (this._writableState.ended)
        return;
      process.nextTick(onEndNT, this);
    }
    function onEndNT(self2) {
      self2.end();
    }
    Object.defineProperty(Duplex.prototype, "destroyed", {
      // making it explicit this property is not enumerable
      // because otherwise some prototype manipulation in
      // userland will fail
      enumerable: false,
      get: function get() {
        if (this._readableState === void 0 || this._writableState === void 0) {
          return false;
        }
        return this._readableState.destroyed && this._writableState.destroyed;
      },
      set: function set(value) {
        if (this._readableState === void 0 || this._writableState === void 0) {
          return;
        }
        this._readableState.destroyed = value;
        this._writableState.destroyed = value;
      }
    });
  }
});

// ../../../node_modules/crc32-stream/node_modules/string_decoder/lib/string_decoder.js
var require_string_decoder7 = __commonJS({
  "../../../node_modules/crc32-stream/node_modules/string_decoder/lib/string_decoder.js"(exports2) {
    "use strict";
    var Buffer2 = require_safe_buffer2().Buffer;
    var isEncoding = Buffer2.isEncoding || function(encoding) {
      encoding = "" + encoding;
      switch (encoding && encoding.toLowerCase()) {
        case "hex":
        case "utf8":
        case "utf-8":
        case "ascii":
        case "binary":
        case "base64":
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
        case "raw":
          return true;
        default:
          return false;
      }
    };
    function _normalizeEncoding(enc) {
      if (!enc)
        return "utf8";
      var retried;
      while (true) {
        switch (enc) {
          case "utf8":
          case "utf-8":
            return "utf8";
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
            return "utf16le";
          case "latin1":
          case "binary":
            return "latin1";
          case "base64":
          case "ascii":
          case "hex":
            return enc;
          default:
            if (retried)
              return;
            enc = ("" + enc).toLowerCase();
            retried = true;
        }
      }
    }
    function normalizeEncoding(enc) {
      var nenc = _normalizeEncoding(enc);
      if (typeof nenc !== "string" && (Buffer2.isEncoding === isEncoding || !isEncoding(enc)))
        throw new Error("Unknown encoding: " + enc);
      return nenc || enc;
    }
    exports2.StringDecoder = StringDecoder;
    function StringDecoder(encoding) {
      this.encoding = normalizeEncoding(encoding);
      var nb;
      switch (this.encoding) {
        case "utf16le":
          this.text = utf16Text;
          this.end = utf16End;
          nb = 4;
          break;
        case "utf8":
          this.fillLast = utf8FillLast;
          nb = 4;
          break;
        case "base64":
          this.text = base64Text;
          this.end = base64End;
          nb = 3;
          break;
        default:
          this.write = simpleWrite;
          this.end = simpleEnd;
          return;
      }
      this.lastNeed = 0;
      this.lastTotal = 0;
      this.lastChar = Buffer2.allocUnsafe(nb);
    }
    StringDecoder.prototype.write = function(buf) {
      if (buf.length === 0)
        return "";
      var r;
      var i;
      if (this.lastNeed) {
        r = this.fillLast(buf);
        if (r === void 0)
          return "";
        i = this.lastNeed;
        this.lastNeed = 0;
      } else {
        i = 0;
      }
      if (i < buf.length)
        return r ? r + this.text(buf, i) : this.text(buf, i);
      return r || "";
    };
    StringDecoder.prototype.end = utf8End;
    StringDecoder.prototype.text = utf8Text;
    StringDecoder.prototype.fillLast = function(buf) {
      if (this.lastNeed <= buf.length) {
        buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, this.lastNeed);
        return this.lastChar.toString(this.encoding, 0, this.lastTotal);
      }
      buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, buf.length);
      this.lastNeed -= buf.length;
    };
    function utf8CheckByte(byte) {
      if (byte <= 127)
        return 0;
      else if (byte >> 5 === 6)
        return 2;
      else if (byte >> 4 === 14)
        return 3;
      else if (byte >> 3 === 30)
        return 4;
      return byte >> 6 === 2 ? -1 : -2;
    }
    function utf8CheckIncomplete(self2, buf, i) {
      var j = buf.length - 1;
      if (j < i)
        return 0;
      var nb = utf8CheckByte(buf[j]);
      if (nb >= 0) {
        if (nb > 0)
          self2.lastNeed = nb - 1;
        return nb;
      }
      if (--j < i || nb === -2)
        return 0;
      nb = utf8CheckByte(buf[j]);
      if (nb >= 0) {
        if (nb > 0)
          self2.lastNeed = nb - 2;
        return nb;
      }
      if (--j < i || nb === -2)
        return 0;
      nb = utf8CheckByte(buf[j]);
      if (nb >= 0) {
        if (nb > 0) {
          if (nb === 2)
            nb = 0;
          else
            self2.lastNeed = nb - 3;
        }
        return nb;
      }
      return 0;
    }
    function utf8CheckExtraBytes(self2, buf, p) {
      if ((buf[0] & 192) !== 128) {
        self2.lastNeed = 0;
        return "\uFFFD";
      }
      if (self2.lastNeed > 1 && buf.length > 1) {
        if ((buf[1] & 192) !== 128) {
          self2.lastNeed = 1;
          return "\uFFFD";
        }
        if (self2.lastNeed > 2 && buf.length > 2) {
          if ((buf[2] & 192) !== 128) {
            self2.lastNeed = 2;
            return "\uFFFD";
          }
        }
      }
    }
    function utf8FillLast(buf) {
      var p = this.lastTotal - this.lastNeed;
      var r = utf8CheckExtraBytes(this, buf, p);
      if (r !== void 0)
        return r;
      if (this.lastNeed <= buf.length) {
        buf.copy(this.lastChar, p, 0, this.lastNeed);
        return this.lastChar.toString(this.encoding, 0, this.lastTotal);
      }
      buf.copy(this.lastChar, p, 0, buf.length);
      this.lastNeed -= buf.length;
    }
    function utf8Text(buf, i) {
      var total = utf8CheckIncomplete(this, buf, i);
      if (!this.lastNeed)
        return buf.toString("utf8", i);
      this.lastTotal = total;
      var end = buf.length - (total - this.lastNeed);
      buf.copy(this.lastChar, 0, end);
      return buf.toString("utf8", i, end);
    }
    function utf8End(buf) {
      var r = buf && buf.length ? this.write(buf) : "";
      if (this.lastNeed)
        return r + "\uFFFD";
      return r;
    }
    function utf16Text(buf, i) {
      if ((buf.length - i) % 2 === 0) {
        var r = buf.toString("utf16le", i);
        if (r) {
          var c = r.charCodeAt(r.length - 1);
          if (c >= 55296 && c <= 56319) {
            this.lastNeed = 2;
            this.lastTotal = 4;
            this.lastChar[0] = buf[buf.length - 2];
            this.lastChar[1] = buf[buf.length - 1];
            return r.slice(0, -1);
          }
        }
        return r;
      }
      this.lastNeed = 1;
      this.lastTotal = 2;
      this.lastChar[0] = buf[buf.length - 1];
      return buf.toString("utf16le", i, buf.length - 1);
    }
    function utf16End(buf) {
      var r = buf && buf.length ? this.write(buf) : "";
      if (this.lastNeed) {
        var end = this.lastTotal - this.lastNeed;
        return r + this.lastChar.toString("utf16le", 0, end);
      }
      return r;
    }
    function base64Text(buf, i) {
      var n = (buf.length - i) % 3;
      if (n === 0)
        return buf.toString("base64", i);
      this.lastNeed = 3 - n;
      this.lastTotal = 3;
      if (n === 1) {
        this.lastChar[0] = buf[buf.length - 1];
      } else {
        this.lastChar[0] = buf[buf.length - 2];
        this.lastChar[1] = buf[buf.length - 1];
      }
      return buf.toString("base64", i, buf.length - n);
    }
    function base64End(buf) {
      var r = buf && buf.length ? this.write(buf) : "";
      if (this.lastNeed)
        return r + this.lastChar.toString("base64", 0, 3 - this.lastNeed);
      return r;
    }
    function simpleWrite(buf) {
      return buf.toString(this.encoding);
    }
    function simpleEnd(buf) {
      return buf && buf.length ? this.write(buf) : "";
    }
  }
});

// ../../../node_modules/crc32-stream/node_modules/readable-stream/lib/internal/streams/end-of-stream.js
var require_end_of_stream4 = __commonJS({
  "../../../node_modules/crc32-stream/node_modules/readable-stream/lib/internal/streams/end-of-stream.js"(exports2, module2) {
    "use strict";
    var ERR_STREAM_PREMATURE_CLOSE = require_errors4().codes.ERR_STREAM_PREMATURE_CLOSE;
    function once(callback) {
      var called = false;
      return function() {
        if (called)
          return;
        called = true;
        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }
        callback.apply(this, args);
      };
    }
    function noop() {
    }
    function isRequest(stream) {
      return stream.setHeader && typeof stream.abort === "function";
    }
    function eos(stream, opts, callback) {
      if (typeof opts === "function")
        return eos(stream, null, opts);
      if (!opts)
        opts = {};
      callback = once(callback || noop);
      var readable = opts.readable || opts.readable !== false && stream.readable;
      var writable = opts.writable || opts.writable !== false && stream.writable;
      var onlegacyfinish = function onlegacyfinish2() {
        if (!stream.writable)
          onfinish();
      };
      var writableEnded = stream._writableState && stream._writableState.finished;
      var onfinish = function onfinish2() {
        writable = false;
        writableEnded = true;
        if (!readable)
          callback.call(stream);
      };
      var readableEnded = stream._readableState && stream._readableState.endEmitted;
      var onend = function onend2() {
        readable = false;
        readableEnded = true;
        if (!writable)
          callback.call(stream);
      };
      var onerror = function onerror2(err) {
        callback.call(stream, err);
      };
      var onclose = function onclose2() {
        var err;
        if (readable && !readableEnded) {
          if (!stream._readableState || !stream._readableState.ended)
            err = new ERR_STREAM_PREMATURE_CLOSE();
          return callback.call(stream, err);
        }
        if (writable && !writableEnded) {
          if (!stream._writableState || !stream._writableState.ended)
            err = new ERR_STREAM_PREMATURE_CLOSE();
          return callback.call(stream, err);
        }
      };
      var onrequest = function onrequest2() {
        stream.req.on("finish", onfinish);
      };
      if (isRequest(stream)) {
        stream.on("complete", onfinish);
        stream.on("abort", onclose);
        if (stream.req)
          onrequest();
        else
          stream.on("request", onrequest);
      } else if (writable && !stream._writableState) {
        stream.on("end", onlegacyfinish);
        stream.on("close", onlegacyfinish);
      }
      stream.on("end", onend);
      stream.on("finish", onfinish);
      if (opts.error !== false)
        stream.on("error", onerror);
      stream.on("close", onclose);
      return function() {
        stream.removeListener("complete", onfinish);
        stream.removeListener("abort", onclose);
        stream.removeListener("request", onrequest);
        if (stream.req)
          stream.req.removeListener("finish", onfinish);
        stream.removeListener("end", onlegacyfinish);
        stream.removeListener("close", onlegacyfinish);
        stream.removeListener("finish", onfinish);
        stream.removeListener("end", onend);
        stream.removeListener("error", onerror);
        stream.removeListener("close", onclose);
      };
    }
    module2.exports = eos;
  }
});

// ../../../node_modules/crc32-stream/node_modules/readable-stream/lib/internal/streams/async_iterator.js
var require_async_iterator4 = __commonJS({
  "../../../node_modules/crc32-stream/node_modules/readable-stream/lib/internal/streams/async_iterator.js"(exports2, module2) {
    "use strict";
    var _Object$setPrototypeO;
    function _defineProperty(obj2, key, value) {
      key = _toPropertyKey(key);
      if (key in obj2) {
        Object.defineProperty(obj2, key, { value, enumerable: true, configurable: true, writable: true });
      } else {
        obj2[key] = value;
      }
      return obj2;
    }
    function _toPropertyKey(arg) {
      var key = _toPrimitive(arg, "string");
      return typeof key === "symbol" ? key : String(key);
    }
    function _toPrimitive(input, hint) {
      if (typeof input !== "object" || input === null)
        return input;
      var prim = input[Symbol.toPrimitive];
      if (prim !== void 0) {
        var res = prim.call(input, hint || "default");
        if (typeof res !== "object")
          return res;
        throw new TypeError("@@toPrimitive must return a primitive value.");
      }
      return (hint === "string" ? String : Number)(input);
    }
    var finished = require_end_of_stream4();
    var kLastResolve = Symbol("lastResolve");
    var kLastReject = Symbol("lastReject");
    var kError = Symbol("error");
    var kEnded = Symbol("ended");
    var kLastPromise = Symbol("lastPromise");
    var kHandlePromise = Symbol("handlePromise");
    var kStream = Symbol("stream");
    function createIterResult(value, done) {
      return {
        value,
        done
      };
    }
    function readAndResolve(iter) {
      var resolve = iter[kLastResolve];
      if (resolve !== null) {
        var data = iter[kStream].read();
        if (data !== null) {
          iter[kLastPromise] = null;
          iter[kLastResolve] = null;
          iter[kLastReject] = null;
          resolve(createIterResult(data, false));
        }
      }
    }
    function onReadable(iter) {
      process.nextTick(readAndResolve, iter);
    }
    function wrapForNext(lastPromise, iter) {
      return function(resolve, reject) {
        lastPromise.then(function() {
          if (iter[kEnded]) {
            resolve(createIterResult(void 0, true));
            return;
          }
          iter[kHandlePromise](resolve, reject);
        }, reject);
      };
    }
    var AsyncIteratorPrototype = Object.getPrototypeOf(function() {
    });
    var ReadableStreamAsyncIteratorPrototype = Object.setPrototypeOf((_Object$setPrototypeO = {
      get stream() {
        return this[kStream];
      },
      next: function next() {
        var _this = this;
        var error = this[kError];
        if (error !== null) {
          return Promise.reject(error);
        }
        if (this[kEnded]) {
          return Promise.resolve(createIterResult(void 0, true));
        }
        if (this[kStream].destroyed) {
          return new Promise(function(resolve, reject) {
            process.nextTick(function() {
              if (_this[kError]) {
                reject(_this[kError]);
              } else {
                resolve(createIterResult(void 0, true));
              }
            });
          });
        }
        var lastPromise = this[kLastPromise];
        var promise;
        if (lastPromise) {
          promise = new Promise(wrapForNext(lastPromise, this));
        } else {
          var data = this[kStream].read();
          if (data !== null) {
            return Promise.resolve(createIterResult(data, false));
          }
          promise = new Promise(this[kHandlePromise]);
        }
        this[kLastPromise] = promise;
        return promise;
      }
    }, _defineProperty(_Object$setPrototypeO, Symbol.asyncIterator, function() {
      return this;
    }), _defineProperty(_Object$setPrototypeO, "return", function _return() {
      var _this2 = this;
      return new Promise(function(resolve, reject) {
        _this2[kStream].destroy(null, function(err) {
          if (err) {
            reject(err);
            return;
          }
          resolve(createIterResult(void 0, true));
        });
      });
    }), _Object$setPrototypeO), AsyncIteratorPrototype);
    var createReadableStreamAsyncIterator = function createReadableStreamAsyncIterator2(stream) {
      var _Object$create;
      var iterator = Object.create(ReadableStreamAsyncIteratorPrototype, (_Object$create = {}, _defineProperty(_Object$create, kStream, {
        value: stream,
        writable: true
      }), _defineProperty(_Object$create, kLastResolve, {
        value: null,
        writable: true
      }), _defineProperty(_Object$create, kLastReject, {
        value: null,
        writable: true
      }), _defineProperty(_Object$create, kError, {
        value: null,
        writable: true
      }), _defineProperty(_Object$create, kEnded, {
        value: stream._readableState.endEmitted,
        writable: true
      }), _defineProperty(_Object$create, kHandlePromise, {
        value: function value(resolve, reject) {
          var data = iterator[kStream].read();
          if (data) {
            iterator[kLastPromise] = null;
            iterator[kLastResolve] = null;
            iterator[kLastReject] = null;
            resolve(createIterResult(data, false));
          } else {
            iterator[kLastResolve] = resolve;
            iterator[kLastReject] = reject;
          }
        },
        writable: true
      }), _Object$create));
      iterator[kLastPromise] = null;
      finished(stream, function(err) {
        if (err && err.code !== "ERR_STREAM_PREMATURE_CLOSE") {
          var reject = iterator[kLastReject];
          if (reject !== null) {
            iterator[kLastPromise] = null;
            iterator[kLastResolve] = null;
            iterator[kLastReject] = null;
            reject(err);
          }
          iterator[kError] = err;
          return;
        }
        var resolve = iterator[kLastResolve];
        if (resolve !== null) {
          iterator[kLastPromise] = null;
          iterator[kLastResolve] = null;
          iterator[kLastReject] = null;
          resolve(createIterResult(void 0, true));
        }
        iterator[kEnded] = true;
      });
      stream.on("readable", onReadable.bind(null, iterator));
      return iterator;
    };
    module2.exports = createReadableStreamAsyncIterator;
  }
});

// ../../../node_modules/crc32-stream/node_modules/readable-stream/lib/internal/streams/from.js
var require_from4 = __commonJS({
  "../../../node_modules/crc32-stream/node_modules/readable-stream/lib/internal/streams/from.js"(exports2, module2) {
    "use strict";
    function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {
      try {
        var info = gen[key](arg);
        var value = info.value;
      } catch (error) {
        reject(error);
        return;
      }
      if (info.done) {
        resolve(value);
      } else {
        Promise.resolve(value).then(_next, _throw);
      }
    }
    function _asyncToGenerator(fn) {
      return function() {
        var self2 = this, args = arguments;
        return new Promise(function(resolve, reject) {
          var gen = fn.apply(self2, args);
          function _next(value) {
            asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value);
          }
          function _throw(err) {
            asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err);
          }
          _next(void 0);
        });
      };
    }
    function ownKeys(object, enumerableOnly) {
      var keys = Object.keys(object);
      if (Object.getOwnPropertySymbols) {
        var symbols = Object.getOwnPropertySymbols(object);
        enumerableOnly && (symbols = symbols.filter(function(sym) {
          return Object.getOwnPropertyDescriptor(object, sym).enumerable;
        })), keys.push.apply(keys, symbols);
      }
      return keys;
    }
    function _objectSpread(target) {
      for (var i = 1; i < arguments.length; i++) {
        var source = null != arguments[i] ? arguments[i] : {};
        i % 2 ? ownKeys(Object(source), true).forEach(function(key) {
          _defineProperty(target, key, source[key]);
        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function(key) {
          Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
        });
      }
      return target;
    }
    function _defineProperty(obj2, key, value) {
      key = _toPropertyKey(key);
      if (key in obj2) {
        Object.defineProperty(obj2, key, { value, enumerable: true, configurable: true, writable: true });
      } else {
        obj2[key] = value;
      }
      return obj2;
    }
    function _toPropertyKey(arg) {
      var key = _toPrimitive(arg, "string");
      return typeof key === "symbol" ? key : String(key);
    }
    function _toPrimitive(input, hint) {
      if (typeof input !== "object" || input === null)
        return input;
      var prim = input[Symbol.toPrimitive];
      if (prim !== void 0) {
        var res = prim.call(input, hint || "default");
        if (typeof res !== "object")
          return res;
        throw new TypeError("@@toPrimitive must return a primitive value.");
      }
      return (hint === "string" ? String : Number)(input);
    }
    var ERR_INVALID_ARG_TYPE = require_errors4().codes.ERR_INVALID_ARG_TYPE;
    function from(Readable, iterable, opts) {
      var iterator;
      if (iterable && typeof iterable.next === "function") {
        iterator = iterable;
      } else if (iterable && iterable[Symbol.asyncIterator])
        iterator = iterable[Symbol.asyncIterator]();
      else if (iterable && iterable[Symbol.iterator])
        iterator = iterable[Symbol.iterator]();
      else
        throw new ERR_INVALID_ARG_TYPE("iterable", ["Iterable"], iterable);
      var readable = new Readable(_objectSpread({
        objectMode: true
      }, opts));
      var reading = false;
      readable._read = function() {
        if (!reading) {
          reading = true;
          next();
        }
      };
      function next() {
        return _next2.apply(this, arguments);
      }
      function _next2() {
        _next2 = _asyncToGenerator(function* () {
          try {
            var _yield$iterator$next = yield iterator.next(), value = _yield$iterator$next.value, done = _yield$iterator$next.done;
            if (done) {
              readable.push(null);
            } else if (readable.push(yield value)) {
              next();
            } else {
              reading = false;
            }
          } catch (err) {
            readable.destroy(err);
          }
        });
        return _next2.apply(this, arguments);
      }
      return readable;
    }
    module2.exports = from;
  }
});

// ../../../node_modules/crc32-stream/node_modules/readable-stream/lib/_stream_readable.js
var require_stream_readable7 = __commonJS({
  "../../../node_modules/crc32-stream/node_modules/readable-stream/lib/_stream_readable.js"(exports2, module2) {
    "use strict";
    module2.exports = Readable;
    var Duplex;
    Readable.ReadableState = ReadableState;
    var EE = require("events").EventEmitter;
    var EElistenerCount = function EElistenerCount2(emitter, type) {
      return emitter.listeners(type).length;
    };
    var Stream = require_stream7();
    var Buffer2 = require("buffer").Buffer;
    var OurUint8Array = (typeof global !== "undefined" ? global : typeof window !== "undefined" ? window : typeof self !== "undefined" ? self : {}).Uint8Array || function() {
    };
    function _uint8ArrayToBuffer(chunk) {
      return Buffer2.from(chunk);
    }
    function _isUint8Array(obj2) {
      return Buffer2.isBuffer(obj2) || obj2 instanceof OurUint8Array;
    }
    var debugUtil = require("util");
    var debug;
    if (debugUtil && debugUtil.debuglog) {
      debug = debugUtil.debuglog("stream");
    } else {
      debug = function debug2() {
      };
    }
    var BufferList = require_buffer_list4();
    var destroyImpl = require_destroy7();
    var _require = require_state4();
    var getHighWaterMark = _require.getHighWaterMark;
    var _require$codes = require_errors4().codes;
    var ERR_INVALID_ARG_TYPE = _require$codes.ERR_INVALID_ARG_TYPE;
    var ERR_STREAM_PUSH_AFTER_EOF = _require$codes.ERR_STREAM_PUSH_AFTER_EOF;
    var ERR_METHOD_NOT_IMPLEMENTED = _require$codes.ERR_METHOD_NOT_IMPLEMENTED;
    var ERR_STREAM_UNSHIFT_AFTER_END_EVENT = _require$codes.ERR_STREAM_UNSHIFT_AFTER_END_EVENT;
    var StringDecoder;
    var createReadableStreamAsyncIterator;
    var from;
    require_inherits()(Readable, Stream);
    var errorOrDestroy = destroyImpl.errorOrDestroy;
    var kProxyEvents = ["error", "close", "destroy", "pause", "resume"];
    function prependListener(emitter, event, fn) {
      if (typeof emitter.prependListener === "function")
        return emitter.prependListener(event, fn);
      if (!emitter._events || !emitter._events[event])
        emitter.on(event, fn);
      else if (Array.isArray(emitter._events[event]))
        emitter._events[event].unshift(fn);
      else
        emitter._events[event] = [fn, emitter._events[event]];
    }
    function ReadableState(options, stream, isDuplex) {
      Duplex = Duplex || require_stream_duplex7();
      options = options || {};
      if (typeof isDuplex !== "boolean")
        isDuplex = stream instanceof Duplex;
      this.objectMode = !!options.objectMode;
      if (isDuplex)
        this.objectMode = this.objectMode || !!options.readableObjectMode;
      this.highWaterMark = getHighWaterMark(this, options, "readableHighWaterMark", isDuplex);
      this.buffer = new BufferList();
      this.length = 0;
      this.pipes = null;
      this.pipesCount = 0;
      this.flowing = null;
      this.ended = false;
      this.endEmitted = false;
      this.reading = false;
      this.sync = true;
      this.needReadable = false;
      this.emittedReadable = false;
      this.readableListening = false;
      this.resumeScheduled = false;
      this.paused = true;
      this.emitClose = options.emitClose !== false;
      this.autoDestroy = !!options.autoDestroy;
      this.destroyed = false;
      this.defaultEncoding = options.defaultEncoding || "utf8";
      this.awaitDrain = 0;
      this.readingMore = false;
      this.decoder = null;
      this.encoding = null;
      if (options.encoding) {
        if (!StringDecoder)
          StringDecoder = require_string_decoder7().StringDecoder;
        this.decoder = new StringDecoder(options.encoding);
        this.encoding = options.encoding;
      }
    }
    function Readable(options) {
      Duplex = Duplex || require_stream_duplex7();
      if (!(this instanceof Readable))
        return new Readable(options);
      var isDuplex = this instanceof Duplex;
      this._readableState = new ReadableState(options, this, isDuplex);
      this.readable = true;
      if (options) {
        if (typeof options.read === "function")
          this._read = options.read;
        if (typeof options.destroy === "function")
          this._destroy = options.destroy;
      }
      Stream.call(this);
    }
    Object.defineProperty(Readable.prototype, "destroyed", {
      // making it explicit this property is not enumerable
      // because otherwise some prototype manipulation in
      // userland will fail
      enumerable: false,
      get: function get() {
        if (this._readableState === void 0) {
          return false;
        }
        return this._readableState.destroyed;
      },
      set: function set(value) {
        if (!this._readableState) {
          return;
        }
        this._readableState.destroyed = value;
      }
    });
    Readable.prototype.destroy = destroyImpl.destroy;
    Readable.prototype._undestroy = destroyImpl.undestroy;
    Readable.prototype._destroy = function(err, cb) {
      cb(err);
    };
    Readable.prototype.push = function(chunk, encoding) {
      var state = this._readableState;
      var skipChunkCheck;
      if (!state.objectMode) {
        if (typeof chunk === "string") {
          encoding = encoding || state.defaultEncoding;
          if (encoding !== state.encoding) {
            chunk = Buffer2.from(chunk, encoding);
            encoding = "";
          }
          skipChunkCheck = true;
        }
      } else {
        skipChunkCheck = true;
      }
      return readableAddChunk(this, chunk, encoding, false, skipChunkCheck);
    };
    Readable.prototype.unshift = function(chunk) {
      return readableAddChunk(this, chunk, null, true, false);
    };
    function readableAddChunk(stream, chunk, encoding, addToFront, skipChunkCheck) {
      debug("readableAddChunk", chunk);
      var state = stream._readableState;
      if (chunk === null) {
        state.reading = false;
        onEofChunk(stream, state);
      } else {
        var er;
        if (!skipChunkCheck)
          er = chunkInvalid(state, chunk);
        if (er) {
          errorOrDestroy(stream, er);
        } else if (state.objectMode || chunk && chunk.length > 0) {
          if (typeof chunk !== "string" && !state.objectMode && Object.getPrototypeOf(chunk) !== Buffer2.prototype) {
            chunk = _uint8ArrayToBuffer(chunk);
          }
          if (addToFront) {
            if (state.endEmitted)
              errorOrDestroy(stream, new ERR_STREAM_UNSHIFT_AFTER_END_EVENT());
            else
              addChunk(stream, state, chunk, true);
          } else if (state.ended) {
            errorOrDestroy(stream, new ERR_STREAM_PUSH_AFTER_EOF());
          } else if (state.destroyed) {
            return false;
          } else {
            state.reading = false;
            if (state.decoder && !encoding) {
              chunk = state.decoder.write(chunk);
              if (state.objectMode || chunk.length !== 0)
                addChunk(stream, state, chunk, false);
              else
                maybeReadMore(stream, state);
            } else {
              addChunk(stream, state, chunk, false);
            }
          }
        } else if (!addToFront) {
          state.reading = false;
          maybeReadMore(stream, state);
        }
      }
      return !state.ended && (state.length < state.highWaterMark || state.length === 0);
    }
    function addChunk(stream, state, chunk, addToFront) {
      if (state.flowing && state.length === 0 && !state.sync) {
        state.awaitDrain = 0;
        stream.emit("data", chunk);
      } else {
        state.length += state.objectMode ? 1 : chunk.length;
        if (addToFront)
          state.buffer.unshift(chunk);
        else
          state.buffer.push(chunk);
        if (state.needReadable)
          emitReadable(stream);
      }
      maybeReadMore(stream, state);
    }
    function chunkInvalid(state, chunk) {
      var er;
      if (!_isUint8Array(chunk) && typeof chunk !== "string" && chunk !== void 0 && !state.objectMode) {
        er = new ERR_INVALID_ARG_TYPE("chunk", ["string", "Buffer", "Uint8Array"], chunk);
      }
      return er;
    }
    Readable.prototype.isPaused = function() {
      return this._readableState.flowing === false;
    };
    Readable.prototype.setEncoding = function(enc) {
      if (!StringDecoder)
        StringDecoder = require_string_decoder7().StringDecoder;
      var decoder = new StringDecoder(enc);
      this._readableState.decoder = decoder;
      this._readableState.encoding = this._readableState.decoder.encoding;
      var p = this._readableState.buffer.head;
      var content = "";
      while (p !== null) {
        content += decoder.write(p.data);
        p = p.next;
      }
      this._readableState.buffer.clear();
      if (content !== "")
        this._readableState.buffer.push(content);
      this._readableState.length = content.length;
      return this;
    };
    var MAX_HWM = 1073741824;
    function computeNewHighWaterMark(n) {
      if (n >= MAX_HWM) {
        n = MAX_HWM;
      } else {
        n--;
        n |= n >>> 1;
        n |= n >>> 2;
        n |= n >>> 4;
        n |= n >>> 8;
        n |= n >>> 16;
        n++;
      }
      return n;
    }
    function howMuchToRead(n, state) {
      if (n <= 0 || state.length === 0 && state.ended)
        return 0;
      if (state.objectMode)
        return 1;
      if (n !== n) {
        if (state.flowing && state.length)
          return state.buffer.head.data.length;
        else
          return state.length;
      }
      if (n > state.highWaterMark)
        state.highWaterMark = computeNewHighWaterMark(n);
      if (n <= state.length)
        return n;
      if (!state.ended) {
        state.needReadable = true;
        return 0;
      }
      return state.length;
    }
    Readable.prototype.read = function(n) {
      debug("read", n);
      n = parseInt(n, 10);
      var state = this._readableState;
      var nOrig = n;
      if (n !== 0)
        state.emittedReadable = false;
      if (n === 0 && state.needReadable && ((state.highWaterMark !== 0 ? state.length >= state.highWaterMark : state.length > 0) || state.ended)) {
        debug("read: emitReadable", state.length, state.ended);
        if (state.length === 0 && state.ended)
          endReadable(this);
        else
          emitReadable(this);
        return null;
      }
      n = howMuchToRead(n, state);
      if (n === 0 && state.ended) {
        if (state.length === 0)
          endReadable(this);
        return null;
      }
      var doRead = state.needReadable;
      debug("need readable", doRead);
      if (state.length === 0 || state.length - n < state.highWaterMark) {
        doRead = true;
        debug("length less than watermark", doRead);
      }
      if (state.ended || state.reading) {
        doRead = false;
        debug("reading or ended", doRead);
      } else if (doRead) {
        debug("do read");
        state.reading = true;
        state.sync = true;
        if (state.length === 0)
          state.needReadable = true;
        this._read(state.highWaterMark);
        state.sync = false;
        if (!state.reading)
          n = howMuchToRead(nOrig, state);
      }
      var ret2;
      if (n > 0)
        ret2 = fromList(n, state);
      else
        ret2 = null;
      if (ret2 === null) {
        state.needReadable = state.length <= state.highWaterMark;
        n = 0;
      } else {
        state.length -= n;
        state.awaitDrain = 0;
      }
      if (state.length === 0) {
        if (!state.ended)
          state.needReadable = true;
        if (nOrig !== n && state.ended)
          endReadable(this);
      }
      if (ret2 !== null)
        this.emit("data", ret2);
      return ret2;
    };
    function onEofChunk(stream, state) {
      debug("onEofChunk");
      if (state.ended)
        return;
      if (state.decoder) {
        var chunk = state.decoder.end();
        if (chunk && chunk.length) {
          state.buffer.push(chunk);
          state.length += state.objectMode ? 1 : chunk.length;
        }
      }
      state.ended = true;
      if (state.sync) {
        emitReadable(stream);
      } else {
        state.needReadable = false;
        if (!state.emittedReadable) {
          state.emittedReadable = true;
          emitReadable_(stream);
        }
      }
    }
    function emitReadable(stream) {
      var state = stream._readableState;
      debug("emitReadable", state.needReadable, state.emittedReadable);
      state.needReadable = false;
      if (!state.emittedReadable) {
        debug("emitReadable", state.flowing);
        state.emittedReadable = true;
        process.nextTick(emitReadable_, stream);
      }
    }
    function emitReadable_(stream) {
      var state = stream._readableState;
      debug("emitReadable_", state.destroyed, state.length, state.ended);
      if (!state.destroyed && (state.length || state.ended)) {
        stream.emit("readable");
        state.emittedReadable = false;
      }
      state.needReadable = !state.flowing && !state.ended && state.length <= state.highWaterMark;
      flow(stream);
    }
    function maybeReadMore(stream, state) {
      if (!state.readingMore) {
        state.readingMore = true;
        process.nextTick(maybeReadMore_, stream, state);
      }
    }
    function maybeReadMore_(stream, state) {
      while (!state.reading && !state.ended && (state.length < state.highWaterMark || state.flowing && state.length === 0)) {
        var len = state.length;
        debug("maybeReadMore read 0");
        stream.read(0);
        if (len === state.length)
          break;
      }
      state.readingMore = false;
    }
    Readable.prototype._read = function(n) {
      errorOrDestroy(this, new ERR_METHOD_NOT_IMPLEMENTED("_read()"));
    };
    Readable.prototype.pipe = function(dest, pipeOpts) {
      var src = this;
      var state = this._readableState;
      switch (state.pipesCount) {
        case 0:
          state.pipes = dest;
          break;
        case 1:
          state.pipes = [state.pipes, dest];
          break;
        default:
          state.pipes.push(dest);
          break;
      }
      state.pipesCount += 1;
      debug("pipe count=%d opts=%j", state.pipesCount, pipeOpts);
      var doEnd = (!pipeOpts || pipeOpts.end !== false) && dest !== process.stdout && dest !== process.stderr;
      var endFn = doEnd ? onend : unpipe;
      if (state.endEmitted)
        process.nextTick(endFn);
      else
        src.once("end", endFn);
      dest.on("unpipe", onunpipe);
      function onunpipe(readable, unpipeInfo) {
        debug("onunpipe");
        if (readable === src) {
          if (unpipeInfo && unpipeInfo.hasUnpiped === false) {
            unpipeInfo.hasUnpiped = true;
            cleanup();
          }
        }
      }
      function onend() {
        debug("onend");
        dest.end();
      }
      var ondrain = pipeOnDrain(src);
      dest.on("drain", ondrain);
      var cleanedUp = false;
      function cleanup() {
        debug("cleanup");
        dest.removeListener("close", onclose);
        dest.removeListener("finish", onfinish);
        dest.removeListener("drain", ondrain);
        dest.removeListener("error", onerror);
        dest.removeListener("unpipe", onunpipe);
        src.removeListener("end", onend);
        src.removeListener("end", unpipe);
        src.removeListener("data", ondata);
        cleanedUp = true;
        if (state.awaitDrain && (!dest._writableState || dest._writableState.needDrain))
          ondrain();
      }
      src.on("data", ondata);
      function ondata(chunk) {
        debug("ondata");
        var ret2 = dest.write(chunk);
        debug("dest.write", ret2);
        if (ret2 === false) {
          if ((state.pipesCount === 1 && state.pipes === dest || state.pipesCount > 1 && indexOf(state.pipes, dest) !== -1) && !cleanedUp) {
            debug("false write response, pause", state.awaitDrain);
            state.awaitDrain++;
          }
          src.pause();
        }
      }
      function onerror(er) {
        debug("onerror", er);
        unpipe();
        dest.removeListener("error", onerror);
        if (EElistenerCount(dest, "error") === 0)
          errorOrDestroy(dest, er);
      }
      prependListener(dest, "error", onerror);
      function onclose() {
        dest.removeListener("finish", onfinish);
        unpipe();
      }
      dest.once("close", onclose);
      function onfinish() {
        debug("onfinish");
        dest.removeListener("close", onclose);
        unpipe();
      }
      dest.once("finish", onfinish);
      function unpipe() {
        debug("unpipe");
        src.unpipe(dest);
      }
      dest.emit("pipe", src);
      if (!state.flowing) {
        debug("pipe resume");
        src.resume();
      }
      return dest;
    };
    function pipeOnDrain(src) {
      return function pipeOnDrainFunctionResult() {
        var state = src._readableState;
        debug("pipeOnDrain", state.awaitDrain);
        if (state.awaitDrain)
          state.awaitDrain--;
        if (state.awaitDrain === 0 && EElistenerCount(src, "data")) {
          state.flowing = true;
          flow(src);
        }
      };
    }
    Readable.prototype.unpipe = function(dest) {
      var state = this._readableState;
      var unpipeInfo = {
        hasUnpiped: false
      };
      if (state.pipesCount === 0)
        return this;
      if (state.pipesCount === 1) {
        if (dest && dest !== state.pipes)
          return this;
        if (!dest)
          dest = state.pipes;
        state.pipes = null;
        state.pipesCount = 0;
        state.flowing = false;
        if (dest)
          dest.emit("unpipe", this, unpipeInfo);
        return this;
      }
      if (!dest) {
        var dests = state.pipes;
        var len = state.pipesCount;
        state.pipes = null;
        state.pipesCount = 0;
        state.flowing = false;
        for (var i = 0; i < len; i++)
          dests[i].emit("unpipe", this, {
            hasUnpiped: false
          });
        return this;
      }
      var index = indexOf(state.pipes, dest);
      if (index === -1)
        return this;
      state.pipes.splice(index, 1);
      state.pipesCount -= 1;
      if (state.pipesCount === 1)
        state.pipes = state.pipes[0];
      dest.emit("unpipe", this, unpipeInfo);
      return this;
    };
    Readable.prototype.on = function(ev, fn) {
      var res = Stream.prototype.on.call(this, ev, fn);
      var state = this._readableState;
      if (ev === "data") {
        state.readableListening = this.listenerCount("readable") > 0;
        if (state.flowing !== false)
          this.resume();
      } else if (ev === "readable") {
        if (!state.endEmitted && !state.readableListening) {
          state.readableListening = state.needReadable = true;
          state.flowing = false;
          state.emittedReadable = false;
          debug("on readable", state.length, state.reading);
          if (state.length) {
            emitReadable(this);
          } else if (!state.reading) {
            process.nextTick(nReadingNextTick, this);
          }
        }
      }
      return res;
    };
    Readable.prototype.addListener = Readable.prototype.on;
    Readable.prototype.removeListener = function(ev, fn) {
      var res = Stream.prototype.removeListener.call(this, ev, fn);
      if (ev === "readable") {
        process.nextTick(updateReadableListening, this);
      }
      return res;
    };
    Readable.prototype.removeAllListeners = function(ev) {
      var res = Stream.prototype.removeAllListeners.apply(this, arguments);
      if (ev === "readable" || ev === void 0) {
        process.nextTick(updateReadableListening, this);
      }
      return res;
    };
    function updateReadableListening(self2) {
      var state = self2._readableState;
      state.readableListening = self2.listenerCount("readable") > 0;
      if (state.resumeScheduled && !state.paused) {
        state.flowing = true;
      } else if (self2.listenerCount("data") > 0) {
        self2.resume();
      }
    }
    function nReadingNextTick(self2) {
      debug("readable nexttick read 0");
      self2.read(0);
    }
    Readable.prototype.resume = function() {
      var state = this._readableState;
      if (!state.flowing) {
        debug("resume");
        state.flowing = !state.readableListening;
        resume(this, state);
      }
      state.paused = false;
      return this;
    };
    function resume(stream, state) {
      if (!state.resumeScheduled) {
        state.resumeScheduled = true;
        process.nextTick(resume_, stream, state);
      }
    }
    function resume_(stream, state) {
      debug("resume", state.reading);
      if (!state.reading) {
        stream.read(0);
      }
      state.resumeScheduled = false;
      stream.emit("resume");
      flow(stream);
      if (state.flowing && !state.reading)
        stream.read(0);
    }
    Readable.prototype.pause = function() {
      debug("call pause flowing=%j", this._readableState.flowing);
      if (this._readableState.flowing !== false) {
        debug("pause");
        this._readableState.flowing = false;
        this.emit("pause");
      }
      this._readableState.paused = true;
      return this;
    };
    function flow(stream) {
      var state = stream._readableState;
      debug("flow", state.flowing);
      while (state.flowing && stream.read() !== null)
        ;
    }
    Readable.prototype.wrap = function(stream) {
      var _this = this;
      var state = this._readableState;
      var paused = false;
      stream.on("end", function() {
        debug("wrapped end");
        if (state.decoder && !state.ended) {
          var chunk = state.decoder.end();
          if (chunk && chunk.length)
            _this.push(chunk);
        }
        _this.push(null);
      });
      stream.on("data", function(chunk) {
        debug("wrapped data");
        if (state.decoder)
          chunk = state.decoder.write(chunk);
        if (state.objectMode && (chunk === null || chunk === void 0))
          return;
        else if (!state.objectMode && (!chunk || !chunk.length))
          return;
        var ret2 = _this.push(chunk);
        if (!ret2) {
          paused = true;
          stream.pause();
        }
      });
      for (var i in stream) {
        if (this[i] === void 0 && typeof stream[i] === "function") {
          this[i] = /* @__PURE__ */ function methodWrap(method) {
            return function methodWrapReturnFunction() {
              return stream[method].apply(stream, arguments);
            };
          }(i);
        }
      }
      for (var n = 0; n < kProxyEvents.length; n++) {
        stream.on(kProxyEvents[n], this.emit.bind(this, kProxyEvents[n]));
      }
      this._read = function(n2) {
        debug("wrapped _read", n2);
        if (paused) {
          paused = false;
          stream.resume();
        }
      };
      return this;
    };
    if (typeof Symbol === "function") {
      Readable.prototype[Symbol.asyncIterator] = function() {
        if (createReadableStreamAsyncIterator === void 0) {
          createReadableStreamAsyncIterator = require_async_iterator4();
        }
        return createReadableStreamAsyncIterator(this);
      };
    }
    Object.defineProperty(Readable.prototype, "readableHighWaterMark", {
      // making it explicit this property is not enumerable
      // because otherwise some prototype manipulation in
      // userland will fail
      enumerable: false,
      get: function get() {
        return this._readableState.highWaterMark;
      }
    });
    Object.defineProperty(Readable.prototype, "readableBuffer", {
      // making it explicit this property is not enumerable
      // because otherwise some prototype manipulation in
      // userland will fail
      enumerable: false,
      get: function get() {
        return this._readableState && this._readableState.buffer;
      }
    });
    Object.defineProperty(Readable.prototype, "readableFlowing", {
      // making it explicit this property is not enumerable
      // because otherwise some prototype manipulation in
      // userland will fail
      enumerable: false,
      get: function get() {
        return this._readableState.flowing;
      },
      set: function set(state) {
        if (this._readableState) {
          this._readableState.flowing = state;
        }
      }
    });
    Readable._fromList = fromList;
    Object.defineProperty(Readable.prototype, "readableLength", {
      // making it explicit this property is not enumerable
      // because otherwise some prototype manipulation in
      // userland will fail
      enumerable: false,
      get: function get() {
        return this._readableState.length;
      }
    });
    function fromList(n, state) {
      if (state.length === 0)
        return null;
      var ret2;
      if (state.objectMode)
        ret2 = state.buffer.shift();
      else if (!n || n >= state.length) {
        if (state.decoder)
          ret2 = state.buffer.join("");
        else if (state.buffer.length === 1)
          ret2 = state.buffer.first();
        else
          ret2 = state.buffer.concat(state.length);
        state.buffer.clear();
      } else {
        ret2 = state.buffer.consume(n, state.decoder);
      }
      return ret2;
    }
    function endReadable(stream) {
      var state = stream._readableState;
      debug("endReadable", state.endEmitted);
      if (!state.endEmitted) {
        state.ended = true;
        process.nextTick(endReadableNT, state, stream);
      }
    }
    function endReadableNT(state, stream) {
      debug("endReadableNT", state.endEmitted, state.length);
      if (!state.endEmitted && state.length === 0) {
        state.endEmitted = true;
        stream.readable = false;
        stream.emit("end");
        if (state.autoDestroy) {
          var wState = stream._writableState;
          if (!wState || wState.autoDestroy && wState.finished) {
            stream.destroy();
          }
        }
      }
    }
    if (typeof Symbol === "function") {
      Readable.from = function(iterable, opts) {
        if (from === void 0) {
          from = require_from4();
        }
        return from(Readable, iterable, opts);
      };
    }
    function indexOf(xs, x) {
      for (var i = 0, l2 = xs.length; i < l2; i++) {
        if (xs[i] === x)
          return i;
      }
      return -1;
    }
  }
});

// ../../../node_modules/crc32-stream/node_modules/readable-stream/lib/_stream_transform.js
var require_stream_transform7 = __commonJS({
  "../../../node_modules/crc32-stream/node_modules/readable-stream/lib/_stream_transform.js"(exports2, module2) {
    "use strict";
    module2.exports = Transform;
    var _require$codes = require_errors4().codes;
    var ERR_METHOD_NOT_IMPLEMENTED = _require$codes.ERR_METHOD_NOT_IMPLEMENTED;
    var ERR_MULTIPLE_CALLBACK = _require$codes.ERR_MULTIPLE_CALLBACK;
    var ERR_TRANSFORM_ALREADY_TRANSFORMING = _require$codes.ERR_TRANSFORM_ALREADY_TRANSFORMING;
    var ERR_TRANSFORM_WITH_LENGTH_0 = _require$codes.ERR_TRANSFORM_WITH_LENGTH_0;
    var Duplex = require_stream_duplex7();
    require_inherits()(Transform, Duplex);
    function afterTransform(er, data) {
      var ts = this._transformState;
      ts.transforming = false;
      var cb = ts.writecb;
      if (cb === null) {
        return this.emit("error", new ERR_MULTIPLE_CALLBACK());
      }
      ts.writechunk = null;
      ts.writecb = null;
      if (data != null)
        this.push(data);
      cb(er);
      var rs = this._readableState;
      rs.reading = false;
      if (rs.needReadable || rs.length < rs.highWaterMark) {
        this._read(rs.highWaterMark);
      }
    }
    function Transform(options) {
      if (!(this instanceof Transform))
        return new Transform(options);
      Duplex.call(this, options);
      this._transformState = {
        afterTransform: afterTransform.bind(this),
        needTransform: false,
        transforming: false,
        writecb: null,
        writechunk: null,
        writeencoding: null
      };
      this._readableState.needReadable = true;
      this._readableState.sync = false;
      if (options) {
        if (typeof options.transform === "function")
          this._transform = options.transform;
        if (typeof options.flush === "function")
          this._flush = options.flush;
      }
      this.on("prefinish", prefinish);
    }
    function prefinish() {
      var _this = this;
      if (typeof this._flush === "function" && !this._readableState.destroyed) {
        this._flush(function(er, data) {
          done(_this, er, data);
        });
      } else {
        done(this, null, null);
      }
    }
    Transform.prototype.push = function(chunk, encoding) {
      this._transformState.needTransform = false;
      return Duplex.prototype.push.call(this, chunk, encoding);
    };
    Transform.prototype._transform = function(chunk, encoding, cb) {
      cb(new ERR_METHOD_NOT_IMPLEMENTED("_transform()"));
    };
    Transform.prototype._write = function(chunk, encoding, cb) {
      var ts = this._transformState;
      ts.writecb = cb;
      ts.writechunk = chunk;
      ts.writeencoding = encoding;
      if (!ts.transforming) {
        var rs = this._readableState;
        if (ts.needTransform || rs.needReadable || rs.length < rs.highWaterMark)
          this._read(rs.highWaterMark);
      }
    };
    Transform.prototype._read = function(n) {
      var ts = this._transformState;
      if (ts.writechunk !== null && !ts.transforming) {
        ts.transforming = true;
        this._transform(ts.writechunk, ts.writeencoding, ts.afterTransform);
      } else {
        ts.needTransform = true;
      }
    };
    Transform.prototype._destroy = function(err, cb) {
      Duplex.prototype._destroy.call(this, err, function(err2) {
        cb(err2);
      });
    };
    function done(stream, er, data) {
      if (er)
        return stream.emit("error", er);
      if (data != null)
        stream.push(data);
      if (stream._writableState.length)
        throw new ERR_TRANSFORM_WITH_LENGTH_0();
      if (stream._transformState.transforming)
        throw new ERR_TRANSFORM_ALREADY_TRANSFORMING();
      return stream.push(null);
    }
  }
});

// ../../../node_modules/crc32-stream/node_modules/readable-stream/lib/_stream_passthrough.js
var require_stream_passthrough7 = __commonJS({
  "../../../node_modules/crc32-stream/node_modules/readable-stream/lib/_stream_passthrough.js"(exports2, module2) {
    "use strict";
    module2.exports = PassThrough;
    var Transform = require_stream_transform7();
    require_inherits()(PassThrough, Transform);
    function PassThrough(options) {
      if (!(this instanceof PassThrough))
        return new PassThrough(options);
      Transform.call(this, options);
    }
    PassThrough.prototype._transform = function(chunk, encoding, cb) {
      cb(null, chunk);
    };
  }
});

// ../../../node_modules/crc32-stream/node_modules/readable-stream/lib/internal/streams/pipeline.js
var require_pipeline4 = __commonJS({
  "../../../node_modules/crc32-stream/node_modules/readable-stream/lib/internal/streams/pipeline.js"(exports2, module2) {
    "use strict";
    var eos;
    function once(callback) {
      var called = false;
      return function() {
        if (called)
          return;
        called = true;
        callback.apply(void 0, arguments);
      };
    }
    var _require$codes = require_errors4().codes;
    var ERR_MISSING_ARGS = _require$codes.ERR_MISSING_ARGS;
    var ERR_STREAM_DESTROYED = _require$codes.ERR_STREAM_DESTROYED;
    function noop(err) {
      if (err)
        throw err;
    }
    function isRequest(stream) {
      return stream.setHeader && typeof stream.abort === "function";
    }
    function destroyer(stream, reading, writing, callback) {
      callback = once(callback);
      var closed = false;
      stream.on("close", function() {
        closed = true;
      });
      if (eos === void 0)
        eos = require_end_of_stream4();
      eos(stream, {
        readable: reading,
        writable: writing
      }, function(err) {
        if (err)
          return callback(err);
        closed = true;
        callback();
      });
      var destroyed = false;
      return function(err) {
        if (closed)
          return;
        if (destroyed)
          return;
        destroyed = true;
        if (isRequest(stream))
          return stream.abort();
        if (typeof stream.destroy === "function")
          return stream.destroy();
        callback(err || new ERR_STREAM_DESTROYED("pipe"));
      };
    }
    function call(fn) {
      fn();
    }
    function pipe(from, to) {
      return from.pipe(to);
    }
    function popCallback(streams) {
      if (!streams.length)
        return noop;
      if (typeof streams[streams.length - 1] !== "function")
        return noop;
      return streams.pop();
    }
    function pipeline() {
      for (var _len = arguments.length, streams = new Array(_len), _key = 0; _key < _len; _key++) {
        streams[_key] = arguments[_key];
      }
      var callback = popCallback(streams);
      if (Array.isArray(streams[0]))
        streams = streams[0];
      if (streams.length < 2) {
        throw new ERR_MISSING_ARGS("streams");
      }
      var error;
      var destroys = streams.map(function(stream, i) {
        var reading = i < streams.length - 1;
        var writing = i > 0;
        return destroyer(stream, reading, writing, function(err) {
          if (!error)
            error = err;
          if (err)
            destroys.forEach(call);
          if (reading)
            return;
          destroys.forEach(call);
          callback(error);
        });
      });
      return streams.reduce(pipe);
    }
    module2.exports = pipeline;
  }
});

// ../../../node_modules/crc32-stream/node_modules/readable-stream/readable.js
var require_readable7 = __commonJS({
  "../../../node_modules/crc32-stream/node_modules/readable-stream/readable.js"(exports2, module2) {
    var Stream = require("stream");
    if (process.env.READABLE_STREAM === "disable" && Stream) {
      module2.exports = Stream.Readable;
      Object.assign(module2.exports, Stream);
      module2.exports.Stream = Stream;
    } else {
      exports2 = module2.exports = require_stream_readable7();
      exports2.Stream = Stream || exports2;
      exports2.Readable = exports2;
      exports2.Writable = require_stream_writable7();
      exports2.Duplex = require_stream_duplex7();
      exports2.Transform = require_stream_transform7();
      exports2.PassThrough = require_stream_passthrough7();
      exports2.finished = require_end_of_stream4();
      exports2.pipeline = require_pipeline4();
    }
  }
});

// ../../../node_modules/crc-32/crc32.js
var require_crc323 = __commonJS({
  "../../../node_modules/crc-32/crc32.js"(exports2) {
    var CRC32;
    (function(factory) {
      if (typeof DO_NOT_EXPORT_CRC === "undefined") {
        if ("object" === typeof exports2) {
          factory(exports2);
        } else if ("function" === typeof define && define.amd) {
          define(function() {
            var module3 = {};
            factory(module3);
            return module3;
          });
        } else {
          factory(CRC32 = {});
        }
      } else {
        factory(CRC32 = {});
      }
    })(function(CRC322) {
      CRC322.version = "1.2.2";
      function signed_crc_table() {
        var c = 0, table = new Array(256);
        for (var n = 0; n != 256; ++n) {
          c = n;
          c = c & 1 ? -306674912 ^ c >>> 1 : c >>> 1;
          c = c & 1 ? -306674912 ^ c >>> 1 : c >>> 1;
          c = c & 1 ? -306674912 ^ c >>> 1 : c >>> 1;
          c = c & 1 ? -306674912 ^ c >>> 1 : c >>> 1;
          c = c & 1 ? -306674912 ^ c >>> 1 : c >>> 1;
          c = c & 1 ? -306674912 ^ c >>> 1 : c >>> 1;
          c = c & 1 ? -306674912 ^ c >>> 1 : c >>> 1;
          c = c & 1 ? -306674912 ^ c >>> 1 : c >>> 1;
          table[n] = c;
        }
        return typeof Int32Array !== "undefined" ? new Int32Array(table) : table;
      }
      var T0 = signed_crc_table();
      function slice_by_16_tables(T) {
        var c = 0, v = 0, n = 0, table = typeof Int32Array !== "undefined" ? new Int32Array(4096) : new Array(4096);
        for (n = 0; n != 256; ++n)
          table[n] = T[n];
        for (n = 0; n != 256; ++n) {
          v = T[n];
          for (c = 256 + n; c < 4096; c += 256)
            v = table[c] = v >>> 8 ^ T[v & 255];
        }
        var out = [];
        for (n = 1; n != 16; ++n)
          out[n - 1] = typeof Int32Array !== "undefined" ? table.subarray(n * 256, n * 256 + 256) : table.slice(n * 256, n * 256 + 256);
        return out;
      }
      var TT = slice_by_16_tables(T0);
      var T1 = TT[0], T2 = TT[1], T3 = TT[2], T4 = TT[3], T5 = TT[4];
      var T6 = TT[5], T7 = TT[6], T8 = TT[7], T9 = TT[8], Ta = TT[9];
      var Tb = TT[10], Tc = TT[11], Td = TT[12], Te = TT[13], Tf = TT[14];
      function crc32_bstr(bstr, seed) {
        var C = seed ^ -1;
        for (var i = 0, L = bstr.length; i < L; )
          C = C >>> 8 ^ T0[(C ^ bstr.charCodeAt(i++)) & 255];
        return ~C;
      }
      function crc32_buf(B, seed) {
        var C = seed ^ -1, L = B.length - 15, i = 0;
        for (; i < L; )
          C = Tf[B[i++] ^ C & 255] ^ Te[B[i++] ^ C >> 8 & 255] ^ Td[B[i++] ^ C >> 16 & 255] ^ Tc[B[i++] ^ C >>> 24] ^ Tb[B[i++]] ^ Ta[B[i++]] ^ T9[B[i++]] ^ T8[B[i++]] ^ T7[B[i++]] ^ T6[B[i++]] ^ T5[B[i++]] ^ T4[B[i++]] ^ T3[B[i++]] ^ T2[B[i++]] ^ T1[B[i++]] ^ T0[B[i++]];
        L += 15;
        while (i < L)
          C = C >>> 8 ^ T0[(C ^ B[i++]) & 255];
        return ~C;
      }
      function crc32_str(str, seed) {
        var C = seed ^ -1;
        for (var i = 0, L = str.length, c = 0, d = 0; i < L; ) {
          c = str.charCodeAt(i++);
          if (c < 128) {
            C = C >>> 8 ^ T0[(C ^ c) & 255];
          } else if (c < 2048) {
            C = C >>> 8 ^ T0[(C ^ (192 | c >> 6 & 31)) & 255];
            C = C >>> 8 ^ T0[(C ^ (128 | c & 63)) & 255];
          } else if (c >= 55296 && c < 57344) {
            c = (c & 1023) + 64;
            d = str.charCodeAt(i++) & 1023;
            C = C >>> 8 ^ T0[(C ^ (240 | c >> 8 & 7)) & 255];
            C = C >>> 8 ^ T0[(C ^ (128 | c >> 2 & 63)) & 255];
            C = C >>> 8 ^ T0[(C ^ (128 | d >> 6 & 15 | (c & 3) << 4)) & 255];
            C = C >>> 8 ^ T0[(C ^ (128 | d & 63)) & 255];
          } else {
            C = C >>> 8 ^ T0[(C ^ (224 | c >> 12 & 15)) & 255];
            C = C >>> 8 ^ T0[(C ^ (128 | c >> 6 & 63)) & 255];
            C = C >>> 8 ^ T0[(C ^ (128 | c & 63)) & 255];
          }
        }
        return ~C;
      }
      CRC322.table = T0;
      CRC322.bstr = crc32_bstr;
      CRC322.buf = crc32_buf;
      CRC322.str = crc32_str;
    });
  }
});

// ../../../node_modules/crc32-stream/lib/crc32-stream.js
var require_crc32_stream = __commonJS({
  "../../../node_modules/crc32-stream/lib/crc32-stream.js"(exports2, module2) {
    "use strict";
    var { Transform } = require_readable7();
    var crc32 = require_crc323();
    var CRC32Stream = class extends Transform {
      constructor(options) {
        super(options);
        this.checksum = Buffer.allocUnsafe(4);
        this.checksum.writeInt32BE(0, 0);
        this.rawSize = 0;
      }
      _transform(chunk, encoding, callback) {
        if (chunk) {
          this.checksum = crc32.buf(chunk, this.checksum) >>> 0;
          this.rawSize += chunk.length;
        }
        callback(null, chunk);
      }
      digest(encoding) {
        const checksum = Buffer.allocUnsafe(4);
        checksum.writeUInt32BE(this.checksum >>> 0, 0);
        return encoding ? checksum.toString(encoding) : checksum;
      }
      hex() {
        return this.digest("hex").toUpperCase();
      }
      size() {
        return this.rawSize;
      }
    };
    module2.exports = CRC32Stream;
  }
});

// ../../../node_modules/crc32-stream/lib/deflate-crc32-stream.js
var require_deflate_crc32_stream = __commonJS({
  "../../../node_modules/crc32-stream/lib/deflate-crc32-stream.js"(exports2, module2) {
    "use strict";
    var { DeflateRaw } = require("zlib");
    var crc32 = require_crc323();
    var DeflateCRC32Stream = class extends DeflateRaw {
      constructor(options) {
        super(options);
        this.checksum = Buffer.allocUnsafe(4);
        this.checksum.writeInt32BE(0, 0);
        this.rawSize = 0;
        this.compressedSize = 0;
      }
      push(chunk, encoding) {
        if (chunk) {
          this.compressedSize += chunk.length;
        }
        return super.push(chunk, encoding);
      }
      _transform(chunk, encoding, callback) {
        if (chunk) {
          this.checksum = crc32.buf(chunk, this.checksum) >>> 0;
          this.rawSize += chunk.length;
        }
        super._transform(chunk, encoding, callback);
      }
      digest(encoding) {
        const checksum = Buffer.allocUnsafe(4);
        checksum.writeUInt32BE(this.checksum >>> 0, 0);
        return encoding ? checksum.toString(encoding) : checksum;
      }
      hex() {
        return this.digest("hex").toUpperCase();
      }
      size(compressed = false) {
        if (compressed) {
          return this.compressedSize;
        } else {
          return this.rawSize;
        }
      }
    };
    module2.exports = DeflateCRC32Stream;
  }
});

// ../../../node_modules/crc32-stream/lib/index.js
var require_lib4 = __commonJS({
  "../../../node_modules/crc32-stream/lib/index.js"(exports2, module2) {
    "use strict";
    module2.exports = {
      CRC32Stream: require_crc32_stream(),
      DeflateCRC32Stream: require_deflate_crc32_stream()
    };
  }
});

// ../../../node_modules/compress-commons/lib/archivers/zip/zip-archive-output-stream.js
var require_zip_archive_output_stream = __commonJS({
  "../../../node_modules/compress-commons/lib/archivers/zip/zip-archive-output-stream.js"(exports2, module2) {
    var inherits2 = require("util").inherits;
    var crc32 = require_buffer_crc32();
    var { CRC32Stream } = require_lib4();
    var { DeflateCRC32Stream } = require_lib4();
    var ArchiveOutputStream = require_archive_output_stream();
    var ZipArchiveEntry = require_zip_archive_entry();
    var GeneralPurposeBit = require_general_purpose_bit();
    var constants = require_constants2();
    var util = require_util3();
    var zipUtil = require_util2();
    var ZipArchiveOutputStream = module2.exports = function(options) {
      if (!(this instanceof ZipArchiveOutputStream)) {
        return new ZipArchiveOutputStream(options);
      }
      options = this.options = this._defaults(options);
      ArchiveOutputStream.call(this, options);
      this._entry = null;
      this._entries = [];
      this._archive = {
        centralLength: 0,
        centralOffset: 0,
        comment: "",
        finish: false,
        finished: false,
        processing: false,
        forceZip64: options.forceZip64,
        forceLocalTime: options.forceLocalTime
      };
    };
    inherits2(ZipArchiveOutputStream, ArchiveOutputStream);
    ZipArchiveOutputStream.prototype._afterAppend = function(ae) {
      this._entries.push(ae);
      if (ae.getGeneralPurposeBit().usesDataDescriptor()) {
        this._writeDataDescriptor(ae);
      }
      this._archive.processing = false;
      this._entry = null;
      if (this._archive.finish && !this._archive.finished) {
        this._finish();
      }
    };
    ZipArchiveOutputStream.prototype._appendBuffer = function(ae, source, callback) {
      if (source.length === 0) {
        ae.setMethod(constants.METHOD_STORED);
      }
      var method = ae.getMethod();
      if (method === constants.METHOD_STORED) {
        ae.setSize(source.length);
        ae.setCompressedSize(source.length);
        ae.setCrc(crc32.unsigned(source));
      }
      this._writeLocalFileHeader(ae);
      if (method === constants.METHOD_STORED) {
        this.write(source);
        this._afterAppend(ae);
        callback(null, ae);
        return;
      } else if (method === constants.METHOD_DEFLATED) {
        this._smartStream(ae, callback).end(source);
        return;
      } else {
        callback(new Error("compression method " + method + " not implemented"));
        return;
      }
    };
    ZipArchiveOutputStream.prototype._appendStream = function(ae, source, callback) {
      ae.getGeneralPurposeBit().useDataDescriptor(true);
      ae.setVersionNeededToExtract(constants.MIN_VERSION_DATA_DESCRIPTOR);
      this._writeLocalFileHeader(ae);
      var smart = this._smartStream(ae, callback);
      source.once("error", function(err) {
        smart.emit("error", err);
        smart.end();
      });
      source.pipe(smart);
    };
    ZipArchiveOutputStream.prototype._defaults = function(o) {
      if (typeof o !== "object") {
        o = {};
      }
      if (typeof o.zlib !== "object") {
        o.zlib = {};
      }
      if (typeof o.zlib.level !== "number") {
        o.zlib.level = constants.ZLIB_BEST_SPEED;
      }
      o.forceZip64 = !!o.forceZip64;
      o.forceLocalTime = !!o.forceLocalTime;
      return o;
    };
    ZipArchiveOutputStream.prototype._finish = function() {
      this._archive.centralOffset = this.offset;
      this._entries.forEach(function(ae) {
        this._writeCentralFileHeader(ae);
      }.bind(this));
      this._archive.centralLength = this.offset - this._archive.centralOffset;
      if (this.isZip64()) {
        this._writeCentralDirectoryZip64();
      }
      this._writeCentralDirectoryEnd();
      this._archive.processing = false;
      this._archive.finish = true;
      this._archive.finished = true;
      this.end();
    };
    ZipArchiveOutputStream.prototype._normalizeEntry = function(ae) {
      if (ae.getMethod() === -1) {
        ae.setMethod(constants.METHOD_DEFLATED);
      }
      if (ae.getMethod() === constants.METHOD_DEFLATED) {
        ae.getGeneralPurposeBit().useDataDescriptor(true);
        ae.setVersionNeededToExtract(constants.MIN_VERSION_DATA_DESCRIPTOR);
      }
      if (ae.getTime() === -1) {
        ae.setTime(/* @__PURE__ */ new Date(), this._archive.forceLocalTime);
      }
      ae._offsets = {
        file: 0,
        data: 0,
        contents: 0
      };
    };
    ZipArchiveOutputStream.prototype._smartStream = function(ae, callback) {
      var deflate = ae.getMethod() === constants.METHOD_DEFLATED;
      var process2 = deflate ? new DeflateCRC32Stream(this.options.zlib) : new CRC32Stream();
      var error = null;
      function handleStuff() {
        var digest = process2.digest().readUInt32BE(0);
        ae.setCrc(digest);
        ae.setSize(process2.size());
        ae.setCompressedSize(process2.size(true));
        this._afterAppend(ae);
        callback(error, ae);
      }
      process2.once("end", handleStuff.bind(this));
      process2.once("error", function(err) {
        error = err;
      });
      process2.pipe(this, { end: false });
      return process2;
    };
    ZipArchiveOutputStream.prototype._writeCentralDirectoryEnd = function() {
      var records = this._entries.length;
      var size = this._archive.centralLength;
      var offset = this._archive.centralOffset;
      if (this.isZip64()) {
        records = constants.ZIP64_MAGIC_SHORT;
        size = constants.ZIP64_MAGIC;
        offset = constants.ZIP64_MAGIC;
      }
      this.write(zipUtil.getLongBytes(constants.SIG_EOCD));
      this.write(constants.SHORT_ZERO);
      this.write(constants.SHORT_ZERO);
      this.write(zipUtil.getShortBytes(records));
      this.write(zipUtil.getShortBytes(records));
      this.write(zipUtil.getLongBytes(size));
      this.write(zipUtil.getLongBytes(offset));
      var comment = this.getComment();
      var commentLength = Buffer.byteLength(comment);
      this.write(zipUtil.getShortBytes(commentLength));
      this.write(comment);
    };
    ZipArchiveOutputStream.prototype._writeCentralDirectoryZip64 = function() {
      this.write(zipUtil.getLongBytes(constants.SIG_ZIP64_EOCD));
      this.write(zipUtil.getEightBytes(44));
      this.write(zipUtil.getShortBytes(constants.MIN_VERSION_ZIP64));
      this.write(zipUtil.getShortBytes(constants.MIN_VERSION_ZIP64));
      this.write(constants.LONG_ZERO);
      this.write(constants.LONG_ZERO);
      this.write(zipUtil.getEightBytes(this._entries.length));
      this.write(zipUtil.getEightBytes(this._entries.length));
      this.write(zipUtil.getEightBytes(this._archive.centralLength));
      this.write(zipUtil.getEightBytes(this._archive.centralOffset));
      this.write(zipUtil.getLongBytes(constants.SIG_ZIP64_EOCD_LOC));
      this.write(constants.LONG_ZERO);
      this.write(zipUtil.getEightBytes(this._archive.centralOffset + this._archive.centralLength));
      this.write(zipUtil.getLongBytes(1));
    };
    ZipArchiveOutputStream.prototype._writeCentralFileHeader = function(ae) {
      var gpb = ae.getGeneralPurposeBit();
      var method = ae.getMethod();
      var offsets = ae._offsets;
      var size = ae.getSize();
      var compressedSize = ae.getCompressedSize();
      if (ae.isZip64() || offsets.file > constants.ZIP64_MAGIC) {
        size = constants.ZIP64_MAGIC;
        compressedSize = constants.ZIP64_MAGIC;
        ae.setVersionNeededToExtract(constants.MIN_VERSION_ZIP64);
        var extraBuf = Buffer.concat([
          zipUtil.getShortBytes(constants.ZIP64_EXTRA_ID),
          zipUtil.getShortBytes(24),
          zipUtil.getEightBytes(ae.getSize()),
          zipUtil.getEightBytes(ae.getCompressedSize()),
          zipUtil.getEightBytes(offsets.file)
        ], 28);
        ae.setExtra(extraBuf);
      }
      this.write(zipUtil.getLongBytes(constants.SIG_CFH));
      this.write(zipUtil.getShortBytes(ae.getPlatform() << 8 | constants.VERSION_MADEBY));
      this.write(zipUtil.getShortBytes(ae.getVersionNeededToExtract()));
      this.write(gpb.encode());
      this.write(zipUtil.getShortBytes(method));
      this.write(zipUtil.getLongBytes(ae.getTimeDos()));
      this.write(zipUtil.getLongBytes(ae.getCrc()));
      this.write(zipUtil.getLongBytes(compressedSize));
      this.write(zipUtil.getLongBytes(size));
      var name = ae.getName();
      var comment = ae.getComment();
      var extra = ae.getCentralDirectoryExtra();
      if (gpb.usesUTF8ForNames()) {
        name = Buffer.from(name);
        comment = Buffer.from(comment);
      }
      this.write(zipUtil.getShortBytes(name.length));
      this.write(zipUtil.getShortBytes(extra.length));
      this.write(zipUtil.getShortBytes(comment.length));
      this.write(constants.SHORT_ZERO);
      this.write(zipUtil.getShortBytes(ae.getInternalAttributes()));
      this.write(zipUtil.getLongBytes(ae.getExternalAttributes()));
      if (offsets.file > constants.ZIP64_MAGIC) {
        this.write(zipUtil.getLongBytes(constants.ZIP64_MAGIC));
      } else {
        this.write(zipUtil.getLongBytes(offsets.file));
      }
      this.write(name);
      this.write(extra);
      this.write(comment);
    };
    ZipArchiveOutputStream.prototype._writeDataDescriptor = function(ae) {
      this.write(zipUtil.getLongBytes(constants.SIG_DD));
      this.write(zipUtil.getLongBytes(ae.getCrc()));
      if (ae.isZip64()) {
        this.write(zipUtil.getEightBytes(ae.getCompressedSize()));
        this.write(zipUtil.getEightBytes(ae.getSize()));
      } else {
        this.write(zipUtil.getLongBytes(ae.getCompressedSize()));
        this.write(zipUtil.getLongBytes(ae.getSize()));
      }
    };
    ZipArchiveOutputStream.prototype._writeLocalFileHeader = function(ae) {
      var gpb = ae.getGeneralPurposeBit();
      var method = ae.getMethod();
      var name = ae.getName();
      var extra = ae.getLocalFileDataExtra();
      if (ae.isZip64()) {
        gpb.useDataDescriptor(true);
        ae.setVersionNeededToExtract(constants.MIN_VERSION_ZIP64);
      }
      if (gpb.usesUTF8ForNames()) {
        name = Buffer.from(name);
      }
      ae._offsets.file = this.offset;
      this.write(zipUtil.getLongBytes(constants.SIG_LFH));
      this.write(zipUtil.getShortBytes(ae.getVersionNeededToExtract()));
      this.write(gpb.encode());
      this.write(zipUtil.getShortBytes(method));
      this.write(zipUtil.getLongBytes(ae.getTimeDos()));
      ae._offsets.data = this.offset;
      if (gpb.usesDataDescriptor()) {
        this.write(constants.LONG_ZERO);
        this.write(constants.LONG_ZERO);
        this.write(constants.LONG_ZERO);
      } else {
        this.write(zipUtil.getLongBytes(ae.getCrc()));
        this.write(zipUtil.getLongBytes(ae.getCompressedSize()));
        this.write(zipUtil.getLongBytes(ae.getSize()));
      }
      this.write(zipUtil.getShortBytes(name.length));
      this.write(zipUtil.getShortBytes(extra.length));
      this.write(name);
      this.write(extra);
      ae._offsets.contents = this.offset;
    };
    ZipArchiveOutputStream.prototype.getComment = function(comment) {
      return this._archive.comment !== null ? this._archive.comment : "";
    };
    ZipArchiveOutputStream.prototype.isZip64 = function() {
      return this._archive.forceZip64 || this._entries.length > constants.ZIP64_MAGIC_SHORT || this._archive.centralLength > constants.ZIP64_MAGIC || this._archive.centralOffset > constants.ZIP64_MAGIC;
    };
    ZipArchiveOutputStream.prototype.setComment = function(comment) {
      this._archive.comment = comment;
    };
  }
});

// ../../../node_modules/compress-commons/lib/compress-commons.js
var require_compress_commons = __commonJS({
  "../../../node_modules/compress-commons/lib/compress-commons.js"(exports2, module2) {
    module2.exports = {
      ArchiveEntry: require_archive_entry(),
      ZipArchiveEntry: require_zip_archive_entry(),
      ArchiveOutputStream: require_archive_output_stream(),
      ZipArchiveOutputStream: require_zip_archive_output_stream()
    };
  }
});

// ../../../node_modules/zip-stream/node_modules/readable-stream/lib/internal/streams/stream.js
var require_stream8 = __commonJS({
  "../../../node_modules/zip-stream/node_modules/readable-stream/lib/internal/streams/stream.js"(exports2, module2) {
    module2.exports = require("stream");
  }
});

// ../../../node_modules/zip-stream/node_modules/readable-stream/lib/internal/streams/buffer_list.js
var require_buffer_list5 = __commonJS({
  "../../../node_modules/zip-stream/node_modules/readable-stream/lib/internal/streams/buffer_list.js"(exports2, module2) {
    "use strict";
    function ownKeys(object, enumerableOnly) {
      var keys = Object.keys(object);
      if (Object.getOwnPropertySymbols) {
        var symbols = Object.getOwnPropertySymbols(object);
        enumerableOnly && (symbols = symbols.filter(function(sym) {
          return Object.getOwnPropertyDescriptor(object, sym).enumerable;
        })), keys.push.apply(keys, symbols);
      }
      return keys;
    }
    function _objectSpread(target) {
      for (var i = 1; i < arguments.length; i++) {
        var source = null != arguments[i] ? arguments[i] : {};
        i % 2 ? ownKeys(Object(source), true).forEach(function(key) {
          _defineProperty(target, key, source[key]);
        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function(key) {
          Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
        });
      }
      return target;
    }
    function _defineProperty(obj2, key, value) {
      key = _toPropertyKey(key);
      if (key in obj2) {
        Object.defineProperty(obj2, key, { value, enumerable: true, configurable: true, writable: true });
      } else {
        obj2[key] = value;
      }
      return obj2;
    }
    function _classCallCheck(instance, Constructor) {
      if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
      }
    }
    function _defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor)
          descriptor.writable = true;
        Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor);
      }
    }
    function _createClass(Constructor, protoProps, staticProps) {
      if (protoProps)
        _defineProperties(Constructor.prototype, protoProps);
      if (staticProps)
        _defineProperties(Constructor, staticProps);
      Object.defineProperty(Constructor, "prototype", { writable: false });
      return Constructor;
    }
    function _toPropertyKey(arg) {
      var key = _toPrimitive(arg, "string");
      return typeof key === "symbol" ? key : String(key);
    }
    function _toPrimitive(input, hint) {
      if (typeof input !== "object" || input === null)
        return input;
      var prim = input[Symbol.toPrimitive];
      if (prim !== void 0) {
        var res = prim.call(input, hint || "default");
        if (typeof res !== "object")
          return res;
        throw new TypeError("@@toPrimitive must return a primitive value.");
      }
      return (hint === "string" ? String : Number)(input);
    }
    var _require = require("buffer");
    var Buffer2 = _require.Buffer;
    var _require2 = require("util");
    var inspect = _require2.inspect;
    var custom = inspect && inspect.custom || "inspect";
    function copyBuffer(src, target, offset) {
      Buffer2.prototype.copy.call(src, target, offset);
    }
    module2.exports = /* @__PURE__ */ function() {
      function BufferList() {
        _classCallCheck(this, BufferList);
        this.head = null;
        this.tail = null;
        this.length = 0;
      }
      _createClass(BufferList, [{
        key: "push",
        value: function push(v) {
          var entry = {
            data: v,
            next: null
          };
          if (this.length > 0)
            this.tail.next = entry;
          else
            this.head = entry;
          this.tail = entry;
          ++this.length;
        }
      }, {
        key: "unshift",
        value: function unshift(v) {
          var entry = {
            data: v,
            next: this.head
          };
          if (this.length === 0)
            this.tail = entry;
          this.head = entry;
          ++this.length;
        }
      }, {
        key: "shift",
        value: function shift() {
          if (this.length === 0)
            return;
          var ret2 = this.head.data;
          if (this.length === 1)
            this.head = this.tail = null;
          else
            this.head = this.head.next;
          --this.length;
          return ret2;
        }
      }, {
        key: "clear",
        value: function clear() {
          this.head = this.tail = null;
          this.length = 0;
        }
      }, {
        key: "join",
        value: function join(s) {
          if (this.length === 0)
            return "";
          var p = this.head;
          var ret2 = "" + p.data;
          while (p = p.next)
            ret2 += s + p.data;
          return ret2;
        }
      }, {
        key: "concat",
        value: function concat(n) {
          if (this.length === 0)
            return Buffer2.alloc(0);
          var ret2 = Buffer2.allocUnsafe(n >>> 0);
          var p = this.head;
          var i = 0;
          while (p) {
            copyBuffer(p.data, ret2, i);
            i += p.data.length;
            p = p.next;
          }
          return ret2;
        }
        // Consumes a specified amount of bytes or characters from the buffered data.
      }, {
        key: "consume",
        value: function consume(n, hasStrings) {
          var ret2;
          if (n < this.head.data.length) {
            ret2 = this.head.data.slice(0, n);
            this.head.data = this.head.data.slice(n);
          } else if (n === this.head.data.length) {
            ret2 = this.shift();
          } else {
            ret2 = hasStrings ? this._getString(n) : this._getBuffer(n);
          }
          return ret2;
        }
      }, {
        key: "first",
        value: function first() {
          return this.head.data;
        }
        // Consumes a specified amount of characters from the buffered data.
      }, {
        key: "_getString",
        value: function _getString(n) {
          var p = this.head;
          var c = 1;
          var ret2 = p.data;
          n -= ret2.length;
          while (p = p.next) {
            var str = p.data;
            var nb = n > str.length ? str.length : n;
            if (nb === str.length)
              ret2 += str;
            else
              ret2 += str.slice(0, n);
            n -= nb;
            if (n === 0) {
              if (nb === str.length) {
                ++c;
                if (p.next)
                  this.head = p.next;
                else
                  this.head = this.tail = null;
              } else {
                this.head = p;
                p.data = str.slice(nb);
              }
              break;
            }
            ++c;
          }
          this.length -= c;
          return ret2;
        }
        // Consumes a specified amount of bytes from the buffered data.
      }, {
        key: "_getBuffer",
        value: function _getBuffer(n) {
          var ret2 = Buffer2.allocUnsafe(n);
          var p = this.head;
          var c = 1;
          p.data.copy(ret2);
          n -= p.data.length;
          while (p = p.next) {
            var buf = p.data;
            var nb = n > buf.length ? buf.length : n;
            buf.copy(ret2, ret2.length - n, 0, nb);
            n -= nb;
            if (n === 0) {
              if (nb === buf.length) {
                ++c;
                if (p.next)
                  this.head = p.next;
                else
                  this.head = this.tail = null;
              } else {
                this.head = p;
                p.data = buf.slice(nb);
              }
              break;
            }
            ++c;
          }
          this.length -= c;
          return ret2;
        }
        // Make sure the linked list only shows the minimal necessary information.
      }, {
        key: custom,
        value: function value(_2, options) {
          return inspect(this, _objectSpread(_objectSpread({}, options), {}, {
            // Only inspect one level.
            depth: 0,
            // It should not recurse.
            customInspect: false
          }));
        }
      }]);
      return BufferList;
    }();
  }
});

// ../../../node_modules/zip-stream/node_modules/readable-stream/lib/internal/streams/destroy.js
var require_destroy8 = __commonJS({
  "../../../node_modules/zip-stream/node_modules/readable-stream/lib/internal/streams/destroy.js"(exports2, module2) {
    "use strict";
    function destroy(err, cb) {
      var _this = this;
      var readableDestroyed = this._readableState && this._readableState.destroyed;
      var writableDestroyed = this._writableState && this._writableState.destroyed;
      if (readableDestroyed || writableDestroyed) {
        if (cb) {
          cb(err);
        } else if (err) {
          if (!this._writableState) {
            process.nextTick(emitErrorNT, this, err);
          } else if (!this._writableState.errorEmitted) {
            this._writableState.errorEmitted = true;
            process.nextTick(emitErrorNT, this, err);
          }
        }
        return this;
      }
      if (this._readableState) {
        this._readableState.destroyed = true;
      }
      if (this._writableState) {
        this._writableState.destroyed = true;
      }
      this._destroy(err || null, function(err2) {
        if (!cb && err2) {
          if (!_this._writableState) {
            process.nextTick(emitErrorAndCloseNT, _this, err2);
          } else if (!_this._writableState.errorEmitted) {
            _this._writableState.errorEmitted = true;
            process.nextTick(emitErrorAndCloseNT, _this, err2);
          } else {
            process.nextTick(emitCloseNT, _this);
          }
        } else if (cb) {
          process.nextTick(emitCloseNT, _this);
          cb(err2);
        } else {
          process.nextTick(emitCloseNT, _this);
        }
      });
      return this;
    }
    function emitErrorAndCloseNT(self2, err) {
      emitErrorNT(self2, err);
      emitCloseNT(self2);
    }
    function emitCloseNT(self2) {
      if (self2._writableState && !self2._writableState.emitClose)
        return;
      if (self2._readableState && !self2._readableState.emitClose)
        return;
      self2.emit("close");
    }
    function undestroy() {
      if (this._readableState) {
        this._readableState.destroyed = false;
        this._readableState.reading = false;
        this._readableState.ended = false;
        this._readableState.endEmitted = false;
      }
      if (this._writableState) {
        this._writableState.destroyed = false;
        this._writableState.ended = false;
        this._writableState.ending = false;
        this._writableState.finalCalled = false;
        this._writableState.prefinished = false;
        this._writableState.finished = false;
        this._writableState.errorEmitted = false;
      }
    }
    function emitErrorNT(self2, err) {
      self2.emit("error", err);
    }
    function errorOrDestroy(stream, err) {
      var rState = stream._readableState;
      var wState = stream._writableState;
      if (rState && rState.autoDestroy || wState && wState.autoDestroy)
        stream.destroy(err);
      else
        stream.emit("error", err);
    }
    module2.exports = {
      destroy,
      undestroy,
      errorOrDestroy
    };
  }
});

// ../../../node_modules/zip-stream/node_modules/readable-stream/errors.js
var require_errors5 = __commonJS({
  "../../../node_modules/zip-stream/node_modules/readable-stream/errors.js"(exports2, module2) {
    "use strict";
    var codes = {};
    function createErrorType(code, message, Base) {
      if (!Base) {
        Base = Error;
      }
      function getMessage(arg1, arg2, arg3) {
        if (typeof message === "string") {
          return message;
        } else {
          return message(arg1, arg2, arg3);
        }
      }
      class NodeError extends Base {
        constructor(arg1, arg2, arg3) {
          super(getMessage(arg1, arg2, arg3));
        }
      }
      NodeError.prototype.name = Base.name;
      NodeError.prototype.code = code;
      codes[code] = NodeError;
    }
    function oneOf(expected, thing) {
      if (Array.isArray(expected)) {
        const len = expected.length;
        expected = expected.map((i) => String(i));
        if (len > 2) {
          return `one of ${thing} ${expected.slice(0, len - 1).join(", ")}, or ` + expected[len - 1];
        } else if (len === 2) {
          return `one of ${thing} ${expected[0]} or ${expected[1]}`;
        } else {
          return `of ${thing} ${expected[0]}`;
        }
      } else {
        return `of ${thing} ${String(expected)}`;
      }
    }
    function startsWith(str, search, pos) {
      return str.substr(!pos || pos < 0 ? 0 : +pos, search.length) === search;
    }
    function endsWith(str, search, this_len) {
      if (this_len === void 0 || this_len > str.length) {
        this_len = str.length;
      }
      return str.substring(this_len - search.length, this_len) === search;
    }
    function includes(str, search, start) {
      if (typeof start !== "number") {
        start = 0;
      }
      if (start + search.length > str.length) {
        return false;
      } else {
        return str.indexOf(search, start) !== -1;
      }
    }
    createErrorType("ERR_INVALID_OPT_VALUE", function(name, value) {
      return 'The value "' + value + '" is invalid for option "' + name + '"';
    }, TypeError);
    createErrorType("ERR_INVALID_ARG_TYPE", function(name, expected, actual) {
      let determiner;
      if (typeof expected === "string" && startsWith(expected, "not ")) {
        determiner = "must not be";
        expected = expected.replace(/^not /, "");
      } else {
        determiner = "must be";
      }
      let msg;
      if (endsWith(name, " argument")) {
        msg = `The ${name} ${determiner} ${oneOf(expected, "type")}`;
      } else {
        const type = includes(name, ".") ? "property" : "argument";
        msg = `The "${name}" ${type} ${determiner} ${oneOf(expected, "type")}`;
      }
      msg += `. Received type ${typeof actual}`;
      return msg;
    }, TypeError);
    createErrorType("ERR_STREAM_PUSH_AFTER_EOF", "stream.push() after EOF");
    createErrorType("ERR_METHOD_NOT_IMPLEMENTED", function(name) {
      return "The " + name + " method is not implemented";
    });
    createErrorType("ERR_STREAM_PREMATURE_CLOSE", "Premature close");
    createErrorType("ERR_STREAM_DESTROYED", function(name) {
      return "Cannot call " + name + " after a stream was destroyed";
    });
    createErrorType("ERR_MULTIPLE_CALLBACK", "Callback called multiple times");
    createErrorType("ERR_STREAM_CANNOT_PIPE", "Cannot pipe, not readable");
    createErrorType("ERR_STREAM_WRITE_AFTER_END", "write after end");
    createErrorType("ERR_STREAM_NULL_VALUES", "May not write null values to stream", TypeError);
    createErrorType("ERR_UNKNOWN_ENCODING", function(arg) {
      return "Unknown encoding: " + arg;
    }, TypeError);
    createErrorType("ERR_STREAM_UNSHIFT_AFTER_END_EVENT", "stream.unshift() after end event");
    module2.exports.codes = codes;
  }
});

// ../../../node_modules/zip-stream/node_modules/readable-stream/lib/internal/streams/state.js
var require_state5 = __commonJS({
  "../../../node_modules/zip-stream/node_modules/readable-stream/lib/internal/streams/state.js"(exports2, module2) {
    "use strict";
    var ERR_INVALID_OPT_VALUE = require_errors5().codes.ERR_INVALID_OPT_VALUE;
    function highWaterMarkFrom(options, isDuplex, duplexKey) {
      return options.highWaterMark != null ? options.highWaterMark : isDuplex ? options[duplexKey] : null;
    }
    function getHighWaterMark(state, options, duplexKey, isDuplex) {
      var hwm = highWaterMarkFrom(options, isDuplex, duplexKey);
      if (hwm != null) {
        if (!(isFinite(hwm) && Math.floor(hwm) === hwm) || hwm < 0) {
          var name = isDuplex ? duplexKey : "highWaterMark";
          throw new ERR_INVALID_OPT_VALUE(name, hwm);
        }
        return Math.floor(hwm);
      }
      return state.objectMode ? 16 : 16 * 1024;
    }
    module2.exports = {
      getHighWaterMark
    };
  }
});

// ../../../node_modules/zip-stream/node_modules/readable-stream/lib/_stream_writable.js
var require_stream_writable8 = __commonJS({
  "../../../node_modules/zip-stream/node_modules/readable-stream/lib/_stream_writable.js"(exports2, module2) {
    "use strict";
    module2.exports = Writable;
    function CorkedRequest(state) {
      var _this = this;
      this.next = null;
      this.entry = null;
      this.finish = function() {
        onCorkedFinish(_this, state);
      };
    }
    var Duplex;
    Writable.WritableState = WritableState;
    var internalUtil = {
      deprecate: require_node()
    };
    var Stream = require_stream8();
    var Buffer2 = require("buffer").Buffer;
    var OurUint8Array = (typeof global !== "undefined" ? global : typeof window !== "undefined" ? window : typeof self !== "undefined" ? self : {}).Uint8Array || function() {
    };
    function _uint8ArrayToBuffer(chunk) {
      return Buffer2.from(chunk);
    }
    function _isUint8Array(obj2) {
      return Buffer2.isBuffer(obj2) || obj2 instanceof OurUint8Array;
    }
    var destroyImpl = require_destroy8();
    var _require = require_state5();
    var getHighWaterMark = _require.getHighWaterMark;
    var _require$codes = require_errors5().codes;
    var ERR_INVALID_ARG_TYPE = _require$codes.ERR_INVALID_ARG_TYPE;
    var ERR_METHOD_NOT_IMPLEMENTED = _require$codes.ERR_METHOD_NOT_IMPLEMENTED;
    var ERR_MULTIPLE_CALLBACK = _require$codes.ERR_MULTIPLE_CALLBACK;
    var ERR_STREAM_CANNOT_PIPE = _require$codes.ERR_STREAM_CANNOT_PIPE;
    var ERR_STREAM_DESTROYED = _require$codes.ERR_STREAM_DESTROYED;
    var ERR_STREAM_NULL_VALUES = _require$codes.ERR_STREAM_NULL_VALUES;
    var ERR_STREAM_WRITE_AFTER_END = _require$codes.ERR_STREAM_WRITE_AFTER_END;
    var ERR_UNKNOWN_ENCODING = _require$codes.ERR_UNKNOWN_ENCODING;
    var errorOrDestroy = destroyImpl.errorOrDestroy;
    require_inherits()(Writable, Stream);
    function nop() {
    }
    function WritableState(options, stream, isDuplex) {
      Duplex = Duplex || require_stream_duplex8();
      options = options || {};
      if (typeof isDuplex !== "boolean")
        isDuplex = stream instanceof Duplex;
      this.objectMode = !!options.objectMode;
      if (isDuplex)
        this.objectMode = this.objectMode || !!options.writableObjectMode;
      this.highWaterMark = getHighWaterMark(this, options, "writableHighWaterMark", isDuplex);
      this.finalCalled = false;
      this.needDrain = false;
      this.ending = false;
      this.ended = false;
      this.finished = false;
      this.destroyed = false;
      var noDecode = options.decodeStrings === false;
      this.decodeStrings = !noDecode;
      this.defaultEncoding = options.defaultEncoding || "utf8";
      this.length = 0;
      this.writing = false;
      this.corked = 0;
      this.sync = true;
      this.bufferProcessing = false;
      this.onwrite = function(er) {
        onwrite(stream, er);
      };
      this.writecb = null;
      this.writelen = 0;
      this.bufferedRequest = null;
      this.lastBufferedRequest = null;
      this.pendingcb = 0;
      this.prefinished = false;
      this.errorEmitted = false;
      this.emitClose = options.emitClose !== false;
      this.autoDestroy = !!options.autoDestroy;
      this.bufferedRequestCount = 0;
      this.corkedRequestsFree = new CorkedRequest(this);
    }
    WritableState.prototype.getBuffer = function getBuffer() {
      var current = this.bufferedRequest;
      var out = [];
      while (current) {
        out.push(current);
        current = current.next;
      }
      return out;
    };
    (function() {
      try {
        Object.defineProperty(WritableState.prototype, "buffer", {
          get: internalUtil.deprecate(function writableStateBufferGetter() {
            return this.getBuffer();
          }, "_writableState.buffer is deprecated. Use _writableState.getBuffer instead.", "DEP0003")
        });
      } catch (_2) {
      }
    })();
    var realHasInstance;
    if (typeof Symbol === "function" && Symbol.hasInstance && typeof Function.prototype[Symbol.hasInstance] === "function") {
      realHasInstance = Function.prototype[Symbol.hasInstance];
      Object.defineProperty(Writable, Symbol.hasInstance, {
        value: function value(object) {
          if (realHasInstance.call(this, object))
            return true;
          if (this !== Writable)
            return false;
          return object && object._writableState instanceof WritableState;
        }
      });
    } else {
      realHasInstance = function realHasInstance2(object) {
        return object instanceof this;
      };
    }
    function Writable(options) {
      Duplex = Duplex || require_stream_duplex8();
      var isDuplex = this instanceof Duplex;
      if (!isDuplex && !realHasInstance.call(Writable, this))
        return new Writable(options);
      this._writableState = new WritableState(options, this, isDuplex);
      this.writable = true;
      if (options) {
        if (typeof options.write === "function")
          this._write = options.write;
        if (typeof options.writev === "function")
          this._writev = options.writev;
        if (typeof options.destroy === "function")
          this._destroy = options.destroy;
        if (typeof options.final === "function")
          this._final = options.final;
      }
      Stream.call(this);
    }
    Writable.prototype.pipe = function() {
      errorOrDestroy(this, new ERR_STREAM_CANNOT_PIPE());
    };
    function writeAfterEnd(stream, cb) {
      var er = new ERR_STREAM_WRITE_AFTER_END();
      errorOrDestroy(stream, er);
      process.nextTick(cb, er);
    }
    function validChunk(stream, state, chunk, cb) {
      var er;
      if (chunk === null) {
        er = new ERR_STREAM_NULL_VALUES();
      } else if (typeof chunk !== "string" && !state.objectMode) {
        er = new ERR_INVALID_ARG_TYPE("chunk", ["string", "Buffer"], chunk);
      }
      if (er) {
        errorOrDestroy(stream, er);
        process.nextTick(cb, er);
        return false;
      }
      return true;
    }
    Writable.prototype.write = function(chunk, encoding, cb) {
      var state = this._writableState;
      var ret2 = false;
      var isBuf = !state.objectMode && _isUint8Array(chunk);
      if (isBuf && !Buffer2.isBuffer(chunk)) {
        chunk = _uint8ArrayToBuffer(chunk);
      }
      if (typeof encoding === "function") {
        cb = encoding;
        encoding = null;
      }
      if (isBuf)
        encoding = "buffer";
      else if (!encoding)
        encoding = state.defaultEncoding;
      if (typeof cb !== "function")
        cb = nop;
      if (state.ending)
        writeAfterEnd(this, cb);
      else if (isBuf || validChunk(this, state, chunk, cb)) {
        state.pendingcb++;
        ret2 = writeOrBuffer(this, state, isBuf, chunk, encoding, cb);
      }
      return ret2;
    };
    Writable.prototype.cork = function() {
      this._writableState.corked++;
    };
    Writable.prototype.uncork = function() {
      var state = this._writableState;
      if (state.corked) {
        state.corked--;
        if (!state.writing && !state.corked && !state.bufferProcessing && state.bufferedRequest)
          clearBuffer(this, state);
      }
    };
    Writable.prototype.setDefaultEncoding = function setDefaultEncoding(encoding) {
      if (typeof encoding === "string")
        encoding = encoding.toLowerCase();
      if (!(["hex", "utf8", "utf-8", "ascii", "binary", "base64", "ucs2", "ucs-2", "utf16le", "utf-16le", "raw"].indexOf((encoding + "").toLowerCase()) > -1))
        throw new ERR_UNKNOWN_ENCODING(encoding);
      this._writableState.defaultEncoding = encoding;
      return this;
    };
    Object.defineProperty(Writable.prototype, "writableBuffer", {
      // making it explicit this property is not enumerable
      // because otherwise some prototype manipulation in
      // userland will fail
      enumerable: false,
      get: function get() {
        return this._writableState && this._writableState.getBuffer();
      }
    });
    function decodeChunk(state, chunk, encoding) {
      if (!state.objectMode && state.decodeStrings !== false && typeof chunk === "string") {
        chunk = Buffer2.from(chunk, encoding);
      }
      return chunk;
    }
    Object.defineProperty(Writable.prototype, "writableHighWaterMark", {
      // making it explicit this property is not enumerable
      // because otherwise some prototype manipulation in
      // userland will fail
      enumerable: false,
      get: function get() {
        return this._writableState.highWaterMark;
      }
    });
    function writeOrBuffer(stream, state, isBuf, chunk, encoding, cb) {
      if (!isBuf) {
        var newChunk = decodeChunk(state, chunk, encoding);
        if (chunk !== newChunk) {
          isBuf = true;
          encoding = "buffer";
          chunk = newChunk;
        }
      }
      var len = state.objectMode ? 1 : chunk.length;
      state.length += len;
      var ret2 = state.length < state.highWaterMark;
      if (!ret2)
        state.needDrain = true;
      if (state.writing || state.corked) {
        var last = state.lastBufferedRequest;
        state.lastBufferedRequest = {
          chunk,
          encoding,
          isBuf,
          callback: cb,
          next: null
        };
        if (last) {
          last.next = state.lastBufferedRequest;
        } else {
          state.bufferedRequest = state.lastBufferedRequest;
        }
        state.bufferedRequestCount += 1;
      } else {
        doWrite(stream, state, false, len, chunk, encoding, cb);
      }
      return ret2;
    }
    function doWrite(stream, state, writev, len, chunk, encoding, cb) {
      state.writelen = len;
      state.writecb = cb;
      state.writing = true;
      state.sync = true;
      if (state.destroyed)
        state.onwrite(new ERR_STREAM_DESTROYED("write"));
      else if (writev)
        stream._writev(chunk, state.onwrite);
      else
        stream._write(chunk, encoding, state.onwrite);
      state.sync = false;
    }
    function onwriteError(stream, state, sync, er, cb) {
      --state.pendingcb;
      if (sync) {
        process.nextTick(cb, er);
        process.nextTick(finishMaybe, stream, state);
        stream._writableState.errorEmitted = true;
        errorOrDestroy(stream, er);
      } else {
        cb(er);
        stream._writableState.errorEmitted = true;
        errorOrDestroy(stream, er);
        finishMaybe(stream, state);
      }
    }
    function onwriteStateUpdate(state) {
      state.writing = false;
      state.writecb = null;
      state.length -= state.writelen;
      state.writelen = 0;
    }
    function onwrite(stream, er) {
      var state = stream._writableState;
      var sync = state.sync;
      var cb = state.writecb;
      if (typeof cb !== "function")
        throw new ERR_MULTIPLE_CALLBACK();
      onwriteStateUpdate(state);
      if (er)
        onwriteError(stream, state, sync, er, cb);
      else {
        var finished = needFinish(state) || stream.destroyed;
        if (!finished && !state.corked && !state.bufferProcessing && state.bufferedRequest) {
          clearBuffer(stream, state);
        }
        if (sync) {
          process.nextTick(afterWrite, stream, state, finished, cb);
        } else {
          afterWrite(stream, state, finished, cb);
        }
      }
    }
    function afterWrite(stream, state, finished, cb) {
      if (!finished)
        onwriteDrain(stream, state);
      state.pendingcb--;
      cb();
      finishMaybe(stream, state);
    }
    function onwriteDrain(stream, state) {
      if (state.length === 0 && state.needDrain) {
        state.needDrain = false;
        stream.emit("drain");
      }
    }
    function clearBuffer(stream, state) {
      state.bufferProcessing = true;
      var entry = state.bufferedRequest;
      if (stream._writev && entry && entry.next) {
        var l2 = state.bufferedRequestCount;
        var buffer = new Array(l2);
        var holder = state.corkedRequestsFree;
        holder.entry = entry;
        var count = 0;
        var allBuffers = true;
        while (entry) {
          buffer[count] = entry;
          if (!entry.isBuf)
            allBuffers = false;
          entry = entry.next;
          count += 1;
        }
        buffer.allBuffers = allBuffers;
        doWrite(stream, state, true, state.length, buffer, "", holder.finish);
        state.pendingcb++;
        state.lastBufferedRequest = null;
        if (holder.next) {
          state.corkedRequestsFree = holder.next;
          holder.next = null;
        } else {
          state.corkedRequestsFree = new CorkedRequest(state);
        }
        state.bufferedRequestCount = 0;
      } else {
        while (entry) {
          var chunk = entry.chunk;
          var encoding = entry.encoding;
          var cb = entry.callback;
          var len = state.objectMode ? 1 : chunk.length;
          doWrite(stream, state, false, len, chunk, encoding, cb);
          entry = entry.next;
          state.bufferedRequestCount--;
          if (state.writing) {
            break;
          }
        }
        if (entry === null)
          state.lastBufferedRequest = null;
      }
      state.bufferedRequest = entry;
      state.bufferProcessing = false;
    }
    Writable.prototype._write = function(chunk, encoding, cb) {
      cb(new ERR_METHOD_NOT_IMPLEMENTED("_write()"));
    };
    Writable.prototype._writev = null;
    Writable.prototype.end = function(chunk, encoding, cb) {
      var state = this._writableState;
      if (typeof chunk === "function") {
        cb = chunk;
        chunk = null;
        encoding = null;
      } else if (typeof encoding === "function") {
        cb = encoding;
        encoding = null;
      }
      if (chunk !== null && chunk !== void 0)
        this.write(chunk, encoding);
      if (state.corked) {
        state.corked = 1;
        this.uncork();
      }
      if (!state.ending)
        endWritable(this, state, cb);
      return this;
    };
    Object.defineProperty(Writable.prototype, "writableLength", {
      // making it explicit this property is not enumerable
      // because otherwise some prototype manipulation in
      // userland will fail
      enumerable: false,
      get: function get() {
        return this._writableState.length;
      }
    });
    function needFinish(state) {
      return state.ending && state.length === 0 && state.bufferedRequest === null && !state.finished && !state.writing;
    }
    function callFinal(stream, state) {
      stream._final(function(err) {
        state.pendingcb--;
        if (err) {
          errorOrDestroy(stream, err);
        }
        state.prefinished = true;
        stream.emit("prefinish");
        finishMaybe(stream, state);
      });
    }
    function prefinish(stream, state) {
      if (!state.prefinished && !state.finalCalled) {
        if (typeof stream._final === "function" && !state.destroyed) {
          state.pendingcb++;
          state.finalCalled = true;
          process.nextTick(callFinal, stream, state);
        } else {
          state.prefinished = true;
          stream.emit("prefinish");
        }
      }
    }
    function finishMaybe(stream, state) {
      var need = needFinish(state);
      if (need) {
        prefinish(stream, state);
        if (state.pendingcb === 0) {
          state.finished = true;
          stream.emit("finish");
          if (state.autoDestroy) {
            var rState = stream._readableState;
            if (!rState || rState.autoDestroy && rState.endEmitted) {
              stream.destroy();
            }
          }
        }
      }
      return need;
    }
    function endWritable(stream, state, cb) {
      state.ending = true;
      finishMaybe(stream, state);
      if (cb) {
        if (state.finished)
          process.nextTick(cb);
        else
          stream.once("finish", cb);
      }
      state.ended = true;
      stream.writable = false;
    }
    function onCorkedFinish(corkReq, state, err) {
      var entry = corkReq.entry;
      corkReq.entry = null;
      while (entry) {
        var cb = entry.callback;
        state.pendingcb--;
        cb(err);
        entry = entry.next;
      }
      state.corkedRequestsFree.next = corkReq;
    }
    Object.defineProperty(Writable.prototype, "destroyed", {
      // making it explicit this property is not enumerable
      // because otherwise some prototype manipulation in
      // userland will fail
      enumerable: false,
      get: function get() {
        if (this._writableState === void 0) {
          return false;
        }
        return this._writableState.destroyed;
      },
      set: function set(value) {
        if (!this._writableState) {
          return;
        }
        this._writableState.destroyed = value;
      }
    });
    Writable.prototype.destroy = destroyImpl.destroy;
    Writable.prototype._undestroy = destroyImpl.undestroy;
    Writable.prototype._destroy = function(err, cb) {
      cb(err);
    };
  }
});

// ../../../node_modules/zip-stream/node_modules/readable-stream/lib/_stream_duplex.js
var require_stream_duplex8 = __commonJS({
  "../../../node_modules/zip-stream/node_modules/readable-stream/lib/_stream_duplex.js"(exports2, module2) {
    "use strict";
    var objectKeys = Object.keys || function(obj2) {
      var keys2 = [];
      for (var key in obj2)
        keys2.push(key);
      return keys2;
    };
    module2.exports = Duplex;
    var Readable = require_stream_readable8();
    var Writable = require_stream_writable8();
    require_inherits()(Duplex, Readable);
    {
      keys = objectKeys(Writable.prototype);
      for (v = 0; v < keys.length; v++) {
        method = keys[v];
        if (!Duplex.prototype[method])
          Duplex.prototype[method] = Writable.prototype[method];
      }
    }
    var keys;
    var method;
    var v;
    function Duplex(options) {
      if (!(this instanceof Duplex))
        return new Duplex(options);
      Readable.call(this, options);
      Writable.call(this, options);
      this.allowHalfOpen = true;
      if (options) {
        if (options.readable === false)
          this.readable = false;
        if (options.writable === false)
          this.writable = false;
        if (options.allowHalfOpen === false) {
          this.allowHalfOpen = false;
          this.once("end", onend);
        }
      }
    }
    Object.defineProperty(Duplex.prototype, "writableHighWaterMark", {
      // making it explicit this property is not enumerable
      // because otherwise some prototype manipulation in
      // userland will fail
      enumerable: false,
      get: function get() {
        return this._writableState.highWaterMark;
      }
    });
    Object.defineProperty(Duplex.prototype, "writableBuffer", {
      // making it explicit this property is not enumerable
      // because otherwise some prototype manipulation in
      // userland will fail
      enumerable: false,
      get: function get() {
        return this._writableState && this._writableState.getBuffer();
      }
    });
    Object.defineProperty(Duplex.prototype, "writableLength", {
      // making it explicit this property is not enumerable
      // because otherwise some prototype manipulation in
      // userland will fail
      enumerable: false,
      get: function get() {
        return this._writableState.length;
      }
    });
    function onend() {
      if (this._writableState.ended)
        return;
      process.nextTick(onEndNT, this);
    }
    function onEndNT(self2) {
      self2.end();
    }
    Object.defineProperty(Duplex.prototype, "destroyed", {
      // making it explicit this property is not enumerable
      // because otherwise some prototype manipulation in
      // userland will fail
      enumerable: false,
      get: function get() {
        if (this._readableState === void 0 || this._writableState === void 0) {
          return false;
        }
        return this._readableState.destroyed && this._writableState.destroyed;
      },
      set: function set(value) {
        if (this._readableState === void 0 || this._writableState === void 0) {
          return;
        }
        this._readableState.destroyed = value;
        this._writableState.destroyed = value;
      }
    });
  }
});

// ../../../node_modules/zip-stream/node_modules/string_decoder/lib/string_decoder.js
var require_string_decoder8 = __commonJS({
  "../../../node_modules/zip-stream/node_modules/string_decoder/lib/string_decoder.js"(exports2) {
    "use strict";
    var Buffer2 = require_safe_buffer2().Buffer;
    var isEncoding = Buffer2.isEncoding || function(encoding) {
      encoding = "" + encoding;
      switch (encoding && encoding.toLowerCase()) {
        case "hex":
        case "utf8":
        case "utf-8":
        case "ascii":
        case "binary":
        case "base64":
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
        case "raw":
          return true;
        default:
          return false;
      }
    };
    function _normalizeEncoding(enc) {
      if (!enc)
        return "utf8";
      var retried;
      while (true) {
        switch (enc) {
          case "utf8":
          case "utf-8":
            return "utf8";
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
            return "utf16le";
          case "latin1":
          case "binary":
            return "latin1";
          case "base64":
          case "ascii":
          case "hex":
            return enc;
          default:
            if (retried)
              return;
            enc = ("" + enc).toLowerCase();
            retried = true;
        }
      }
    }
    function normalizeEncoding(enc) {
      var nenc = _normalizeEncoding(enc);
      if (typeof nenc !== "string" && (Buffer2.isEncoding === isEncoding || !isEncoding(enc)))
        throw new Error("Unknown encoding: " + enc);
      return nenc || enc;
    }
    exports2.StringDecoder = StringDecoder;
    function StringDecoder(encoding) {
      this.encoding = normalizeEncoding(encoding);
      var nb;
      switch (this.encoding) {
        case "utf16le":
          this.text = utf16Text;
          this.end = utf16End;
          nb = 4;
          break;
        case "utf8":
          this.fillLast = utf8FillLast;
          nb = 4;
          break;
        case "base64":
          this.text = base64Text;
          this.end = base64End;
          nb = 3;
          break;
        default:
          this.write = simpleWrite;
          this.end = simpleEnd;
          return;
      }
      this.lastNeed = 0;
      this.lastTotal = 0;
      this.lastChar = Buffer2.allocUnsafe(nb);
    }
    StringDecoder.prototype.write = function(buf) {
      if (buf.length === 0)
        return "";
      var r;
      var i;
      if (this.lastNeed) {
        r = this.fillLast(buf);
        if (r === void 0)
          return "";
        i = this.lastNeed;
        this.lastNeed = 0;
      } else {
        i = 0;
      }
      if (i < buf.length)
        return r ? r + this.text(buf, i) : this.text(buf, i);
      return r || "";
    };
    StringDecoder.prototype.end = utf8End;
    StringDecoder.prototype.text = utf8Text;
    StringDecoder.prototype.fillLast = function(buf) {
      if (this.lastNeed <= buf.length) {
        buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, this.lastNeed);
        return this.lastChar.toString(this.encoding, 0, this.lastTotal);
      }
      buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, buf.length);
      this.lastNeed -= buf.length;
    };
    function utf8CheckByte(byte) {
      if (byte <= 127)
        return 0;
      else if (byte >> 5 === 6)
        return 2;
      else if (byte >> 4 === 14)
        return 3;
      else if (byte >> 3 === 30)
        return 4;
      return byte >> 6 === 2 ? -1 : -2;
    }
    function utf8CheckIncomplete(self2, buf, i) {
      var j = buf.length - 1;
      if (j < i)
        return 0;
      var nb = utf8CheckByte(buf[j]);
      if (nb >= 0) {
        if (nb > 0)
          self2.lastNeed = nb - 1;
        return nb;
      }
      if (--j < i || nb === -2)
        return 0;
      nb = utf8CheckByte(buf[j]);
      if (nb >= 0) {
        if (nb > 0)
          self2.lastNeed = nb - 2;
        return nb;
      }
      if (--j < i || nb === -2)
        return 0;
      nb = utf8CheckByte(buf[j]);
      if (nb >= 0) {
        if (nb > 0) {
          if (nb === 2)
            nb = 0;
          else
            self2.lastNeed = nb - 3;
        }
        return nb;
      }
      return 0;
    }
    function utf8CheckExtraBytes(self2, buf, p) {
      if ((buf[0] & 192) !== 128) {
        self2.lastNeed = 0;
        return "\uFFFD";
      }
      if (self2.lastNeed > 1 && buf.length > 1) {
        if ((buf[1] & 192) !== 128) {
          self2.lastNeed = 1;
          return "\uFFFD";
        }
        if (self2.lastNeed > 2 && buf.length > 2) {
          if ((buf[2] & 192) !== 128) {
            self2.lastNeed = 2;
            return "\uFFFD";
          }
        }
      }
    }
    function utf8FillLast(buf) {
      var p = this.lastTotal - this.lastNeed;
      var r = utf8CheckExtraBytes(this, buf, p);
      if (r !== void 0)
        return r;
      if (this.lastNeed <= buf.length) {
        buf.copy(this.lastChar, p, 0, this.lastNeed);
        return this.lastChar.toString(this.encoding, 0, this.lastTotal);
      }
      buf.copy(this.lastChar, p, 0, buf.length);
      this.lastNeed -= buf.length;
    }
    function utf8Text(buf, i) {
      var total = utf8CheckIncomplete(this, buf, i);
      if (!this.lastNeed)
        return buf.toString("utf8", i);
      this.lastTotal = total;
      var end = buf.length - (total - this.lastNeed);
      buf.copy(this.lastChar, 0, end);
      return buf.toString("utf8", i, end);
    }
    function utf8End(buf) {
      var r = buf && buf.length ? this.write(buf) : "";
      if (this.lastNeed)
        return r + "\uFFFD";
      return r;
    }
    function utf16Text(buf, i) {
      if ((buf.length - i) % 2 === 0) {
        var r = buf.toString("utf16le", i);
        if (r) {
          var c = r.charCodeAt(r.length - 1);
          if (c >= 55296 && c <= 56319) {
            this.lastNeed = 2;
            this.lastTotal = 4;
            this.lastChar[0] = buf[buf.length - 2];
            this.lastChar[1] = buf[buf.length - 1];
            return r.slice(0, -1);
          }
        }
        return r;
      }
      this.lastNeed = 1;
      this.lastTotal = 2;
      this.lastChar[0] = buf[buf.length - 1];
      return buf.toString("utf16le", i, buf.length - 1);
    }
    function utf16End(buf) {
      var r = buf && buf.length ? this.write(buf) : "";
      if (this.lastNeed) {
        var end = this.lastTotal - this.lastNeed;
        return r + this.lastChar.toString("utf16le", 0, end);
      }
      return r;
    }
    function base64Text(buf, i) {
      var n = (buf.length - i) % 3;
      if (n === 0)
        return buf.toString("base64", i);
      this.lastNeed = 3 - n;
      this.lastTotal = 3;
      if (n === 1) {
        this.lastChar[0] = buf[buf.length - 1];
      } else {
        this.lastChar[0] = buf[buf.length - 2];
        this.lastChar[1] = buf[buf.length - 1];
      }
      return buf.toString("base64", i, buf.length - n);
    }
    function base64End(buf) {
      var r = buf && buf.length ? this.write(buf) : "";
      if (this.lastNeed)
        return r + this.lastChar.toString("base64", 0, 3 - this.lastNeed);
      return r;
    }
    function simpleWrite(buf) {
      return buf.toString(this.encoding);
    }
    function simpleEnd(buf) {
      return buf && buf.length ? this.write(buf) : "";
    }
  }
});

// ../../../node_modules/zip-stream/node_modules/readable-stream/lib/internal/streams/end-of-stream.js
var require_end_of_stream5 = __commonJS({
  "../../../node_modules/zip-stream/node_modules/readable-stream/lib/internal/streams/end-of-stream.js"(exports2, module2) {
    "use strict";
    var ERR_STREAM_PREMATURE_CLOSE = require_errors5().codes.ERR_STREAM_PREMATURE_CLOSE;
    function once(callback) {
      var called = false;
      return function() {
        if (called)
          return;
        called = true;
        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }
        callback.apply(this, args);
      };
    }
    function noop() {
    }
    function isRequest(stream) {
      return stream.setHeader && typeof stream.abort === "function";
    }
    function eos(stream, opts, callback) {
      if (typeof opts === "function")
        return eos(stream, null, opts);
      if (!opts)
        opts = {};
      callback = once(callback || noop);
      var readable = opts.readable || opts.readable !== false && stream.readable;
      var writable = opts.writable || opts.writable !== false && stream.writable;
      var onlegacyfinish = function onlegacyfinish2() {
        if (!stream.writable)
          onfinish();
      };
      var writableEnded = stream._writableState && stream._writableState.finished;
      var onfinish = function onfinish2() {
        writable = false;
        writableEnded = true;
        if (!readable)
          callback.call(stream);
      };
      var readableEnded = stream._readableState && stream._readableState.endEmitted;
      var onend = function onend2() {
        readable = false;
        readableEnded = true;
        if (!writable)
          callback.call(stream);
      };
      var onerror = function onerror2(err) {
        callback.call(stream, err);
      };
      var onclose = function onclose2() {
        var err;
        if (readable && !readableEnded) {
          if (!stream._readableState || !stream._readableState.ended)
            err = new ERR_STREAM_PREMATURE_CLOSE();
          return callback.call(stream, err);
        }
        if (writable && !writableEnded) {
          if (!stream._writableState || !stream._writableState.ended)
            err = new ERR_STREAM_PREMATURE_CLOSE();
          return callback.call(stream, err);
        }
      };
      var onrequest = function onrequest2() {
        stream.req.on("finish", onfinish);
      };
      if (isRequest(stream)) {
        stream.on("complete", onfinish);
        stream.on("abort", onclose);
        if (stream.req)
          onrequest();
        else
          stream.on("request", onrequest);
      } else if (writable && !stream._writableState) {
        stream.on("end", onlegacyfinish);
        stream.on("close", onlegacyfinish);
      }
      stream.on("end", onend);
      stream.on("finish", onfinish);
      if (opts.error !== false)
        stream.on("error", onerror);
      stream.on("close", onclose);
      return function() {
        stream.removeListener("complete", onfinish);
        stream.removeListener("abort", onclose);
        stream.removeListener("request", onrequest);
        if (stream.req)
          stream.req.removeListener("finish", onfinish);
        stream.removeListener("end", onlegacyfinish);
        stream.removeListener("close", onlegacyfinish);
        stream.removeListener("finish", onfinish);
        stream.removeListener("end", onend);
        stream.removeListener("error", onerror);
        stream.removeListener("close", onclose);
      };
    }
    module2.exports = eos;
  }
});

// ../../../node_modules/zip-stream/node_modules/readable-stream/lib/internal/streams/async_iterator.js
var require_async_iterator5 = __commonJS({
  "../../../node_modules/zip-stream/node_modules/readable-stream/lib/internal/streams/async_iterator.js"(exports2, module2) {
    "use strict";
    var _Object$setPrototypeO;
    function _defineProperty(obj2, key, value) {
      key = _toPropertyKey(key);
      if (key in obj2) {
        Object.defineProperty(obj2, key, { value, enumerable: true, configurable: true, writable: true });
      } else {
        obj2[key] = value;
      }
      return obj2;
    }
    function _toPropertyKey(arg) {
      var key = _toPrimitive(arg, "string");
      return typeof key === "symbol" ? key : String(key);
    }
    function _toPrimitive(input, hint) {
      if (typeof input !== "object" || input === null)
        return input;
      var prim = input[Symbol.toPrimitive];
      if (prim !== void 0) {
        var res = prim.call(input, hint || "default");
        if (typeof res !== "object")
          return res;
        throw new TypeError("@@toPrimitive must return a primitive value.");
      }
      return (hint === "string" ? String : Number)(input);
    }
    var finished = require_end_of_stream5();
    var kLastResolve = Symbol("lastResolve");
    var kLastReject = Symbol("lastReject");
    var kError = Symbol("error");
    var kEnded = Symbol("ended");
    var kLastPromise = Symbol("lastPromise");
    var kHandlePromise = Symbol("handlePromise");
    var kStream = Symbol("stream");
    function createIterResult(value, done) {
      return {
        value,
        done
      };
    }
    function readAndResolve(iter) {
      var resolve = iter[kLastResolve];
      if (resolve !== null) {
        var data = iter[kStream].read();
        if (data !== null) {
          iter[kLastPromise] = null;
          iter[kLastResolve] = null;
          iter[kLastReject] = null;
          resolve(createIterResult(data, false));
        }
      }
    }
    function onReadable(iter) {
      process.nextTick(readAndResolve, iter);
    }
    function wrapForNext(lastPromise, iter) {
      return function(resolve, reject) {
        lastPromise.then(function() {
          if (iter[kEnded]) {
            resolve(createIterResult(void 0, true));
            return;
          }
          iter[kHandlePromise](resolve, reject);
        }, reject);
      };
    }
    var AsyncIteratorPrototype = Object.getPrototypeOf(function() {
    });
    var ReadableStreamAsyncIteratorPrototype = Object.setPrototypeOf((_Object$setPrototypeO = {
      get stream() {
        return this[kStream];
      },
      next: function next() {
        var _this = this;
        var error = this[kError];
        if (error !== null) {
          return Promise.reject(error);
        }
        if (this[kEnded]) {
          return Promise.resolve(createIterResult(void 0, true));
        }
        if (this[kStream].destroyed) {
          return new Promise(function(resolve, reject) {
            process.nextTick(function() {
              if (_this[kError]) {
                reject(_this[kError]);
              } else {
                resolve(createIterResult(void 0, true));
              }
            });
          });
        }
        var lastPromise = this[kLastPromise];
        var promise;
        if (lastPromise) {
          promise = new Promise(wrapForNext(lastPromise, this));
        } else {
          var data = this[kStream].read();
          if (data !== null) {
            return Promise.resolve(createIterResult(data, false));
          }
          promise = new Promise(this[kHandlePromise]);
        }
        this[kLastPromise] = promise;
        return promise;
      }
    }, _defineProperty(_Object$setPrototypeO, Symbol.asyncIterator, function() {
      return this;
    }), _defineProperty(_Object$setPrototypeO, "return", function _return() {
      var _this2 = this;
      return new Promise(function(resolve, reject) {
        _this2[kStream].destroy(null, function(err) {
          if (err) {
            reject(err);
            return;
          }
          resolve(createIterResult(void 0, true));
        });
      });
    }), _Object$setPrototypeO), AsyncIteratorPrototype);
    var createReadableStreamAsyncIterator = function createReadableStreamAsyncIterator2(stream) {
      var _Object$create;
      var iterator = Object.create(ReadableStreamAsyncIteratorPrototype, (_Object$create = {}, _defineProperty(_Object$create, kStream, {
        value: stream,
        writable: true
      }), _defineProperty(_Object$create, kLastResolve, {
        value: null,
        writable: true
      }), _defineProperty(_Object$create, kLastReject, {
        value: null,
        writable: true
      }), _defineProperty(_Object$create, kError, {
        value: null,
        writable: true
      }), _defineProperty(_Object$create, kEnded, {
        value: stream._readableState.endEmitted,
        writable: true
      }), _defineProperty(_Object$create, kHandlePromise, {
        value: function value(resolve, reject) {
          var data = iterator[kStream].read();
          if (data) {
            iterator[kLastPromise] = null;
            iterator[kLastResolve] = null;
            iterator[kLastReject] = null;
            resolve(createIterResult(data, false));
          } else {
            iterator[kLastResolve] = resolve;
            iterator[kLastReject] = reject;
          }
        },
        writable: true
      }), _Object$create));
      iterator[kLastPromise] = null;
      finished(stream, function(err) {
        if (err && err.code !== "ERR_STREAM_PREMATURE_CLOSE") {
          var reject = iterator[kLastReject];
          if (reject !== null) {
            iterator[kLastPromise] = null;
            iterator[kLastResolve] = null;
            iterator[kLastReject] = null;
            reject(err);
          }
          iterator[kError] = err;
          return;
        }
        var resolve = iterator[kLastResolve];
        if (resolve !== null) {
          iterator[kLastPromise] = null;
          iterator[kLastResolve] = null;
          iterator[kLastReject] = null;
          resolve(createIterResult(void 0, true));
        }
        iterator[kEnded] = true;
      });
      stream.on("readable", onReadable.bind(null, iterator));
      return iterator;
    };
    module2.exports = createReadableStreamAsyncIterator;
  }
});

// ../../../node_modules/zip-stream/node_modules/readable-stream/lib/internal/streams/from.js
var require_from5 = __commonJS({
  "../../../node_modules/zip-stream/node_modules/readable-stream/lib/internal/streams/from.js"(exports2, module2) {
    "use strict";
    function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {
      try {
        var info = gen[key](arg);
        var value = info.value;
      } catch (error) {
        reject(error);
        return;
      }
      if (info.done) {
        resolve(value);
      } else {
        Promise.resolve(value).then(_next, _throw);
      }
    }
    function _asyncToGenerator(fn) {
      return function() {
        var self2 = this, args = arguments;
        return new Promise(function(resolve, reject) {
          var gen = fn.apply(self2, args);
          function _next(value) {
            asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value);
          }
          function _throw(err) {
            asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err);
          }
          _next(void 0);
        });
      };
    }
    function ownKeys(object, enumerableOnly) {
      var keys = Object.keys(object);
      if (Object.getOwnPropertySymbols) {
        var symbols = Object.getOwnPropertySymbols(object);
        enumerableOnly && (symbols = symbols.filter(function(sym) {
          return Object.getOwnPropertyDescriptor(object, sym).enumerable;
        })), keys.push.apply(keys, symbols);
      }
      return keys;
    }
    function _objectSpread(target) {
      for (var i = 1; i < arguments.length; i++) {
        var source = null != arguments[i] ? arguments[i] : {};
        i % 2 ? ownKeys(Object(source), true).forEach(function(key) {
          _defineProperty(target, key, source[key]);
        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function(key) {
          Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
        });
      }
      return target;
    }
    function _defineProperty(obj2, key, value) {
      key = _toPropertyKey(key);
      if (key in obj2) {
        Object.defineProperty(obj2, key, { value, enumerable: true, configurable: true, writable: true });
      } else {
        obj2[key] = value;
      }
      return obj2;
    }
    function _toPropertyKey(arg) {
      var key = _toPrimitive(arg, "string");
      return typeof key === "symbol" ? key : String(key);
    }
    function _toPrimitive(input, hint) {
      if (typeof input !== "object" || input === null)
        return input;
      var prim = input[Symbol.toPrimitive];
      if (prim !== void 0) {
        var res = prim.call(input, hint || "default");
        if (typeof res !== "object")
          return res;
        throw new TypeError("@@toPrimitive must return a primitive value.");
      }
      return (hint === "string" ? String : Number)(input);
    }
    var ERR_INVALID_ARG_TYPE = require_errors5().codes.ERR_INVALID_ARG_TYPE;
    function from(Readable, iterable, opts) {
      var iterator;
      if (iterable && typeof iterable.next === "function") {
        iterator = iterable;
      } else if (iterable && iterable[Symbol.asyncIterator])
        iterator = iterable[Symbol.asyncIterator]();
      else if (iterable && iterable[Symbol.iterator])
        iterator = iterable[Symbol.iterator]();
      else
        throw new ERR_INVALID_ARG_TYPE("iterable", ["Iterable"], iterable);
      var readable = new Readable(_objectSpread({
        objectMode: true
      }, opts));
      var reading = false;
      readable._read = function() {
        if (!reading) {
          reading = true;
          next();
        }
      };
      function next() {
        return _next2.apply(this, arguments);
      }
      function _next2() {
        _next2 = _asyncToGenerator(function* () {
          try {
            var _yield$iterator$next = yield iterator.next(), value = _yield$iterator$next.value, done = _yield$iterator$next.done;
            if (done) {
              readable.push(null);
            } else if (readable.push(yield value)) {
              next();
            } else {
              reading = false;
            }
          } catch (err) {
            readable.destroy(err);
          }
        });
        return _next2.apply(this, arguments);
      }
      return readable;
    }
    module2.exports = from;
  }
});

// ../../../node_modules/zip-stream/node_modules/readable-stream/lib/_stream_readable.js
var require_stream_readable8 = __commonJS({
  "../../../node_modules/zip-stream/node_modules/readable-stream/lib/_stream_readable.js"(exports2, module2) {
    "use strict";
    module2.exports = Readable;
    var Duplex;
    Readable.ReadableState = ReadableState;
    var EE = require("events").EventEmitter;
    var EElistenerCount = function EElistenerCount2(emitter, type) {
      return emitter.listeners(type).length;
    };
    var Stream = require_stream8();
    var Buffer2 = require("buffer").Buffer;
    var OurUint8Array = (typeof global !== "undefined" ? global : typeof window !== "undefined" ? window : typeof self !== "undefined" ? self : {}).Uint8Array || function() {
    };
    function _uint8ArrayToBuffer(chunk) {
      return Buffer2.from(chunk);
    }
    function _isUint8Array(obj2) {
      return Buffer2.isBuffer(obj2) || obj2 instanceof OurUint8Array;
    }
    var debugUtil = require("util");
    var debug;
    if (debugUtil && debugUtil.debuglog) {
      debug = debugUtil.debuglog("stream");
    } else {
      debug = function debug2() {
      };
    }
    var BufferList = require_buffer_list5();
    var destroyImpl = require_destroy8();
    var _require = require_state5();
    var getHighWaterMark = _require.getHighWaterMark;
    var _require$codes = require_errors5().codes;
    var ERR_INVALID_ARG_TYPE = _require$codes.ERR_INVALID_ARG_TYPE;
    var ERR_STREAM_PUSH_AFTER_EOF = _require$codes.ERR_STREAM_PUSH_AFTER_EOF;
    var ERR_METHOD_NOT_IMPLEMENTED = _require$codes.ERR_METHOD_NOT_IMPLEMENTED;
    var ERR_STREAM_UNSHIFT_AFTER_END_EVENT = _require$codes.ERR_STREAM_UNSHIFT_AFTER_END_EVENT;
    var StringDecoder;
    var createReadableStreamAsyncIterator;
    var from;
    require_inherits()(Readable, Stream);
    var errorOrDestroy = destroyImpl.errorOrDestroy;
    var kProxyEvents = ["error", "close", "destroy", "pause", "resume"];
    function prependListener(emitter, event, fn) {
      if (typeof emitter.prependListener === "function")
        return emitter.prependListener(event, fn);
      if (!emitter._events || !emitter._events[event])
        emitter.on(event, fn);
      else if (Array.isArray(emitter._events[event]))
        emitter._events[event].unshift(fn);
      else
        emitter._events[event] = [fn, emitter._events[event]];
    }
    function ReadableState(options, stream, isDuplex) {
      Duplex = Duplex || require_stream_duplex8();
      options = options || {};
      if (typeof isDuplex !== "boolean")
        isDuplex = stream instanceof Duplex;
      this.objectMode = !!options.objectMode;
      if (isDuplex)
        this.objectMode = this.objectMode || !!options.readableObjectMode;
      this.highWaterMark = getHighWaterMark(this, options, "readableHighWaterMark", isDuplex);
      this.buffer = new BufferList();
      this.length = 0;
      this.pipes = null;
      this.pipesCount = 0;
      this.flowing = null;
      this.ended = false;
      this.endEmitted = false;
      this.reading = false;
      this.sync = true;
      this.needReadable = false;
      this.emittedReadable = false;
      this.readableListening = false;
      this.resumeScheduled = false;
      this.paused = true;
      this.emitClose = options.emitClose !== false;
      this.autoDestroy = !!options.autoDestroy;
      this.destroyed = false;
      this.defaultEncoding = options.defaultEncoding || "utf8";
      this.awaitDrain = 0;
      this.readingMore = false;
      this.decoder = null;
      this.encoding = null;
      if (options.encoding) {
        if (!StringDecoder)
          StringDecoder = require_string_decoder8().StringDecoder;
        this.decoder = new StringDecoder(options.encoding);
        this.encoding = options.encoding;
      }
    }
    function Readable(options) {
      Duplex = Duplex || require_stream_duplex8();
      if (!(this instanceof Readable))
        return new Readable(options);
      var isDuplex = this instanceof Duplex;
      this._readableState = new ReadableState(options, this, isDuplex);
      this.readable = true;
      if (options) {
        if (typeof options.read === "function")
          this._read = options.read;
        if (typeof options.destroy === "function")
          this._destroy = options.destroy;
      }
      Stream.call(this);
    }
    Object.defineProperty(Readable.prototype, "destroyed", {
      // making it explicit this property is not enumerable
      // because otherwise some prototype manipulation in
      // userland will fail
      enumerable: false,
      get: function get() {
        if (this._readableState === void 0) {
          return false;
        }
        return this._readableState.destroyed;
      },
      set: function set(value) {
        if (!this._readableState) {
          return;
        }
        this._readableState.destroyed = value;
      }
    });
    Readable.prototype.destroy = destroyImpl.destroy;
    Readable.prototype._undestroy = destroyImpl.undestroy;
    Readable.prototype._destroy = function(err, cb) {
      cb(err);
    };
    Readable.prototype.push = function(chunk, encoding) {
      var state = this._readableState;
      var skipChunkCheck;
      if (!state.objectMode) {
        if (typeof chunk === "string") {
          encoding = encoding || state.defaultEncoding;
          if (encoding !== state.encoding) {
            chunk = Buffer2.from(chunk, encoding);
            encoding = "";
          }
          skipChunkCheck = true;
        }
      } else {
        skipChunkCheck = true;
      }
      return readableAddChunk(this, chunk, encoding, false, skipChunkCheck);
    };
    Readable.prototype.unshift = function(chunk) {
      return readableAddChunk(this, chunk, null, true, false);
    };
    function readableAddChunk(stream, chunk, encoding, addToFront, skipChunkCheck) {
      debug("readableAddChunk", chunk);
      var state = stream._readableState;
      if (chunk === null) {
        state.reading = false;
        onEofChunk(stream, state);
      } else {
        var er;
        if (!skipChunkCheck)
          er = chunkInvalid(state, chunk);
        if (er) {
          errorOrDestroy(stream, er);
        } else if (state.objectMode || chunk && chunk.length > 0) {
          if (typeof chunk !== "string" && !state.objectMode && Object.getPrototypeOf(chunk) !== Buffer2.prototype) {
            chunk = _uint8ArrayToBuffer(chunk);
          }
          if (addToFront) {
            if (state.endEmitted)
              errorOrDestroy(stream, new ERR_STREAM_UNSHIFT_AFTER_END_EVENT());
            else
              addChunk(stream, state, chunk, true);
          } else if (state.ended) {
            errorOrDestroy(stream, new ERR_STREAM_PUSH_AFTER_EOF());
          } else if (state.destroyed) {
            return false;
          } else {
            state.reading = false;
            if (state.decoder && !encoding) {
              chunk = state.decoder.write(chunk);
              if (state.objectMode || chunk.length !== 0)
                addChunk(stream, state, chunk, false);
              else
                maybeReadMore(stream, state);
            } else {
              addChunk(stream, state, chunk, false);
            }
          }
        } else if (!addToFront) {
          state.reading = false;
          maybeReadMore(stream, state);
        }
      }
      return !state.ended && (state.length < state.highWaterMark || state.length === 0);
    }
    function addChunk(stream, state, chunk, addToFront) {
      if (state.flowing && state.length === 0 && !state.sync) {
        state.awaitDrain = 0;
        stream.emit("data", chunk);
      } else {
        state.length += state.objectMode ? 1 : chunk.length;
        if (addToFront)
          state.buffer.unshift(chunk);
        else
          state.buffer.push(chunk);
        if (state.needReadable)
          emitReadable(stream);
      }
      maybeReadMore(stream, state);
    }
    function chunkInvalid(state, chunk) {
      var er;
      if (!_isUint8Array(chunk) && typeof chunk !== "string" && chunk !== void 0 && !state.objectMode) {
        er = new ERR_INVALID_ARG_TYPE("chunk", ["string", "Buffer", "Uint8Array"], chunk);
      }
      return er;
    }
    Readable.prototype.isPaused = function() {
      return this._readableState.flowing === false;
    };
    Readable.prototype.setEncoding = function(enc) {
      if (!StringDecoder)
        StringDecoder = require_string_decoder8().StringDecoder;
      var decoder = new StringDecoder(enc);
      this._readableState.decoder = decoder;
      this._readableState.encoding = this._readableState.decoder.encoding;
      var p = this._readableState.buffer.head;
      var content = "";
      while (p !== null) {
        content += decoder.write(p.data);
        p = p.next;
      }
      this._readableState.buffer.clear();
      if (content !== "")
        this._readableState.buffer.push(content);
      this._readableState.length = content.length;
      return this;
    };
    var MAX_HWM = 1073741824;
    function computeNewHighWaterMark(n) {
      if (n >= MAX_HWM) {
        n = MAX_HWM;
      } else {
        n--;
        n |= n >>> 1;
        n |= n >>> 2;
        n |= n >>> 4;
        n |= n >>> 8;
        n |= n >>> 16;
        n++;
      }
      return n;
    }
    function howMuchToRead(n, state) {
      if (n <= 0 || state.length === 0 && state.ended)
        return 0;
      if (state.objectMode)
        return 1;
      if (n !== n) {
        if (state.flowing && state.length)
          return state.buffer.head.data.length;
        else
          return state.length;
      }
      if (n > state.highWaterMark)
        state.highWaterMark = computeNewHighWaterMark(n);
      if (n <= state.length)
        return n;
      if (!state.ended) {
        state.needReadable = true;
        return 0;
      }
      return state.length;
    }
    Readable.prototype.read = function(n) {
      debug("read", n);
      n = parseInt(n, 10);
      var state = this._readableState;
      var nOrig = n;
      if (n !== 0)
        state.emittedReadable = false;
      if (n === 0 && state.needReadable && ((state.highWaterMark !== 0 ? state.length >= state.highWaterMark : state.length > 0) || state.ended)) {
        debug("read: emitReadable", state.length, state.ended);
        if (state.length === 0 && state.ended)
          endReadable(this);
        else
          emitReadable(this);
        return null;
      }
      n = howMuchToRead(n, state);
      if (n === 0 && state.ended) {
        if (state.length === 0)
          endReadable(this);
        return null;
      }
      var doRead = state.needReadable;
      debug("need readable", doRead);
      if (state.length === 0 || state.length - n < state.highWaterMark) {
        doRead = true;
        debug("length less than watermark", doRead);
      }
      if (state.ended || state.reading) {
        doRead = false;
        debug("reading or ended", doRead);
      } else if (doRead) {
        debug("do read");
        state.reading = true;
        state.sync = true;
        if (state.length === 0)
          state.needReadable = true;
        this._read(state.highWaterMark);
        state.sync = false;
        if (!state.reading)
          n = howMuchToRead(nOrig, state);
      }
      var ret2;
      if (n > 0)
        ret2 = fromList(n, state);
      else
        ret2 = null;
      if (ret2 === null) {
        state.needReadable = state.length <= state.highWaterMark;
        n = 0;
      } else {
        state.length -= n;
        state.awaitDrain = 0;
      }
      if (state.length === 0) {
        if (!state.ended)
          state.needReadable = true;
        if (nOrig !== n && state.ended)
          endReadable(this);
      }
      if (ret2 !== null)
        this.emit("data", ret2);
      return ret2;
    };
    function onEofChunk(stream, state) {
      debug("onEofChunk");
      if (state.ended)
        return;
      if (state.decoder) {
        var chunk = state.decoder.end();
        if (chunk && chunk.length) {
          state.buffer.push(chunk);
          state.length += state.objectMode ? 1 : chunk.length;
        }
      }
      state.ended = true;
      if (state.sync) {
        emitReadable(stream);
      } else {
        state.needReadable = false;
        if (!state.emittedReadable) {
          state.emittedReadable = true;
          emitReadable_(stream);
        }
      }
    }
    function emitReadable(stream) {
      var state = stream._readableState;
      debug("emitReadable", state.needReadable, state.emittedReadable);
      state.needReadable = false;
      if (!state.emittedReadable) {
        debug("emitReadable", state.flowing);
        state.emittedReadable = true;
        process.nextTick(emitReadable_, stream);
      }
    }
    function emitReadable_(stream) {
      var state = stream._readableState;
      debug("emitReadable_", state.destroyed, state.length, state.ended);
      if (!state.destroyed && (state.length || state.ended)) {
        stream.emit("readable");
        state.emittedReadable = false;
      }
      state.needReadable = !state.flowing && !state.ended && state.length <= state.highWaterMark;
      flow(stream);
    }
    function maybeReadMore(stream, state) {
      if (!state.readingMore) {
        state.readingMore = true;
        process.nextTick(maybeReadMore_, stream, state);
      }
    }
    function maybeReadMore_(stream, state) {
      while (!state.reading && !state.ended && (state.length < state.highWaterMark || state.flowing && state.length === 0)) {
        var len = state.length;
        debug("maybeReadMore read 0");
        stream.read(0);
        if (len === state.length)
          break;
      }
      state.readingMore = false;
    }
    Readable.prototype._read = function(n) {
      errorOrDestroy(this, new ERR_METHOD_NOT_IMPLEMENTED("_read()"));
    };
    Readable.prototype.pipe = function(dest, pipeOpts) {
      var src = this;
      var state = this._readableState;
      switch (state.pipesCount) {
        case 0:
          state.pipes = dest;
          break;
        case 1:
          state.pipes = [state.pipes, dest];
          break;
        default:
          state.pipes.push(dest);
          break;
      }
      state.pipesCount += 1;
      debug("pipe count=%d opts=%j", state.pipesCount, pipeOpts);
      var doEnd = (!pipeOpts || pipeOpts.end !== false) && dest !== process.stdout && dest !== process.stderr;
      var endFn = doEnd ? onend : unpipe;
      if (state.endEmitted)
        process.nextTick(endFn);
      else
        src.once("end", endFn);
      dest.on("unpipe", onunpipe);
      function onunpipe(readable, unpipeInfo) {
        debug("onunpipe");
        if (readable === src) {
          if (unpipeInfo && unpipeInfo.hasUnpiped === false) {
            unpipeInfo.hasUnpiped = true;
            cleanup();
          }
        }
      }
      function onend() {
        debug("onend");
        dest.end();
      }
      var ondrain = pipeOnDrain(src);
      dest.on("drain", ondrain);
      var cleanedUp = false;
      function cleanup() {
        debug("cleanup");
        dest.removeListener("close", onclose);
        dest.removeListener("finish", onfinish);
        dest.removeListener("drain", ondrain);
        dest.removeListener("error", onerror);
        dest.removeListener("unpipe", onunpipe);
        src.removeListener("end", onend);
        src.removeListener("end", unpipe);
        src.removeListener("data", ondata);
        cleanedUp = true;
        if (state.awaitDrain && (!dest._writableState || dest._writableState.needDrain))
          ondrain();
      }
      src.on("data", ondata);
      function ondata(chunk) {
        debug("ondata");
        var ret2 = dest.write(chunk);
        debug("dest.write", ret2);
        if (ret2 === false) {
          if ((state.pipesCount === 1 && state.pipes === dest || state.pipesCount > 1 && indexOf(state.pipes, dest) !== -1) && !cleanedUp) {
            debug("false write response, pause", state.awaitDrain);
            state.awaitDrain++;
          }
          src.pause();
        }
      }
      function onerror(er) {
        debug("onerror", er);
        unpipe();
        dest.removeListener("error", onerror);
        if (EElistenerCount(dest, "error") === 0)
          errorOrDestroy(dest, er);
      }
      prependListener(dest, "error", onerror);
      function onclose() {
        dest.removeListener("finish", onfinish);
        unpipe();
      }
      dest.once("close", onclose);
      function onfinish() {
        debug("onfinish");
        dest.removeListener("close", onclose);
        unpipe();
      }
      dest.once("finish", onfinish);
      function unpipe() {
        debug("unpipe");
        src.unpipe(dest);
      }
      dest.emit("pipe", src);
      if (!state.flowing) {
        debug("pipe resume");
        src.resume();
      }
      return dest;
    };
    function pipeOnDrain(src) {
      return function pipeOnDrainFunctionResult() {
        var state = src._readableState;
        debug("pipeOnDrain", state.awaitDrain);
        if (state.awaitDrain)
          state.awaitDrain--;
        if (state.awaitDrain === 0 && EElistenerCount(src, "data")) {
          state.flowing = true;
          flow(src);
        }
      };
    }
    Readable.prototype.unpipe = function(dest) {
      var state = this._readableState;
      var unpipeInfo = {
        hasUnpiped: false
      };
      if (state.pipesCount === 0)
        return this;
      if (state.pipesCount === 1) {
        if (dest && dest !== state.pipes)
          return this;
        if (!dest)
          dest = state.pipes;
        state.pipes = null;
        state.pipesCount = 0;
        state.flowing = false;
        if (dest)
          dest.emit("unpipe", this, unpipeInfo);
        return this;
      }
      if (!dest) {
        var dests = state.pipes;
        var len = state.pipesCount;
        state.pipes = null;
        state.pipesCount = 0;
        state.flowing = false;
        for (var i = 0; i < len; i++)
          dests[i].emit("unpipe", this, {
            hasUnpiped: false
          });
        return this;
      }
      var index = indexOf(state.pipes, dest);
      if (index === -1)
        return this;
      state.pipes.splice(index, 1);
      state.pipesCount -= 1;
      if (state.pipesCount === 1)
        state.pipes = state.pipes[0];
      dest.emit("unpipe", this, unpipeInfo);
      return this;
    };
    Readable.prototype.on = function(ev, fn) {
      var res = Stream.prototype.on.call(this, ev, fn);
      var state = this._readableState;
      if (ev === "data") {
        state.readableListening = this.listenerCount("readable") > 0;
        if (state.flowing !== false)
          this.resume();
      } else if (ev === "readable") {
        if (!state.endEmitted && !state.readableListening) {
          state.readableListening = state.needReadable = true;
          state.flowing = false;
          state.emittedReadable = false;
          debug("on readable", state.length, state.reading);
          if (state.length) {
            emitReadable(this);
          } else if (!state.reading) {
            process.nextTick(nReadingNextTick, this);
          }
        }
      }
      return res;
    };
    Readable.prototype.addListener = Readable.prototype.on;
    Readable.prototype.removeListener = function(ev, fn) {
      var res = Stream.prototype.removeListener.call(this, ev, fn);
      if (ev === "readable") {
        process.nextTick(updateReadableListening, this);
      }
      return res;
    };
    Readable.prototype.removeAllListeners = function(ev) {
      var res = Stream.prototype.removeAllListeners.apply(this, arguments);
      if (ev === "readable" || ev === void 0) {
        process.nextTick(updateReadableListening, this);
      }
      return res;
    };
    function updateReadableListening(self2) {
      var state = self2._readableState;
      state.readableListening = self2.listenerCount("readable") > 0;
      if (state.resumeScheduled && !state.paused) {
        state.flowing = true;
      } else if (self2.listenerCount("data") > 0) {
        self2.resume();
      }
    }
    function nReadingNextTick(self2) {
      debug("readable nexttick read 0");
      self2.read(0);
    }
    Readable.prototype.resume = function() {
      var state = this._readableState;
      if (!state.flowing) {
        debug("resume");
        state.flowing = !state.readableListening;
        resume(this, state);
      }
      state.paused = false;
      return this;
    };
    function resume(stream, state) {
      if (!state.resumeScheduled) {
        state.resumeScheduled = true;
        process.nextTick(resume_, stream, state);
      }
    }
    function resume_(stream, state) {
      debug("resume", state.reading);
      if (!state.reading) {
        stream.read(0);
      }
      state.resumeScheduled = false;
      stream.emit("resume");
      flow(stream);
      if (state.flowing && !state.reading)
        stream.read(0);
    }
    Readable.prototype.pause = function() {
      debug("call pause flowing=%j", this._readableState.flowing);
      if (this._readableState.flowing !== false) {
        debug("pause");
        this._readableState.flowing = false;
        this.emit("pause");
      }
      this._readableState.paused = true;
      return this;
    };
    function flow(stream) {
      var state = stream._readableState;
      debug("flow", state.flowing);
      while (state.flowing && stream.read() !== null)
        ;
    }
    Readable.prototype.wrap = function(stream) {
      var _this = this;
      var state = this._readableState;
      var paused = false;
      stream.on("end", function() {
        debug("wrapped end");
        if (state.decoder && !state.ended) {
          var chunk = state.decoder.end();
          if (chunk && chunk.length)
            _this.push(chunk);
        }
        _this.push(null);
      });
      stream.on("data", function(chunk) {
        debug("wrapped data");
        if (state.decoder)
          chunk = state.decoder.write(chunk);
        if (state.objectMode && (chunk === null || chunk === void 0))
          return;
        else if (!state.objectMode && (!chunk || !chunk.length))
          return;
        var ret2 = _this.push(chunk);
        if (!ret2) {
          paused = true;
          stream.pause();
        }
      });
      for (var i in stream) {
        if (this[i] === void 0 && typeof stream[i] === "function") {
          this[i] = /* @__PURE__ */ function methodWrap(method) {
            return function methodWrapReturnFunction() {
              return stream[method].apply(stream, arguments);
            };
          }(i);
        }
      }
      for (var n = 0; n < kProxyEvents.length; n++) {
        stream.on(kProxyEvents[n], this.emit.bind(this, kProxyEvents[n]));
      }
      this._read = function(n2) {
        debug("wrapped _read", n2);
        if (paused) {
          paused = false;
          stream.resume();
        }
      };
      return this;
    };
    if (typeof Symbol === "function") {
      Readable.prototype[Symbol.asyncIterator] = function() {
        if (createReadableStreamAsyncIterator === void 0) {
          createReadableStreamAsyncIterator = require_async_iterator5();
        }
        return createReadableStreamAsyncIterator(this);
      };
    }
    Object.defineProperty(Readable.prototype, "readableHighWaterMark", {
      // making it explicit this property is not enumerable
      // because otherwise some prototype manipulation in
      // userland will fail
      enumerable: false,
      get: function get() {
        return this._readableState.highWaterMark;
      }
    });
    Object.defineProperty(Readable.prototype, "readableBuffer", {
      // making it explicit this property is not enumerable
      // because otherwise some prototype manipulation in
      // userland will fail
      enumerable: false,
      get: function get() {
        return this._readableState && this._readableState.buffer;
      }
    });
    Object.defineProperty(Readable.prototype, "readableFlowing", {
      // making it explicit this property is not enumerable
      // because otherwise some prototype manipulation in
      // userland will fail
      enumerable: false,
      get: function get() {
        return this._readableState.flowing;
      },
      set: function set(state) {
        if (this._readableState) {
          this._readableState.flowing = state;
        }
      }
    });
    Readable._fromList = fromList;
    Object.defineProperty(Readable.prototype, "readableLength", {
      // making it explicit this property is not enumerable
      // because otherwise some prototype manipulation in
      // userland will fail
      enumerable: false,
      get: function get() {
        return this._readableState.length;
      }
    });
    function fromList(n, state) {
      if (state.length === 0)
        return null;
      var ret2;
      if (state.objectMode)
        ret2 = state.buffer.shift();
      else if (!n || n >= state.length) {
        if (state.decoder)
          ret2 = state.buffer.join("");
        else if (state.buffer.length === 1)
          ret2 = state.buffer.first();
        else
          ret2 = state.buffer.concat(state.length);
        state.buffer.clear();
      } else {
        ret2 = state.buffer.consume(n, state.decoder);
      }
      return ret2;
    }
    function endReadable(stream) {
      var state = stream._readableState;
      debug("endReadable", state.endEmitted);
      if (!state.endEmitted) {
        state.ended = true;
        process.nextTick(endReadableNT, state, stream);
      }
    }
    function endReadableNT(state, stream) {
      debug("endReadableNT", state.endEmitted, state.length);
      if (!state.endEmitted && state.length === 0) {
        state.endEmitted = true;
        stream.readable = false;
        stream.emit("end");
        if (state.autoDestroy) {
          var wState = stream._writableState;
          if (!wState || wState.autoDestroy && wState.finished) {
            stream.destroy();
          }
        }
      }
    }
    if (typeof Symbol === "function") {
      Readable.from = function(iterable, opts) {
        if (from === void 0) {
          from = require_from5();
        }
        return from(Readable, iterable, opts);
      };
    }
    function indexOf(xs, x) {
      for (var i = 0, l2 = xs.length; i < l2; i++) {
        if (xs[i] === x)
          return i;
      }
      return -1;
    }
  }
});

// ../../../node_modules/zip-stream/node_modules/readable-stream/lib/_stream_transform.js
var require_stream_transform8 = __commonJS({
  "../../../node_modules/zip-stream/node_modules/readable-stream/lib/_stream_transform.js"(exports2, module2) {
    "use strict";
    module2.exports = Transform;
    var _require$codes = require_errors5().codes;
    var ERR_METHOD_NOT_IMPLEMENTED = _require$codes.ERR_METHOD_NOT_IMPLEMENTED;
    var ERR_MULTIPLE_CALLBACK = _require$codes.ERR_MULTIPLE_CALLBACK;
    var ERR_TRANSFORM_ALREADY_TRANSFORMING = _require$codes.ERR_TRANSFORM_ALREADY_TRANSFORMING;
    var ERR_TRANSFORM_WITH_LENGTH_0 = _require$codes.ERR_TRANSFORM_WITH_LENGTH_0;
    var Duplex = require_stream_duplex8();
    require_inherits()(Transform, Duplex);
    function afterTransform(er, data) {
      var ts = this._transformState;
      ts.transforming = false;
      var cb = ts.writecb;
      if (cb === null) {
        return this.emit("error", new ERR_MULTIPLE_CALLBACK());
      }
      ts.writechunk = null;
      ts.writecb = null;
      if (data != null)
        this.push(data);
      cb(er);
      var rs = this._readableState;
      rs.reading = false;
      if (rs.needReadable || rs.length < rs.highWaterMark) {
        this._read(rs.highWaterMark);
      }
    }
    function Transform(options) {
      if (!(this instanceof Transform))
        return new Transform(options);
      Duplex.call(this, options);
      this._transformState = {
        afterTransform: afterTransform.bind(this),
        needTransform: false,
        transforming: false,
        writecb: null,
        writechunk: null,
        writeencoding: null
      };
      this._readableState.needReadable = true;
      this._readableState.sync = false;
      if (options) {
        if (typeof options.transform === "function")
          this._transform = options.transform;
        if (typeof options.flush === "function")
          this._flush = options.flush;
      }
      this.on("prefinish", prefinish);
    }
    function prefinish() {
      var _this = this;
      if (typeof this._flush === "function" && !this._readableState.destroyed) {
        this._flush(function(er, data) {
          done(_this, er, data);
        });
      } else {
        done(this, null, null);
      }
    }
    Transform.prototype.push = function(chunk, encoding) {
      this._transformState.needTransform = false;
      return Duplex.prototype.push.call(this, chunk, encoding);
    };
    Transform.prototype._transform = function(chunk, encoding, cb) {
      cb(new ERR_METHOD_NOT_IMPLEMENTED("_transform()"));
    };
    Transform.prototype._write = function(chunk, encoding, cb) {
      var ts = this._transformState;
      ts.writecb = cb;
      ts.writechunk = chunk;
      ts.writeencoding = encoding;
      if (!ts.transforming) {
        var rs = this._readableState;
        if (ts.needTransform || rs.needReadable || rs.length < rs.highWaterMark)
          this._read(rs.highWaterMark);
      }
    };
    Transform.prototype._read = function(n) {
      var ts = this._transformState;
      if (ts.writechunk !== null && !ts.transforming) {
        ts.transforming = true;
        this._transform(ts.writechunk, ts.writeencoding, ts.afterTransform);
      } else {
        ts.needTransform = true;
      }
    };
    Transform.prototype._destroy = function(err, cb) {
      Duplex.prototype._destroy.call(this, err, function(err2) {
        cb(err2);
      });
    };
    function done(stream, er, data) {
      if (er)
        return stream.emit("error", er);
      if (data != null)
        stream.push(data);
      if (stream._writableState.length)
        throw new ERR_TRANSFORM_WITH_LENGTH_0();
      if (stream._transformState.transforming)
        throw new ERR_TRANSFORM_ALREADY_TRANSFORMING();
      return stream.push(null);
    }
  }
});

// ../../../node_modules/zip-stream/node_modules/readable-stream/lib/_stream_passthrough.js
var require_stream_passthrough8 = __commonJS({
  "../../../node_modules/zip-stream/node_modules/readable-stream/lib/_stream_passthrough.js"(exports2, module2) {
    "use strict";
    module2.exports = PassThrough;
    var Transform = require_stream_transform8();
    require_inherits()(PassThrough, Transform);
    function PassThrough(options) {
      if (!(this instanceof PassThrough))
        return new PassThrough(options);
      Transform.call(this, options);
    }
    PassThrough.prototype._transform = function(chunk, encoding, cb) {
      cb(null, chunk);
    };
  }
});

// ../../../node_modules/zip-stream/node_modules/readable-stream/lib/internal/streams/pipeline.js
var require_pipeline5 = __commonJS({
  "../../../node_modules/zip-stream/node_modules/readable-stream/lib/internal/streams/pipeline.js"(exports2, module2) {
    "use strict";
    var eos;
    function once(callback) {
      var called = false;
      return function() {
        if (called)
          return;
        called = true;
        callback.apply(void 0, arguments);
      };
    }
    var _require$codes = require_errors5().codes;
    var ERR_MISSING_ARGS = _require$codes.ERR_MISSING_ARGS;
    var ERR_STREAM_DESTROYED = _require$codes.ERR_STREAM_DESTROYED;
    function noop(err) {
      if (err)
        throw err;
    }
    function isRequest(stream) {
      return stream.setHeader && typeof stream.abort === "function";
    }
    function destroyer(stream, reading, writing, callback) {
      callback = once(callback);
      var closed = false;
      stream.on("close", function() {
        closed = true;
      });
      if (eos === void 0)
        eos = require_end_of_stream5();
      eos(stream, {
        readable: reading,
        writable: writing
      }, function(err) {
        if (err)
          return callback(err);
        closed = true;
        callback();
      });
      var destroyed = false;
      return function(err) {
        if (closed)
          return;
        if (destroyed)
          return;
        destroyed = true;
        if (isRequest(stream))
          return stream.abort();
        if (typeof stream.destroy === "function")
          return stream.destroy();
        callback(err || new ERR_STREAM_DESTROYED("pipe"));
      };
    }
    function call(fn) {
      fn();
    }
    function pipe(from, to) {
      return from.pipe(to);
    }
    function popCallback(streams) {
      if (!streams.length)
        return noop;
      if (typeof streams[streams.length - 1] !== "function")
        return noop;
      return streams.pop();
    }
    function pipeline() {
      for (var _len = arguments.length, streams = new Array(_len), _key = 0; _key < _len; _key++) {
        streams[_key] = arguments[_key];
      }
      var callback = popCallback(streams);
      if (Array.isArray(streams[0]))
        streams = streams[0];
      if (streams.length < 2) {
        throw new ERR_MISSING_ARGS("streams");
      }
      var error;
      var destroys = streams.map(function(stream, i) {
        var reading = i < streams.length - 1;
        var writing = i > 0;
        return destroyer(stream, reading, writing, function(err) {
          if (!error)
            error = err;
          if (err)
            destroys.forEach(call);
          if (reading)
            return;
          destroys.forEach(call);
          callback(error);
        });
      });
      return streams.reduce(pipe);
    }
    module2.exports = pipeline;
  }
});

// ../../../node_modules/zip-stream/node_modules/readable-stream/readable.js
var require_readable8 = __commonJS({
  "../../../node_modules/zip-stream/node_modules/readable-stream/readable.js"(exports2, module2) {
    var Stream = require("stream");
    if (process.env.READABLE_STREAM === "disable" && Stream) {
      module2.exports = Stream.Readable;
      Object.assign(module2.exports, Stream);
      module2.exports.Stream = Stream;
    } else {
      exports2 = module2.exports = require_stream_readable8();
      exports2.Stream = Stream || exports2;
      exports2.Readable = exports2;
      exports2.Writable = require_stream_writable8();
      exports2.Duplex = require_stream_duplex8();
      exports2.Transform = require_stream_transform8();
      exports2.PassThrough = require_stream_passthrough8();
      exports2.finished = require_end_of_stream5();
      exports2.pipeline = require_pipeline5();
    }
  }
});

// ../../../node_modules/zip-stream/node_modules/brace-expansion/index.js
var require_brace_expansion3 = __commonJS({
  "../../../node_modules/zip-stream/node_modules/brace-expansion/index.js"(exports2, module2) {
    var concatMap = require_concat_map();
    var balanced = require_balanced_match();
    module2.exports = expandTop;
    var escSlash = "\0SLASH" + Math.random() + "\0";
    var escOpen = "\0OPEN" + Math.random() + "\0";
    var escClose = "\0CLOSE" + Math.random() + "\0";
    var escComma = "\0COMMA" + Math.random() + "\0";
    var escPeriod = "\0PERIOD" + Math.random() + "\0";
    function numeric(str) {
      return parseInt(str, 10) == str ? parseInt(str, 10) : str.charCodeAt(0);
    }
    function escapeBraces(str) {
      return str.split("\\\\").join(escSlash).split("\\{").join(escOpen).split("\\}").join(escClose).split("\\,").join(escComma).split("\\.").join(escPeriod);
    }
    function unescapeBraces(str) {
      return str.split(escSlash).join("\\").split(escOpen).join("{").split(escClose).join("}").split(escComma).join(",").split(escPeriod).join(".");
    }
    function parseCommaParts(str) {
      if (!str)
        return [""];
      var parts = [];
      var m = balanced("{", "}", str);
      if (!m)
        return str.split(",");
      var pre = m.pre;
      var body = m.body;
      var post = m.post;
      var p = pre.split(",");
      p[p.length - 1] += "{" + body + "}";
      var postParts = parseCommaParts(post);
      if (post.length) {
        p[p.length - 1] += postParts.shift();
        p.push.apply(p, postParts);
      }
      parts.push.apply(parts, p);
      return parts;
    }
    function expandTop(str) {
      if (!str)
        return [];
      if (str.substr(0, 2) === "{}") {
        str = "\\{\\}" + str.substr(2);
      }
      return expand(escapeBraces(str), true).map(unescapeBraces);
    }
    function embrace(str) {
      return "{" + str + "}";
    }
    function isPadded(el) {
      return /^-?0\d/.test(el);
    }
    function lte(i, y) {
      return i <= y;
    }
    function gte(i, y) {
      return i >= y;
    }
    function expand(str, isTop) {
      var expansions = [];
      var m = balanced("{", "}", str);
      if (!m || /\$$/.test(m.pre))
        return [str];
      var isNumericSequence = /^-?\d+\.\.-?\d+(?:\.\.-?\d+)?$/.test(m.body);
      var isAlphaSequence = /^[a-zA-Z]\.\.[a-zA-Z](?:\.\.-?\d+)?$/.test(m.body);
      var isSequence = isNumericSequence || isAlphaSequence;
      var isOptions = m.body.indexOf(",") >= 0;
      if (!isSequence && !isOptions) {
        if (m.post.match(/,.*\}/)) {
          str = m.pre + "{" + m.body + escClose + m.post;
          return expand(str);
        }
        return [str];
      }
      var n;
      if (isSequence) {
        n = m.body.split(/\.\./);
      } else {
        n = parseCommaParts(m.body);
        if (n.length === 1) {
          n = expand(n[0], false).map(embrace);
          if (n.length === 1) {
            var post = m.post.length ? expand(m.post, false) : [""];
            return post.map(function(p) {
              return m.pre + n[0] + p;
            });
          }
        }
      }
      var pre = m.pre;
      var post = m.post.length ? expand(m.post, false) : [""];
      var N;
      if (isSequence) {
        var x = numeric(n[0]);
        var y = numeric(n[1]);
        var width = Math.max(n[0].length, n[1].length);
        var incr = n.length == 3 ? Math.abs(numeric(n[2])) : 1;
        var test = lte;
        var reverse = y < x;
        if (reverse) {
          incr *= -1;
          test = gte;
        }
        var pad = n.some(isPadded);
        N = [];
        for (var i = x; test(i, y); i += incr) {
          var c;
          if (isAlphaSequence) {
            c = String.fromCharCode(i);
            if (c === "\\")
              c = "";
          } else {
            c = String(i);
            if (pad) {
              var need = width - c.length;
              if (need > 0) {
                var z = new Array(need + 1).join("0");
                if (i < 0)
                  c = "-" + z + c.slice(1);
                else
                  c = z + c;
              }
            }
          }
          N.push(c);
        }
      } else {
        N = concatMap(n, function(el) {
          return expand(el, false);
        });
      }
      for (var j = 0; j < N.length; j++) {
        for (var k = 0; k < post.length; k++) {
          var expansion = pre + N[j] + post[k];
          if (!isTop || isSequence || expansion)
            expansions.push(expansion);
        }
      }
      return expansions;
    }
  }
});

// ../../../node_modules/zip-stream/node_modules/minimatch/minimatch.js
var require_minimatch3 = __commonJS({
  "../../../node_modules/zip-stream/node_modules/minimatch/minimatch.js"(exports2, module2) {
    module2.exports = minimatch;
    minimatch.Minimatch = Minimatch;
    var path = function() {
      try {
        return require("path");
      } catch (e) {
      }
    }() || {
      sep: "/"
    };
    minimatch.sep = path.sep;
    var GLOBSTAR = minimatch.GLOBSTAR = Minimatch.GLOBSTAR = {};
    var expand = require_brace_expansion3();
    var plTypes = {
      "!": { open: "(?:(?!(?:", close: "))[^/]*?)" },
      "?": { open: "(?:", close: ")?" },
      "+": { open: "(?:", close: ")+" },
      "*": { open: "(?:", close: ")*" },
      "@": { open: "(?:", close: ")" }
    };
    var qmark = "[^/]";
    var star = qmark + "*?";
    var twoStarDot = "(?:(?!(?:\\/|^)(?:\\.{1,2})($|\\/)).)*?";
    var twoStarNoDot = "(?:(?!(?:\\/|^)\\.).)*?";
    var reSpecials = charSet("().*{}+?[]^$\\!");
    function charSet(s) {
      return s.split("").reduce(function(set, c) {
        set[c] = true;
        return set;
      }, {});
    }
    var slashSplit = /\/+/;
    minimatch.filter = filter;
    function filter(pattern, options) {
      options = options || {};
      return function(p, i, list) {
        return minimatch(p, pattern, options);
      };
    }
    function ext(a, b) {
      b = b || {};
      var t = {};
      Object.keys(a).forEach(function(k) {
        t[k] = a[k];
      });
      Object.keys(b).forEach(function(k) {
        t[k] = b[k];
      });
      return t;
    }
    minimatch.defaults = function(def) {
      if (!def || typeof def !== "object" || !Object.keys(def).length) {
        return minimatch;
      }
      var orig = minimatch;
      var m = function minimatch2(p, pattern, options) {
        return orig(p, pattern, ext(def, options));
      };
      m.Minimatch = function Minimatch2(pattern, options) {
        return new orig.Minimatch(pattern, ext(def, options));
      };
      m.Minimatch.defaults = function defaults(options) {
        return orig.defaults(ext(def, options)).Minimatch;
      };
      m.filter = function filter2(pattern, options) {
        return orig.filter(pattern, ext(def, options));
      };
      m.defaults = function defaults(options) {
        return orig.defaults(ext(def, options));
      };
      m.makeRe = function makeRe2(pattern, options) {
        return orig.makeRe(pattern, ext(def, options));
      };
      m.braceExpand = function braceExpand2(pattern, options) {
        return orig.braceExpand(pattern, ext(def, options));
      };
      m.match = function(list, pattern, options) {
        return orig.match(list, pattern, ext(def, options));
      };
      return m;
    };
    Minimatch.defaults = function(def) {
      return minimatch.defaults(def).Minimatch;
    };
    function minimatch(p, pattern, options) {
      assertValidPattern(pattern);
      if (!options)
        options = {};
      if (!options.nocomment && pattern.charAt(0) === "#") {
        return false;
      }
      return new Minimatch(pattern, options).match(p);
    }
    function Minimatch(pattern, options) {
      if (!(this instanceof Minimatch)) {
        return new Minimatch(pattern, options);
      }
      assertValidPattern(pattern);
      if (!options)
        options = {};
      pattern = pattern.trim();
      if (!options.allowWindowsEscape && path.sep !== "/") {
        pattern = pattern.split(path.sep).join("/");
      }
      this.options = options;
      this.set = [];
      this.pattern = pattern;
      this.regexp = null;
      this.negate = false;
      this.comment = false;
      this.empty = false;
      this.partial = !!options.partial;
      this.make();
    }
    Minimatch.prototype.debug = function() {
    };
    Minimatch.prototype.make = make;
    function make() {
      var pattern = this.pattern;
      var options = this.options;
      if (!options.nocomment && pattern.charAt(0) === "#") {
        this.comment = true;
        return;
      }
      if (!pattern) {
        this.empty = true;
        return;
      }
      this.parseNegate();
      var set = this.globSet = this.braceExpand();
      if (options.debug)
        this.debug = function debug() {
          console.error.apply(console, arguments);
        };
      this.debug(this.pattern, set);
      set = this.globParts = set.map(function(s) {
        return s.split(slashSplit);
      });
      this.debug(this.pattern, set);
      set = set.map(function(s, si, set2) {
        return s.map(this.parse, this);
      }, this);
      this.debug(this.pattern, set);
      set = set.filter(function(s) {
        return s.indexOf(false) === -1;
      });
      this.debug(this.pattern, set);
      this.set = set;
    }
    Minimatch.prototype.parseNegate = parseNegate;
    function parseNegate() {
      var pattern = this.pattern;
      var negate = false;
      var options = this.options;
      var negateOffset = 0;
      if (options.nonegate)
        return;
      for (var i = 0, l2 = pattern.length; i < l2 && pattern.charAt(i) === "!"; i++) {
        negate = !negate;
        negateOffset++;
      }
      if (negateOffset)
        this.pattern = pattern.substr(negateOffset);
      this.negate = negate;
    }
    minimatch.braceExpand = function(pattern, options) {
      return braceExpand(pattern, options);
    };
    Minimatch.prototype.braceExpand = braceExpand;
    function braceExpand(pattern, options) {
      if (!options) {
        if (this instanceof Minimatch) {
          options = this.options;
        } else {
          options = {};
        }
      }
      pattern = typeof pattern === "undefined" ? this.pattern : pattern;
      assertValidPattern(pattern);
      if (options.nobrace || !/\{(?:(?!\{).)*\}/.test(pattern)) {
        return [pattern];
      }
      return expand(pattern);
    }
    var MAX_PATTERN_LENGTH = 1024 * 64;
    var assertValidPattern = function(pattern) {
      if (typeof pattern !== "string") {
        throw new TypeError("invalid pattern");
      }
      if (pattern.length > MAX_PATTERN_LENGTH) {
        throw new TypeError("pattern is too long");
      }
    };
    Minimatch.prototype.parse = parse2;
    var SUBPARSE = {};
    function parse2(pattern, isSub) {
      assertValidPattern(pattern);
      var options = this.options;
      if (pattern === "**") {
        if (!options.noglobstar)
          return GLOBSTAR;
        else
          pattern = "*";
      }
      if (pattern === "")
        return "";
      var re = "";
      var hasMagic = !!options.nocase;
      var escaping = false;
      var patternListStack = [];
      var negativeLists = [];
      var stateChar;
      var inClass = false;
      var reClassStart = -1;
      var classStart = -1;
      var patternStart = pattern.charAt(0) === "." ? "" : options.dot ? "(?!(?:^|\\/)\\.{1,2}(?:$|\\/))" : "(?!\\.)";
      var self2 = this;
      function clearStateChar() {
        if (stateChar) {
          switch (stateChar) {
            case "*":
              re += star;
              hasMagic = true;
              break;
            case "?":
              re += qmark;
              hasMagic = true;
              break;
            default:
              re += "\\" + stateChar;
              break;
          }
          self2.debug("clearStateChar %j %j", stateChar, re);
          stateChar = false;
        }
      }
      for (var i = 0, len = pattern.length, c; i < len && (c = pattern.charAt(i)); i++) {
        this.debug("%s	%s %s %j", pattern, i, re, c);
        if (escaping && reSpecials[c]) {
          re += "\\" + c;
          escaping = false;
          continue;
        }
        switch (c) {
          case "/": {
            return false;
          }
          case "\\":
            clearStateChar();
            escaping = true;
            continue;
          case "?":
          case "*":
          case "+":
          case "@":
          case "!":
            this.debug("%s	%s %s %j <-- stateChar", pattern, i, re, c);
            if (inClass) {
              this.debug("  in class");
              if (c === "!" && i === classStart + 1)
                c = "^";
              re += c;
              continue;
            }
            self2.debug("call clearStateChar %j", stateChar);
            clearStateChar();
            stateChar = c;
            if (options.noext)
              clearStateChar();
            continue;
          case "(":
            if (inClass) {
              re += "(";
              continue;
            }
            if (!stateChar) {
              re += "\\(";
              continue;
            }
            patternListStack.push({
              type: stateChar,
              start: i - 1,
              reStart: re.length,
              open: plTypes[stateChar].open,
              close: plTypes[stateChar].close
            });
            re += stateChar === "!" ? "(?:(?!(?:" : "(?:";
            this.debug("plType %j %j", stateChar, re);
            stateChar = false;
            continue;
          case ")":
            if (inClass || !patternListStack.length) {
              re += "\\)";
              continue;
            }
            clearStateChar();
            hasMagic = true;
            var pl = patternListStack.pop();
            re += pl.close;
            if (pl.type === "!") {
              negativeLists.push(pl);
            }
            pl.reEnd = re.length;
            continue;
          case "|":
            if (inClass || !patternListStack.length || escaping) {
              re += "\\|";
              escaping = false;
              continue;
            }
            clearStateChar();
            re += "|";
            continue;
          case "[":
            clearStateChar();
            if (inClass) {
              re += "\\" + c;
              continue;
            }
            inClass = true;
            classStart = i;
            reClassStart = re.length;
            re += c;
            continue;
          case "]":
            if (i === classStart + 1 || !inClass) {
              re += "\\" + c;
              escaping = false;
              continue;
            }
            var cs = pattern.substring(classStart + 1, i);
            try {
              RegExp("[" + cs + "]");
            } catch (er) {
              var sp = this.parse(cs, SUBPARSE);
              re = re.substr(0, reClassStart) + "\\[" + sp[0] + "\\]";
              hasMagic = hasMagic || sp[1];
              inClass = false;
              continue;
            }
            hasMagic = true;
            inClass = false;
            re += c;
            continue;
          default:
            clearStateChar();
            if (escaping) {
              escaping = false;
            } else if (reSpecials[c] && !(c === "^" && inClass)) {
              re += "\\";
            }
            re += c;
        }
      }
      if (inClass) {
        cs = pattern.substr(classStart + 1);
        sp = this.parse(cs, SUBPARSE);
        re = re.substr(0, reClassStart) + "\\[" + sp[0];
        hasMagic = hasMagic || sp[1];
      }
      for (pl = patternListStack.pop(); pl; pl = patternListStack.pop()) {
        var tail = re.slice(pl.reStart + pl.open.length);
        this.debug("setting tail", re, pl);
        tail = tail.replace(/((?:\\{2}){0,64})(\\?)\|/g, function(_2, $1, $2) {
          if (!$2) {
            $2 = "\\";
          }
          return $1 + $1 + $2 + "|";
        });
        this.debug("tail=%j\n   %s", tail, tail, pl, re);
        var t = pl.type === "*" ? star : pl.type === "?" ? qmark : "\\" + pl.type;
        hasMagic = true;
        re = re.slice(0, pl.reStart) + t + "\\(" + tail;
      }
      clearStateChar();
      if (escaping) {
        re += "\\\\";
      }
      var addPatternStart = false;
      switch (re.charAt(0)) {
        case "[":
        case ".":
        case "(":
          addPatternStart = true;
      }
      for (var n = negativeLists.length - 1; n > -1; n--) {
        var nl = negativeLists[n];
        var nlBefore = re.slice(0, nl.reStart);
        var nlFirst = re.slice(nl.reStart, nl.reEnd - 8);
        var nlLast = re.slice(nl.reEnd - 8, nl.reEnd);
        var nlAfter = re.slice(nl.reEnd);
        nlLast += nlAfter;
        var openParensBefore = nlBefore.split("(").length - 1;
        var cleanAfter = nlAfter;
        for (i = 0; i < openParensBefore; i++) {
          cleanAfter = cleanAfter.replace(/\)[+*?]?/, "");
        }
        nlAfter = cleanAfter;
        var dollar = "";
        if (nlAfter === "" && isSub !== SUBPARSE) {
          dollar = "$";
        }
        var newRe = nlBefore + nlFirst + nlAfter + dollar + nlLast;
        re = newRe;
      }
      if (re !== "" && hasMagic) {
        re = "(?=.)" + re;
      }
      if (addPatternStart) {
        re = patternStart + re;
      }
      if (isSub === SUBPARSE) {
        return [re, hasMagic];
      }
      if (!hasMagic) {
        return globUnescape(pattern);
      }
      var flags = options.nocase ? "i" : "";
      try {
        var regExp = new RegExp("^" + re + "$", flags);
      } catch (er) {
        return new RegExp("$.");
      }
      regExp._glob = pattern;
      regExp._src = re;
      return regExp;
    }
    minimatch.makeRe = function(pattern, options) {
      return new Minimatch(pattern, options || {}).makeRe();
    };
    Minimatch.prototype.makeRe = makeRe;
    function makeRe() {
      if (this.regexp || this.regexp === false)
        return this.regexp;
      var set = this.set;
      if (!set.length) {
        this.regexp = false;
        return this.regexp;
      }
      var options = this.options;
      var twoStar = options.noglobstar ? star : options.dot ? twoStarDot : twoStarNoDot;
      var flags = options.nocase ? "i" : "";
      var re = set.map(function(pattern) {
        return pattern.map(function(p) {
          return p === GLOBSTAR ? twoStar : typeof p === "string" ? regExpEscape(p) : p._src;
        }).join("\\/");
      }).join("|");
      re = "^(?:" + re + ")$";
      if (this.negate)
        re = "^(?!" + re + ").*$";
      try {
        this.regexp = new RegExp(re, flags);
      } catch (ex) {
        this.regexp = false;
      }
      return this.regexp;
    }
    minimatch.match = function(list, pattern, options) {
      options = options || {};
      var mm = new Minimatch(pattern, options);
      list = list.filter(function(f) {
        return mm.match(f);
      });
      if (mm.options.nonull && !list.length) {
        list.push(pattern);
      }
      return list;
    };
    Minimatch.prototype.match = function match(f, partial) {
      if (typeof partial === "undefined")
        partial = this.partial;
      this.debug("match", f, this.pattern);
      if (this.comment)
        return false;
      if (this.empty)
        return f === "";
      if (f === "/" && partial)
        return true;
      var options = this.options;
      if (path.sep !== "/") {
        f = f.split(path.sep).join("/");
      }
      f = f.split(slashSplit);
      this.debug(this.pattern, "split", f);
      var set = this.set;
      this.debug(this.pattern, "set", set);
      var filename;
      var i;
      for (i = f.length - 1; i >= 0; i--) {
        filename = f[i];
        if (filename)
          break;
      }
      for (i = 0; i < set.length; i++) {
        var pattern = set[i];
        var file = f;
        if (options.matchBase && pattern.length === 1) {
          file = [filename];
        }
        var hit = this.matchOne(file, pattern, partial);
        if (hit) {
          if (options.flipNegate)
            return true;
          return !this.negate;
        }
      }
      if (options.flipNegate)
        return false;
      return this.negate;
    };
    Minimatch.prototype.matchOne = function(file, pattern, partial) {
      var options = this.options;
      this.debug(
        "matchOne",
        { "this": this, file, pattern }
      );
      this.debug("matchOne", file.length, pattern.length);
      for (var fi = 0, pi = 0, fl = file.length, pl = pattern.length; fi < fl && pi < pl; fi++, pi++) {
        this.debug("matchOne loop");
        var p = pattern[pi];
        var f = file[fi];
        this.debug(pattern, p, f);
        if (p === false)
          return false;
        if (p === GLOBSTAR) {
          this.debug("GLOBSTAR", [pattern, p, f]);
          var fr = fi;
          var pr = pi + 1;
          if (pr === pl) {
            this.debug("** at the end");
            for (; fi < fl; fi++) {
              if (file[fi] === "." || file[fi] === ".." || !options.dot && file[fi].charAt(0) === ".")
                return false;
            }
            return true;
          }
          while (fr < fl) {
            var swallowee = file[fr];
            this.debug("\nglobstar while", file, fr, pattern, pr, swallowee);
            if (this.matchOne(file.slice(fr), pattern.slice(pr), partial)) {
              this.debug("globstar found match!", fr, fl, swallowee);
              return true;
            } else {
              if (swallowee === "." || swallowee === ".." || !options.dot && swallowee.charAt(0) === ".") {
                this.debug("dot detected!", file, fr, pattern, pr);
                break;
              }
              this.debug("globstar swallow a segment, and continue");
              fr++;
            }
          }
          if (partial) {
            this.debug("\n>>> no match, partial?", file, fr, pattern, pr);
            if (fr === fl)
              return true;
          }
          return false;
        }
        var hit;
        if (typeof p === "string") {
          hit = f === p;
          this.debug("string match", p, f, hit);
        } else {
          hit = f.match(p);
          this.debug("pattern match", p, f, hit);
        }
        if (!hit)
          return false;
      }
      if (fi === fl && pi === pl) {
        return true;
      } else if (fi === fl) {
        return partial;
      } else if (pi === pl) {
        return fi === fl - 1 && file[fi] === "";
      }
      throw new Error("wtf?");
    };
    function globUnescape(s) {
      return s.replace(/\\(.)/g, "$1");
    }
    function regExpEscape(s) {
      return s.replace(/[-[\]{}()*+?.,\\^$|#\s]/g, "\\$&");
    }
  }
});

// ../../../node_modules/zip-stream/node_modules/glob/common.js
var require_common3 = __commonJS({
  "../../../node_modules/zip-stream/node_modules/glob/common.js"(exports2) {
    exports2.setopts = setopts;
    exports2.ownProp = ownProp;
    exports2.makeAbs = makeAbs;
    exports2.finish = finish;
    exports2.mark = mark;
    exports2.isIgnored = isIgnored;
    exports2.childrenIgnored = childrenIgnored;
    function ownProp(obj2, field) {
      return Object.prototype.hasOwnProperty.call(obj2, field);
    }
    var fs = require("fs");
    var path = require("path");
    var minimatch = require_minimatch3();
    var isAbsolute = require_path_is_absolute();
    var Minimatch = minimatch.Minimatch;
    function alphasort(a, b) {
      return a.localeCompare(b, "en");
    }
    function setupIgnores(self2, options) {
      self2.ignore = options.ignore || [];
      if (!Array.isArray(self2.ignore))
        self2.ignore = [self2.ignore];
      if (self2.ignore.length) {
        self2.ignore = self2.ignore.map(ignoreMap);
      }
    }
    function ignoreMap(pattern) {
      var gmatcher = null;
      if (pattern.slice(-3) === "/**") {
        var gpattern = pattern.replace(/(\/\*\*)+$/, "");
        gmatcher = new Minimatch(gpattern, { dot: true });
      }
      return {
        matcher: new Minimatch(pattern, { dot: true }),
        gmatcher
      };
    }
    function setopts(self2, pattern, options) {
      if (!options)
        options = {};
      if (options.matchBase && -1 === pattern.indexOf("/")) {
        if (options.noglobstar) {
          throw new Error("base matching requires globstar");
        }
        pattern = "**/" + pattern;
      }
      self2.silent = !!options.silent;
      self2.pattern = pattern;
      self2.strict = options.strict !== false;
      self2.realpath = !!options.realpath;
      self2.realpathCache = options.realpathCache || /* @__PURE__ */ Object.create(null);
      self2.follow = !!options.follow;
      self2.dot = !!options.dot;
      self2.mark = !!options.mark;
      self2.nodir = !!options.nodir;
      if (self2.nodir)
        self2.mark = true;
      self2.sync = !!options.sync;
      self2.nounique = !!options.nounique;
      self2.nonull = !!options.nonull;
      self2.nosort = !!options.nosort;
      self2.nocase = !!options.nocase;
      self2.stat = !!options.stat;
      self2.noprocess = !!options.noprocess;
      self2.absolute = !!options.absolute;
      self2.fs = options.fs || fs;
      self2.maxLength = options.maxLength || Infinity;
      self2.cache = options.cache || /* @__PURE__ */ Object.create(null);
      self2.statCache = options.statCache || /* @__PURE__ */ Object.create(null);
      self2.symlinks = options.symlinks || /* @__PURE__ */ Object.create(null);
      setupIgnores(self2, options);
      self2.changedCwd = false;
      var cwd = process.cwd();
      if (!ownProp(options, "cwd"))
        self2.cwd = cwd;
      else {
        self2.cwd = path.resolve(options.cwd);
        self2.changedCwd = self2.cwd !== cwd;
      }
      self2.root = options.root || path.resolve(self2.cwd, "/");
      self2.root = path.resolve(self2.root);
      if (process.platform === "win32")
        self2.root = self2.root.replace(/\\/g, "/");
      self2.cwdAbs = isAbsolute(self2.cwd) ? self2.cwd : makeAbs(self2, self2.cwd);
      if (process.platform === "win32")
        self2.cwdAbs = self2.cwdAbs.replace(/\\/g, "/");
      self2.nomount = !!options.nomount;
      options.nonegate = true;
      options.nocomment = true;
      options.allowWindowsEscape = false;
      self2.minimatch = new Minimatch(pattern, options);
      self2.options = self2.minimatch.options;
    }
    function finish(self2) {
      var nou = self2.nounique;
      var all = nou ? [] : /* @__PURE__ */ Object.create(null);
      for (var i = 0, l2 = self2.matches.length; i < l2; i++) {
        var matches = self2.matches[i];
        if (!matches || Object.keys(matches).length === 0) {
          if (self2.nonull) {
            var literal = self2.minimatch.globSet[i];
            if (nou)
              all.push(literal);
            else
              all[literal] = true;
          }
        } else {
          var m = Object.keys(matches);
          if (nou)
            all.push.apply(all, m);
          else
            m.forEach(function(m2) {
              all[m2] = true;
            });
        }
      }
      if (!nou)
        all = Object.keys(all);
      if (!self2.nosort)
        all = all.sort(alphasort);
      if (self2.mark) {
        for (var i = 0; i < all.length; i++) {
          all[i] = self2._mark(all[i]);
        }
        if (self2.nodir) {
          all = all.filter(function(e) {
            var notDir = !/\/$/.test(e);
            var c = self2.cache[e] || self2.cache[makeAbs(self2, e)];
            if (notDir && c)
              notDir = c !== "DIR" && !Array.isArray(c);
            return notDir;
          });
        }
      }
      if (self2.ignore.length)
        all = all.filter(function(m2) {
          return !isIgnored(self2, m2);
        });
      self2.found = all;
    }
    function mark(self2, p) {
      var abs = makeAbs(self2, p);
      var c = self2.cache[abs];
      var m = p;
      if (c) {
        var isDir = c === "DIR" || Array.isArray(c);
        var slash = p.slice(-1) === "/";
        if (isDir && !slash)
          m += "/";
        else if (!isDir && slash)
          m = m.slice(0, -1);
        if (m !== p) {
          var mabs = makeAbs(self2, m);
          self2.statCache[mabs] = self2.statCache[abs];
          self2.cache[mabs] = self2.cache[abs];
        }
      }
      return m;
    }
    function makeAbs(self2, f) {
      var abs = f;
      if (f.charAt(0) === "/") {
        abs = path.join(self2.root, f);
      } else if (isAbsolute(f) || f === "") {
        abs = f;
      } else if (self2.changedCwd) {
        abs = path.resolve(self2.cwd, f);
      } else {
        abs = path.resolve(f);
      }
      if (process.platform === "win32")
        abs = abs.replace(/\\/g, "/");
      return abs;
    }
    function isIgnored(self2, path2) {
      if (!self2.ignore.length)
        return false;
      return self2.ignore.some(function(item) {
        return item.matcher.match(path2) || !!(item.gmatcher && item.gmatcher.match(path2));
      });
    }
    function childrenIgnored(self2, path2) {
      if (!self2.ignore.length)
        return false;
      return self2.ignore.some(function(item) {
        return !!(item.gmatcher && item.gmatcher.match(path2));
      });
    }
  }
});

// ../../../node_modules/zip-stream/node_modules/glob/sync.js
var require_sync2 = __commonJS({
  "../../../node_modules/zip-stream/node_modules/glob/sync.js"(exports2, module2) {
    module2.exports = globSync;
    globSync.GlobSync = GlobSync;
    var rp = require_fs();
    var minimatch = require_minimatch3();
    var Minimatch = minimatch.Minimatch;
    var Glob = require_glob2().Glob;
    var util = require("util");
    var path = require("path");
    var assert = require("assert");
    var isAbsolute = require_path_is_absolute();
    var common = require_common3();
    var setopts = common.setopts;
    var ownProp = common.ownProp;
    var childrenIgnored = common.childrenIgnored;
    var isIgnored = common.isIgnored;
    function globSync(pattern, options) {
      if (typeof options === "function" || arguments.length === 3)
        throw new TypeError("callback provided to sync glob\nSee: https://github.com/isaacs/node-glob/issues/167");
      return new GlobSync(pattern, options).found;
    }
    function GlobSync(pattern, options) {
      if (!pattern)
        throw new Error("must provide pattern");
      if (typeof options === "function" || arguments.length === 3)
        throw new TypeError("callback provided to sync glob\nSee: https://github.com/isaacs/node-glob/issues/167");
      if (!(this instanceof GlobSync))
        return new GlobSync(pattern, options);
      setopts(this, pattern, options);
      if (this.noprocess)
        return this;
      var n = this.minimatch.set.length;
      this.matches = new Array(n);
      for (var i = 0; i < n; i++) {
        this._process(this.minimatch.set[i], i, false);
      }
      this._finish();
    }
    GlobSync.prototype._finish = function() {
      assert.ok(this instanceof GlobSync);
      if (this.realpath) {
        var self2 = this;
        this.matches.forEach(function(matchset, index) {
          var set = self2.matches[index] = /* @__PURE__ */ Object.create(null);
          for (var p in matchset) {
            try {
              p = self2._makeAbs(p);
              var real = rp.realpathSync(p, self2.realpathCache);
              set[real] = true;
            } catch (er) {
              if (er.syscall === "stat")
                set[self2._makeAbs(p)] = true;
              else
                throw er;
            }
          }
        });
      }
      common.finish(this);
    };
    GlobSync.prototype._process = function(pattern, index, inGlobStar) {
      assert.ok(this instanceof GlobSync);
      var n = 0;
      while (typeof pattern[n] === "string") {
        n++;
      }
      var prefix;
      switch (n) {
        case pattern.length:
          this._processSimple(pattern.join("/"), index);
          return;
        case 0:
          prefix = null;
          break;
        default:
          prefix = pattern.slice(0, n).join("/");
          break;
      }
      var remain = pattern.slice(n);
      var read;
      if (prefix === null)
        read = ".";
      else if (isAbsolute(prefix) || isAbsolute(pattern.map(function(p) {
        return typeof p === "string" ? p : "[*]";
      }).join("/"))) {
        if (!prefix || !isAbsolute(prefix))
          prefix = "/" + prefix;
        read = prefix;
      } else
        read = prefix;
      var abs = this._makeAbs(read);
      if (childrenIgnored(this, read))
        return;
      var isGlobStar = remain[0] === minimatch.GLOBSTAR;
      if (isGlobStar)
        this._processGlobStar(prefix, read, abs, remain, index, inGlobStar);
      else
        this._processReaddir(prefix, read, abs, remain, index, inGlobStar);
    };
    GlobSync.prototype._processReaddir = function(prefix, read, abs, remain, index, inGlobStar) {
      var entries = this._readdir(abs, inGlobStar);
      if (!entries)
        return;
      var pn = remain[0];
      var negate = !!this.minimatch.negate;
      var rawGlob = pn._glob;
      var dotOk = this.dot || rawGlob.charAt(0) === ".";
      var matchedEntries = [];
      for (var i = 0; i < entries.length; i++) {
        var e = entries[i];
        if (e.charAt(0) !== "." || dotOk) {
          var m;
          if (negate && !prefix) {
            m = !e.match(pn);
          } else {
            m = e.match(pn);
          }
          if (m)
            matchedEntries.push(e);
        }
      }
      var len = matchedEntries.length;
      if (len === 0)
        return;
      if (remain.length === 1 && !this.mark && !this.stat) {
        if (!this.matches[index])
          this.matches[index] = /* @__PURE__ */ Object.create(null);
        for (var i = 0; i < len; i++) {
          var e = matchedEntries[i];
          if (prefix) {
            if (prefix.slice(-1) !== "/")
              e = prefix + "/" + e;
            else
              e = prefix + e;
          }
          if (e.charAt(0) === "/" && !this.nomount) {
            e = path.join(this.root, e);
          }
          this._emitMatch(index, e);
        }
        return;
      }
      remain.shift();
      for (var i = 0; i < len; i++) {
        var e = matchedEntries[i];
        var newPattern;
        if (prefix)
          newPattern = [prefix, e];
        else
          newPattern = [e];
        this._process(newPattern.concat(remain), index, inGlobStar);
      }
    };
    GlobSync.prototype._emitMatch = function(index, e) {
      if (isIgnored(this, e))
        return;
      var abs = this._makeAbs(e);
      if (this.mark)
        e = this._mark(e);
      if (this.absolute) {
        e = abs;
      }
      if (this.matches[index][e])
        return;
      if (this.nodir) {
        var c = this.cache[abs];
        if (c === "DIR" || Array.isArray(c))
          return;
      }
      this.matches[index][e] = true;
      if (this.stat)
        this._stat(e);
    };
    GlobSync.prototype._readdirInGlobStar = function(abs) {
      if (this.follow)
        return this._readdir(abs, false);
      var entries;
      var lstat;
      var stat;
      try {
        lstat = this.fs.lstatSync(abs);
      } catch (er) {
        if (er.code === "ENOENT") {
          return null;
        }
      }
      var isSym = lstat && lstat.isSymbolicLink();
      this.symlinks[abs] = isSym;
      if (!isSym && lstat && !lstat.isDirectory())
        this.cache[abs] = "FILE";
      else
        entries = this._readdir(abs, false);
      return entries;
    };
    GlobSync.prototype._readdir = function(abs, inGlobStar) {
      var entries;
      if (inGlobStar && !ownProp(this.symlinks, abs))
        return this._readdirInGlobStar(abs);
      if (ownProp(this.cache, abs)) {
        var c = this.cache[abs];
        if (!c || c === "FILE")
          return null;
        if (Array.isArray(c))
          return c;
      }
      try {
        return this._readdirEntries(abs, this.fs.readdirSync(abs));
      } catch (er) {
        this._readdirError(abs, er);
        return null;
      }
    };
    GlobSync.prototype._readdirEntries = function(abs, entries) {
      if (!this.mark && !this.stat) {
        for (var i = 0; i < entries.length; i++) {
          var e = entries[i];
          if (abs === "/")
            e = abs + e;
          else
            e = abs + "/" + e;
          this.cache[e] = true;
        }
      }
      this.cache[abs] = entries;
      return entries;
    };
    GlobSync.prototype._readdirError = function(f, er) {
      switch (er.code) {
        case "ENOTSUP":
        case "ENOTDIR":
          var abs = this._makeAbs(f);
          this.cache[abs] = "FILE";
          if (abs === this.cwdAbs) {
            var error = new Error(er.code + " invalid cwd " + this.cwd);
            error.path = this.cwd;
            error.code = er.code;
            throw error;
          }
          break;
        case "ENOENT":
        case "ELOOP":
        case "ENAMETOOLONG":
        case "UNKNOWN":
          this.cache[this._makeAbs(f)] = false;
          break;
        default:
          this.cache[this._makeAbs(f)] = false;
          if (this.strict)
            throw er;
          if (!this.silent)
            console.error("glob error", er);
          break;
      }
    };
    GlobSync.prototype._processGlobStar = function(prefix, read, abs, remain, index, inGlobStar) {
      var entries = this._readdir(abs, inGlobStar);
      if (!entries)
        return;
      var remainWithoutGlobStar = remain.slice(1);
      var gspref = prefix ? [prefix] : [];
      var noGlobStar = gspref.concat(remainWithoutGlobStar);
      this._process(noGlobStar, index, false);
      var len = entries.length;
      var isSym = this.symlinks[abs];
      if (isSym && inGlobStar)
        return;
      for (var i = 0; i < len; i++) {
        var e = entries[i];
        if (e.charAt(0) === "." && !this.dot)
          continue;
        var instead = gspref.concat(entries[i], remainWithoutGlobStar);
        this._process(instead, index, true);
        var below = gspref.concat(entries[i], remain);
        this._process(below, index, true);
      }
    };
    GlobSync.prototype._processSimple = function(prefix, index) {
      var exists = this._stat(prefix);
      if (!this.matches[index])
        this.matches[index] = /* @__PURE__ */ Object.create(null);
      if (!exists)
        return;
      if (prefix && isAbsolute(prefix) && !this.nomount) {
        var trail = /[\/\\]$/.test(prefix);
        if (prefix.charAt(0) === "/") {
          prefix = path.join(this.root, prefix);
        } else {
          prefix = path.resolve(this.root, prefix);
          if (trail)
            prefix += "/";
        }
      }
      if (process.platform === "win32")
        prefix = prefix.replace(/\\/g, "/");
      this._emitMatch(index, prefix);
    };
    GlobSync.prototype._stat = function(f) {
      var abs = this._makeAbs(f);
      var needDir = f.slice(-1) === "/";
      if (f.length > this.maxLength)
        return false;
      if (!this.stat && ownProp(this.cache, abs)) {
        var c = this.cache[abs];
        if (Array.isArray(c))
          c = "DIR";
        if (!needDir || c === "DIR")
          return c;
        if (needDir && c === "FILE")
          return false;
      }
      var exists;
      var stat = this.statCache[abs];
      if (!stat) {
        var lstat;
        try {
          lstat = this.fs.lstatSync(abs);
        } catch (er) {
          if (er && (er.code === "ENOENT" || er.code === "ENOTDIR")) {
            this.statCache[abs] = false;
            return false;
          }
        }
        if (lstat && lstat.isSymbolicLink()) {
          try {
            stat = this.fs.statSync(abs);
          } catch (er) {
            stat = lstat;
          }
        } else {
          stat = lstat;
        }
      }
      this.statCache[abs] = stat;
      var c = true;
      if (stat)
        c = stat.isDirectory() ? "DIR" : "FILE";
      this.cache[abs] = this.cache[abs] || c;
      if (needDir && c === "FILE")
        return false;
      return c;
    };
    GlobSync.prototype._mark = function(p) {
      return common.mark(this, p);
    };
    GlobSync.prototype._makeAbs = function(f) {
      return common.makeAbs(this, f);
    };
  }
});

// ../../../node_modules/zip-stream/node_modules/glob/glob.js
var require_glob2 = __commonJS({
  "../../../node_modules/zip-stream/node_modules/glob/glob.js"(exports2, module2) {
    module2.exports = glob;
    var rp = require_fs();
    var minimatch = require_minimatch3();
    var Minimatch = minimatch.Minimatch;
    var inherits2 = require_inherits();
    var EE = require("events").EventEmitter;
    var path = require("path");
    var assert = require("assert");
    var isAbsolute = require_path_is_absolute();
    var globSync = require_sync2();
    var common = require_common3();
    var setopts = common.setopts;
    var ownProp = common.ownProp;
    var inflight = require_inflight();
    var util = require("util");
    var childrenIgnored = common.childrenIgnored;
    var isIgnored = common.isIgnored;
    var once = require_once();
    function glob(pattern, options, cb) {
      if (typeof options === "function")
        cb = options, options = {};
      if (!options)
        options = {};
      if (options.sync) {
        if (cb)
          throw new TypeError("callback provided to sync glob");
        return globSync(pattern, options);
      }
      return new Glob(pattern, options, cb);
    }
    glob.sync = globSync;
    var GlobSync = glob.GlobSync = globSync.GlobSync;
    glob.glob = glob;
    function extend(origin, add) {
      if (add === null || typeof add !== "object") {
        return origin;
      }
      var keys = Object.keys(add);
      var i = keys.length;
      while (i--) {
        origin[keys[i]] = add[keys[i]];
      }
      return origin;
    }
    glob.hasMagic = function(pattern, options_) {
      var options = extend({}, options_);
      options.noprocess = true;
      var g = new Glob(pattern, options);
      var set = g.minimatch.set;
      if (!pattern)
        return false;
      if (set.length > 1)
        return true;
      for (var j = 0; j < set[0].length; j++) {
        if (typeof set[0][j] !== "string")
          return true;
      }
      return false;
    };
    glob.Glob = Glob;
    inherits2(Glob, EE);
    function Glob(pattern, options, cb) {
      if (typeof options === "function") {
        cb = options;
        options = null;
      }
      if (options && options.sync) {
        if (cb)
          throw new TypeError("callback provided to sync glob");
        return new GlobSync(pattern, options);
      }
      if (!(this instanceof Glob))
        return new Glob(pattern, options, cb);
      setopts(this, pattern, options);
      this._didRealPath = false;
      var n = this.minimatch.set.length;
      this.matches = new Array(n);
      if (typeof cb === "function") {
        cb = once(cb);
        this.on("error", cb);
        this.on("end", function(matches) {
          cb(null, matches);
        });
      }
      var self2 = this;
      this._processing = 0;
      this._emitQueue = [];
      this._processQueue = [];
      this.paused = false;
      if (this.noprocess)
        return this;
      if (n === 0)
        return done();
      var sync = true;
      for (var i = 0; i < n; i++) {
        this._process(this.minimatch.set[i], i, false, done);
      }
      sync = false;
      function done() {
        --self2._processing;
        if (self2._processing <= 0) {
          if (sync) {
            process.nextTick(function() {
              self2._finish();
            });
          } else {
            self2._finish();
          }
        }
      }
    }
    Glob.prototype._finish = function() {
      assert(this instanceof Glob);
      if (this.aborted)
        return;
      if (this.realpath && !this._didRealpath)
        return this._realpath();
      common.finish(this);
      this.emit("end", this.found);
    };
    Glob.prototype._realpath = function() {
      if (this._didRealpath)
        return;
      this._didRealpath = true;
      var n = this.matches.length;
      if (n === 0)
        return this._finish();
      var self2 = this;
      for (var i = 0; i < this.matches.length; i++)
        this._realpathSet(i, next);
      function next() {
        if (--n === 0)
          self2._finish();
      }
    };
    Glob.prototype._realpathSet = function(index, cb) {
      var matchset = this.matches[index];
      if (!matchset)
        return cb();
      var found = Object.keys(matchset);
      var self2 = this;
      var n = found.length;
      if (n === 0)
        return cb();
      var set = this.matches[index] = /* @__PURE__ */ Object.create(null);
      found.forEach(function(p, i) {
        p = self2._makeAbs(p);
        rp.realpath(p, self2.realpathCache, function(er, real) {
          if (!er)
            set[real] = true;
          else if (er.syscall === "stat")
            set[p] = true;
          else
            self2.emit("error", er);
          if (--n === 0) {
            self2.matches[index] = set;
            cb();
          }
        });
      });
    };
    Glob.prototype._mark = function(p) {
      return common.mark(this, p);
    };
    Glob.prototype._makeAbs = function(f) {
      return common.makeAbs(this, f);
    };
    Glob.prototype.abort = function() {
      this.aborted = true;
      this.emit("abort");
    };
    Glob.prototype.pause = function() {
      if (!this.paused) {
        this.paused = true;
        this.emit("pause");
      }
    };
    Glob.prototype.resume = function() {
      if (this.paused) {
        this.emit("resume");
        this.paused = false;
        if (this._emitQueue.length) {
          var eq = this._emitQueue.slice(0);
          this._emitQueue.length = 0;
          for (var i = 0; i < eq.length; i++) {
            var e = eq[i];
            this._emitMatch(e[0], e[1]);
          }
        }
        if (this._processQueue.length) {
          var pq = this._processQueue.slice(0);
          this._processQueue.length = 0;
          for (var i = 0; i < pq.length; i++) {
            var p = pq[i];
            this._processing--;
            this._process(p[0], p[1], p[2], p[3]);
          }
        }
      }
    };
    Glob.prototype._process = function(pattern, index, inGlobStar, cb) {
      assert(this instanceof Glob);
      assert(typeof cb === "function");
      if (this.aborted)
        return;
      this._processing++;
      if (this.paused) {
        this._processQueue.push([pattern, index, inGlobStar, cb]);
        return;
      }
      var n = 0;
      while (typeof pattern[n] === "string") {
        n++;
      }
      var prefix;
      switch (n) {
        case pattern.length:
          this._processSimple(pattern.join("/"), index, cb);
          return;
        case 0:
          prefix = null;
          break;
        default:
          prefix = pattern.slice(0, n).join("/");
          break;
      }
      var remain = pattern.slice(n);
      var read;
      if (prefix === null)
        read = ".";
      else if (isAbsolute(prefix) || isAbsolute(pattern.map(function(p) {
        return typeof p === "string" ? p : "[*]";
      }).join("/"))) {
        if (!prefix || !isAbsolute(prefix))
          prefix = "/" + prefix;
        read = prefix;
      } else
        read = prefix;
      var abs = this._makeAbs(read);
      if (childrenIgnored(this, read))
        return cb();
      var isGlobStar = remain[0] === minimatch.GLOBSTAR;
      if (isGlobStar)
        this._processGlobStar(prefix, read, abs, remain, index, inGlobStar, cb);
      else
        this._processReaddir(prefix, read, abs, remain, index, inGlobStar, cb);
    };
    Glob.prototype._processReaddir = function(prefix, read, abs, remain, index, inGlobStar, cb) {
      var self2 = this;
      this._readdir(abs, inGlobStar, function(er, entries) {
        return self2._processReaddir2(prefix, read, abs, remain, index, inGlobStar, entries, cb);
      });
    };
    Glob.prototype._processReaddir2 = function(prefix, read, abs, remain, index, inGlobStar, entries, cb) {
      if (!entries)
        return cb();
      var pn = remain[0];
      var negate = !!this.minimatch.negate;
      var rawGlob = pn._glob;
      var dotOk = this.dot || rawGlob.charAt(0) === ".";
      var matchedEntries = [];
      for (var i = 0; i < entries.length; i++) {
        var e = entries[i];
        if (e.charAt(0) !== "." || dotOk) {
          var m;
          if (negate && !prefix) {
            m = !e.match(pn);
          } else {
            m = e.match(pn);
          }
          if (m)
            matchedEntries.push(e);
        }
      }
      var len = matchedEntries.length;
      if (len === 0)
        return cb();
      if (remain.length === 1 && !this.mark && !this.stat) {
        if (!this.matches[index])
          this.matches[index] = /* @__PURE__ */ Object.create(null);
        for (var i = 0; i < len; i++) {
          var e = matchedEntries[i];
          if (prefix) {
            if (prefix !== "/")
              e = prefix + "/" + e;
            else
              e = prefix + e;
          }
          if (e.charAt(0) === "/" && !this.nomount) {
            e = path.join(this.root, e);
          }
          this._emitMatch(index, e);
        }
        return cb();
      }
      remain.shift();
      for (var i = 0; i < len; i++) {
        var e = matchedEntries[i];
        var newPattern;
        if (prefix) {
          if (prefix !== "/")
            e = prefix + "/" + e;
          else
            e = prefix + e;
        }
        this._process([e].concat(remain), index, inGlobStar, cb);
      }
      cb();
    };
    Glob.prototype._emitMatch = function(index, e) {
      if (this.aborted)
        return;
      if (isIgnored(this, e))
        return;
      if (this.paused) {
        this._emitQueue.push([index, e]);
        return;
      }
      var abs = isAbsolute(e) ? e : this._makeAbs(e);
      if (this.mark)
        e = this._mark(e);
      if (this.absolute)
        e = abs;
      if (this.matches[index][e])
        return;
      if (this.nodir) {
        var c = this.cache[abs];
        if (c === "DIR" || Array.isArray(c))
          return;
      }
      this.matches[index][e] = true;
      var st = this.statCache[abs];
      if (st)
        this.emit("stat", e, st);
      this.emit("match", e);
    };
    Glob.prototype._readdirInGlobStar = function(abs, cb) {
      if (this.aborted)
        return;
      if (this.follow)
        return this._readdir(abs, false, cb);
      var lstatkey = "lstat\0" + abs;
      var self2 = this;
      var lstatcb = inflight(lstatkey, lstatcb_);
      if (lstatcb)
        self2.fs.lstat(abs, lstatcb);
      function lstatcb_(er, lstat) {
        if (er && er.code === "ENOENT")
          return cb();
        var isSym = lstat && lstat.isSymbolicLink();
        self2.symlinks[abs] = isSym;
        if (!isSym && lstat && !lstat.isDirectory()) {
          self2.cache[abs] = "FILE";
          cb();
        } else
          self2._readdir(abs, false, cb);
      }
    };
    Glob.prototype._readdir = function(abs, inGlobStar, cb) {
      if (this.aborted)
        return;
      cb = inflight("readdir\0" + abs + "\0" + inGlobStar, cb);
      if (!cb)
        return;
      if (inGlobStar && !ownProp(this.symlinks, abs))
        return this._readdirInGlobStar(abs, cb);
      if (ownProp(this.cache, abs)) {
        var c = this.cache[abs];
        if (!c || c === "FILE")
          return cb();
        if (Array.isArray(c))
          return cb(null, c);
      }
      var self2 = this;
      self2.fs.readdir(abs, readdirCb(this, abs, cb));
    };
    function readdirCb(self2, abs, cb) {
      return function(er, entries) {
        if (er)
          self2._readdirError(abs, er, cb);
        else
          self2._readdirEntries(abs, entries, cb);
      };
    }
    Glob.prototype._readdirEntries = function(abs, entries, cb) {
      if (this.aborted)
        return;
      if (!this.mark && !this.stat) {
        for (var i = 0; i < entries.length; i++) {
          var e = entries[i];
          if (abs === "/")
            e = abs + e;
          else
            e = abs + "/" + e;
          this.cache[e] = true;
        }
      }
      this.cache[abs] = entries;
      return cb(null, entries);
    };
    Glob.prototype._readdirError = function(f, er, cb) {
      if (this.aborted)
        return;
      switch (er.code) {
        case "ENOTSUP":
        case "ENOTDIR":
          var abs = this._makeAbs(f);
          this.cache[abs] = "FILE";
          if (abs === this.cwdAbs) {
            var error = new Error(er.code + " invalid cwd " + this.cwd);
            error.path = this.cwd;
            error.code = er.code;
            this.emit("error", error);
            this.abort();
          }
          break;
        case "ENOENT":
        case "ELOOP":
        case "ENAMETOOLONG":
        case "UNKNOWN":
          this.cache[this._makeAbs(f)] = false;
          break;
        default:
          this.cache[this._makeAbs(f)] = false;
          if (this.strict) {
            this.emit("error", er);
            this.abort();
          }
          if (!this.silent)
            console.error("glob error", er);
          break;
      }
      return cb();
    };
    Glob.prototype._processGlobStar = function(prefix, read, abs, remain, index, inGlobStar, cb) {
      var self2 = this;
      this._readdir(abs, inGlobStar, function(er, entries) {
        self2._processGlobStar2(prefix, read, abs, remain, index, inGlobStar, entries, cb);
      });
    };
    Glob.prototype._processGlobStar2 = function(prefix, read, abs, remain, index, inGlobStar, entries, cb) {
      if (!entries)
        return cb();
      var remainWithoutGlobStar = remain.slice(1);
      var gspref = prefix ? [prefix] : [];
      var noGlobStar = gspref.concat(remainWithoutGlobStar);
      this._process(noGlobStar, index, false, cb);
      var isSym = this.symlinks[abs];
      var len = entries.length;
      if (isSym && inGlobStar)
        return cb();
      for (var i = 0; i < len; i++) {
        var e = entries[i];
        if (e.charAt(0) === "." && !this.dot)
          continue;
        var instead = gspref.concat(entries[i], remainWithoutGlobStar);
        this._process(instead, index, true, cb);
        var below = gspref.concat(entries[i], remain);
        this._process(below, index, true, cb);
      }
      cb();
    };
    Glob.prototype._processSimple = function(prefix, index, cb) {
      var self2 = this;
      this._stat(prefix, function(er, exists) {
        self2._processSimple2(prefix, index, er, exists, cb);
      });
    };
    Glob.prototype._processSimple2 = function(prefix, index, er, exists, cb) {
      if (!this.matches[index])
        this.matches[index] = /* @__PURE__ */ Object.create(null);
      if (!exists)
        return cb();
      if (prefix && isAbsolute(prefix) && !this.nomount) {
        var trail = /[\/\\]$/.test(prefix);
        if (prefix.charAt(0) === "/") {
          prefix = path.join(this.root, prefix);
        } else {
          prefix = path.resolve(this.root, prefix);
          if (trail)
            prefix += "/";
        }
      }
      if (process.platform === "win32")
        prefix = prefix.replace(/\\/g, "/");
      this._emitMatch(index, prefix);
      cb();
    };
    Glob.prototype._stat = function(f, cb) {
      var abs = this._makeAbs(f);
      var needDir = f.slice(-1) === "/";
      if (f.length > this.maxLength)
        return cb();
      if (!this.stat && ownProp(this.cache, abs)) {
        var c = this.cache[abs];
        if (Array.isArray(c))
          c = "DIR";
        if (!needDir || c === "DIR")
          return cb(null, c);
        if (needDir && c === "FILE")
          return cb();
      }
      var exists;
      var stat = this.statCache[abs];
      if (stat !== void 0) {
        if (stat === false)
          return cb(null, stat);
        else {
          var type = stat.isDirectory() ? "DIR" : "FILE";
          if (needDir && type === "FILE")
            return cb();
          else
            return cb(null, type, stat);
        }
      }
      var self2 = this;
      var statcb = inflight("stat\0" + abs, lstatcb_);
      if (statcb)
        self2.fs.lstat(abs, statcb);
      function lstatcb_(er, lstat) {
        if (lstat && lstat.isSymbolicLink()) {
          return self2.fs.stat(abs, function(er2, stat2) {
            if (er2)
              self2._stat2(f, abs, null, lstat, cb);
            else
              self2._stat2(f, abs, er2, stat2, cb);
          });
        } else {
          self2._stat2(f, abs, er, lstat, cb);
        }
      }
    };
    Glob.prototype._stat2 = function(f, abs, er, stat, cb) {
      if (er && (er.code === "ENOENT" || er.code === "ENOTDIR")) {
        this.statCache[abs] = false;
        return cb();
      }
      var needDir = f.slice(-1) === "/";
      this.statCache[abs] = stat;
      if (abs.slice(-1) === "/" && stat && !stat.isDirectory())
        return cb(null, false, stat);
      var c = true;
      if (stat)
        c = stat.isDirectory() ? "DIR" : "FILE";
      this.cache[abs] = this.cache[abs] || c;
      if (needDir && c === "FILE")
        return cb();
      return cb(null, c, stat);
    };
  }
});

// ../../../node_modules/zip-stream/node_modules/archiver-utils/file.js
var require_file2 = __commonJS({
  "../../../node_modules/zip-stream/node_modules/archiver-utils/file.js"(exports2, module2) {
    var fs = require_graceful_fs();
    var path = require("path");
    var flatten = require_lodash10();
    var difference = require_lodash11();
    var union = require_lodash12();
    var isPlainObject = require_lodash13();
    var glob = require_glob2();
    var file = module2.exports = {};
    var pathSeparatorRe = /[\/\\]/g;
    var processPatterns = function(patterns, fn) {
      var result = [];
      flatten(patterns).forEach(function(pattern) {
        var exclusion = pattern.indexOf("!") === 0;
        if (exclusion) {
          pattern = pattern.slice(1);
        }
        var matches = fn(pattern);
        if (exclusion) {
          result = difference(result, matches);
        } else {
          result = union(result, matches);
        }
      });
      return result;
    };
    file.exists = function() {
      var filepath = path.join.apply(path, arguments);
      return fs.existsSync(filepath);
    };
    file.expand = function(...args) {
      var options = isPlainObject(args[0]) ? args.shift() : {};
      var patterns = Array.isArray(args[0]) ? args[0] : args;
      if (patterns.length === 0) {
        return [];
      }
      var matches = processPatterns(patterns, function(pattern) {
        return glob.sync(pattern, options);
      });
      if (options.filter) {
        matches = matches.filter(function(filepath) {
          filepath = path.join(options.cwd || "", filepath);
          try {
            if (typeof options.filter === "function") {
              return options.filter(filepath);
            } else {
              return fs.statSync(filepath)[options.filter]();
            }
          } catch (e) {
            return false;
          }
        });
      }
      return matches;
    };
    file.expandMapping = function(patterns, destBase, options) {
      options = Object.assign({
        rename: function(destBase2, destPath) {
          return path.join(destBase2 || "", destPath);
        }
      }, options);
      var files = [];
      var fileByDest = {};
      file.expand(options, patterns).forEach(function(src) {
        var destPath = src;
        if (options.flatten) {
          destPath = path.basename(destPath);
        }
        if (options.ext) {
          destPath = destPath.replace(/(\.[^\/]*)?$/, options.ext);
        }
        var dest = options.rename(destBase, destPath, options);
        if (options.cwd) {
          src = path.join(options.cwd, src);
        }
        dest = dest.replace(pathSeparatorRe, "/");
        src = src.replace(pathSeparatorRe, "/");
        if (fileByDest[dest]) {
          fileByDest[dest].src.push(src);
        } else {
          files.push({
            src: [src],
            dest
          });
          fileByDest[dest] = files[files.length - 1];
        }
      });
      return files;
    };
    file.normalizeFilesArray = function(data) {
      var files = [];
      data.forEach(function(obj2) {
        var prop;
        if ("src" in obj2 || "dest" in obj2) {
          files.push(obj2);
        }
      });
      if (files.length === 0) {
        return [];
      }
      files = _(files).chain().forEach(function(obj2) {
        if (!("src" in obj2) || !obj2.src) {
          return;
        }
        if (Array.isArray(obj2.src)) {
          obj2.src = flatten(obj2.src);
        } else {
          obj2.src = [obj2.src];
        }
      }).map(function(obj2) {
        var expandOptions = Object.assign({}, obj2);
        delete expandOptions.src;
        delete expandOptions.dest;
        if (obj2.expand) {
          return file.expandMapping(obj2.src, obj2.dest, expandOptions).map(function(mapObj) {
            var result2 = Object.assign({}, obj2);
            result2.orig = Object.assign({}, obj2);
            result2.src = mapObj.src;
            result2.dest = mapObj.dest;
            ["expand", "cwd", "flatten", "rename", "ext"].forEach(function(prop) {
              delete result2[prop];
            });
            return result2;
          });
        }
        var result = Object.assign({}, obj2);
        result.orig = Object.assign({}, obj2);
        if ("src" in result) {
          Object.defineProperty(result, "src", {
            enumerable: true,
            get: function fn() {
              var src;
              if (!("result" in fn)) {
                src = obj2.src;
                src = Array.isArray(src) ? flatten(src) : [src];
                fn.result = file.expand(expandOptions, src);
              }
              return fn.result;
            }
          });
        }
        if ("dest" in result) {
          result.dest = obj2.dest;
        }
        return result;
      }).flatten().value();
      return files;
    };
  }
});

// ../../../node_modules/zip-stream/node_modules/archiver-utils/index.js
var require_archiver_utils2 = __commonJS({
  "../../../node_modules/zip-stream/node_modules/archiver-utils/index.js"(exports2, module2) {
    var fs = require_graceful_fs();
    var path = require("path");
    var lazystream = require_lazystream();
    var normalizePath = require_normalize_path();
    var defaults = require_lodash9();
    var Stream = require("stream").Stream;
    var PassThrough = require_readable8().PassThrough;
    var utils = module2.exports = {};
    utils.file = require_file2();
    utils.collectStream = function(source, callback) {
      var collection = [];
      var size = 0;
      source.on("error", callback);
      source.on("data", function(chunk) {
        collection.push(chunk);
        size += chunk.length;
      });
      source.on("end", function() {
        var buf = Buffer.alloc(size);
        var offset = 0;
        collection.forEach(function(data) {
          data.copy(buf, offset);
          offset += data.length;
        });
        callback(null, buf);
      });
    };
    utils.dateify = function(dateish) {
      dateish = dateish || /* @__PURE__ */ new Date();
      if (dateish instanceof Date) {
        dateish = dateish;
      } else if (typeof dateish === "string") {
        dateish = new Date(dateish);
      } else {
        dateish = /* @__PURE__ */ new Date();
      }
      return dateish;
    };
    utils.defaults = function(object, source, guard) {
      var args = arguments;
      args[0] = args[0] || {};
      return defaults(...args);
    };
    utils.isStream = function(source) {
      return source instanceof Stream;
    };
    utils.lazyReadStream = function(filepath) {
      return new lazystream.Readable(function() {
        return fs.createReadStream(filepath);
      });
    };
    utils.normalizeInputSource = function(source) {
      if (source === null) {
        return Buffer.alloc(0);
      } else if (typeof source === "string") {
        return Buffer.from(source);
      } else if (utils.isStream(source)) {
        return source.pipe(new PassThrough());
      }
      return source;
    };
    utils.sanitizePath = function(filepath) {
      return normalizePath(filepath, false).replace(/^\w+:/, "").replace(/^(\.\.\/|\/)+/, "");
    };
    utils.trailingSlashIt = function(str) {
      return str.slice(-1) !== "/" ? str + "/" : str;
    };
    utils.unixifyPath = function(filepath) {
      return normalizePath(filepath, false).replace(/^\w+:/, "");
    };
    utils.walkdir = function(dirpath, base, callback) {
      var results = [];
      if (typeof base === "function") {
        callback = base;
        base = dirpath;
      }
      fs.readdir(dirpath, function(err, list) {
        var i = 0;
        var file;
        var filepath;
        if (err) {
          return callback(err);
        }
        (function next() {
          file = list[i++];
          if (!file) {
            return callback(null, results);
          }
          filepath = path.join(dirpath, file);
          fs.stat(filepath, function(err2, stats) {
            results.push({
              path: filepath,
              relative: path.relative(base, filepath).replace(/\\/g, "/"),
              stats
            });
            if (stats && stats.isDirectory()) {
              utils.walkdir(filepath, base, function(err3, res) {
                res.forEach(function(dirEntry) {
                  results.push(dirEntry);
                });
                next();
              });
            } else {
              next();
            }
          });
        })();
      });
    };
  }
});

// ../../../node_modules/zip-stream/index.js
var require_zip_stream2 = __commonJS({
  "../../../node_modules/zip-stream/index.js"(exports2, module2) {
    var inherits2 = require("util").inherits;
    var ZipArchiveOutputStream = require_compress_commons().ZipArchiveOutputStream;
    var ZipArchiveEntry = require_compress_commons().ZipArchiveEntry;
    var util = require_archiver_utils2();
    var ZipStream = module2.exports = function(options) {
      if (!(this instanceof ZipStream)) {
        return new ZipStream(options);
      }
      options = this.options = options || {};
      options.zlib = options.zlib || {};
      ZipArchiveOutputStream.call(this, options);
      if (typeof options.level === "number" && options.level >= 0) {
        options.zlib.level = options.level;
        delete options.level;
      }
      if (!options.forceZip64 && typeof options.zlib.level === "number" && options.zlib.level === 0) {
        options.store = true;
      }
      options.namePrependSlash = options.namePrependSlash || false;
      if (options.comment && options.comment.length > 0) {
        this.setComment(options.comment);
      }
    };
    inherits2(ZipStream, ZipArchiveOutputStream);
    ZipStream.prototype._normalizeFileData = function(data) {
      data = util.defaults(data, {
        type: "file",
        name: null,
        namePrependSlash: this.options.namePrependSlash,
        linkname: null,
        date: null,
        mode: null,
        store: this.options.store,
        comment: ""
      });
      var isDir = data.type === "directory";
      var isSymlink = data.type === "symlink";
      if (data.name) {
        data.name = util.sanitizePath(data.name);
        if (!isSymlink && data.name.slice(-1) === "/") {
          isDir = true;
          data.type = "directory";
        } else if (isDir) {
          data.name += "/";
        }
      }
      if (isDir || isSymlink) {
        data.store = true;
      }
      data.date = util.dateify(data.date);
      return data;
    };
    ZipStream.prototype.entry = function(source, data, callback) {
      if (typeof callback !== "function") {
        callback = this._emitErrorCallback.bind(this);
      }
      data = this._normalizeFileData(data);
      if (data.type !== "file" && data.type !== "directory" && data.type !== "symlink") {
        callback(new Error(data.type + " entries not currently supported"));
        return;
      }
      if (typeof data.name !== "string" || data.name.length === 0) {
        callback(new Error("entry name must be a non-empty string value"));
        return;
      }
      if (data.type === "symlink" && typeof data.linkname !== "string") {
        callback(new Error("entry linkname must be a non-empty string value when type equals symlink"));
        return;
      }
      var entry = new ZipArchiveEntry(data.name);
      entry.setTime(data.date, this.options.forceLocalTime);
      if (data.namePrependSlash) {
        entry.setName(data.name, true);
      }
      if (data.store) {
        entry.setMethod(0);
      }
      if (data.comment.length > 0) {
        entry.setComment(data.comment);
      }
      if (data.type === "symlink" && typeof data.mode !== "number") {
        data.mode = 40960;
      }
      if (typeof data.mode === "number") {
        if (data.type === "symlink") {
          data.mode |= 40960;
        }
        entry.setUnixMode(data.mode);
      }
      if (data.type === "symlink" && typeof data.linkname === "string") {
        source = Buffer.from(data.linkname);
      }
      return ZipArchiveOutputStream.prototype.entry.call(this, entry, source, callback);
    };
    ZipStream.prototype.finalize = function() {
      this.finish();
    };
  }
});

// ../../../node_modules/archiver/lib/plugins/zip.js
var require_zip = __commonJS({
  "../../../node_modules/archiver/lib/plugins/zip.js"(exports2, module2) {
    var engine = require_zip_stream2();
    var util = require_archiver_utils();
    var Zip = function(options) {
      if (!(this instanceof Zip)) {
        return new Zip(options);
      }
      options = this.options = util.defaults(options, {
        comment: "",
        forceUTC: false,
        namePrependSlash: false,
        store: false
      });
      this.supports = {
        directory: true,
        symlink: true
      };
      this.engine = new engine(options);
    };
    Zip.prototype.append = function(source, data, callback) {
      this.engine.entry(source, data, callback);
    };
    Zip.prototype.finalize = function() {
      this.engine.finalize();
    };
    Zip.prototype.on = function() {
      return this.engine.on.apply(this.engine, arguments);
    };
    Zip.prototype.pipe = function() {
      return this.engine.pipe.apply(this.engine, arguments);
    };
    Zip.prototype.unpipe = function() {
      return this.engine.unpipe.apply(this.engine, arguments);
    };
    module2.exports = Zip;
  }
});

// ../../../node_modules/bl/node_modules/readable-stream/lib/internal/streams/stream.js
var require_stream9 = __commonJS({
  "../../../node_modules/bl/node_modules/readable-stream/lib/internal/streams/stream.js"(exports2, module2) {
    module2.exports = require("stream");
  }
});

// ../../../node_modules/bl/node_modules/readable-stream/lib/internal/streams/buffer_list.js
var require_buffer_list6 = __commonJS({
  "../../../node_modules/bl/node_modules/readable-stream/lib/internal/streams/buffer_list.js"(exports2, module2) {
    "use strict";
    function ownKeys(object, enumerableOnly) {
      var keys = Object.keys(object);
      if (Object.getOwnPropertySymbols) {
        var symbols = Object.getOwnPropertySymbols(object);
        enumerableOnly && (symbols = symbols.filter(function(sym) {
          return Object.getOwnPropertyDescriptor(object, sym).enumerable;
        })), keys.push.apply(keys, symbols);
      }
      return keys;
    }
    function _objectSpread(target) {
      for (var i = 1; i < arguments.length; i++) {
        var source = null != arguments[i] ? arguments[i] : {};
        i % 2 ? ownKeys(Object(source), true).forEach(function(key) {
          _defineProperty(target, key, source[key]);
        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function(key) {
          Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
        });
      }
      return target;
    }
    function _defineProperty(obj2, key, value) {
      key = _toPropertyKey(key);
      if (key in obj2) {
        Object.defineProperty(obj2, key, { value, enumerable: true, configurable: true, writable: true });
      } else {
        obj2[key] = value;
      }
      return obj2;
    }
    function _classCallCheck(instance, Constructor) {
      if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
      }
    }
    function _defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor)
          descriptor.writable = true;
        Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor);
      }
    }
    function _createClass(Constructor, protoProps, staticProps) {
      if (protoProps)
        _defineProperties(Constructor.prototype, protoProps);
      if (staticProps)
        _defineProperties(Constructor, staticProps);
      Object.defineProperty(Constructor, "prototype", { writable: false });
      return Constructor;
    }
    function _toPropertyKey(arg) {
      var key = _toPrimitive(arg, "string");
      return typeof key === "symbol" ? key : String(key);
    }
    function _toPrimitive(input, hint) {
      if (typeof input !== "object" || input === null)
        return input;
      var prim = input[Symbol.toPrimitive];
      if (prim !== void 0) {
        var res = prim.call(input, hint || "default");
        if (typeof res !== "object")
          return res;
        throw new TypeError("@@toPrimitive must return a primitive value.");
      }
      return (hint === "string" ? String : Number)(input);
    }
    var _require = require("buffer");
    var Buffer2 = _require.Buffer;
    var _require2 = require("util");
    var inspect = _require2.inspect;
    var custom = inspect && inspect.custom || "inspect";
    function copyBuffer(src, target, offset) {
      Buffer2.prototype.copy.call(src, target, offset);
    }
    module2.exports = /* @__PURE__ */ function() {
      function BufferList() {
        _classCallCheck(this, BufferList);
        this.head = null;
        this.tail = null;
        this.length = 0;
      }
      _createClass(BufferList, [{
        key: "push",
        value: function push(v) {
          var entry = {
            data: v,
            next: null
          };
          if (this.length > 0)
            this.tail.next = entry;
          else
            this.head = entry;
          this.tail = entry;
          ++this.length;
        }
      }, {
        key: "unshift",
        value: function unshift(v) {
          var entry = {
            data: v,
            next: this.head
          };
          if (this.length === 0)
            this.tail = entry;
          this.head = entry;
          ++this.length;
        }
      }, {
        key: "shift",
        value: function shift() {
          if (this.length === 0)
            return;
          var ret2 = this.head.data;
          if (this.length === 1)
            this.head = this.tail = null;
          else
            this.head = this.head.next;
          --this.length;
          return ret2;
        }
      }, {
        key: "clear",
        value: function clear() {
          this.head = this.tail = null;
          this.length = 0;
        }
      }, {
        key: "join",
        value: function join(s) {
          if (this.length === 0)
            return "";
          var p = this.head;
          var ret2 = "" + p.data;
          while (p = p.next)
            ret2 += s + p.data;
          return ret2;
        }
      }, {
        key: "concat",
        value: function concat(n) {
          if (this.length === 0)
            return Buffer2.alloc(0);
          var ret2 = Buffer2.allocUnsafe(n >>> 0);
          var p = this.head;
          var i = 0;
          while (p) {
            copyBuffer(p.data, ret2, i);
            i += p.data.length;
            p = p.next;
          }
          return ret2;
        }
        // Consumes a specified amount of bytes or characters from the buffered data.
      }, {
        key: "consume",
        value: function consume(n, hasStrings) {
          var ret2;
          if (n < this.head.data.length) {
            ret2 = this.head.data.slice(0, n);
            this.head.data = this.head.data.slice(n);
          } else if (n === this.head.data.length) {
            ret2 = this.shift();
          } else {
            ret2 = hasStrings ? this._getString(n) : this._getBuffer(n);
          }
          return ret2;
        }
      }, {
        key: "first",
        value: function first() {
          return this.head.data;
        }
        // Consumes a specified amount of characters from the buffered data.
      }, {
        key: "_getString",
        value: function _getString(n) {
          var p = this.head;
          var c = 1;
          var ret2 = p.data;
          n -= ret2.length;
          while (p = p.next) {
            var str = p.data;
            var nb = n > str.length ? str.length : n;
            if (nb === str.length)
              ret2 += str;
            else
              ret2 += str.slice(0, n);
            n -= nb;
            if (n === 0) {
              if (nb === str.length) {
                ++c;
                if (p.next)
                  this.head = p.next;
                else
                  this.head = this.tail = null;
              } else {
                this.head = p;
                p.data = str.slice(nb);
              }
              break;
            }
            ++c;
          }
          this.length -= c;
          return ret2;
        }
        // Consumes a specified amount of bytes from the buffered data.
      }, {
        key: "_getBuffer",
        value: function _getBuffer(n) {
          var ret2 = Buffer2.allocUnsafe(n);
          var p = this.head;
          var c = 1;
          p.data.copy(ret2);
          n -= p.data.length;
          while (p = p.next) {
            var buf = p.data;
            var nb = n > buf.length ? buf.length : n;
            buf.copy(ret2, ret2.length - n, 0, nb);
            n -= nb;
            if (n === 0) {
              if (nb === buf.length) {
                ++c;
                if (p.next)
                  this.head = p.next;
                else
                  this.head = this.tail = null;
              } else {
                this.head = p;
                p.data = buf.slice(nb);
              }
              break;
            }
            ++c;
          }
          this.length -= c;
          return ret2;
        }
        // Make sure the linked list only shows the minimal necessary information.
      }, {
        key: custom,
        value: function value(_2, options) {
          return inspect(this, _objectSpread(_objectSpread({}, options), {}, {
            // Only inspect one level.
            depth: 0,
            // It should not recurse.
            customInspect: false
          }));
        }
      }]);
      return BufferList;
    }();
  }
});

// ../../../node_modules/bl/node_modules/readable-stream/lib/internal/streams/destroy.js
var require_destroy9 = __commonJS({
  "../../../node_modules/bl/node_modules/readable-stream/lib/internal/streams/destroy.js"(exports2, module2) {
    "use strict";
    function destroy(err, cb) {
      var _this = this;
      var readableDestroyed = this._readableState && this._readableState.destroyed;
      var writableDestroyed = this._writableState && this._writableState.destroyed;
      if (readableDestroyed || writableDestroyed) {
        if (cb) {
          cb(err);
        } else if (err) {
          if (!this._writableState) {
            process.nextTick(emitErrorNT, this, err);
          } else if (!this._writableState.errorEmitted) {
            this._writableState.errorEmitted = true;
            process.nextTick(emitErrorNT, this, err);
          }
        }
        return this;
      }
      if (this._readableState) {
        this._readableState.destroyed = true;
      }
      if (this._writableState) {
        this._writableState.destroyed = true;
      }
      this._destroy(err || null, function(err2) {
        if (!cb && err2) {
          if (!_this._writableState) {
            process.nextTick(emitErrorAndCloseNT, _this, err2);
          } else if (!_this._writableState.errorEmitted) {
            _this._writableState.errorEmitted = true;
            process.nextTick(emitErrorAndCloseNT, _this, err2);
          } else {
            process.nextTick(emitCloseNT, _this);
          }
        } else if (cb) {
          process.nextTick(emitCloseNT, _this);
          cb(err2);
        } else {
          process.nextTick(emitCloseNT, _this);
        }
      });
      return this;
    }
    function emitErrorAndCloseNT(self2, err) {
      emitErrorNT(self2, err);
      emitCloseNT(self2);
    }
    function emitCloseNT(self2) {
      if (self2._writableState && !self2._writableState.emitClose)
        return;
      if (self2._readableState && !self2._readableState.emitClose)
        return;
      self2.emit("close");
    }
    function undestroy() {
      if (this._readableState) {
        this._readableState.destroyed = false;
        this._readableState.reading = false;
        this._readableState.ended = false;
        this._readableState.endEmitted = false;
      }
      if (this._writableState) {
        this._writableState.destroyed = false;
        this._writableState.ended = false;
        this._writableState.ending = false;
        this._writableState.finalCalled = false;
        this._writableState.prefinished = false;
        this._writableState.finished = false;
        this._writableState.errorEmitted = false;
      }
    }
    function emitErrorNT(self2, err) {
      self2.emit("error", err);
    }
    function errorOrDestroy(stream, err) {
      var rState = stream._readableState;
      var wState = stream._writableState;
      if (rState && rState.autoDestroy || wState && wState.autoDestroy)
        stream.destroy(err);
      else
        stream.emit("error", err);
    }
    module2.exports = {
      destroy,
      undestroy,
      errorOrDestroy
    };
  }
});

// ../../../node_modules/bl/node_modules/readable-stream/errors.js
var require_errors6 = __commonJS({
  "../../../node_modules/bl/node_modules/readable-stream/errors.js"(exports2, module2) {
    "use strict";
    var codes = {};
    function createErrorType(code, message, Base) {
      if (!Base) {
        Base = Error;
      }
      function getMessage(arg1, arg2, arg3) {
        if (typeof message === "string") {
          return message;
        } else {
          return message(arg1, arg2, arg3);
        }
      }
      class NodeError extends Base {
        constructor(arg1, arg2, arg3) {
          super(getMessage(arg1, arg2, arg3));
        }
      }
      NodeError.prototype.name = Base.name;
      NodeError.prototype.code = code;
      codes[code] = NodeError;
    }
    function oneOf(expected, thing) {
      if (Array.isArray(expected)) {
        const len = expected.length;
        expected = expected.map((i) => String(i));
        if (len > 2) {
          return `one of ${thing} ${expected.slice(0, len - 1).join(", ")}, or ` + expected[len - 1];
        } else if (len === 2) {
          return `one of ${thing} ${expected[0]} or ${expected[1]}`;
        } else {
          return `of ${thing} ${expected[0]}`;
        }
      } else {
        return `of ${thing} ${String(expected)}`;
      }
    }
    function startsWith(str, search, pos) {
      return str.substr(!pos || pos < 0 ? 0 : +pos, search.length) === search;
    }
    function endsWith(str, search, this_len) {
      if (this_len === void 0 || this_len > str.length) {
        this_len = str.length;
      }
      return str.substring(this_len - search.length, this_len) === search;
    }
    function includes(str, search, start) {
      if (typeof start !== "number") {
        start = 0;
      }
      if (start + search.length > str.length) {
        return false;
      } else {
        return str.indexOf(search, start) !== -1;
      }
    }
    createErrorType("ERR_INVALID_OPT_VALUE", function(name, value) {
      return 'The value "' + value + '" is invalid for option "' + name + '"';
    }, TypeError);
    createErrorType("ERR_INVALID_ARG_TYPE", function(name, expected, actual) {
      let determiner;
      if (typeof expected === "string" && startsWith(expected, "not ")) {
        determiner = "must not be";
        expected = expected.replace(/^not /, "");
      } else {
        determiner = "must be";
      }
      let msg;
      if (endsWith(name, " argument")) {
        msg = `The ${name} ${determiner} ${oneOf(expected, "type")}`;
      } else {
        const type = includes(name, ".") ? "property" : "argument";
        msg = `The "${name}" ${type} ${determiner} ${oneOf(expected, "type")}`;
      }
      msg += `. Received type ${typeof actual}`;
      return msg;
    }, TypeError);
    createErrorType("ERR_STREAM_PUSH_AFTER_EOF", "stream.push() after EOF");
    createErrorType("ERR_METHOD_NOT_IMPLEMENTED", function(name) {
      return "The " + name + " method is not implemented";
    });
    createErrorType("ERR_STREAM_PREMATURE_CLOSE", "Premature close");
    createErrorType("ERR_STREAM_DESTROYED", function(name) {
      return "Cannot call " + name + " after a stream was destroyed";
    });
    createErrorType("ERR_MULTIPLE_CALLBACK", "Callback called multiple times");
    createErrorType("ERR_STREAM_CANNOT_PIPE", "Cannot pipe, not readable");
    createErrorType("ERR_STREAM_WRITE_AFTER_END", "write after end");
    createErrorType("ERR_STREAM_NULL_VALUES", "May not write null values to stream", TypeError);
    createErrorType("ERR_UNKNOWN_ENCODING", function(arg) {
      return "Unknown encoding: " + arg;
    }, TypeError);
    createErrorType("ERR_STREAM_UNSHIFT_AFTER_END_EVENT", "stream.unshift() after end event");
    module2.exports.codes = codes;
  }
});

// ../../../node_modules/bl/node_modules/readable-stream/lib/internal/streams/state.js
var require_state6 = __commonJS({
  "../../../node_modules/bl/node_modules/readable-stream/lib/internal/streams/state.js"(exports2, module2) {
    "use strict";
    var ERR_INVALID_OPT_VALUE = require_errors6().codes.ERR_INVALID_OPT_VALUE;
    function highWaterMarkFrom(options, isDuplex, duplexKey) {
      return options.highWaterMark != null ? options.highWaterMark : isDuplex ? options[duplexKey] : null;
    }
    function getHighWaterMark(state, options, duplexKey, isDuplex) {
      var hwm = highWaterMarkFrom(options, isDuplex, duplexKey);
      if (hwm != null) {
        if (!(isFinite(hwm) && Math.floor(hwm) === hwm) || hwm < 0) {
          var name = isDuplex ? duplexKey : "highWaterMark";
          throw new ERR_INVALID_OPT_VALUE(name, hwm);
        }
        return Math.floor(hwm);
      }
      return state.objectMode ? 16 : 16 * 1024;
    }
    module2.exports = {
      getHighWaterMark
    };
  }
});

// ../../../node_modules/bl/node_modules/readable-stream/lib/_stream_writable.js
var require_stream_writable9 = __commonJS({
  "../../../node_modules/bl/node_modules/readable-stream/lib/_stream_writable.js"(exports2, module2) {
    "use strict";
    module2.exports = Writable;
    function CorkedRequest(state) {
      var _this = this;
      this.next = null;
      this.entry = null;
      this.finish = function() {
        onCorkedFinish(_this, state);
      };
    }
    var Duplex;
    Writable.WritableState = WritableState;
    var internalUtil = {
      deprecate: require_node()
    };
    var Stream = require_stream9();
    var Buffer2 = require("buffer").Buffer;
    var OurUint8Array = (typeof global !== "undefined" ? global : typeof window !== "undefined" ? window : typeof self !== "undefined" ? self : {}).Uint8Array || function() {
    };
    function _uint8ArrayToBuffer(chunk) {
      return Buffer2.from(chunk);
    }
    function _isUint8Array(obj2) {
      return Buffer2.isBuffer(obj2) || obj2 instanceof OurUint8Array;
    }
    var destroyImpl = require_destroy9();
    var _require = require_state6();
    var getHighWaterMark = _require.getHighWaterMark;
    var _require$codes = require_errors6().codes;
    var ERR_INVALID_ARG_TYPE = _require$codes.ERR_INVALID_ARG_TYPE;
    var ERR_METHOD_NOT_IMPLEMENTED = _require$codes.ERR_METHOD_NOT_IMPLEMENTED;
    var ERR_MULTIPLE_CALLBACK = _require$codes.ERR_MULTIPLE_CALLBACK;
    var ERR_STREAM_CANNOT_PIPE = _require$codes.ERR_STREAM_CANNOT_PIPE;
    var ERR_STREAM_DESTROYED = _require$codes.ERR_STREAM_DESTROYED;
    var ERR_STREAM_NULL_VALUES = _require$codes.ERR_STREAM_NULL_VALUES;
    var ERR_STREAM_WRITE_AFTER_END = _require$codes.ERR_STREAM_WRITE_AFTER_END;
    var ERR_UNKNOWN_ENCODING = _require$codes.ERR_UNKNOWN_ENCODING;
    var errorOrDestroy = destroyImpl.errorOrDestroy;
    require_inherits()(Writable, Stream);
    function nop() {
    }
    function WritableState(options, stream, isDuplex) {
      Duplex = Duplex || require_stream_duplex9();
      options = options || {};
      if (typeof isDuplex !== "boolean")
        isDuplex = stream instanceof Duplex;
      this.objectMode = !!options.objectMode;
      if (isDuplex)
        this.objectMode = this.objectMode || !!options.writableObjectMode;
      this.highWaterMark = getHighWaterMark(this, options, "writableHighWaterMark", isDuplex);
      this.finalCalled = false;
      this.needDrain = false;
      this.ending = false;
      this.ended = false;
      this.finished = false;
      this.destroyed = false;
      var noDecode = options.decodeStrings === false;
      this.decodeStrings = !noDecode;
      this.defaultEncoding = options.defaultEncoding || "utf8";
      this.length = 0;
      this.writing = false;
      this.corked = 0;
      this.sync = true;
      this.bufferProcessing = false;
      this.onwrite = function(er) {
        onwrite(stream, er);
      };
      this.writecb = null;
      this.writelen = 0;
      this.bufferedRequest = null;
      this.lastBufferedRequest = null;
      this.pendingcb = 0;
      this.prefinished = false;
      this.errorEmitted = false;
      this.emitClose = options.emitClose !== false;
      this.autoDestroy = !!options.autoDestroy;
      this.bufferedRequestCount = 0;
      this.corkedRequestsFree = new CorkedRequest(this);
    }
    WritableState.prototype.getBuffer = function getBuffer() {
      var current = this.bufferedRequest;
      var out = [];
      while (current) {
        out.push(current);
        current = current.next;
      }
      return out;
    };
    (function() {
      try {
        Object.defineProperty(WritableState.prototype, "buffer", {
          get: internalUtil.deprecate(function writableStateBufferGetter() {
            return this.getBuffer();
          }, "_writableState.buffer is deprecated. Use _writableState.getBuffer instead.", "DEP0003")
        });
      } catch (_2) {
      }
    })();
    var realHasInstance;
    if (typeof Symbol === "function" && Symbol.hasInstance && typeof Function.prototype[Symbol.hasInstance] === "function") {
      realHasInstance = Function.prototype[Symbol.hasInstance];
      Object.defineProperty(Writable, Symbol.hasInstance, {
        value: function value(object) {
          if (realHasInstance.call(this, object))
            return true;
          if (this !== Writable)
            return false;
          return object && object._writableState instanceof WritableState;
        }
      });
    } else {
      realHasInstance = function realHasInstance2(object) {
        return object instanceof this;
      };
    }
    function Writable(options) {
      Duplex = Duplex || require_stream_duplex9();
      var isDuplex = this instanceof Duplex;
      if (!isDuplex && !realHasInstance.call(Writable, this))
        return new Writable(options);
      this._writableState = new WritableState(options, this, isDuplex);
      this.writable = true;
      if (options) {
        if (typeof options.write === "function")
          this._write = options.write;
        if (typeof options.writev === "function")
          this._writev = options.writev;
        if (typeof options.destroy === "function")
          this._destroy = options.destroy;
        if (typeof options.final === "function")
          this._final = options.final;
      }
      Stream.call(this);
    }
    Writable.prototype.pipe = function() {
      errorOrDestroy(this, new ERR_STREAM_CANNOT_PIPE());
    };
    function writeAfterEnd(stream, cb) {
      var er = new ERR_STREAM_WRITE_AFTER_END();
      errorOrDestroy(stream, er);
      process.nextTick(cb, er);
    }
    function validChunk(stream, state, chunk, cb) {
      var er;
      if (chunk === null) {
        er = new ERR_STREAM_NULL_VALUES();
      } else if (typeof chunk !== "string" && !state.objectMode) {
        er = new ERR_INVALID_ARG_TYPE("chunk", ["string", "Buffer"], chunk);
      }
      if (er) {
        errorOrDestroy(stream, er);
        process.nextTick(cb, er);
        return false;
      }
      return true;
    }
    Writable.prototype.write = function(chunk, encoding, cb) {
      var state = this._writableState;
      var ret2 = false;
      var isBuf = !state.objectMode && _isUint8Array(chunk);
      if (isBuf && !Buffer2.isBuffer(chunk)) {
        chunk = _uint8ArrayToBuffer(chunk);
      }
      if (typeof encoding === "function") {
        cb = encoding;
        encoding = null;
      }
      if (isBuf)
        encoding = "buffer";
      else if (!encoding)
        encoding = state.defaultEncoding;
      if (typeof cb !== "function")
        cb = nop;
      if (state.ending)
        writeAfterEnd(this, cb);
      else if (isBuf || validChunk(this, state, chunk, cb)) {
        state.pendingcb++;
        ret2 = writeOrBuffer(this, state, isBuf, chunk, encoding, cb);
      }
      return ret2;
    };
    Writable.prototype.cork = function() {
      this._writableState.corked++;
    };
    Writable.prototype.uncork = function() {
      var state = this._writableState;
      if (state.corked) {
        state.corked--;
        if (!state.writing && !state.corked && !state.bufferProcessing && state.bufferedRequest)
          clearBuffer(this, state);
      }
    };
    Writable.prototype.setDefaultEncoding = function setDefaultEncoding(encoding) {
      if (typeof encoding === "string")
        encoding = encoding.toLowerCase();
      if (!(["hex", "utf8", "utf-8", "ascii", "binary", "base64", "ucs2", "ucs-2", "utf16le", "utf-16le", "raw"].indexOf((encoding + "").toLowerCase()) > -1))
        throw new ERR_UNKNOWN_ENCODING(encoding);
      this._writableState.defaultEncoding = encoding;
      return this;
    };
    Object.defineProperty(Writable.prototype, "writableBuffer", {
      // making it explicit this property is not enumerable
      // because otherwise some prototype manipulation in
      // userland will fail
      enumerable: false,
      get: function get() {
        return this._writableState && this._writableState.getBuffer();
      }
    });
    function decodeChunk(state, chunk, encoding) {
      if (!state.objectMode && state.decodeStrings !== false && typeof chunk === "string") {
        chunk = Buffer2.from(chunk, encoding);
      }
      return chunk;
    }
    Object.defineProperty(Writable.prototype, "writableHighWaterMark", {
      // making it explicit this property is not enumerable
      // because otherwise some prototype manipulation in
      // userland will fail
      enumerable: false,
      get: function get() {
        return this._writableState.highWaterMark;
      }
    });
    function writeOrBuffer(stream, state, isBuf, chunk, encoding, cb) {
      if (!isBuf) {
        var newChunk = decodeChunk(state, chunk, encoding);
        if (chunk !== newChunk) {
          isBuf = true;
          encoding = "buffer";
          chunk = newChunk;
        }
      }
      var len = state.objectMode ? 1 : chunk.length;
      state.length += len;
      var ret2 = state.length < state.highWaterMark;
      if (!ret2)
        state.needDrain = true;
      if (state.writing || state.corked) {
        var last = state.lastBufferedRequest;
        state.lastBufferedRequest = {
          chunk,
          encoding,
          isBuf,
          callback: cb,
          next: null
        };
        if (last) {
          last.next = state.lastBufferedRequest;
        } else {
          state.bufferedRequest = state.lastBufferedRequest;
        }
        state.bufferedRequestCount += 1;
      } else {
        doWrite(stream, state, false, len, chunk, encoding, cb);
      }
      return ret2;
    }
    function doWrite(stream, state, writev, len, chunk, encoding, cb) {
      state.writelen = len;
      state.writecb = cb;
      state.writing = true;
      state.sync = true;
      if (state.destroyed)
        state.onwrite(new ERR_STREAM_DESTROYED("write"));
      else if (writev)
        stream._writev(chunk, state.onwrite);
      else
        stream._write(chunk, encoding, state.onwrite);
      state.sync = false;
    }
    function onwriteError(stream, state, sync, er, cb) {
      --state.pendingcb;
      if (sync) {
        process.nextTick(cb, er);
        process.nextTick(finishMaybe, stream, state);
        stream._writableState.errorEmitted = true;
        errorOrDestroy(stream, er);
      } else {
        cb(er);
        stream._writableState.errorEmitted = true;
        errorOrDestroy(stream, er);
        finishMaybe(stream, state);
      }
    }
    function onwriteStateUpdate(state) {
      state.writing = false;
      state.writecb = null;
      state.length -= state.writelen;
      state.writelen = 0;
    }
    function onwrite(stream, er) {
      var state = stream._writableState;
      var sync = state.sync;
      var cb = state.writecb;
      if (typeof cb !== "function")
        throw new ERR_MULTIPLE_CALLBACK();
      onwriteStateUpdate(state);
      if (er)
        onwriteError(stream, state, sync, er, cb);
      else {
        var finished = needFinish(state) || stream.destroyed;
        if (!finished && !state.corked && !state.bufferProcessing && state.bufferedRequest) {
          clearBuffer(stream, state);
        }
        if (sync) {
          process.nextTick(afterWrite, stream, state, finished, cb);
        } else {
          afterWrite(stream, state, finished, cb);
        }
      }
    }
    function afterWrite(stream, state, finished, cb) {
      if (!finished)
        onwriteDrain(stream, state);
      state.pendingcb--;
      cb();
      finishMaybe(stream, state);
    }
    function onwriteDrain(stream, state) {
      if (state.length === 0 && state.needDrain) {
        state.needDrain = false;
        stream.emit("drain");
      }
    }
    function clearBuffer(stream, state) {
      state.bufferProcessing = true;
      var entry = state.bufferedRequest;
      if (stream._writev && entry && entry.next) {
        var l2 = state.bufferedRequestCount;
        var buffer = new Array(l2);
        var holder = state.corkedRequestsFree;
        holder.entry = entry;
        var count = 0;
        var allBuffers = true;
        while (entry) {
          buffer[count] = entry;
          if (!entry.isBuf)
            allBuffers = false;
          entry = entry.next;
          count += 1;
        }
        buffer.allBuffers = allBuffers;
        doWrite(stream, state, true, state.length, buffer, "", holder.finish);
        state.pendingcb++;
        state.lastBufferedRequest = null;
        if (holder.next) {
          state.corkedRequestsFree = holder.next;
          holder.next = null;
        } else {
          state.corkedRequestsFree = new CorkedRequest(state);
        }
        state.bufferedRequestCount = 0;
      } else {
        while (entry) {
          var chunk = entry.chunk;
          var encoding = entry.encoding;
          var cb = entry.callback;
          var len = state.objectMode ? 1 : chunk.length;
          doWrite(stream, state, false, len, chunk, encoding, cb);
          entry = entry.next;
          state.bufferedRequestCount--;
          if (state.writing) {
            break;
          }
        }
        if (entry === null)
          state.lastBufferedRequest = null;
      }
      state.bufferedRequest = entry;
      state.bufferProcessing = false;
    }
    Writable.prototype._write = function(chunk, encoding, cb) {
      cb(new ERR_METHOD_NOT_IMPLEMENTED("_write()"));
    };
    Writable.prototype._writev = null;
    Writable.prototype.end = function(chunk, encoding, cb) {
      var state = this._writableState;
      if (typeof chunk === "function") {
        cb = chunk;
        chunk = null;
        encoding = null;
      } else if (typeof encoding === "function") {
        cb = encoding;
        encoding = null;
      }
      if (chunk !== null && chunk !== void 0)
        this.write(chunk, encoding);
      if (state.corked) {
        state.corked = 1;
        this.uncork();
      }
      if (!state.ending)
        endWritable(this, state, cb);
      return this;
    };
    Object.defineProperty(Writable.prototype, "writableLength", {
      // making it explicit this property is not enumerable
      // because otherwise some prototype manipulation in
      // userland will fail
      enumerable: false,
      get: function get() {
        return this._writableState.length;
      }
    });
    function needFinish(state) {
      return state.ending && state.length === 0 && state.bufferedRequest === null && !state.finished && !state.writing;
    }
    function callFinal(stream, state) {
      stream._final(function(err) {
        state.pendingcb--;
        if (err) {
          errorOrDestroy(stream, err);
        }
        state.prefinished = true;
        stream.emit("prefinish");
        finishMaybe(stream, state);
      });
    }
    function prefinish(stream, state) {
      if (!state.prefinished && !state.finalCalled) {
        if (typeof stream._final === "function" && !state.destroyed) {
          state.pendingcb++;
          state.finalCalled = true;
          process.nextTick(callFinal, stream, state);
        } else {
          state.prefinished = true;
          stream.emit("prefinish");
        }
      }
    }
    function finishMaybe(stream, state) {
      var need = needFinish(state);
      if (need) {
        prefinish(stream, state);
        if (state.pendingcb === 0) {
          state.finished = true;
          stream.emit("finish");
          if (state.autoDestroy) {
            var rState = stream._readableState;
            if (!rState || rState.autoDestroy && rState.endEmitted) {
              stream.destroy();
            }
          }
        }
      }
      return need;
    }
    function endWritable(stream, state, cb) {
      state.ending = true;
      finishMaybe(stream, state);
      if (cb) {
        if (state.finished)
          process.nextTick(cb);
        else
          stream.once("finish", cb);
      }
      state.ended = true;
      stream.writable = false;
    }
    function onCorkedFinish(corkReq, state, err) {
      var entry = corkReq.entry;
      corkReq.entry = null;
      while (entry) {
        var cb = entry.callback;
        state.pendingcb--;
        cb(err);
        entry = entry.next;
      }
      state.corkedRequestsFree.next = corkReq;
    }
    Object.defineProperty(Writable.prototype, "destroyed", {
      // making it explicit this property is not enumerable
      // because otherwise some prototype manipulation in
      // userland will fail
      enumerable: false,
      get: function get() {
        if (this._writableState === void 0) {
          return false;
        }
        return this._writableState.destroyed;
      },
      set: function set(value) {
        if (!this._writableState) {
          return;
        }
        this._writableState.destroyed = value;
      }
    });
    Writable.prototype.destroy = destroyImpl.destroy;
    Writable.prototype._undestroy = destroyImpl.undestroy;
    Writable.prototype._destroy = function(err, cb) {
      cb(err);
    };
  }
});

// ../../../node_modules/bl/node_modules/readable-stream/lib/_stream_duplex.js
var require_stream_duplex9 = __commonJS({
  "../../../node_modules/bl/node_modules/readable-stream/lib/_stream_duplex.js"(exports2, module2) {
    "use strict";
    var objectKeys = Object.keys || function(obj2) {
      var keys2 = [];
      for (var key in obj2)
        keys2.push(key);
      return keys2;
    };
    module2.exports = Duplex;
    var Readable = require_stream_readable9();
    var Writable = require_stream_writable9();
    require_inherits()(Duplex, Readable);
    {
      keys = objectKeys(Writable.prototype);
      for (v = 0; v < keys.length; v++) {
        method = keys[v];
        if (!Duplex.prototype[method])
          Duplex.prototype[method] = Writable.prototype[method];
      }
    }
    var keys;
    var method;
    var v;
    function Duplex(options) {
      if (!(this instanceof Duplex))
        return new Duplex(options);
      Readable.call(this, options);
      Writable.call(this, options);
      this.allowHalfOpen = true;
      if (options) {
        if (options.readable === false)
          this.readable = false;
        if (options.writable === false)
          this.writable = false;
        if (options.allowHalfOpen === false) {
          this.allowHalfOpen = false;
          this.once("end", onend);
        }
      }
    }
    Object.defineProperty(Duplex.prototype, "writableHighWaterMark", {
      // making it explicit this property is not enumerable
      // because otherwise some prototype manipulation in
      // userland will fail
      enumerable: false,
      get: function get() {
        return this._writableState.highWaterMark;
      }
    });
    Object.defineProperty(Duplex.prototype, "writableBuffer", {
      // making it explicit this property is not enumerable
      // because otherwise some prototype manipulation in
      // userland will fail
      enumerable: false,
      get: function get() {
        return this._writableState && this._writableState.getBuffer();
      }
    });
    Object.defineProperty(Duplex.prototype, "writableLength", {
      // making it explicit this property is not enumerable
      // because otherwise some prototype manipulation in
      // userland will fail
      enumerable: false,
      get: function get() {
        return this._writableState.length;
      }
    });
    function onend() {
      if (this._writableState.ended)
        return;
      process.nextTick(onEndNT, this);
    }
    function onEndNT(self2) {
      self2.end();
    }
    Object.defineProperty(Duplex.prototype, "destroyed", {
      // making it explicit this property is not enumerable
      // because otherwise some prototype manipulation in
      // userland will fail
      enumerable: false,
      get: function get() {
        if (this._readableState === void 0 || this._writableState === void 0) {
          return false;
        }
        return this._readableState.destroyed && this._writableState.destroyed;
      },
      set: function set(value) {
        if (this._readableState === void 0 || this._writableState === void 0) {
          return;
        }
        this._readableState.destroyed = value;
        this._writableState.destroyed = value;
      }
    });
  }
});

// ../../../node_modules/bl/node_modules/string_decoder/lib/string_decoder.js
var require_string_decoder9 = __commonJS({
  "../../../node_modules/bl/node_modules/string_decoder/lib/string_decoder.js"(exports2) {
    "use strict";
    var Buffer2 = require_safe_buffer2().Buffer;
    var isEncoding = Buffer2.isEncoding || function(encoding) {
      encoding = "" + encoding;
      switch (encoding && encoding.toLowerCase()) {
        case "hex":
        case "utf8":
        case "utf-8":
        case "ascii":
        case "binary":
        case "base64":
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
        case "raw":
          return true;
        default:
          return false;
      }
    };
    function _normalizeEncoding(enc) {
      if (!enc)
        return "utf8";
      var retried;
      while (true) {
        switch (enc) {
          case "utf8":
          case "utf-8":
            return "utf8";
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
            return "utf16le";
          case "latin1":
          case "binary":
            return "latin1";
          case "base64":
          case "ascii":
          case "hex":
            return enc;
          default:
            if (retried)
              return;
            enc = ("" + enc).toLowerCase();
            retried = true;
        }
      }
    }
    function normalizeEncoding(enc) {
      var nenc = _normalizeEncoding(enc);
      if (typeof nenc !== "string" && (Buffer2.isEncoding === isEncoding || !isEncoding(enc)))
        throw new Error("Unknown encoding: " + enc);
      return nenc || enc;
    }
    exports2.StringDecoder = StringDecoder;
    function StringDecoder(encoding) {
      this.encoding = normalizeEncoding(encoding);
      var nb;
      switch (this.encoding) {
        case "utf16le":
          this.text = utf16Text;
          this.end = utf16End;
          nb = 4;
          break;
        case "utf8":
          this.fillLast = utf8FillLast;
          nb = 4;
          break;
        case "base64":
          this.text = base64Text;
          this.end = base64End;
          nb = 3;
          break;
        default:
          this.write = simpleWrite;
          this.end = simpleEnd;
          return;
      }
      this.lastNeed = 0;
      this.lastTotal = 0;
      this.lastChar = Buffer2.allocUnsafe(nb);
    }
    StringDecoder.prototype.write = function(buf) {
      if (buf.length === 0)
        return "";
      var r;
      var i;
      if (this.lastNeed) {
        r = this.fillLast(buf);
        if (r === void 0)
          return "";
        i = this.lastNeed;
        this.lastNeed = 0;
      } else {
        i = 0;
      }
      if (i < buf.length)
        return r ? r + this.text(buf, i) : this.text(buf, i);
      return r || "";
    };
    StringDecoder.prototype.end = utf8End;
    StringDecoder.prototype.text = utf8Text;
    StringDecoder.prototype.fillLast = function(buf) {
      if (this.lastNeed <= buf.length) {
        buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, this.lastNeed);
        return this.lastChar.toString(this.encoding, 0, this.lastTotal);
      }
      buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, buf.length);
      this.lastNeed -= buf.length;
    };
    function utf8CheckByte(byte) {
      if (byte <= 127)
        return 0;
      else if (byte >> 5 === 6)
        return 2;
      else if (byte >> 4 === 14)
        return 3;
      else if (byte >> 3 === 30)
        return 4;
      return byte >> 6 === 2 ? -1 : -2;
    }
    function utf8CheckIncomplete(self2, buf, i) {
      var j = buf.length - 1;
      if (j < i)
        return 0;
      var nb = utf8CheckByte(buf[j]);
      if (nb >= 0) {
        if (nb > 0)
          self2.lastNeed = nb - 1;
        return nb;
      }
      if (--j < i || nb === -2)
        return 0;
      nb = utf8CheckByte(buf[j]);
      if (nb >= 0) {
        if (nb > 0)
          self2.lastNeed = nb - 2;
        return nb;
      }
      if (--j < i || nb === -2)
        return 0;
      nb = utf8CheckByte(buf[j]);
      if (nb >= 0) {
        if (nb > 0) {
          if (nb === 2)
            nb = 0;
          else
            self2.lastNeed = nb - 3;
        }
        return nb;
      }
      return 0;
    }
    function utf8CheckExtraBytes(self2, buf, p) {
      if ((buf[0] & 192) !== 128) {
        self2.lastNeed = 0;
        return "\uFFFD";
      }
      if (self2.lastNeed > 1 && buf.length > 1) {
        if ((buf[1] & 192) !== 128) {
          self2.lastNeed = 1;
          return "\uFFFD";
        }
        if (self2.lastNeed > 2 && buf.length > 2) {
          if ((buf[2] & 192) !== 128) {
            self2.lastNeed = 2;
            return "\uFFFD";
          }
        }
      }
    }
    function utf8FillLast(buf) {
      var p = this.lastTotal - this.lastNeed;
      var r = utf8CheckExtraBytes(this, buf, p);
      if (r !== void 0)
        return r;
      if (this.lastNeed <= buf.length) {
        buf.copy(this.lastChar, p, 0, this.lastNeed);
        return this.lastChar.toString(this.encoding, 0, this.lastTotal);
      }
      buf.copy(this.lastChar, p, 0, buf.length);
      this.lastNeed -= buf.length;
    }
    function utf8Text(buf, i) {
      var total = utf8CheckIncomplete(this, buf, i);
      if (!this.lastNeed)
        return buf.toString("utf8", i);
      this.lastTotal = total;
      var end = buf.length - (total - this.lastNeed);
      buf.copy(this.lastChar, 0, end);
      return buf.toString("utf8", i, end);
    }
    function utf8End(buf) {
      var r = buf && buf.length ? this.write(buf) : "";
      if (this.lastNeed)
        return r + "\uFFFD";
      return r;
    }
    function utf16Text(buf, i) {
      if ((buf.length - i) % 2 === 0) {
        var r = buf.toString("utf16le", i);
        if (r) {
          var c = r.charCodeAt(r.length - 1);
          if (c >= 55296 && c <= 56319) {
            this.lastNeed = 2;
            this.lastTotal = 4;
            this.lastChar[0] = buf[buf.length - 2];
            this.lastChar[1] = buf[buf.length - 1];
            return r.slice(0, -1);
          }
        }
        return r;
      }
      this.lastNeed = 1;
      this.lastTotal = 2;
      this.lastChar[0] = buf[buf.length - 1];
      return buf.toString("utf16le", i, buf.length - 1);
    }
    function utf16End(buf) {
      var r = buf && buf.length ? this.write(buf) : "";
      if (this.lastNeed) {
        var end = this.lastTotal - this.lastNeed;
        return r + this.lastChar.toString("utf16le", 0, end);
      }
      return r;
    }
    function base64Text(buf, i) {
      var n = (buf.length - i) % 3;
      if (n === 0)
        return buf.toString("base64", i);
      this.lastNeed = 3 - n;
      this.lastTotal = 3;
      if (n === 1) {
        this.lastChar[0] = buf[buf.length - 1];
      } else {
        this.lastChar[0] = buf[buf.length - 2];
        this.lastChar[1] = buf[buf.length - 1];
      }
      return buf.toString("base64", i, buf.length - n);
    }
    function base64End(buf) {
      var r = buf && buf.length ? this.write(buf) : "";
      if (this.lastNeed)
        return r + this.lastChar.toString("base64", 0, 3 - this.lastNeed);
      return r;
    }
    function simpleWrite(buf) {
      return buf.toString(this.encoding);
    }
    function simpleEnd(buf) {
      return buf && buf.length ? this.write(buf) : "";
    }
  }
});

// ../../../node_modules/bl/node_modules/readable-stream/lib/internal/streams/end-of-stream.js
var require_end_of_stream6 = __commonJS({
  "../../../node_modules/bl/node_modules/readable-stream/lib/internal/streams/end-of-stream.js"(exports2, module2) {
    "use strict";
    var ERR_STREAM_PREMATURE_CLOSE = require_errors6().codes.ERR_STREAM_PREMATURE_CLOSE;
    function once(callback) {
      var called = false;
      return function() {
        if (called)
          return;
        called = true;
        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }
        callback.apply(this, args);
      };
    }
    function noop() {
    }
    function isRequest(stream) {
      return stream.setHeader && typeof stream.abort === "function";
    }
    function eos(stream, opts, callback) {
      if (typeof opts === "function")
        return eos(stream, null, opts);
      if (!opts)
        opts = {};
      callback = once(callback || noop);
      var readable = opts.readable || opts.readable !== false && stream.readable;
      var writable = opts.writable || opts.writable !== false && stream.writable;
      var onlegacyfinish = function onlegacyfinish2() {
        if (!stream.writable)
          onfinish();
      };
      var writableEnded = stream._writableState && stream._writableState.finished;
      var onfinish = function onfinish2() {
        writable = false;
        writableEnded = true;
        if (!readable)
          callback.call(stream);
      };
      var readableEnded = stream._readableState && stream._readableState.endEmitted;
      var onend = function onend2() {
        readable = false;
        readableEnded = true;
        if (!writable)
          callback.call(stream);
      };
      var onerror = function onerror2(err) {
        callback.call(stream, err);
      };
      var onclose = function onclose2() {
        var err;
        if (readable && !readableEnded) {
          if (!stream._readableState || !stream._readableState.ended)
            err = new ERR_STREAM_PREMATURE_CLOSE();
          return callback.call(stream, err);
        }
        if (writable && !writableEnded) {
          if (!stream._writableState || !stream._writableState.ended)
            err = new ERR_STREAM_PREMATURE_CLOSE();
          return callback.call(stream, err);
        }
      };
      var onrequest = function onrequest2() {
        stream.req.on("finish", onfinish);
      };
      if (isRequest(stream)) {
        stream.on("complete", onfinish);
        stream.on("abort", onclose);
        if (stream.req)
          onrequest();
        else
          stream.on("request", onrequest);
      } else if (writable && !stream._writableState) {
        stream.on("end", onlegacyfinish);
        stream.on("close", onlegacyfinish);
      }
      stream.on("end", onend);
      stream.on("finish", onfinish);
      if (opts.error !== false)
        stream.on("error", onerror);
      stream.on("close", onclose);
      return function() {
        stream.removeListener("complete", onfinish);
        stream.removeListener("abort", onclose);
        stream.removeListener("request", onrequest);
        if (stream.req)
          stream.req.removeListener("finish", onfinish);
        stream.removeListener("end", onlegacyfinish);
        stream.removeListener("close", onlegacyfinish);
        stream.removeListener("finish", onfinish);
        stream.removeListener("end", onend);
        stream.removeListener("error", onerror);
        stream.removeListener("close", onclose);
      };
    }
    module2.exports = eos;
  }
});

// ../../../node_modules/bl/node_modules/readable-stream/lib/internal/streams/async_iterator.js
var require_async_iterator6 = __commonJS({
  "../../../node_modules/bl/node_modules/readable-stream/lib/internal/streams/async_iterator.js"(exports2, module2) {
    "use strict";
    var _Object$setPrototypeO;
    function _defineProperty(obj2, key, value) {
      key = _toPropertyKey(key);
      if (key in obj2) {
        Object.defineProperty(obj2, key, { value, enumerable: true, configurable: true, writable: true });
      } else {
        obj2[key] = value;
      }
      return obj2;
    }
    function _toPropertyKey(arg) {
      var key = _toPrimitive(arg, "string");
      return typeof key === "symbol" ? key : String(key);
    }
    function _toPrimitive(input, hint) {
      if (typeof input !== "object" || input === null)
        return input;
      var prim = input[Symbol.toPrimitive];
      if (prim !== void 0) {
        var res = prim.call(input, hint || "default");
        if (typeof res !== "object")
          return res;
        throw new TypeError("@@toPrimitive must return a primitive value.");
      }
      return (hint === "string" ? String : Number)(input);
    }
    var finished = require_end_of_stream6();
    var kLastResolve = Symbol("lastResolve");
    var kLastReject = Symbol("lastReject");
    var kError = Symbol("error");
    var kEnded = Symbol("ended");
    var kLastPromise = Symbol("lastPromise");
    var kHandlePromise = Symbol("handlePromise");
    var kStream = Symbol("stream");
    function createIterResult(value, done) {
      return {
        value,
        done
      };
    }
    function readAndResolve(iter) {
      var resolve = iter[kLastResolve];
      if (resolve !== null) {
        var data = iter[kStream].read();
        if (data !== null) {
          iter[kLastPromise] = null;
          iter[kLastResolve] = null;
          iter[kLastReject] = null;
          resolve(createIterResult(data, false));
        }
      }
    }
    function onReadable(iter) {
      process.nextTick(readAndResolve, iter);
    }
    function wrapForNext(lastPromise, iter) {
      return function(resolve, reject) {
        lastPromise.then(function() {
          if (iter[kEnded]) {
            resolve(createIterResult(void 0, true));
            return;
          }
          iter[kHandlePromise](resolve, reject);
        }, reject);
      };
    }
    var AsyncIteratorPrototype = Object.getPrototypeOf(function() {
    });
    var ReadableStreamAsyncIteratorPrototype = Object.setPrototypeOf((_Object$setPrototypeO = {
      get stream() {
        return this[kStream];
      },
      next: function next() {
        var _this = this;
        var error = this[kError];
        if (error !== null) {
          return Promise.reject(error);
        }
        if (this[kEnded]) {
          return Promise.resolve(createIterResult(void 0, true));
        }
        if (this[kStream].destroyed) {
          return new Promise(function(resolve, reject) {
            process.nextTick(function() {
              if (_this[kError]) {
                reject(_this[kError]);
              } else {
                resolve(createIterResult(void 0, true));
              }
            });
          });
        }
        var lastPromise = this[kLastPromise];
        var promise;
        if (lastPromise) {
          promise = new Promise(wrapForNext(lastPromise, this));
        } else {
          var data = this[kStream].read();
          if (data !== null) {
            return Promise.resolve(createIterResult(data, false));
          }
          promise = new Promise(this[kHandlePromise]);
        }
        this[kLastPromise] = promise;
        return promise;
      }
    }, _defineProperty(_Object$setPrototypeO, Symbol.asyncIterator, function() {
      return this;
    }), _defineProperty(_Object$setPrototypeO, "return", function _return() {
      var _this2 = this;
      return new Promise(function(resolve, reject) {
        _this2[kStream].destroy(null, function(err) {
          if (err) {
            reject(err);
            return;
          }
          resolve(createIterResult(void 0, true));
        });
      });
    }), _Object$setPrototypeO), AsyncIteratorPrototype);
    var createReadableStreamAsyncIterator = function createReadableStreamAsyncIterator2(stream) {
      var _Object$create;
      var iterator = Object.create(ReadableStreamAsyncIteratorPrototype, (_Object$create = {}, _defineProperty(_Object$create, kStream, {
        value: stream,
        writable: true
      }), _defineProperty(_Object$create, kLastResolve, {
        value: null,
        writable: true
      }), _defineProperty(_Object$create, kLastReject, {
        value: null,
        writable: true
      }), _defineProperty(_Object$create, kError, {
        value: null,
        writable: true
      }), _defineProperty(_Object$create, kEnded, {
        value: stream._readableState.endEmitted,
        writable: true
      }), _defineProperty(_Object$create, kHandlePromise, {
        value: function value(resolve, reject) {
          var data = iterator[kStream].read();
          if (data) {
            iterator[kLastPromise] = null;
            iterator[kLastResolve] = null;
            iterator[kLastReject] = null;
            resolve(createIterResult(data, false));
          } else {
            iterator[kLastResolve] = resolve;
            iterator[kLastReject] = reject;
          }
        },
        writable: true
      }), _Object$create));
      iterator[kLastPromise] = null;
      finished(stream, function(err) {
        if (err && err.code !== "ERR_STREAM_PREMATURE_CLOSE") {
          var reject = iterator[kLastReject];
          if (reject !== null) {
            iterator[kLastPromise] = null;
            iterator[kLastResolve] = null;
            iterator[kLastReject] = null;
            reject(err);
          }
          iterator[kError] = err;
          return;
        }
        var resolve = iterator[kLastResolve];
        if (resolve !== null) {
          iterator[kLastPromise] = null;
          iterator[kLastResolve] = null;
          iterator[kLastReject] = null;
          resolve(createIterResult(void 0, true));
        }
        iterator[kEnded] = true;
      });
      stream.on("readable", onReadable.bind(null, iterator));
      return iterator;
    };
    module2.exports = createReadableStreamAsyncIterator;
  }
});

// ../../../node_modules/bl/node_modules/readable-stream/lib/internal/streams/from.js
var require_from6 = __commonJS({
  "../../../node_modules/bl/node_modules/readable-stream/lib/internal/streams/from.js"(exports2, module2) {
    "use strict";
    function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {
      try {
        var info = gen[key](arg);
        var value = info.value;
      } catch (error) {
        reject(error);
        return;
      }
      if (info.done) {
        resolve(value);
      } else {
        Promise.resolve(value).then(_next, _throw);
      }
    }
    function _asyncToGenerator(fn) {
      return function() {
        var self2 = this, args = arguments;
        return new Promise(function(resolve, reject) {
          var gen = fn.apply(self2, args);
          function _next(value) {
            asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value);
          }
          function _throw(err) {
            asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err);
          }
          _next(void 0);
        });
      };
    }
    function ownKeys(object, enumerableOnly) {
      var keys = Object.keys(object);
      if (Object.getOwnPropertySymbols) {
        var symbols = Object.getOwnPropertySymbols(object);
        enumerableOnly && (symbols = symbols.filter(function(sym) {
          return Object.getOwnPropertyDescriptor(object, sym).enumerable;
        })), keys.push.apply(keys, symbols);
      }
      return keys;
    }
    function _objectSpread(target) {
      for (var i = 1; i < arguments.length; i++) {
        var source = null != arguments[i] ? arguments[i] : {};
        i % 2 ? ownKeys(Object(source), true).forEach(function(key) {
          _defineProperty(target, key, source[key]);
        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function(key) {
          Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
        });
      }
      return target;
    }
    function _defineProperty(obj2, key, value) {
      key = _toPropertyKey(key);
      if (key in obj2) {
        Object.defineProperty(obj2, key, { value, enumerable: true, configurable: true, writable: true });
      } else {
        obj2[key] = value;
      }
      return obj2;
    }
    function _toPropertyKey(arg) {
      var key = _toPrimitive(arg, "string");
      return typeof key === "symbol" ? key : String(key);
    }
    function _toPrimitive(input, hint) {
      if (typeof input !== "object" || input === null)
        return input;
      var prim = input[Symbol.toPrimitive];
      if (prim !== void 0) {
        var res = prim.call(input, hint || "default");
        if (typeof res !== "object")
          return res;
        throw new TypeError("@@toPrimitive must return a primitive value.");
      }
      return (hint === "string" ? String : Number)(input);
    }
    var ERR_INVALID_ARG_TYPE = require_errors6().codes.ERR_INVALID_ARG_TYPE;
    function from(Readable, iterable, opts) {
      var iterator;
      if (iterable && typeof iterable.next === "function") {
        iterator = iterable;
      } else if (iterable && iterable[Symbol.asyncIterator])
        iterator = iterable[Symbol.asyncIterator]();
      else if (iterable && iterable[Symbol.iterator])
        iterator = iterable[Symbol.iterator]();
      else
        throw new ERR_INVALID_ARG_TYPE("iterable", ["Iterable"], iterable);
      var readable = new Readable(_objectSpread({
        objectMode: true
      }, opts));
      var reading = false;
      readable._read = function() {
        if (!reading) {
          reading = true;
          next();
        }
      };
      function next() {
        return _next2.apply(this, arguments);
      }
      function _next2() {
        _next2 = _asyncToGenerator(function* () {
          try {
            var _yield$iterator$next = yield iterator.next(), value = _yield$iterator$next.value, done = _yield$iterator$next.done;
            if (done) {
              readable.push(null);
            } else if (readable.push(yield value)) {
              next();
            } else {
              reading = false;
            }
          } catch (err) {
            readable.destroy(err);
          }
        });
        return _next2.apply(this, arguments);
      }
      return readable;
    }
    module2.exports = from;
  }
});

// ../../../node_modules/bl/node_modules/readable-stream/lib/_stream_readable.js
var require_stream_readable9 = __commonJS({
  "../../../node_modules/bl/node_modules/readable-stream/lib/_stream_readable.js"(exports2, module2) {
    "use strict";
    module2.exports = Readable;
    var Duplex;
    Readable.ReadableState = ReadableState;
    var EE = require("events").EventEmitter;
    var EElistenerCount = function EElistenerCount2(emitter, type) {
      return emitter.listeners(type).length;
    };
    var Stream = require_stream9();
    var Buffer2 = require("buffer").Buffer;
    var OurUint8Array = (typeof global !== "undefined" ? global : typeof window !== "undefined" ? window : typeof self !== "undefined" ? self : {}).Uint8Array || function() {
    };
    function _uint8ArrayToBuffer(chunk) {
      return Buffer2.from(chunk);
    }
    function _isUint8Array(obj2) {
      return Buffer2.isBuffer(obj2) || obj2 instanceof OurUint8Array;
    }
    var debugUtil = require("util");
    var debug;
    if (debugUtil && debugUtil.debuglog) {
      debug = debugUtil.debuglog("stream");
    } else {
      debug = function debug2() {
      };
    }
    var BufferList = require_buffer_list6();
    var destroyImpl = require_destroy9();
    var _require = require_state6();
    var getHighWaterMark = _require.getHighWaterMark;
    var _require$codes = require_errors6().codes;
    var ERR_INVALID_ARG_TYPE = _require$codes.ERR_INVALID_ARG_TYPE;
    var ERR_STREAM_PUSH_AFTER_EOF = _require$codes.ERR_STREAM_PUSH_AFTER_EOF;
    var ERR_METHOD_NOT_IMPLEMENTED = _require$codes.ERR_METHOD_NOT_IMPLEMENTED;
    var ERR_STREAM_UNSHIFT_AFTER_END_EVENT = _require$codes.ERR_STREAM_UNSHIFT_AFTER_END_EVENT;
    var StringDecoder;
    var createReadableStreamAsyncIterator;
    var from;
    require_inherits()(Readable, Stream);
    var errorOrDestroy = destroyImpl.errorOrDestroy;
    var kProxyEvents = ["error", "close", "destroy", "pause", "resume"];
    function prependListener(emitter, event, fn) {
      if (typeof emitter.prependListener === "function")
        return emitter.prependListener(event, fn);
      if (!emitter._events || !emitter._events[event])
        emitter.on(event, fn);
      else if (Array.isArray(emitter._events[event]))
        emitter._events[event].unshift(fn);
      else
        emitter._events[event] = [fn, emitter._events[event]];
    }
    function ReadableState(options, stream, isDuplex) {
      Duplex = Duplex || require_stream_duplex9();
      options = options || {};
      if (typeof isDuplex !== "boolean")
        isDuplex = stream instanceof Duplex;
      this.objectMode = !!options.objectMode;
      if (isDuplex)
        this.objectMode = this.objectMode || !!options.readableObjectMode;
      this.highWaterMark = getHighWaterMark(this, options, "readableHighWaterMark", isDuplex);
      this.buffer = new BufferList();
      this.length = 0;
      this.pipes = null;
      this.pipesCount = 0;
      this.flowing = null;
      this.ended = false;
      this.endEmitted = false;
      this.reading = false;
      this.sync = true;
      this.needReadable = false;
      this.emittedReadable = false;
      this.readableListening = false;
      this.resumeScheduled = false;
      this.paused = true;
      this.emitClose = options.emitClose !== false;
      this.autoDestroy = !!options.autoDestroy;
      this.destroyed = false;
      this.defaultEncoding = options.defaultEncoding || "utf8";
      this.awaitDrain = 0;
      this.readingMore = false;
      this.decoder = null;
      this.encoding = null;
      if (options.encoding) {
        if (!StringDecoder)
          StringDecoder = require_string_decoder9().StringDecoder;
        this.decoder = new StringDecoder(options.encoding);
        this.encoding = options.encoding;
      }
    }
    function Readable(options) {
      Duplex = Duplex || require_stream_duplex9();
      if (!(this instanceof Readable))
        return new Readable(options);
      var isDuplex = this instanceof Duplex;
      this._readableState = new ReadableState(options, this, isDuplex);
      this.readable = true;
      if (options) {
        if (typeof options.read === "function")
          this._read = options.read;
        if (typeof options.destroy === "function")
          this._destroy = options.destroy;
      }
      Stream.call(this);
    }
    Object.defineProperty(Readable.prototype, "destroyed", {
      // making it explicit this property is not enumerable
      // because otherwise some prototype manipulation in
      // userland will fail
      enumerable: false,
      get: function get() {
        if (this._readableState === void 0) {
          return false;
        }
        return this._readableState.destroyed;
      },
      set: function set(value) {
        if (!this._readableState) {
          return;
        }
        this._readableState.destroyed = value;
      }
    });
    Readable.prototype.destroy = destroyImpl.destroy;
    Readable.prototype._undestroy = destroyImpl.undestroy;
    Readable.prototype._destroy = function(err, cb) {
      cb(err);
    };
    Readable.prototype.push = function(chunk, encoding) {
      var state = this._readableState;
      var skipChunkCheck;
      if (!state.objectMode) {
        if (typeof chunk === "string") {
          encoding = encoding || state.defaultEncoding;
          if (encoding !== state.encoding) {
            chunk = Buffer2.from(chunk, encoding);
            encoding = "";
          }
          skipChunkCheck = true;
        }
      } else {
        skipChunkCheck = true;
      }
      return readableAddChunk(this, chunk, encoding, false, skipChunkCheck);
    };
    Readable.prototype.unshift = function(chunk) {
      return readableAddChunk(this, chunk, null, true, false);
    };
    function readableAddChunk(stream, chunk, encoding, addToFront, skipChunkCheck) {
      debug("readableAddChunk", chunk);
      var state = stream._readableState;
      if (chunk === null) {
        state.reading = false;
        onEofChunk(stream, state);
      } else {
        var er;
        if (!skipChunkCheck)
          er = chunkInvalid(state, chunk);
        if (er) {
          errorOrDestroy(stream, er);
        } else if (state.objectMode || chunk && chunk.length > 0) {
          if (typeof chunk !== "string" && !state.objectMode && Object.getPrototypeOf(chunk) !== Buffer2.prototype) {
            chunk = _uint8ArrayToBuffer(chunk);
          }
          if (addToFront) {
            if (state.endEmitted)
              errorOrDestroy(stream, new ERR_STREAM_UNSHIFT_AFTER_END_EVENT());
            else
              addChunk(stream, state, chunk, true);
          } else if (state.ended) {
            errorOrDestroy(stream, new ERR_STREAM_PUSH_AFTER_EOF());
          } else if (state.destroyed) {
            return false;
          } else {
            state.reading = false;
            if (state.decoder && !encoding) {
              chunk = state.decoder.write(chunk);
              if (state.objectMode || chunk.length !== 0)
                addChunk(stream, state, chunk, false);
              else
                maybeReadMore(stream, state);
            } else {
              addChunk(stream, state, chunk, false);
            }
          }
        } else if (!addToFront) {
          state.reading = false;
          maybeReadMore(stream, state);
        }
      }
      return !state.ended && (state.length < state.highWaterMark || state.length === 0);
    }
    function addChunk(stream, state, chunk, addToFront) {
      if (state.flowing && state.length === 0 && !state.sync) {
        state.awaitDrain = 0;
        stream.emit("data", chunk);
      } else {
        state.length += state.objectMode ? 1 : chunk.length;
        if (addToFront)
          state.buffer.unshift(chunk);
        else
          state.buffer.push(chunk);
        if (state.needReadable)
          emitReadable(stream);
      }
      maybeReadMore(stream, state);
    }
    function chunkInvalid(state, chunk) {
      var er;
      if (!_isUint8Array(chunk) && typeof chunk !== "string" && chunk !== void 0 && !state.objectMode) {
        er = new ERR_INVALID_ARG_TYPE("chunk", ["string", "Buffer", "Uint8Array"], chunk);
      }
      return er;
    }
    Readable.prototype.isPaused = function() {
      return this._readableState.flowing === false;
    };
    Readable.prototype.setEncoding = function(enc) {
      if (!StringDecoder)
        StringDecoder = require_string_decoder9().StringDecoder;
      var decoder = new StringDecoder(enc);
      this._readableState.decoder = decoder;
      this._readableState.encoding = this._readableState.decoder.encoding;
      var p = this._readableState.buffer.head;
      var content = "";
      while (p !== null) {
        content += decoder.write(p.data);
        p = p.next;
      }
      this._readableState.buffer.clear();
      if (content !== "")
        this._readableState.buffer.push(content);
      this._readableState.length = content.length;
      return this;
    };
    var MAX_HWM = 1073741824;
    function computeNewHighWaterMark(n) {
      if (n >= MAX_HWM) {
        n = MAX_HWM;
      } else {
        n--;
        n |= n >>> 1;
        n |= n >>> 2;
        n |= n >>> 4;
        n |= n >>> 8;
        n |= n >>> 16;
        n++;
      }
      return n;
    }
    function howMuchToRead(n, state) {
      if (n <= 0 || state.length === 0 && state.ended)
        return 0;
      if (state.objectMode)
        return 1;
      if (n !== n) {
        if (state.flowing && state.length)
          return state.buffer.head.data.length;
        else
          return state.length;
      }
      if (n > state.highWaterMark)
        state.highWaterMark = computeNewHighWaterMark(n);
      if (n <= state.length)
        return n;
      if (!state.ended) {
        state.needReadable = true;
        return 0;
      }
      return state.length;
    }
    Readable.prototype.read = function(n) {
      debug("read", n);
      n = parseInt(n, 10);
      var state = this._readableState;
      var nOrig = n;
      if (n !== 0)
        state.emittedReadable = false;
      if (n === 0 && state.needReadable && ((state.highWaterMark !== 0 ? state.length >= state.highWaterMark : state.length > 0) || state.ended)) {
        debug("read: emitReadable", state.length, state.ended);
        if (state.length === 0 && state.ended)
          endReadable(this);
        else
          emitReadable(this);
        return null;
      }
      n = howMuchToRead(n, state);
      if (n === 0 && state.ended) {
        if (state.length === 0)
          endReadable(this);
        return null;
      }
      var doRead = state.needReadable;
      debug("need readable", doRead);
      if (state.length === 0 || state.length - n < state.highWaterMark) {
        doRead = true;
        debug("length less than watermark", doRead);
      }
      if (state.ended || state.reading) {
        doRead = false;
        debug("reading or ended", doRead);
      } else if (doRead) {
        debug("do read");
        state.reading = true;
        state.sync = true;
        if (state.length === 0)
          state.needReadable = true;
        this._read(state.highWaterMark);
        state.sync = false;
        if (!state.reading)
          n = howMuchToRead(nOrig, state);
      }
      var ret2;
      if (n > 0)
        ret2 = fromList(n, state);
      else
        ret2 = null;
      if (ret2 === null) {
        state.needReadable = state.length <= state.highWaterMark;
        n = 0;
      } else {
        state.length -= n;
        state.awaitDrain = 0;
      }
      if (state.length === 0) {
        if (!state.ended)
          state.needReadable = true;
        if (nOrig !== n && state.ended)
          endReadable(this);
      }
      if (ret2 !== null)
        this.emit("data", ret2);
      return ret2;
    };
    function onEofChunk(stream, state) {
      debug("onEofChunk");
      if (state.ended)
        return;
      if (state.decoder) {
        var chunk = state.decoder.end();
        if (chunk && chunk.length) {
          state.buffer.push(chunk);
          state.length += state.objectMode ? 1 : chunk.length;
        }
      }
      state.ended = true;
      if (state.sync) {
        emitReadable(stream);
      } else {
        state.needReadable = false;
        if (!state.emittedReadable) {
          state.emittedReadable = true;
          emitReadable_(stream);
        }
      }
    }
    function emitReadable(stream) {
      var state = stream._readableState;
      debug("emitReadable", state.needReadable, state.emittedReadable);
      state.needReadable = false;
      if (!state.emittedReadable) {
        debug("emitReadable", state.flowing);
        state.emittedReadable = true;
        process.nextTick(emitReadable_, stream);
      }
    }
    function emitReadable_(stream) {
      var state = stream._readableState;
      debug("emitReadable_", state.destroyed, state.length, state.ended);
      if (!state.destroyed && (state.length || state.ended)) {
        stream.emit("readable");
        state.emittedReadable = false;
      }
      state.needReadable = !state.flowing && !state.ended && state.length <= state.highWaterMark;
      flow(stream);
    }
    function maybeReadMore(stream, state) {
      if (!state.readingMore) {
        state.readingMore = true;
        process.nextTick(maybeReadMore_, stream, state);
      }
    }
    function maybeReadMore_(stream, state) {
      while (!state.reading && !state.ended && (state.length < state.highWaterMark || state.flowing && state.length === 0)) {
        var len = state.length;
        debug("maybeReadMore read 0");
        stream.read(0);
        if (len === state.length)
          break;
      }
      state.readingMore = false;
    }
    Readable.prototype._read = function(n) {
      errorOrDestroy(this, new ERR_METHOD_NOT_IMPLEMENTED("_read()"));
    };
    Readable.prototype.pipe = function(dest, pipeOpts) {
      var src = this;
      var state = this._readableState;
      switch (state.pipesCount) {
        case 0:
          state.pipes = dest;
          break;
        case 1:
          state.pipes = [state.pipes, dest];
          break;
        default:
          state.pipes.push(dest);
          break;
      }
      state.pipesCount += 1;
      debug("pipe count=%d opts=%j", state.pipesCount, pipeOpts);
      var doEnd = (!pipeOpts || pipeOpts.end !== false) && dest !== process.stdout && dest !== process.stderr;
      var endFn = doEnd ? onend : unpipe;
      if (state.endEmitted)
        process.nextTick(endFn);
      else
        src.once("end", endFn);
      dest.on("unpipe", onunpipe);
      function onunpipe(readable, unpipeInfo) {
        debug("onunpipe");
        if (readable === src) {
          if (unpipeInfo && unpipeInfo.hasUnpiped === false) {
            unpipeInfo.hasUnpiped = true;
            cleanup();
          }
        }
      }
      function onend() {
        debug("onend");
        dest.end();
      }
      var ondrain = pipeOnDrain(src);
      dest.on("drain", ondrain);
      var cleanedUp = false;
      function cleanup() {
        debug("cleanup");
        dest.removeListener("close", onclose);
        dest.removeListener("finish", onfinish);
        dest.removeListener("drain", ondrain);
        dest.removeListener("error", onerror);
        dest.removeListener("unpipe", onunpipe);
        src.removeListener("end", onend);
        src.removeListener("end", unpipe);
        src.removeListener("data", ondata);
        cleanedUp = true;
        if (state.awaitDrain && (!dest._writableState || dest._writableState.needDrain))
          ondrain();
      }
      src.on("data", ondata);
      function ondata(chunk) {
        debug("ondata");
        var ret2 = dest.write(chunk);
        debug("dest.write", ret2);
        if (ret2 === false) {
          if ((state.pipesCount === 1 && state.pipes === dest || state.pipesCount > 1 && indexOf(state.pipes, dest) !== -1) && !cleanedUp) {
            debug("false write response, pause", state.awaitDrain);
            state.awaitDrain++;
          }
          src.pause();
        }
      }
      function onerror(er) {
        debug("onerror", er);
        unpipe();
        dest.removeListener("error", onerror);
        if (EElistenerCount(dest, "error") === 0)
          errorOrDestroy(dest, er);
      }
      prependListener(dest, "error", onerror);
      function onclose() {
        dest.removeListener("finish", onfinish);
        unpipe();
      }
      dest.once("close", onclose);
      function onfinish() {
        debug("onfinish");
        dest.removeListener("close", onclose);
        unpipe();
      }
      dest.once("finish", onfinish);
      function unpipe() {
        debug("unpipe");
        src.unpipe(dest);
      }
      dest.emit("pipe", src);
      if (!state.flowing) {
        debug("pipe resume");
        src.resume();
      }
      return dest;
    };
    function pipeOnDrain(src) {
      return function pipeOnDrainFunctionResult() {
        var state = src._readableState;
        debug("pipeOnDrain", state.awaitDrain);
        if (state.awaitDrain)
          state.awaitDrain--;
        if (state.awaitDrain === 0 && EElistenerCount(src, "data")) {
          state.flowing = true;
          flow(src);
        }
      };
    }
    Readable.prototype.unpipe = function(dest) {
      var state = this._readableState;
      var unpipeInfo = {
        hasUnpiped: false
      };
      if (state.pipesCount === 0)
        return this;
      if (state.pipesCount === 1) {
        if (dest && dest !== state.pipes)
          return this;
        if (!dest)
          dest = state.pipes;
        state.pipes = null;
        state.pipesCount = 0;
        state.flowing = false;
        if (dest)
          dest.emit("unpipe", this, unpipeInfo);
        return this;
      }
      if (!dest) {
        var dests = state.pipes;
        var len = state.pipesCount;
        state.pipes = null;
        state.pipesCount = 0;
        state.flowing = false;
        for (var i = 0; i < len; i++)
          dests[i].emit("unpipe", this, {
            hasUnpiped: false
          });
        return this;
      }
      var index = indexOf(state.pipes, dest);
      if (index === -1)
        return this;
      state.pipes.splice(index, 1);
      state.pipesCount -= 1;
      if (state.pipesCount === 1)
        state.pipes = state.pipes[0];
      dest.emit("unpipe", this, unpipeInfo);
      return this;
    };
    Readable.prototype.on = function(ev, fn) {
      var res = Stream.prototype.on.call(this, ev, fn);
      var state = this._readableState;
      if (ev === "data") {
        state.readableListening = this.listenerCount("readable") > 0;
        if (state.flowing !== false)
          this.resume();
      } else if (ev === "readable") {
        if (!state.endEmitted && !state.readableListening) {
          state.readableListening = state.needReadable = true;
          state.flowing = false;
          state.emittedReadable = false;
          debug("on readable", state.length, state.reading);
          if (state.length) {
            emitReadable(this);
          } else if (!state.reading) {
            process.nextTick(nReadingNextTick, this);
          }
        }
      }
      return res;
    };
    Readable.prototype.addListener = Readable.prototype.on;
    Readable.prototype.removeListener = function(ev, fn) {
      var res = Stream.prototype.removeListener.call(this, ev, fn);
      if (ev === "readable") {
        process.nextTick(updateReadableListening, this);
      }
      return res;
    };
    Readable.prototype.removeAllListeners = function(ev) {
      var res = Stream.prototype.removeAllListeners.apply(this, arguments);
      if (ev === "readable" || ev === void 0) {
        process.nextTick(updateReadableListening, this);
      }
      return res;
    };
    function updateReadableListening(self2) {
      var state = self2._readableState;
      state.readableListening = self2.listenerCount("readable") > 0;
      if (state.resumeScheduled && !state.paused) {
        state.flowing = true;
      } else if (self2.listenerCount("data") > 0) {
        self2.resume();
      }
    }
    function nReadingNextTick(self2) {
      debug("readable nexttick read 0");
      self2.read(0);
    }
    Readable.prototype.resume = function() {
      var state = this._readableState;
      if (!state.flowing) {
        debug("resume");
        state.flowing = !state.readableListening;
        resume(this, state);
      }
      state.paused = false;
      return this;
    };
    function resume(stream, state) {
      if (!state.resumeScheduled) {
        state.resumeScheduled = true;
        process.nextTick(resume_, stream, state);
      }
    }
    function resume_(stream, state) {
      debug("resume", state.reading);
      if (!state.reading) {
        stream.read(0);
      }
      state.resumeScheduled = false;
      stream.emit("resume");
      flow(stream);
      if (state.flowing && !state.reading)
        stream.read(0);
    }
    Readable.prototype.pause = function() {
      debug("call pause flowing=%j", this._readableState.flowing);
      if (this._readableState.flowing !== false) {
        debug("pause");
        this._readableState.flowing = false;
        this.emit("pause");
      }
      this._readableState.paused = true;
      return this;
    };
    function flow(stream) {
      var state = stream._readableState;
      debug("flow", state.flowing);
      while (state.flowing && stream.read() !== null)
        ;
    }
    Readable.prototype.wrap = function(stream) {
      var _this = this;
      var state = this._readableState;
      var paused = false;
      stream.on("end", function() {
        debug("wrapped end");
        if (state.decoder && !state.ended) {
          var chunk = state.decoder.end();
          if (chunk && chunk.length)
            _this.push(chunk);
        }
        _this.push(null);
      });
      stream.on("data", function(chunk) {
        debug("wrapped data");
        if (state.decoder)
          chunk = state.decoder.write(chunk);
        if (state.objectMode && (chunk === null || chunk === void 0))
          return;
        else if (!state.objectMode && (!chunk || !chunk.length))
          return;
        var ret2 = _this.push(chunk);
        if (!ret2) {
          paused = true;
          stream.pause();
        }
      });
      for (var i in stream) {
        if (this[i] === void 0 && typeof stream[i] === "function") {
          this[i] = /* @__PURE__ */ function methodWrap(method) {
            return function methodWrapReturnFunction() {
              return stream[method].apply(stream, arguments);
            };
          }(i);
        }
      }
      for (var n = 0; n < kProxyEvents.length; n++) {
        stream.on(kProxyEvents[n], this.emit.bind(this, kProxyEvents[n]));
      }
      this._read = function(n2) {
        debug("wrapped _read", n2);
        if (paused) {
          paused = false;
          stream.resume();
        }
      };
      return this;
    };
    if (typeof Symbol === "function") {
      Readable.prototype[Symbol.asyncIterator] = function() {
        if (createReadableStreamAsyncIterator === void 0) {
          createReadableStreamAsyncIterator = require_async_iterator6();
        }
        return createReadableStreamAsyncIterator(this);
      };
    }
    Object.defineProperty(Readable.prototype, "readableHighWaterMark", {
      // making it explicit this property is not enumerable
      // because otherwise some prototype manipulation in
      // userland will fail
      enumerable: false,
      get: function get() {
        return this._readableState.highWaterMark;
      }
    });
    Object.defineProperty(Readable.prototype, "readableBuffer", {
      // making it explicit this property is not enumerable
      // because otherwise some prototype manipulation in
      // userland will fail
      enumerable: false,
      get: function get() {
        return this._readableState && this._readableState.buffer;
      }
    });
    Object.defineProperty(Readable.prototype, "readableFlowing", {
      // making it explicit this property is not enumerable
      // because otherwise some prototype manipulation in
      // userland will fail
      enumerable: false,
      get: function get() {
        return this._readableState.flowing;
      },
      set: function set(state) {
        if (this._readableState) {
          this._readableState.flowing = state;
        }
      }
    });
    Readable._fromList = fromList;
    Object.defineProperty(Readable.prototype, "readableLength", {
      // making it explicit this property is not enumerable
      // because otherwise some prototype manipulation in
      // userland will fail
      enumerable: false,
      get: function get() {
        return this._readableState.length;
      }
    });
    function fromList(n, state) {
      if (state.length === 0)
        return null;
      var ret2;
      if (state.objectMode)
        ret2 = state.buffer.shift();
      else if (!n || n >= state.length) {
        if (state.decoder)
          ret2 = state.buffer.join("");
        else if (state.buffer.length === 1)
          ret2 = state.buffer.first();
        else
          ret2 = state.buffer.concat(state.length);
        state.buffer.clear();
      } else {
        ret2 = state.buffer.consume(n, state.decoder);
      }
      return ret2;
    }
    function endReadable(stream) {
      var state = stream._readableState;
      debug("endReadable", state.endEmitted);
      if (!state.endEmitted) {
        state.ended = true;
        process.nextTick(endReadableNT, state, stream);
      }
    }
    function endReadableNT(state, stream) {
      debug("endReadableNT", state.endEmitted, state.length);
      if (!state.endEmitted && state.length === 0) {
        state.endEmitted = true;
        stream.readable = false;
        stream.emit("end");
        if (state.autoDestroy) {
          var wState = stream._writableState;
          if (!wState || wState.autoDestroy && wState.finished) {
            stream.destroy();
          }
        }
      }
    }
    if (typeof Symbol === "function") {
      Readable.from = function(iterable, opts) {
        if (from === void 0) {
          from = require_from6();
        }
        return from(Readable, iterable, opts);
      };
    }
    function indexOf(xs, x) {
      for (var i = 0, l2 = xs.length; i < l2; i++) {
        if (xs[i] === x)
          return i;
      }
      return -1;
    }
  }
});

// ../../../node_modules/bl/node_modules/readable-stream/lib/_stream_transform.js
var require_stream_transform9 = __commonJS({
  "../../../node_modules/bl/node_modules/readable-stream/lib/_stream_transform.js"(exports2, module2) {
    "use strict";
    module2.exports = Transform;
    var _require$codes = require_errors6().codes;
    var ERR_METHOD_NOT_IMPLEMENTED = _require$codes.ERR_METHOD_NOT_IMPLEMENTED;
    var ERR_MULTIPLE_CALLBACK = _require$codes.ERR_MULTIPLE_CALLBACK;
    var ERR_TRANSFORM_ALREADY_TRANSFORMING = _require$codes.ERR_TRANSFORM_ALREADY_TRANSFORMING;
    var ERR_TRANSFORM_WITH_LENGTH_0 = _require$codes.ERR_TRANSFORM_WITH_LENGTH_0;
    var Duplex = require_stream_duplex9();
    require_inherits()(Transform, Duplex);
    function afterTransform(er, data) {
      var ts = this._transformState;
      ts.transforming = false;
      var cb = ts.writecb;
      if (cb === null) {
        return this.emit("error", new ERR_MULTIPLE_CALLBACK());
      }
      ts.writechunk = null;
      ts.writecb = null;
      if (data != null)
        this.push(data);
      cb(er);
      var rs = this._readableState;
      rs.reading = false;
      if (rs.needReadable || rs.length < rs.highWaterMark) {
        this._read(rs.highWaterMark);
      }
    }
    function Transform(options) {
      if (!(this instanceof Transform))
        return new Transform(options);
      Duplex.call(this, options);
      this._transformState = {
        afterTransform: afterTransform.bind(this),
        needTransform: false,
        transforming: false,
        writecb: null,
        writechunk: null,
        writeencoding: null
      };
      this._readableState.needReadable = true;
      this._readableState.sync = false;
      if (options) {
        if (typeof options.transform === "function")
          this._transform = options.transform;
        if (typeof options.flush === "function")
          this._flush = options.flush;
      }
      this.on("prefinish", prefinish);
    }
    function prefinish() {
      var _this = this;
      if (typeof this._flush === "function" && !this._readableState.destroyed) {
        this._flush(function(er, data) {
          done(_this, er, data);
        });
      } else {
        done(this, null, null);
      }
    }
    Transform.prototype.push = function(chunk, encoding) {
      this._transformState.needTransform = false;
      return Duplex.prototype.push.call(this, chunk, encoding);
    };
    Transform.prototype._transform = function(chunk, encoding, cb) {
      cb(new ERR_METHOD_NOT_IMPLEMENTED("_transform()"));
    };
    Transform.prototype._write = function(chunk, encoding, cb) {
      var ts = this._transformState;
      ts.writecb = cb;
      ts.writechunk = chunk;
      ts.writeencoding = encoding;
      if (!ts.transforming) {
        var rs = this._readableState;
        if (ts.needTransform || rs.needReadable || rs.length < rs.highWaterMark)
          this._read(rs.highWaterMark);
      }
    };
    Transform.prototype._read = function(n) {
      var ts = this._transformState;
      if (ts.writechunk !== null && !ts.transforming) {
        ts.transforming = true;
        this._transform(ts.writechunk, ts.writeencoding, ts.afterTransform);
      } else {
        ts.needTransform = true;
      }
    };
    Transform.prototype._destroy = function(err, cb) {
      Duplex.prototype._destroy.call(this, err, function(err2) {
        cb(err2);
      });
    };
    function done(stream, er, data) {
      if (er)
        return stream.emit("error", er);
      if (data != null)
        stream.push(data);
      if (stream._writableState.length)
        throw new ERR_TRANSFORM_WITH_LENGTH_0();
      if (stream._transformState.transforming)
        throw new ERR_TRANSFORM_ALREADY_TRANSFORMING();
      return stream.push(null);
    }
  }
});

// ../../../node_modules/bl/node_modules/readable-stream/lib/_stream_passthrough.js
var require_stream_passthrough9 = __commonJS({
  "../../../node_modules/bl/node_modules/readable-stream/lib/_stream_passthrough.js"(exports2, module2) {
    "use strict";
    module2.exports = PassThrough;
    var Transform = require_stream_transform9();
    require_inherits()(PassThrough, Transform);
    function PassThrough(options) {
      if (!(this instanceof PassThrough))
        return new PassThrough(options);
      Transform.call(this, options);
    }
    PassThrough.prototype._transform = function(chunk, encoding, cb) {
      cb(null, chunk);
    };
  }
});

// ../../../node_modules/bl/node_modules/readable-stream/lib/internal/streams/pipeline.js
var require_pipeline6 = __commonJS({
  "../../../node_modules/bl/node_modules/readable-stream/lib/internal/streams/pipeline.js"(exports2, module2) {
    "use strict";
    var eos;
    function once(callback) {
      var called = false;
      return function() {
        if (called)
          return;
        called = true;
        callback.apply(void 0, arguments);
      };
    }
    var _require$codes = require_errors6().codes;
    var ERR_MISSING_ARGS = _require$codes.ERR_MISSING_ARGS;
    var ERR_STREAM_DESTROYED = _require$codes.ERR_STREAM_DESTROYED;
    function noop(err) {
      if (err)
        throw err;
    }
    function isRequest(stream) {
      return stream.setHeader && typeof stream.abort === "function";
    }
    function destroyer(stream, reading, writing, callback) {
      callback = once(callback);
      var closed = false;
      stream.on("close", function() {
        closed = true;
      });
      if (eos === void 0)
        eos = require_end_of_stream6();
      eos(stream, {
        readable: reading,
        writable: writing
      }, function(err) {
        if (err)
          return callback(err);
        closed = true;
        callback();
      });
      var destroyed = false;
      return function(err) {
        if (closed)
          return;
        if (destroyed)
          return;
        destroyed = true;
        if (isRequest(stream))
          return stream.abort();
        if (typeof stream.destroy === "function")
          return stream.destroy();
        callback(err || new ERR_STREAM_DESTROYED("pipe"));
      };
    }
    function call(fn) {
      fn();
    }
    function pipe(from, to) {
      return from.pipe(to);
    }
    function popCallback(streams) {
      if (!streams.length)
        return noop;
      if (typeof streams[streams.length - 1] !== "function")
        return noop;
      return streams.pop();
    }
    function pipeline() {
      for (var _len = arguments.length, streams = new Array(_len), _key = 0; _key < _len; _key++) {
        streams[_key] = arguments[_key];
      }
      var callback = popCallback(streams);
      if (Array.isArray(streams[0]))
        streams = streams[0];
      if (streams.length < 2) {
        throw new ERR_MISSING_ARGS("streams");
      }
      var error;
      var destroys = streams.map(function(stream, i) {
        var reading = i < streams.length - 1;
        var writing = i > 0;
        return destroyer(stream, reading, writing, function(err) {
          if (!error)
            error = err;
          if (err)
            destroys.forEach(call);
          if (reading)
            return;
          destroys.forEach(call);
          callback(error);
        });
      });
      return streams.reduce(pipe);
    }
    module2.exports = pipeline;
  }
});

// ../../../node_modules/bl/node_modules/readable-stream/readable.js
var require_readable9 = __commonJS({
  "../../../node_modules/bl/node_modules/readable-stream/readable.js"(exports2, module2) {
    var Stream = require("stream");
    if (process.env.READABLE_STREAM === "disable" && Stream) {
      module2.exports = Stream.Readable;
      Object.assign(module2.exports, Stream);
      module2.exports.Stream = Stream;
    } else {
      exports2 = module2.exports = require_stream_readable9();
      exports2.Stream = Stream || exports2;
      exports2.Readable = exports2;
      exports2.Writable = require_stream_writable9();
      exports2.Duplex = require_stream_duplex9();
      exports2.Transform = require_stream_transform9();
      exports2.PassThrough = require_stream_passthrough9();
      exports2.finished = require_end_of_stream6();
      exports2.pipeline = require_pipeline6();
    }
  }
});

// ../../../node_modules/bl/BufferList.js
var require_BufferList4 = __commonJS({
  "../../../node_modules/bl/BufferList.js"(exports2, module2) {
    "use strict";
    var { Buffer: Buffer2 } = require("buffer");
    var symbol = Symbol.for("BufferList");
    function BufferList(buf) {
      if (!(this instanceof BufferList)) {
        return new BufferList(buf);
      }
      BufferList._init.call(this, buf);
    }
    BufferList._init = function _init(buf) {
      Object.defineProperty(this, symbol, { value: true });
      this._bufs = [];
      this.length = 0;
      if (buf) {
        this.append(buf);
      }
    };
    BufferList.prototype._new = function _new(buf) {
      return new BufferList(buf);
    };
    BufferList.prototype._offset = function _offset(offset) {
      if (offset === 0) {
        return [0, 0];
      }
      let tot = 0;
      for (let i = 0; i < this._bufs.length; i++) {
        const _t = tot + this._bufs[i].length;
        if (offset < _t || i === this._bufs.length - 1) {
          return [i, offset - tot];
        }
        tot = _t;
      }
    };
    BufferList.prototype._reverseOffset = function(blOffset) {
      const bufferId = blOffset[0];
      let offset = blOffset[1];
      for (let i = 0; i < bufferId; i++) {
        offset += this._bufs[i].length;
      }
      return offset;
    };
    BufferList.prototype.get = function get(index) {
      if (index > this.length || index < 0) {
        return void 0;
      }
      const offset = this._offset(index);
      return this._bufs[offset[0]][offset[1]];
    };
    BufferList.prototype.slice = function slice(start, end) {
      if (typeof start === "number" && start < 0) {
        start += this.length;
      }
      if (typeof end === "number" && end < 0) {
        end += this.length;
      }
      return this.copy(null, 0, start, end);
    };
    BufferList.prototype.copy = function copy(dst, dstStart, srcStart, srcEnd) {
      if (typeof srcStart !== "number" || srcStart < 0) {
        srcStart = 0;
      }
      if (typeof srcEnd !== "number" || srcEnd > this.length) {
        srcEnd = this.length;
      }
      if (srcStart >= this.length) {
        return dst || Buffer2.alloc(0);
      }
      if (srcEnd <= 0) {
        return dst || Buffer2.alloc(0);
      }
      const copy2 = !!dst;
      const off = this._offset(srcStart);
      const len = srcEnd - srcStart;
      let bytes = len;
      let bufoff = copy2 && dstStart || 0;
      let start = off[1];
      if (srcStart === 0 && srcEnd === this.length) {
        if (!copy2) {
          return this._bufs.length === 1 ? this._bufs[0] : Buffer2.concat(this._bufs, this.length);
        }
        for (let i = 0; i < this._bufs.length; i++) {
          this._bufs[i].copy(dst, bufoff);
          bufoff += this._bufs[i].length;
        }
        return dst;
      }
      if (bytes <= this._bufs[off[0]].length - start) {
        return copy2 ? this._bufs[off[0]].copy(dst, dstStart, start, start + bytes) : this._bufs[off[0]].slice(start, start + bytes);
      }
      if (!copy2) {
        dst = Buffer2.allocUnsafe(len);
      }
      for (let i = off[0]; i < this._bufs.length; i++) {
        const l2 = this._bufs[i].length - start;
        if (bytes > l2) {
          this._bufs[i].copy(dst, bufoff, start);
          bufoff += l2;
        } else {
          this._bufs[i].copy(dst, bufoff, start, start + bytes);
          bufoff += l2;
          break;
        }
        bytes -= l2;
        if (start) {
          start = 0;
        }
      }
      if (dst.length > bufoff)
        return dst.slice(0, bufoff);
      return dst;
    };
    BufferList.prototype.shallowSlice = function shallowSlice(start, end) {
      start = start || 0;
      end = typeof end !== "number" ? this.length : end;
      if (start < 0) {
        start += this.length;
      }
      if (end < 0) {
        end += this.length;
      }
      if (start === end) {
        return this._new();
      }
      const startOffset = this._offset(start);
      const endOffset = this._offset(end);
      const buffers = this._bufs.slice(startOffset[0], endOffset[0] + 1);
      if (endOffset[1] === 0) {
        buffers.pop();
      } else {
        buffers[buffers.length - 1] = buffers[buffers.length - 1].slice(0, endOffset[1]);
      }
      if (startOffset[1] !== 0) {
        buffers[0] = buffers[0].slice(startOffset[1]);
      }
      return this._new(buffers);
    };
    BufferList.prototype.toString = function toString(encoding, start, end) {
      return this.slice(start, end).toString(encoding);
    };
    BufferList.prototype.consume = function consume(bytes) {
      bytes = Math.trunc(bytes);
      if (Number.isNaN(bytes) || bytes <= 0)
        return this;
      while (this._bufs.length) {
        if (bytes >= this._bufs[0].length) {
          bytes -= this._bufs[0].length;
          this.length -= this._bufs[0].length;
          this._bufs.shift();
        } else {
          this._bufs[0] = this._bufs[0].slice(bytes);
          this.length -= bytes;
          break;
        }
      }
      return this;
    };
    BufferList.prototype.duplicate = function duplicate() {
      const copy = this._new();
      for (let i = 0; i < this._bufs.length; i++) {
        copy.append(this._bufs[i]);
      }
      return copy;
    };
    BufferList.prototype.append = function append(buf) {
      if (buf == null) {
        return this;
      }
      if (buf.buffer) {
        this._appendBuffer(Buffer2.from(buf.buffer, buf.byteOffset, buf.byteLength));
      } else if (Array.isArray(buf)) {
        for (let i = 0; i < buf.length; i++) {
          this.append(buf[i]);
        }
      } else if (this._isBufferList(buf)) {
        for (let i = 0; i < buf._bufs.length; i++) {
          this.append(buf._bufs[i]);
        }
      } else {
        if (typeof buf === "number") {
          buf = buf.toString();
        }
        this._appendBuffer(Buffer2.from(buf));
      }
      return this;
    };
    BufferList.prototype._appendBuffer = function appendBuffer(buf) {
      this._bufs.push(buf);
      this.length += buf.length;
    };
    BufferList.prototype.indexOf = function(search, offset, encoding) {
      if (encoding === void 0 && typeof offset === "string") {
        encoding = offset;
        offset = void 0;
      }
      if (typeof search === "function" || Array.isArray(search)) {
        throw new TypeError('The "value" argument must be one of type string, Buffer, BufferList, or Uint8Array.');
      } else if (typeof search === "number") {
        search = Buffer2.from([search]);
      } else if (typeof search === "string") {
        search = Buffer2.from(search, encoding);
      } else if (this._isBufferList(search)) {
        search = search.slice();
      } else if (Array.isArray(search.buffer)) {
        search = Buffer2.from(search.buffer, search.byteOffset, search.byteLength);
      } else if (!Buffer2.isBuffer(search)) {
        search = Buffer2.from(search);
      }
      offset = Number(offset || 0);
      if (isNaN(offset)) {
        offset = 0;
      }
      if (offset < 0) {
        offset = this.length + offset;
      }
      if (offset < 0) {
        offset = 0;
      }
      if (search.length === 0) {
        return offset > this.length ? this.length : offset;
      }
      const blOffset = this._offset(offset);
      let blIndex = blOffset[0];
      let buffOffset = blOffset[1];
      for (; blIndex < this._bufs.length; blIndex++) {
        const buff = this._bufs[blIndex];
        while (buffOffset < buff.length) {
          const availableWindow = buff.length - buffOffset;
          if (availableWindow >= search.length) {
            const nativeSearchResult = buff.indexOf(search, buffOffset);
            if (nativeSearchResult !== -1) {
              return this._reverseOffset([blIndex, nativeSearchResult]);
            }
            buffOffset = buff.length - search.length + 1;
          } else {
            const revOffset = this._reverseOffset([blIndex, buffOffset]);
            if (this._match(revOffset, search)) {
              return revOffset;
            }
            buffOffset++;
          }
        }
        buffOffset = 0;
      }
      return -1;
    };
    BufferList.prototype._match = function(offset, search) {
      if (this.length - offset < search.length) {
        return false;
      }
      for (let searchOffset = 0; searchOffset < search.length; searchOffset++) {
        if (this.get(offset + searchOffset) !== search[searchOffset]) {
          return false;
        }
      }
      return true;
    };
    (function() {
      const methods = {
        readDoubleBE: 8,
        readDoubleLE: 8,
        readFloatBE: 4,
        readFloatLE: 4,
        readInt32BE: 4,
        readInt32LE: 4,
        readUInt32BE: 4,
        readUInt32LE: 4,
        readInt16BE: 2,
        readInt16LE: 2,
        readUInt16BE: 2,
        readUInt16LE: 2,
        readInt8: 1,
        readUInt8: 1,
        readIntBE: null,
        readIntLE: null,
        readUIntBE: null,
        readUIntLE: null
      };
      for (const m in methods) {
        (function(m2) {
          if (methods[m2] === null) {
            BufferList.prototype[m2] = function(offset, byteLength) {
              return this.slice(offset, offset + byteLength)[m2](0, byteLength);
            };
          } else {
            BufferList.prototype[m2] = function(offset = 0) {
              return this.slice(offset, offset + methods[m2])[m2](0);
            };
          }
        })(m);
      }
    })();
    BufferList.prototype._isBufferList = function _isBufferList(b) {
      return b instanceof BufferList || BufferList.isBufferList(b);
    };
    BufferList.isBufferList = function isBufferList(b) {
      return b != null && b[symbol];
    };
    module2.exports = BufferList;
  }
});

// ../../../node_modules/bl/bl.js
var require_bl = __commonJS({
  "../../../node_modules/bl/bl.js"(exports2, module2) {
    "use strict";
    var DuplexStream = require_readable9().Duplex;
    var inherits2 = require_inherits();
    var BufferList = require_BufferList4();
    function BufferListStream(callback) {
      if (!(this instanceof BufferListStream)) {
        return new BufferListStream(callback);
      }
      if (typeof callback === "function") {
        this._callback = callback;
        const piper = function piper2(err) {
          if (this._callback) {
            this._callback(err);
            this._callback = null;
          }
        }.bind(this);
        this.on("pipe", function onPipe(src) {
          src.on("error", piper);
        });
        this.on("unpipe", function onUnpipe(src) {
          src.removeListener("error", piper);
        });
        callback = null;
      }
      BufferList._init.call(this, callback);
      DuplexStream.call(this);
    }
    inherits2(BufferListStream, DuplexStream);
    Object.assign(BufferListStream.prototype, BufferList.prototype);
    BufferListStream.prototype._new = function _new(callback) {
      return new BufferListStream(callback);
    };
    BufferListStream.prototype._write = function _write(buf, encoding, callback) {
      this._appendBuffer(buf);
      if (typeof callback === "function") {
        callback();
      }
    };
    BufferListStream.prototype._read = function _read(size) {
      if (!this.length) {
        return this.push(null);
      }
      size = Math.min(size, this.length);
      this.push(this.slice(0, size));
      this.consume(size);
    };
    BufferListStream.prototype.end = function end(chunk) {
      DuplexStream.prototype.end.call(this, chunk);
      if (this._callback) {
        this._callback(null, this.slice());
        this._callback = null;
      }
    };
    BufferListStream.prototype._destroy = function _destroy(err, cb) {
      this._bufs.length = 0;
      this.length = 0;
      cb(err);
    };
    BufferListStream.prototype._isBufferList = function _isBufferList(b) {
      return b instanceof BufferListStream || b instanceof BufferList || BufferListStream.isBufferList(b);
    };
    BufferListStream.isBufferList = BufferList.isBufferList;
    module2.exports = BufferListStream;
    module2.exports.BufferListStream = BufferListStream;
    module2.exports.BufferList = BufferList;
  }
});

// ../../../node_modules/tar-stream/headers.js
var require_headers = __commonJS({
  "../../../node_modules/tar-stream/headers.js"(exports2) {
    var alloc = Buffer.alloc;
    var ZEROS = "0000000000000000000";
    var SEVENS = "7777777777777777777";
    var ZERO_OFFSET = "0".charCodeAt(0);
    var USTAR_MAGIC = Buffer.from("ustar\0", "binary");
    var USTAR_VER = Buffer.from("00", "binary");
    var GNU_MAGIC = Buffer.from("ustar ", "binary");
    var GNU_VER = Buffer.from(" \0", "binary");
    var MASK = parseInt("7777", 8);
    var MAGIC_OFFSET = 257;
    var VERSION_OFFSET = 263;
    var clamp = function(index, len, defaultValue) {
      if (typeof index !== "number")
        return defaultValue;
      index = ~~index;
      if (index >= len)
        return len;
      if (index >= 0)
        return index;
      index += len;
      if (index >= 0)
        return index;
      return 0;
    };
    var toType = function(flag) {
      switch (flag) {
        case 0:
          return "file";
        case 1:
          return "link";
        case 2:
          return "symlink";
        case 3:
          return "character-device";
        case 4:
          return "block-device";
        case 5:
          return "directory";
        case 6:
          return "fifo";
        case 7:
          return "contiguous-file";
        case 72:
          return "pax-header";
        case 55:
          return "pax-global-header";
        case 27:
          return "gnu-long-link-path";
        case 28:
        case 30:
          return "gnu-long-path";
      }
      return null;
    };
    var toTypeflag = function(flag) {
      switch (flag) {
        case "file":
          return 0;
        case "link":
          return 1;
        case "symlink":
          return 2;
        case "character-device":
          return 3;
        case "block-device":
          return 4;
        case "directory":
          return 5;
        case "fifo":
          return 6;
        case "contiguous-file":
          return 7;
        case "pax-header":
          return 72;
      }
      return 0;
    };
    var indexOf = function(block, num, offset, end) {
      for (; offset < end; offset++) {
        if (block[offset] === num)
          return offset;
      }
      return end;
    };
    var cksum = function(block) {
      var sum = 8 * 32;
      for (var i = 0; i < 148; i++)
        sum += block[i];
      for (var j = 156; j < 512; j++)
        sum += block[j];
      return sum;
    };
    var encodeOct = function(val, n) {
      val = val.toString(8);
      if (val.length > n)
        return SEVENS.slice(0, n) + " ";
      else
        return ZEROS.slice(0, n - val.length) + val + " ";
    };
    function parse256(buf) {
      var positive;
      if (buf[0] === 128)
        positive = true;
      else if (buf[0] === 255)
        positive = false;
      else
        return null;
      var tuple = [];
      for (var i = buf.length - 1; i > 0; i--) {
        var byte = buf[i];
        if (positive)
          tuple.push(byte);
        else
          tuple.push(255 - byte);
      }
      var sum = 0;
      var l2 = tuple.length;
      for (i = 0; i < l2; i++) {
        sum += tuple[i] * Math.pow(256, i);
      }
      return positive ? sum : -1 * sum;
    }
    var decodeOct = function(val, offset, length) {
      val = val.slice(offset, offset + length);
      offset = 0;
      if (val[offset] & 128) {
        return parse256(val);
      } else {
        while (offset < val.length && val[offset] === 32)
          offset++;
        var end = clamp(indexOf(val, 32, offset, val.length), val.length, val.length);
        while (offset < end && val[offset] === 0)
          offset++;
        if (end === offset)
          return 0;
        return parseInt(val.slice(offset, end).toString(), 8);
      }
    };
    var decodeStr = function(val, offset, length, encoding) {
      return val.slice(offset, indexOf(val, 0, offset, offset + length)).toString(encoding);
    };
    var addLength = function(str) {
      var len = Buffer.byteLength(str);
      var digits = Math.floor(Math.log(len) / Math.log(10)) + 1;
      if (len + digits >= Math.pow(10, digits))
        digits++;
      return len + digits + str;
    };
    exports2.decodeLongPath = function(buf, encoding) {
      return decodeStr(buf, 0, buf.length, encoding);
    };
    exports2.encodePax = function(opts) {
      var result = "";
      if (opts.name)
        result += addLength(" path=" + opts.name + "\n");
      if (opts.linkname)
        result += addLength(" linkpath=" + opts.linkname + "\n");
      var pax = opts.pax;
      if (pax) {
        for (var key in pax) {
          result += addLength(" " + key + "=" + pax[key] + "\n");
        }
      }
      return Buffer.from(result);
    };
    exports2.decodePax = function(buf) {
      var result = {};
      while (buf.length) {
        var i = 0;
        while (i < buf.length && buf[i] !== 32)
          i++;
        var len = parseInt(buf.slice(0, i).toString(), 10);
        if (!len)
          return result;
        var b = buf.slice(i + 1, len - 1).toString();
        var keyIndex = b.indexOf("=");
        if (keyIndex === -1)
          return result;
        result[b.slice(0, keyIndex)] = b.slice(keyIndex + 1);
        buf = buf.slice(len);
      }
      return result;
    };
    exports2.encode = function(opts) {
      var buf = alloc(512);
      var name = opts.name;
      var prefix = "";
      if (opts.typeflag === 5 && name[name.length - 1] !== "/")
        name += "/";
      if (Buffer.byteLength(name) !== name.length)
        return null;
      while (Buffer.byteLength(name) > 100) {
        var i = name.indexOf("/");
        if (i === -1)
          return null;
        prefix += prefix ? "/" + name.slice(0, i) : name.slice(0, i);
        name = name.slice(i + 1);
      }
      if (Buffer.byteLength(name) > 100 || Buffer.byteLength(prefix) > 155)
        return null;
      if (opts.linkname && Buffer.byteLength(opts.linkname) > 100)
        return null;
      buf.write(name);
      buf.write(encodeOct(opts.mode & MASK, 6), 100);
      buf.write(encodeOct(opts.uid, 6), 108);
      buf.write(encodeOct(opts.gid, 6), 116);
      buf.write(encodeOct(opts.size, 11), 124);
      buf.write(encodeOct(opts.mtime.getTime() / 1e3 | 0, 11), 136);
      buf[156] = ZERO_OFFSET + toTypeflag(opts.type);
      if (opts.linkname)
        buf.write(opts.linkname, 157);
      USTAR_MAGIC.copy(buf, MAGIC_OFFSET);
      USTAR_VER.copy(buf, VERSION_OFFSET);
      if (opts.uname)
        buf.write(opts.uname, 265);
      if (opts.gname)
        buf.write(opts.gname, 297);
      buf.write(encodeOct(opts.devmajor || 0, 6), 329);
      buf.write(encodeOct(opts.devminor || 0, 6), 337);
      if (prefix)
        buf.write(prefix, 345);
      buf.write(encodeOct(cksum(buf), 6), 148);
      return buf;
    };
    exports2.decode = function(buf, filenameEncoding, allowUnknownFormat) {
      var typeflag = buf[156] === 0 ? 0 : buf[156] - ZERO_OFFSET;
      var name = decodeStr(buf, 0, 100, filenameEncoding);
      var mode = decodeOct(buf, 100, 8);
      var uid = decodeOct(buf, 108, 8);
      var gid = decodeOct(buf, 116, 8);
      var size = decodeOct(buf, 124, 12);
      var mtime = decodeOct(buf, 136, 12);
      var type = toType(typeflag);
      var linkname = buf[157] === 0 ? null : decodeStr(buf, 157, 100, filenameEncoding);
      var uname = decodeStr(buf, 265, 32);
      var gname = decodeStr(buf, 297, 32);
      var devmajor = decodeOct(buf, 329, 8);
      var devminor = decodeOct(buf, 337, 8);
      var c = cksum(buf);
      if (c === 8 * 32)
        return null;
      if (c !== decodeOct(buf, 148, 8))
        throw new Error("Invalid tar header. Maybe the tar is corrupted or it needs to be gunzipped?");
      if (USTAR_MAGIC.compare(buf, MAGIC_OFFSET, MAGIC_OFFSET + 6) === 0) {
        if (buf[345])
          name = decodeStr(buf, 345, 155, filenameEncoding) + "/" + name;
      } else if (GNU_MAGIC.compare(buf, MAGIC_OFFSET, MAGIC_OFFSET + 6) === 0 && GNU_VER.compare(buf, VERSION_OFFSET, VERSION_OFFSET + 2) === 0) {
      } else {
        if (!allowUnknownFormat) {
          throw new Error("Invalid tar header: unknown format.");
        }
      }
      if (typeflag === 0 && name && name[name.length - 1] === "/")
        typeflag = 5;
      return {
        name,
        mode,
        uid,
        gid,
        size,
        mtime: new Date(1e3 * mtime),
        type,
        linkname,
        uname,
        gname,
        devmajor,
        devminor
      };
    };
  }
});

// ../../../node_modules/tar-stream/node_modules/readable-stream/lib/internal/streams/stream.js
var require_stream10 = __commonJS({
  "../../../node_modules/tar-stream/node_modules/readable-stream/lib/internal/streams/stream.js"(exports2, module2) {
    module2.exports = require("stream");
  }
});

// ../../../node_modules/tar-stream/node_modules/readable-stream/lib/internal/streams/buffer_list.js
var require_buffer_list7 = __commonJS({
  "../../../node_modules/tar-stream/node_modules/readable-stream/lib/internal/streams/buffer_list.js"(exports2, module2) {
    "use strict";
    function ownKeys(object, enumerableOnly) {
      var keys = Object.keys(object);
      if (Object.getOwnPropertySymbols) {
        var symbols = Object.getOwnPropertySymbols(object);
        enumerableOnly && (symbols = symbols.filter(function(sym) {
          return Object.getOwnPropertyDescriptor(object, sym).enumerable;
        })), keys.push.apply(keys, symbols);
      }
      return keys;
    }
    function _objectSpread(target) {
      for (var i = 1; i < arguments.length; i++) {
        var source = null != arguments[i] ? arguments[i] : {};
        i % 2 ? ownKeys(Object(source), true).forEach(function(key) {
          _defineProperty(target, key, source[key]);
        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function(key) {
          Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
        });
      }
      return target;
    }
    function _defineProperty(obj2, key, value) {
      key = _toPropertyKey(key);
      if (key in obj2) {
        Object.defineProperty(obj2, key, { value, enumerable: true, configurable: true, writable: true });
      } else {
        obj2[key] = value;
      }
      return obj2;
    }
    function _classCallCheck(instance, Constructor) {
      if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
      }
    }
    function _defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor)
          descriptor.writable = true;
        Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor);
      }
    }
    function _createClass(Constructor, protoProps, staticProps) {
      if (protoProps)
        _defineProperties(Constructor.prototype, protoProps);
      if (staticProps)
        _defineProperties(Constructor, staticProps);
      Object.defineProperty(Constructor, "prototype", { writable: false });
      return Constructor;
    }
    function _toPropertyKey(arg) {
      var key = _toPrimitive(arg, "string");
      return typeof key === "symbol" ? key : String(key);
    }
    function _toPrimitive(input, hint) {
      if (typeof input !== "object" || input === null)
        return input;
      var prim = input[Symbol.toPrimitive];
      if (prim !== void 0) {
        var res = prim.call(input, hint || "default");
        if (typeof res !== "object")
          return res;
        throw new TypeError("@@toPrimitive must return a primitive value.");
      }
      return (hint === "string" ? String : Number)(input);
    }
    var _require = require("buffer");
    var Buffer2 = _require.Buffer;
    var _require2 = require("util");
    var inspect = _require2.inspect;
    var custom = inspect && inspect.custom || "inspect";
    function copyBuffer(src, target, offset) {
      Buffer2.prototype.copy.call(src, target, offset);
    }
    module2.exports = /* @__PURE__ */ function() {
      function BufferList() {
        _classCallCheck(this, BufferList);
        this.head = null;
        this.tail = null;
        this.length = 0;
      }
      _createClass(BufferList, [{
        key: "push",
        value: function push(v) {
          var entry = {
            data: v,
            next: null
          };
          if (this.length > 0)
            this.tail.next = entry;
          else
            this.head = entry;
          this.tail = entry;
          ++this.length;
        }
      }, {
        key: "unshift",
        value: function unshift(v) {
          var entry = {
            data: v,
            next: this.head
          };
          if (this.length === 0)
            this.tail = entry;
          this.head = entry;
          ++this.length;
        }
      }, {
        key: "shift",
        value: function shift() {
          if (this.length === 0)
            return;
          var ret2 = this.head.data;
          if (this.length === 1)
            this.head = this.tail = null;
          else
            this.head = this.head.next;
          --this.length;
          return ret2;
        }
      }, {
        key: "clear",
        value: function clear() {
          this.head = this.tail = null;
          this.length = 0;
        }
      }, {
        key: "join",
        value: function join(s) {
          if (this.length === 0)
            return "";
          var p = this.head;
          var ret2 = "" + p.data;
          while (p = p.next)
            ret2 += s + p.data;
          return ret2;
        }
      }, {
        key: "concat",
        value: function concat(n) {
          if (this.length === 0)
            return Buffer2.alloc(0);
          var ret2 = Buffer2.allocUnsafe(n >>> 0);
          var p = this.head;
          var i = 0;
          while (p) {
            copyBuffer(p.data, ret2, i);
            i += p.data.length;
            p = p.next;
          }
          return ret2;
        }
        // Consumes a specified amount of bytes or characters from the buffered data.
      }, {
        key: "consume",
        value: function consume(n, hasStrings) {
          var ret2;
          if (n < this.head.data.length) {
            ret2 = this.head.data.slice(0, n);
            this.head.data = this.head.data.slice(n);
          } else if (n === this.head.data.length) {
            ret2 = this.shift();
          } else {
            ret2 = hasStrings ? this._getString(n) : this._getBuffer(n);
          }
          return ret2;
        }
      }, {
        key: "first",
        value: function first() {
          return this.head.data;
        }
        // Consumes a specified amount of characters from the buffered data.
      }, {
        key: "_getString",
        value: function _getString(n) {
          var p = this.head;
          var c = 1;
          var ret2 = p.data;
          n -= ret2.length;
          while (p = p.next) {
            var str = p.data;
            var nb = n > str.length ? str.length : n;
            if (nb === str.length)
              ret2 += str;
            else
              ret2 += str.slice(0, n);
            n -= nb;
            if (n === 0) {
              if (nb === str.length) {
                ++c;
                if (p.next)
                  this.head = p.next;
                else
                  this.head = this.tail = null;
              } else {
                this.head = p;
                p.data = str.slice(nb);
              }
              break;
            }
            ++c;
          }
          this.length -= c;
          return ret2;
        }
        // Consumes a specified amount of bytes from the buffered data.
      }, {
        key: "_getBuffer",
        value: function _getBuffer(n) {
          var ret2 = Buffer2.allocUnsafe(n);
          var p = this.head;
          var c = 1;
          p.data.copy(ret2);
          n -= p.data.length;
          while (p = p.next) {
            var buf = p.data;
            var nb = n > buf.length ? buf.length : n;
            buf.copy(ret2, ret2.length - n, 0, nb);
            n -= nb;
            if (n === 0) {
              if (nb === buf.length) {
                ++c;
                if (p.next)
                  this.head = p.next;
                else
                  this.head = this.tail = null;
              } else {
                this.head = p;
                p.data = buf.slice(nb);
              }
              break;
            }
            ++c;
          }
          this.length -= c;
          return ret2;
        }
        // Make sure the linked list only shows the minimal necessary information.
      }, {
        key: custom,
        value: function value(_2, options) {
          return inspect(this, _objectSpread(_objectSpread({}, options), {}, {
            // Only inspect one level.
            depth: 0,
            // It should not recurse.
            customInspect: false
          }));
        }
      }]);
      return BufferList;
    }();
  }
});

// ../../../node_modules/tar-stream/node_modules/readable-stream/lib/internal/streams/destroy.js
var require_destroy10 = __commonJS({
  "../../../node_modules/tar-stream/node_modules/readable-stream/lib/internal/streams/destroy.js"(exports2, module2) {
    "use strict";
    function destroy(err, cb) {
      var _this = this;
      var readableDestroyed = this._readableState && this._readableState.destroyed;
      var writableDestroyed = this._writableState && this._writableState.destroyed;
      if (readableDestroyed || writableDestroyed) {
        if (cb) {
          cb(err);
        } else if (err) {
          if (!this._writableState) {
            process.nextTick(emitErrorNT, this, err);
          } else if (!this._writableState.errorEmitted) {
            this._writableState.errorEmitted = true;
            process.nextTick(emitErrorNT, this, err);
          }
        }
        return this;
      }
      if (this._readableState) {
        this._readableState.destroyed = true;
      }
      if (this._writableState) {
        this._writableState.destroyed = true;
      }
      this._destroy(err || null, function(err2) {
        if (!cb && err2) {
          if (!_this._writableState) {
            process.nextTick(emitErrorAndCloseNT, _this, err2);
          } else if (!_this._writableState.errorEmitted) {
            _this._writableState.errorEmitted = true;
            process.nextTick(emitErrorAndCloseNT, _this, err2);
          } else {
            process.nextTick(emitCloseNT, _this);
          }
        } else if (cb) {
          process.nextTick(emitCloseNT, _this);
          cb(err2);
        } else {
          process.nextTick(emitCloseNT, _this);
        }
      });
      return this;
    }
    function emitErrorAndCloseNT(self2, err) {
      emitErrorNT(self2, err);
      emitCloseNT(self2);
    }
    function emitCloseNT(self2) {
      if (self2._writableState && !self2._writableState.emitClose)
        return;
      if (self2._readableState && !self2._readableState.emitClose)
        return;
      self2.emit("close");
    }
    function undestroy() {
      if (this._readableState) {
        this._readableState.destroyed = false;
        this._readableState.reading = false;
        this._readableState.ended = false;
        this._readableState.endEmitted = false;
      }
      if (this._writableState) {
        this._writableState.destroyed = false;
        this._writableState.ended = false;
        this._writableState.ending = false;
        this._writableState.finalCalled = false;
        this._writableState.prefinished = false;
        this._writableState.finished = false;
        this._writableState.errorEmitted = false;
      }
    }
    function emitErrorNT(self2, err) {
      self2.emit("error", err);
    }
    function errorOrDestroy(stream, err) {
      var rState = stream._readableState;
      var wState = stream._writableState;
      if (rState && rState.autoDestroy || wState && wState.autoDestroy)
        stream.destroy(err);
      else
        stream.emit("error", err);
    }
    module2.exports = {
      destroy,
      undestroy,
      errorOrDestroy
    };
  }
});

// ../../../node_modules/tar-stream/node_modules/readable-stream/errors.js
var require_errors7 = __commonJS({
  "../../../node_modules/tar-stream/node_modules/readable-stream/errors.js"(exports2, module2) {
    "use strict";
    var codes = {};
    function createErrorType(code, message, Base) {
      if (!Base) {
        Base = Error;
      }
      function getMessage(arg1, arg2, arg3) {
        if (typeof message === "string") {
          return message;
        } else {
          return message(arg1, arg2, arg3);
        }
      }
      class NodeError extends Base {
        constructor(arg1, arg2, arg3) {
          super(getMessage(arg1, arg2, arg3));
        }
      }
      NodeError.prototype.name = Base.name;
      NodeError.prototype.code = code;
      codes[code] = NodeError;
    }
    function oneOf(expected, thing) {
      if (Array.isArray(expected)) {
        const len = expected.length;
        expected = expected.map((i) => String(i));
        if (len > 2) {
          return `one of ${thing} ${expected.slice(0, len - 1).join(", ")}, or ` + expected[len - 1];
        } else if (len === 2) {
          return `one of ${thing} ${expected[0]} or ${expected[1]}`;
        } else {
          return `of ${thing} ${expected[0]}`;
        }
      } else {
        return `of ${thing} ${String(expected)}`;
      }
    }
    function startsWith(str, search, pos) {
      return str.substr(!pos || pos < 0 ? 0 : +pos, search.length) === search;
    }
    function endsWith(str, search, this_len) {
      if (this_len === void 0 || this_len > str.length) {
        this_len = str.length;
      }
      return str.substring(this_len - search.length, this_len) === search;
    }
    function includes(str, search, start) {
      if (typeof start !== "number") {
        start = 0;
      }
      if (start + search.length > str.length) {
        return false;
      } else {
        return str.indexOf(search, start) !== -1;
      }
    }
    createErrorType("ERR_INVALID_OPT_VALUE", function(name, value) {
      return 'The value "' + value + '" is invalid for option "' + name + '"';
    }, TypeError);
    createErrorType("ERR_INVALID_ARG_TYPE", function(name, expected, actual) {
      let determiner;
      if (typeof expected === "string" && startsWith(expected, "not ")) {
        determiner = "must not be";
        expected = expected.replace(/^not /, "");
      } else {
        determiner = "must be";
      }
      let msg;
      if (endsWith(name, " argument")) {
        msg = `The ${name} ${determiner} ${oneOf(expected, "type")}`;
      } else {
        const type = includes(name, ".") ? "property" : "argument";
        msg = `The "${name}" ${type} ${determiner} ${oneOf(expected, "type")}`;
      }
      msg += `. Received type ${typeof actual}`;
      return msg;
    }, TypeError);
    createErrorType("ERR_STREAM_PUSH_AFTER_EOF", "stream.push() after EOF");
    createErrorType("ERR_METHOD_NOT_IMPLEMENTED", function(name) {
      return "The " + name + " method is not implemented";
    });
    createErrorType("ERR_STREAM_PREMATURE_CLOSE", "Premature close");
    createErrorType("ERR_STREAM_DESTROYED", function(name) {
      return "Cannot call " + name + " after a stream was destroyed";
    });
    createErrorType("ERR_MULTIPLE_CALLBACK", "Callback called multiple times");
    createErrorType("ERR_STREAM_CANNOT_PIPE", "Cannot pipe, not readable");
    createErrorType("ERR_STREAM_WRITE_AFTER_END", "write after end");
    createErrorType("ERR_STREAM_NULL_VALUES", "May not write null values to stream", TypeError);
    createErrorType("ERR_UNKNOWN_ENCODING", function(arg) {
      return "Unknown encoding: " + arg;
    }, TypeError);
    createErrorType("ERR_STREAM_UNSHIFT_AFTER_END_EVENT", "stream.unshift() after end event");
    module2.exports.codes = codes;
  }
});

// ../../../node_modules/tar-stream/node_modules/readable-stream/lib/internal/streams/state.js
var require_state7 = __commonJS({
  "../../../node_modules/tar-stream/node_modules/readable-stream/lib/internal/streams/state.js"(exports2, module2) {
    "use strict";
    var ERR_INVALID_OPT_VALUE = require_errors7().codes.ERR_INVALID_OPT_VALUE;
    function highWaterMarkFrom(options, isDuplex, duplexKey) {
      return options.highWaterMark != null ? options.highWaterMark : isDuplex ? options[duplexKey] : null;
    }
    function getHighWaterMark(state, options, duplexKey, isDuplex) {
      var hwm = highWaterMarkFrom(options, isDuplex, duplexKey);
      if (hwm != null) {
        if (!(isFinite(hwm) && Math.floor(hwm) === hwm) || hwm < 0) {
          var name = isDuplex ? duplexKey : "highWaterMark";
          throw new ERR_INVALID_OPT_VALUE(name, hwm);
        }
        return Math.floor(hwm);
      }
      return state.objectMode ? 16 : 16 * 1024;
    }
    module2.exports = {
      getHighWaterMark
    };
  }
});

// ../../../node_modules/tar-stream/node_modules/readable-stream/lib/_stream_writable.js
var require_stream_writable10 = __commonJS({
  "../../../node_modules/tar-stream/node_modules/readable-stream/lib/_stream_writable.js"(exports2, module2) {
    "use strict";
    module2.exports = Writable;
    function CorkedRequest(state) {
      var _this = this;
      this.next = null;
      this.entry = null;
      this.finish = function() {
        onCorkedFinish(_this, state);
      };
    }
    var Duplex;
    Writable.WritableState = WritableState;
    var internalUtil = {
      deprecate: require_node()
    };
    var Stream = require_stream10();
    var Buffer2 = require("buffer").Buffer;
    var OurUint8Array = (typeof global !== "undefined" ? global : typeof window !== "undefined" ? window : typeof self !== "undefined" ? self : {}).Uint8Array || function() {
    };
    function _uint8ArrayToBuffer(chunk) {
      return Buffer2.from(chunk);
    }
    function _isUint8Array(obj2) {
      return Buffer2.isBuffer(obj2) || obj2 instanceof OurUint8Array;
    }
    var destroyImpl = require_destroy10();
    var _require = require_state7();
    var getHighWaterMark = _require.getHighWaterMark;
    var _require$codes = require_errors7().codes;
    var ERR_INVALID_ARG_TYPE = _require$codes.ERR_INVALID_ARG_TYPE;
    var ERR_METHOD_NOT_IMPLEMENTED = _require$codes.ERR_METHOD_NOT_IMPLEMENTED;
    var ERR_MULTIPLE_CALLBACK = _require$codes.ERR_MULTIPLE_CALLBACK;
    var ERR_STREAM_CANNOT_PIPE = _require$codes.ERR_STREAM_CANNOT_PIPE;
    var ERR_STREAM_DESTROYED = _require$codes.ERR_STREAM_DESTROYED;
    var ERR_STREAM_NULL_VALUES = _require$codes.ERR_STREAM_NULL_VALUES;
    var ERR_STREAM_WRITE_AFTER_END = _require$codes.ERR_STREAM_WRITE_AFTER_END;
    var ERR_UNKNOWN_ENCODING = _require$codes.ERR_UNKNOWN_ENCODING;
    var errorOrDestroy = destroyImpl.errorOrDestroy;
    require_inherits()(Writable, Stream);
    function nop() {
    }
    function WritableState(options, stream, isDuplex) {
      Duplex = Duplex || require_stream_duplex10();
      options = options || {};
      if (typeof isDuplex !== "boolean")
        isDuplex = stream instanceof Duplex;
      this.objectMode = !!options.objectMode;
      if (isDuplex)
        this.objectMode = this.objectMode || !!options.writableObjectMode;
      this.highWaterMark = getHighWaterMark(this, options, "writableHighWaterMark", isDuplex);
      this.finalCalled = false;
      this.needDrain = false;
      this.ending = false;
      this.ended = false;
      this.finished = false;
      this.destroyed = false;
      var noDecode = options.decodeStrings === false;
      this.decodeStrings = !noDecode;
      this.defaultEncoding = options.defaultEncoding || "utf8";
      this.length = 0;
      this.writing = false;
      this.corked = 0;
      this.sync = true;
      this.bufferProcessing = false;
      this.onwrite = function(er) {
        onwrite(stream, er);
      };
      this.writecb = null;
      this.writelen = 0;
      this.bufferedRequest = null;
      this.lastBufferedRequest = null;
      this.pendingcb = 0;
      this.prefinished = false;
      this.errorEmitted = false;
      this.emitClose = options.emitClose !== false;
      this.autoDestroy = !!options.autoDestroy;
      this.bufferedRequestCount = 0;
      this.corkedRequestsFree = new CorkedRequest(this);
    }
    WritableState.prototype.getBuffer = function getBuffer() {
      var current = this.bufferedRequest;
      var out = [];
      while (current) {
        out.push(current);
        current = current.next;
      }
      return out;
    };
    (function() {
      try {
        Object.defineProperty(WritableState.prototype, "buffer", {
          get: internalUtil.deprecate(function writableStateBufferGetter() {
            return this.getBuffer();
          }, "_writableState.buffer is deprecated. Use _writableState.getBuffer instead.", "DEP0003")
        });
      } catch (_2) {
      }
    })();
    var realHasInstance;
    if (typeof Symbol === "function" && Symbol.hasInstance && typeof Function.prototype[Symbol.hasInstance] === "function") {
      realHasInstance = Function.prototype[Symbol.hasInstance];
      Object.defineProperty(Writable, Symbol.hasInstance, {
        value: function value(object) {
          if (realHasInstance.call(this, object))
            return true;
          if (this !== Writable)
            return false;
          return object && object._writableState instanceof WritableState;
        }
      });
    } else {
      realHasInstance = function realHasInstance2(object) {
        return object instanceof this;
      };
    }
    function Writable(options) {
      Duplex = Duplex || require_stream_duplex10();
      var isDuplex = this instanceof Duplex;
      if (!isDuplex && !realHasInstance.call(Writable, this))
        return new Writable(options);
      this._writableState = new WritableState(options, this, isDuplex);
      this.writable = true;
      if (options) {
        if (typeof options.write === "function")
          this._write = options.write;
        if (typeof options.writev === "function")
          this._writev = options.writev;
        if (typeof options.destroy === "function")
          this._destroy = options.destroy;
        if (typeof options.final === "function")
          this._final = options.final;
      }
      Stream.call(this);
    }
    Writable.prototype.pipe = function() {
      errorOrDestroy(this, new ERR_STREAM_CANNOT_PIPE());
    };
    function writeAfterEnd(stream, cb) {
      var er = new ERR_STREAM_WRITE_AFTER_END();
      errorOrDestroy(stream, er);
      process.nextTick(cb, er);
    }
    function validChunk(stream, state, chunk, cb) {
      var er;
      if (chunk === null) {
        er = new ERR_STREAM_NULL_VALUES();
      } else if (typeof chunk !== "string" && !state.objectMode) {
        er = new ERR_INVALID_ARG_TYPE("chunk", ["string", "Buffer"], chunk);
      }
      if (er) {
        errorOrDestroy(stream, er);
        process.nextTick(cb, er);
        return false;
      }
      return true;
    }
    Writable.prototype.write = function(chunk, encoding, cb) {
      var state = this._writableState;
      var ret2 = false;
      var isBuf = !state.objectMode && _isUint8Array(chunk);
      if (isBuf && !Buffer2.isBuffer(chunk)) {
        chunk = _uint8ArrayToBuffer(chunk);
      }
      if (typeof encoding === "function") {
        cb = encoding;
        encoding = null;
      }
      if (isBuf)
        encoding = "buffer";
      else if (!encoding)
        encoding = state.defaultEncoding;
      if (typeof cb !== "function")
        cb = nop;
      if (state.ending)
        writeAfterEnd(this, cb);
      else if (isBuf || validChunk(this, state, chunk, cb)) {
        state.pendingcb++;
        ret2 = writeOrBuffer(this, state, isBuf, chunk, encoding, cb);
      }
      return ret2;
    };
    Writable.prototype.cork = function() {
      this._writableState.corked++;
    };
    Writable.prototype.uncork = function() {
      var state = this._writableState;
      if (state.corked) {
        state.corked--;
        if (!state.writing && !state.corked && !state.bufferProcessing && state.bufferedRequest)
          clearBuffer(this, state);
      }
    };
    Writable.prototype.setDefaultEncoding = function setDefaultEncoding(encoding) {
      if (typeof encoding === "string")
        encoding = encoding.toLowerCase();
      if (!(["hex", "utf8", "utf-8", "ascii", "binary", "base64", "ucs2", "ucs-2", "utf16le", "utf-16le", "raw"].indexOf((encoding + "").toLowerCase()) > -1))
        throw new ERR_UNKNOWN_ENCODING(encoding);
      this._writableState.defaultEncoding = encoding;
      return this;
    };
    Object.defineProperty(Writable.prototype, "writableBuffer", {
      // making it explicit this property is not enumerable
      // because otherwise some prototype manipulation in
      // userland will fail
      enumerable: false,
      get: function get() {
        return this._writableState && this._writableState.getBuffer();
      }
    });
    function decodeChunk(state, chunk, encoding) {
      if (!state.objectMode && state.decodeStrings !== false && typeof chunk === "string") {
        chunk = Buffer2.from(chunk, encoding);
      }
      return chunk;
    }
    Object.defineProperty(Writable.prototype, "writableHighWaterMark", {
      // making it explicit this property is not enumerable
      // because otherwise some prototype manipulation in
      // userland will fail
      enumerable: false,
      get: function get() {
        return this._writableState.highWaterMark;
      }
    });
    function writeOrBuffer(stream, state, isBuf, chunk, encoding, cb) {
      if (!isBuf) {
        var newChunk = decodeChunk(state, chunk, encoding);
        if (chunk !== newChunk) {
          isBuf = true;
          encoding = "buffer";
          chunk = newChunk;
        }
      }
      var len = state.objectMode ? 1 : chunk.length;
      state.length += len;
      var ret2 = state.length < state.highWaterMark;
      if (!ret2)
        state.needDrain = true;
      if (state.writing || state.corked) {
        var last = state.lastBufferedRequest;
        state.lastBufferedRequest = {
          chunk,
          encoding,
          isBuf,
          callback: cb,
          next: null
        };
        if (last) {
          last.next = state.lastBufferedRequest;
        } else {
          state.bufferedRequest = state.lastBufferedRequest;
        }
        state.bufferedRequestCount += 1;
      } else {
        doWrite(stream, state, false, len, chunk, encoding, cb);
      }
      return ret2;
    }
    function doWrite(stream, state, writev, len, chunk, encoding, cb) {
      state.writelen = len;
      state.writecb = cb;
      state.writing = true;
      state.sync = true;
      if (state.destroyed)
        state.onwrite(new ERR_STREAM_DESTROYED("write"));
      else if (writev)
        stream._writev(chunk, state.onwrite);
      else
        stream._write(chunk, encoding, state.onwrite);
      state.sync = false;
    }
    function onwriteError(stream, state, sync, er, cb) {
      --state.pendingcb;
      if (sync) {
        process.nextTick(cb, er);
        process.nextTick(finishMaybe, stream, state);
        stream._writableState.errorEmitted = true;
        errorOrDestroy(stream, er);
      } else {
        cb(er);
        stream._writableState.errorEmitted = true;
        errorOrDestroy(stream, er);
        finishMaybe(stream, state);
      }
    }
    function onwriteStateUpdate(state) {
      state.writing = false;
      state.writecb = null;
      state.length -= state.writelen;
      state.writelen = 0;
    }
    function onwrite(stream, er) {
      var state = stream._writableState;
      var sync = state.sync;
      var cb = state.writecb;
      if (typeof cb !== "function")
        throw new ERR_MULTIPLE_CALLBACK();
      onwriteStateUpdate(state);
      if (er)
        onwriteError(stream, state, sync, er, cb);
      else {
        var finished = needFinish(state) || stream.destroyed;
        if (!finished && !state.corked && !state.bufferProcessing && state.bufferedRequest) {
          clearBuffer(stream, state);
        }
        if (sync) {
          process.nextTick(afterWrite, stream, state, finished, cb);
        } else {
          afterWrite(stream, state, finished, cb);
        }
      }
    }
    function afterWrite(stream, state, finished, cb) {
      if (!finished)
        onwriteDrain(stream, state);
      state.pendingcb--;
      cb();
      finishMaybe(stream, state);
    }
    function onwriteDrain(stream, state) {
      if (state.length === 0 && state.needDrain) {
        state.needDrain = false;
        stream.emit("drain");
      }
    }
    function clearBuffer(stream, state) {
      state.bufferProcessing = true;
      var entry = state.bufferedRequest;
      if (stream._writev && entry && entry.next) {
        var l2 = state.bufferedRequestCount;
        var buffer = new Array(l2);
        var holder = state.corkedRequestsFree;
        holder.entry = entry;
        var count = 0;
        var allBuffers = true;
        while (entry) {
          buffer[count] = entry;
          if (!entry.isBuf)
            allBuffers = false;
          entry = entry.next;
          count += 1;
        }
        buffer.allBuffers = allBuffers;
        doWrite(stream, state, true, state.length, buffer, "", holder.finish);
        state.pendingcb++;
        state.lastBufferedRequest = null;
        if (holder.next) {
          state.corkedRequestsFree = holder.next;
          holder.next = null;
        } else {
          state.corkedRequestsFree = new CorkedRequest(state);
        }
        state.bufferedRequestCount = 0;
      } else {
        while (entry) {
          var chunk = entry.chunk;
          var encoding = entry.encoding;
          var cb = entry.callback;
          var len = state.objectMode ? 1 : chunk.length;
          doWrite(stream, state, false, len, chunk, encoding, cb);
          entry = entry.next;
          state.bufferedRequestCount--;
          if (state.writing) {
            break;
          }
        }
        if (entry === null)
          state.lastBufferedRequest = null;
      }
      state.bufferedRequest = entry;
      state.bufferProcessing = false;
    }
    Writable.prototype._write = function(chunk, encoding, cb) {
      cb(new ERR_METHOD_NOT_IMPLEMENTED("_write()"));
    };
    Writable.prototype._writev = null;
    Writable.prototype.end = function(chunk, encoding, cb) {
      var state = this._writableState;
      if (typeof chunk === "function") {
        cb = chunk;
        chunk = null;
        encoding = null;
      } else if (typeof encoding === "function") {
        cb = encoding;
        encoding = null;
      }
      if (chunk !== null && chunk !== void 0)
        this.write(chunk, encoding);
      if (state.corked) {
        state.corked = 1;
        this.uncork();
      }
      if (!state.ending)
        endWritable(this, state, cb);
      return this;
    };
    Object.defineProperty(Writable.prototype, "writableLength", {
      // making it explicit this property is not enumerable
      // because otherwise some prototype manipulation in
      // userland will fail
      enumerable: false,
      get: function get() {
        return this._writableState.length;
      }
    });
    function needFinish(state) {
      return state.ending && state.length === 0 && state.bufferedRequest === null && !state.finished && !state.writing;
    }
    function callFinal(stream, state) {
      stream._final(function(err) {
        state.pendingcb--;
        if (err) {
          errorOrDestroy(stream, err);
        }
        state.prefinished = true;
        stream.emit("prefinish");
        finishMaybe(stream, state);
      });
    }
    function prefinish(stream, state) {
      if (!state.prefinished && !state.finalCalled) {
        if (typeof stream._final === "function" && !state.destroyed) {
          state.pendingcb++;
          state.finalCalled = true;
          process.nextTick(callFinal, stream, state);
        } else {
          state.prefinished = true;
          stream.emit("prefinish");
        }
      }
    }
    function finishMaybe(stream, state) {
      var need = needFinish(state);
      if (need) {
        prefinish(stream, state);
        if (state.pendingcb === 0) {
          state.finished = true;
          stream.emit("finish");
          if (state.autoDestroy) {
            var rState = stream._readableState;
            if (!rState || rState.autoDestroy && rState.endEmitted) {
              stream.destroy();
            }
          }
        }
      }
      return need;
    }
    function endWritable(stream, state, cb) {
      state.ending = true;
      finishMaybe(stream, state);
      if (cb) {
        if (state.finished)
          process.nextTick(cb);
        else
          stream.once("finish", cb);
      }
      state.ended = true;
      stream.writable = false;
    }
    function onCorkedFinish(corkReq, state, err) {
      var entry = corkReq.entry;
      corkReq.entry = null;
      while (entry) {
        var cb = entry.callback;
        state.pendingcb--;
        cb(err);
        entry = entry.next;
      }
      state.corkedRequestsFree.next = corkReq;
    }
    Object.defineProperty(Writable.prototype, "destroyed", {
      // making it explicit this property is not enumerable
      // because otherwise some prototype manipulation in
      // userland will fail
      enumerable: false,
      get: function get() {
        if (this._writableState === void 0) {
          return false;
        }
        return this._writableState.destroyed;
      },
      set: function set(value) {
        if (!this._writableState) {
          return;
        }
        this._writableState.destroyed = value;
      }
    });
    Writable.prototype.destroy = destroyImpl.destroy;
    Writable.prototype._undestroy = destroyImpl.undestroy;
    Writable.prototype._destroy = function(err, cb) {
      cb(err);
    };
  }
});

// ../../../node_modules/tar-stream/node_modules/readable-stream/lib/_stream_duplex.js
var require_stream_duplex10 = __commonJS({
  "../../../node_modules/tar-stream/node_modules/readable-stream/lib/_stream_duplex.js"(exports2, module2) {
    "use strict";
    var objectKeys = Object.keys || function(obj2) {
      var keys2 = [];
      for (var key in obj2)
        keys2.push(key);
      return keys2;
    };
    module2.exports = Duplex;
    var Readable = require_stream_readable10();
    var Writable = require_stream_writable10();
    require_inherits()(Duplex, Readable);
    {
      keys = objectKeys(Writable.prototype);
      for (v = 0; v < keys.length; v++) {
        method = keys[v];
        if (!Duplex.prototype[method])
          Duplex.prototype[method] = Writable.prototype[method];
      }
    }
    var keys;
    var method;
    var v;
    function Duplex(options) {
      if (!(this instanceof Duplex))
        return new Duplex(options);
      Readable.call(this, options);
      Writable.call(this, options);
      this.allowHalfOpen = true;
      if (options) {
        if (options.readable === false)
          this.readable = false;
        if (options.writable === false)
          this.writable = false;
        if (options.allowHalfOpen === false) {
          this.allowHalfOpen = false;
          this.once("end", onend);
        }
      }
    }
    Object.defineProperty(Duplex.prototype, "writableHighWaterMark", {
      // making it explicit this property is not enumerable
      // because otherwise some prototype manipulation in
      // userland will fail
      enumerable: false,
      get: function get() {
        return this._writableState.highWaterMark;
      }
    });
    Object.defineProperty(Duplex.prototype, "writableBuffer", {
      // making it explicit this property is not enumerable
      // because otherwise some prototype manipulation in
      // userland will fail
      enumerable: false,
      get: function get() {
        return this._writableState && this._writableState.getBuffer();
      }
    });
    Object.defineProperty(Duplex.prototype, "writableLength", {
      // making it explicit this property is not enumerable
      // because otherwise some prototype manipulation in
      // userland will fail
      enumerable: false,
      get: function get() {
        return this._writableState.length;
      }
    });
    function onend() {
      if (this._writableState.ended)
        return;
      process.nextTick(onEndNT, this);
    }
    function onEndNT(self2) {
      self2.end();
    }
    Object.defineProperty(Duplex.prototype, "destroyed", {
      // making it explicit this property is not enumerable
      // because otherwise some prototype manipulation in
      // userland will fail
      enumerable: false,
      get: function get() {
        if (this._readableState === void 0 || this._writableState === void 0) {
          return false;
        }
        return this._readableState.destroyed && this._writableState.destroyed;
      },
      set: function set(value) {
        if (this._readableState === void 0 || this._writableState === void 0) {
          return;
        }
        this._readableState.destroyed = value;
        this._writableState.destroyed = value;
      }
    });
  }
});

// ../../../node_modules/tar-stream/node_modules/string_decoder/lib/string_decoder.js
var require_string_decoder10 = __commonJS({
  "../../../node_modules/tar-stream/node_modules/string_decoder/lib/string_decoder.js"(exports2) {
    "use strict";
    var Buffer2 = require_safe_buffer2().Buffer;
    var isEncoding = Buffer2.isEncoding || function(encoding) {
      encoding = "" + encoding;
      switch (encoding && encoding.toLowerCase()) {
        case "hex":
        case "utf8":
        case "utf-8":
        case "ascii":
        case "binary":
        case "base64":
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
        case "raw":
          return true;
        default:
          return false;
      }
    };
    function _normalizeEncoding(enc) {
      if (!enc)
        return "utf8";
      var retried;
      while (true) {
        switch (enc) {
          case "utf8":
          case "utf-8":
            return "utf8";
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
            return "utf16le";
          case "latin1":
          case "binary":
            return "latin1";
          case "base64":
          case "ascii":
          case "hex":
            return enc;
          default:
            if (retried)
              return;
            enc = ("" + enc).toLowerCase();
            retried = true;
        }
      }
    }
    function normalizeEncoding(enc) {
      var nenc = _normalizeEncoding(enc);
      if (typeof nenc !== "string" && (Buffer2.isEncoding === isEncoding || !isEncoding(enc)))
        throw new Error("Unknown encoding: " + enc);
      return nenc || enc;
    }
    exports2.StringDecoder = StringDecoder;
    function StringDecoder(encoding) {
      this.encoding = normalizeEncoding(encoding);
      var nb;
      switch (this.encoding) {
        case "utf16le":
          this.text = utf16Text;
          this.end = utf16End;
          nb = 4;
          break;
        case "utf8":
          this.fillLast = utf8FillLast;
          nb = 4;
          break;
        case "base64":
          this.text = base64Text;
          this.end = base64End;
          nb = 3;
          break;
        default:
          this.write = simpleWrite;
          this.end = simpleEnd;
          return;
      }
      this.lastNeed = 0;
      this.lastTotal = 0;
      this.lastChar = Buffer2.allocUnsafe(nb);
    }
    StringDecoder.prototype.write = function(buf) {
      if (buf.length === 0)
        return "";
      var r;
      var i;
      if (this.lastNeed) {
        r = this.fillLast(buf);
        if (r === void 0)
          return "";
        i = this.lastNeed;
        this.lastNeed = 0;
      } else {
        i = 0;
      }
      if (i < buf.length)
        return r ? r + this.text(buf, i) : this.text(buf, i);
      return r || "";
    };
    StringDecoder.prototype.end = utf8End;
    StringDecoder.prototype.text = utf8Text;
    StringDecoder.prototype.fillLast = function(buf) {
      if (this.lastNeed <= buf.length) {
        buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, this.lastNeed);
        return this.lastChar.toString(this.encoding, 0, this.lastTotal);
      }
      buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, buf.length);
      this.lastNeed -= buf.length;
    };
    function utf8CheckByte(byte) {
      if (byte <= 127)
        return 0;
      else if (byte >> 5 === 6)
        return 2;
      else if (byte >> 4 === 14)
        return 3;
      else if (byte >> 3 === 30)
        return 4;
      return byte >> 6 === 2 ? -1 : -2;
    }
    function utf8CheckIncomplete(self2, buf, i) {
      var j = buf.length - 1;
      if (j < i)
        return 0;
      var nb = utf8CheckByte(buf[j]);
      if (nb >= 0) {
        if (nb > 0)
          self2.lastNeed = nb - 1;
        return nb;
      }
      if (--j < i || nb === -2)
        return 0;
      nb = utf8CheckByte(buf[j]);
      if (nb >= 0) {
        if (nb > 0)
          self2.lastNeed = nb - 2;
        return nb;
      }
      if (--j < i || nb === -2)
        return 0;
      nb = utf8CheckByte(buf[j]);
      if (nb >= 0) {
        if (nb > 0) {
          if (nb === 2)
            nb = 0;
          else
            self2.lastNeed = nb - 3;
        }
        return nb;
      }
      return 0;
    }
    function utf8CheckExtraBytes(self2, buf, p) {
      if ((buf[0] & 192) !== 128) {
        self2.lastNeed = 0;
        return "\uFFFD";
      }
      if (self2.lastNeed > 1 && buf.length > 1) {
        if ((buf[1] & 192) !== 128) {
          self2.lastNeed = 1;
          return "\uFFFD";
        }
        if (self2.lastNeed > 2 && buf.length > 2) {
          if ((buf[2] & 192) !== 128) {
            self2.lastNeed = 2;
            return "\uFFFD";
          }
        }
      }
    }
    function utf8FillLast(buf) {
      var p = this.lastTotal - this.lastNeed;
      var r = utf8CheckExtraBytes(this, buf, p);
      if (r !== void 0)
        return r;
      if (this.lastNeed <= buf.length) {
        buf.copy(this.lastChar, p, 0, this.lastNeed);
        return this.lastChar.toString(this.encoding, 0, this.lastTotal);
      }
      buf.copy(this.lastChar, p, 0, buf.length);
      this.lastNeed -= buf.length;
    }
    function utf8Text(buf, i) {
      var total = utf8CheckIncomplete(this, buf, i);
      if (!this.lastNeed)
        return buf.toString("utf8", i);
      this.lastTotal = total;
      var end = buf.length - (total - this.lastNeed);
      buf.copy(this.lastChar, 0, end);
      return buf.toString("utf8", i, end);
    }
    function utf8End(buf) {
      var r = buf && buf.length ? this.write(buf) : "";
      if (this.lastNeed)
        return r + "\uFFFD";
      return r;
    }
    function utf16Text(buf, i) {
      if ((buf.length - i) % 2 === 0) {
        var r = buf.toString("utf16le", i);
        if (r) {
          var c = r.charCodeAt(r.length - 1);
          if (c >= 55296 && c <= 56319) {
            this.lastNeed = 2;
            this.lastTotal = 4;
            this.lastChar[0] = buf[buf.length - 2];
            this.lastChar[1] = buf[buf.length - 1];
            return r.slice(0, -1);
          }
        }
        return r;
      }
      this.lastNeed = 1;
      this.lastTotal = 2;
      this.lastChar[0] = buf[buf.length - 1];
      return buf.toString("utf16le", i, buf.length - 1);
    }
    function utf16End(buf) {
      var r = buf && buf.length ? this.write(buf) : "";
      if (this.lastNeed) {
        var end = this.lastTotal - this.lastNeed;
        return r + this.lastChar.toString("utf16le", 0, end);
      }
      return r;
    }
    function base64Text(buf, i) {
      var n = (buf.length - i) % 3;
      if (n === 0)
        return buf.toString("base64", i);
      this.lastNeed = 3 - n;
      this.lastTotal = 3;
      if (n === 1) {
        this.lastChar[0] = buf[buf.length - 1];
      } else {
        this.lastChar[0] = buf[buf.length - 2];
        this.lastChar[1] = buf[buf.length - 1];
      }
      return buf.toString("base64", i, buf.length - n);
    }
    function base64End(buf) {
      var r = buf && buf.length ? this.write(buf) : "";
      if (this.lastNeed)
        return r + this.lastChar.toString("base64", 0, 3 - this.lastNeed);
      return r;
    }
    function simpleWrite(buf) {
      return buf.toString(this.encoding);
    }
    function simpleEnd(buf) {
      return buf && buf.length ? this.write(buf) : "";
    }
  }
});

// ../../../node_modules/tar-stream/node_modules/readable-stream/lib/internal/streams/end-of-stream.js
var require_end_of_stream7 = __commonJS({
  "../../../node_modules/tar-stream/node_modules/readable-stream/lib/internal/streams/end-of-stream.js"(exports2, module2) {
    "use strict";
    var ERR_STREAM_PREMATURE_CLOSE = require_errors7().codes.ERR_STREAM_PREMATURE_CLOSE;
    function once(callback) {
      var called = false;
      return function() {
        if (called)
          return;
        called = true;
        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }
        callback.apply(this, args);
      };
    }
    function noop() {
    }
    function isRequest(stream) {
      return stream.setHeader && typeof stream.abort === "function";
    }
    function eos(stream, opts, callback) {
      if (typeof opts === "function")
        return eos(stream, null, opts);
      if (!opts)
        opts = {};
      callback = once(callback || noop);
      var readable = opts.readable || opts.readable !== false && stream.readable;
      var writable = opts.writable || opts.writable !== false && stream.writable;
      var onlegacyfinish = function onlegacyfinish2() {
        if (!stream.writable)
          onfinish();
      };
      var writableEnded = stream._writableState && stream._writableState.finished;
      var onfinish = function onfinish2() {
        writable = false;
        writableEnded = true;
        if (!readable)
          callback.call(stream);
      };
      var readableEnded = stream._readableState && stream._readableState.endEmitted;
      var onend = function onend2() {
        readable = false;
        readableEnded = true;
        if (!writable)
          callback.call(stream);
      };
      var onerror = function onerror2(err) {
        callback.call(stream, err);
      };
      var onclose = function onclose2() {
        var err;
        if (readable && !readableEnded) {
          if (!stream._readableState || !stream._readableState.ended)
            err = new ERR_STREAM_PREMATURE_CLOSE();
          return callback.call(stream, err);
        }
        if (writable && !writableEnded) {
          if (!stream._writableState || !stream._writableState.ended)
            err = new ERR_STREAM_PREMATURE_CLOSE();
          return callback.call(stream, err);
        }
      };
      var onrequest = function onrequest2() {
        stream.req.on("finish", onfinish);
      };
      if (isRequest(stream)) {
        stream.on("complete", onfinish);
        stream.on("abort", onclose);
        if (stream.req)
          onrequest();
        else
          stream.on("request", onrequest);
      } else if (writable && !stream._writableState) {
        stream.on("end", onlegacyfinish);
        stream.on("close", onlegacyfinish);
      }
      stream.on("end", onend);
      stream.on("finish", onfinish);
      if (opts.error !== false)
        stream.on("error", onerror);
      stream.on("close", onclose);
      return function() {
        stream.removeListener("complete", onfinish);
        stream.removeListener("abort", onclose);
        stream.removeListener("request", onrequest);
        if (stream.req)
          stream.req.removeListener("finish", onfinish);
        stream.removeListener("end", onlegacyfinish);
        stream.removeListener("close", onlegacyfinish);
        stream.removeListener("finish", onfinish);
        stream.removeListener("end", onend);
        stream.removeListener("error", onerror);
        stream.removeListener("close", onclose);
      };
    }
    module2.exports = eos;
  }
});

// ../../../node_modules/tar-stream/node_modules/readable-stream/lib/internal/streams/async_iterator.js
var require_async_iterator7 = __commonJS({
  "../../../node_modules/tar-stream/node_modules/readable-stream/lib/internal/streams/async_iterator.js"(exports2, module2) {
    "use strict";
    var _Object$setPrototypeO;
    function _defineProperty(obj2, key, value) {
      key = _toPropertyKey(key);
      if (key in obj2) {
        Object.defineProperty(obj2, key, { value, enumerable: true, configurable: true, writable: true });
      } else {
        obj2[key] = value;
      }
      return obj2;
    }
    function _toPropertyKey(arg) {
      var key = _toPrimitive(arg, "string");
      return typeof key === "symbol" ? key : String(key);
    }
    function _toPrimitive(input, hint) {
      if (typeof input !== "object" || input === null)
        return input;
      var prim = input[Symbol.toPrimitive];
      if (prim !== void 0) {
        var res = prim.call(input, hint || "default");
        if (typeof res !== "object")
          return res;
        throw new TypeError("@@toPrimitive must return a primitive value.");
      }
      return (hint === "string" ? String : Number)(input);
    }
    var finished = require_end_of_stream7();
    var kLastResolve = Symbol("lastResolve");
    var kLastReject = Symbol("lastReject");
    var kError = Symbol("error");
    var kEnded = Symbol("ended");
    var kLastPromise = Symbol("lastPromise");
    var kHandlePromise = Symbol("handlePromise");
    var kStream = Symbol("stream");
    function createIterResult(value, done) {
      return {
        value,
        done
      };
    }
    function readAndResolve(iter) {
      var resolve = iter[kLastResolve];
      if (resolve !== null) {
        var data = iter[kStream].read();
        if (data !== null) {
          iter[kLastPromise] = null;
          iter[kLastResolve] = null;
          iter[kLastReject] = null;
          resolve(createIterResult(data, false));
        }
      }
    }
    function onReadable(iter) {
      process.nextTick(readAndResolve, iter);
    }
    function wrapForNext(lastPromise, iter) {
      return function(resolve, reject) {
        lastPromise.then(function() {
          if (iter[kEnded]) {
            resolve(createIterResult(void 0, true));
            return;
          }
          iter[kHandlePromise](resolve, reject);
        }, reject);
      };
    }
    var AsyncIteratorPrototype = Object.getPrototypeOf(function() {
    });
    var ReadableStreamAsyncIteratorPrototype = Object.setPrototypeOf((_Object$setPrototypeO = {
      get stream() {
        return this[kStream];
      },
      next: function next() {
        var _this = this;
        var error = this[kError];
        if (error !== null) {
          return Promise.reject(error);
        }
        if (this[kEnded]) {
          return Promise.resolve(createIterResult(void 0, true));
        }
        if (this[kStream].destroyed) {
          return new Promise(function(resolve, reject) {
            process.nextTick(function() {
              if (_this[kError]) {
                reject(_this[kError]);
              } else {
                resolve(createIterResult(void 0, true));
              }
            });
          });
        }
        var lastPromise = this[kLastPromise];
        var promise;
        if (lastPromise) {
          promise = new Promise(wrapForNext(lastPromise, this));
        } else {
          var data = this[kStream].read();
          if (data !== null) {
            return Promise.resolve(createIterResult(data, false));
          }
          promise = new Promise(this[kHandlePromise]);
        }
        this[kLastPromise] = promise;
        return promise;
      }
    }, _defineProperty(_Object$setPrototypeO, Symbol.asyncIterator, function() {
      return this;
    }), _defineProperty(_Object$setPrototypeO, "return", function _return() {
      var _this2 = this;
      return new Promise(function(resolve, reject) {
        _this2[kStream].destroy(null, function(err) {
          if (err) {
            reject(err);
            return;
          }
          resolve(createIterResult(void 0, true));
        });
      });
    }), _Object$setPrototypeO), AsyncIteratorPrototype);
    var createReadableStreamAsyncIterator = function createReadableStreamAsyncIterator2(stream) {
      var _Object$create;
      var iterator = Object.create(ReadableStreamAsyncIteratorPrototype, (_Object$create = {}, _defineProperty(_Object$create, kStream, {
        value: stream,
        writable: true
      }), _defineProperty(_Object$create, kLastResolve, {
        value: null,
        writable: true
      }), _defineProperty(_Object$create, kLastReject, {
        value: null,
        writable: true
      }), _defineProperty(_Object$create, kError, {
        value: null,
        writable: true
      }), _defineProperty(_Object$create, kEnded, {
        value: stream._readableState.endEmitted,
        writable: true
      }), _defineProperty(_Object$create, kHandlePromise, {
        value: function value(resolve, reject) {
          var data = iterator[kStream].read();
          if (data) {
            iterator[kLastPromise] = null;
            iterator[kLastResolve] = null;
            iterator[kLastReject] = null;
            resolve(createIterResult(data, false));
          } else {
            iterator[kLastResolve] = resolve;
            iterator[kLastReject] = reject;
          }
        },
        writable: true
      }), _Object$create));
      iterator[kLastPromise] = null;
      finished(stream, function(err) {
        if (err && err.code !== "ERR_STREAM_PREMATURE_CLOSE") {
          var reject = iterator[kLastReject];
          if (reject !== null) {
            iterator[kLastPromise] = null;
            iterator[kLastResolve] = null;
            iterator[kLastReject] = null;
            reject(err);
          }
          iterator[kError] = err;
          return;
        }
        var resolve = iterator[kLastResolve];
        if (resolve !== null) {
          iterator[kLastPromise] = null;
          iterator[kLastResolve] = null;
          iterator[kLastReject] = null;
          resolve(createIterResult(void 0, true));
        }
        iterator[kEnded] = true;
      });
      stream.on("readable", onReadable.bind(null, iterator));
      return iterator;
    };
    module2.exports = createReadableStreamAsyncIterator;
  }
});

// ../../../node_modules/tar-stream/node_modules/readable-stream/lib/internal/streams/from.js
var require_from7 = __commonJS({
  "../../../node_modules/tar-stream/node_modules/readable-stream/lib/internal/streams/from.js"(exports2, module2) {
    "use strict";
    function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {
      try {
        var info = gen[key](arg);
        var value = info.value;
      } catch (error) {
        reject(error);
        return;
      }
      if (info.done) {
        resolve(value);
      } else {
        Promise.resolve(value).then(_next, _throw);
      }
    }
    function _asyncToGenerator(fn) {
      return function() {
        var self2 = this, args = arguments;
        return new Promise(function(resolve, reject) {
          var gen = fn.apply(self2, args);
          function _next(value) {
            asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value);
          }
          function _throw(err) {
            asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err);
          }
          _next(void 0);
        });
      };
    }
    function ownKeys(object, enumerableOnly) {
      var keys = Object.keys(object);
      if (Object.getOwnPropertySymbols) {
        var symbols = Object.getOwnPropertySymbols(object);
        enumerableOnly && (symbols = symbols.filter(function(sym) {
          return Object.getOwnPropertyDescriptor(object, sym).enumerable;
        })), keys.push.apply(keys, symbols);
      }
      return keys;
    }
    function _objectSpread(target) {
      for (var i = 1; i < arguments.length; i++) {
        var source = null != arguments[i] ? arguments[i] : {};
        i % 2 ? ownKeys(Object(source), true).forEach(function(key) {
          _defineProperty(target, key, source[key]);
        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function(key) {
          Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
        });
      }
      return target;
    }
    function _defineProperty(obj2, key, value) {
      key = _toPropertyKey(key);
      if (key in obj2) {
        Object.defineProperty(obj2, key, { value, enumerable: true, configurable: true, writable: true });
      } else {
        obj2[key] = value;
      }
      return obj2;
    }
    function _toPropertyKey(arg) {
      var key = _toPrimitive(arg, "string");
      return typeof key === "symbol" ? key : String(key);
    }
    function _toPrimitive(input, hint) {
      if (typeof input !== "object" || input === null)
        return input;
      var prim = input[Symbol.toPrimitive];
      if (prim !== void 0) {
        var res = prim.call(input, hint || "default");
        if (typeof res !== "object")
          return res;
        throw new TypeError("@@toPrimitive must return a primitive value.");
      }
      return (hint === "string" ? String : Number)(input);
    }
    var ERR_INVALID_ARG_TYPE = require_errors7().codes.ERR_INVALID_ARG_TYPE;
    function from(Readable, iterable, opts) {
      var iterator;
      if (iterable && typeof iterable.next === "function") {
        iterator = iterable;
      } else if (iterable && iterable[Symbol.asyncIterator])
        iterator = iterable[Symbol.asyncIterator]();
      else if (iterable && iterable[Symbol.iterator])
        iterator = iterable[Symbol.iterator]();
      else
        throw new ERR_INVALID_ARG_TYPE("iterable", ["Iterable"], iterable);
      var readable = new Readable(_objectSpread({
        objectMode: true
      }, opts));
      var reading = false;
      readable._read = function() {
        if (!reading) {
          reading = true;
          next();
        }
      };
      function next() {
        return _next2.apply(this, arguments);
      }
      function _next2() {
        _next2 = _asyncToGenerator(function* () {
          try {
            var _yield$iterator$next = yield iterator.next(), value = _yield$iterator$next.value, done = _yield$iterator$next.done;
            if (done) {
              readable.push(null);
            } else if (readable.push(yield value)) {
              next();
            } else {
              reading = false;
            }
          } catch (err) {
            readable.destroy(err);
          }
        });
        return _next2.apply(this, arguments);
      }
      return readable;
    }
    module2.exports = from;
  }
});

// ../../../node_modules/tar-stream/node_modules/readable-stream/lib/_stream_readable.js
var require_stream_readable10 = __commonJS({
  "../../../node_modules/tar-stream/node_modules/readable-stream/lib/_stream_readable.js"(exports2, module2) {
    "use strict";
    module2.exports = Readable;
    var Duplex;
    Readable.ReadableState = ReadableState;
    var EE = require("events").EventEmitter;
    var EElistenerCount = function EElistenerCount2(emitter, type) {
      return emitter.listeners(type).length;
    };
    var Stream = require_stream10();
    var Buffer2 = require("buffer").Buffer;
    var OurUint8Array = (typeof global !== "undefined" ? global : typeof window !== "undefined" ? window : typeof self !== "undefined" ? self : {}).Uint8Array || function() {
    };
    function _uint8ArrayToBuffer(chunk) {
      return Buffer2.from(chunk);
    }
    function _isUint8Array(obj2) {
      return Buffer2.isBuffer(obj2) || obj2 instanceof OurUint8Array;
    }
    var debugUtil = require("util");
    var debug;
    if (debugUtil && debugUtil.debuglog) {
      debug = debugUtil.debuglog("stream");
    } else {
      debug = function debug2() {
      };
    }
    var BufferList = require_buffer_list7();
    var destroyImpl = require_destroy10();
    var _require = require_state7();
    var getHighWaterMark = _require.getHighWaterMark;
    var _require$codes = require_errors7().codes;
    var ERR_INVALID_ARG_TYPE = _require$codes.ERR_INVALID_ARG_TYPE;
    var ERR_STREAM_PUSH_AFTER_EOF = _require$codes.ERR_STREAM_PUSH_AFTER_EOF;
    var ERR_METHOD_NOT_IMPLEMENTED = _require$codes.ERR_METHOD_NOT_IMPLEMENTED;
    var ERR_STREAM_UNSHIFT_AFTER_END_EVENT = _require$codes.ERR_STREAM_UNSHIFT_AFTER_END_EVENT;
    var StringDecoder;
    var createReadableStreamAsyncIterator;
    var from;
    require_inherits()(Readable, Stream);
    var errorOrDestroy = destroyImpl.errorOrDestroy;
    var kProxyEvents = ["error", "close", "destroy", "pause", "resume"];
    function prependListener(emitter, event, fn) {
      if (typeof emitter.prependListener === "function")
        return emitter.prependListener(event, fn);
      if (!emitter._events || !emitter._events[event])
        emitter.on(event, fn);
      else if (Array.isArray(emitter._events[event]))
        emitter._events[event].unshift(fn);
      else
        emitter._events[event] = [fn, emitter._events[event]];
    }
    function ReadableState(options, stream, isDuplex) {
      Duplex = Duplex || require_stream_duplex10();
      options = options || {};
      if (typeof isDuplex !== "boolean")
        isDuplex = stream instanceof Duplex;
      this.objectMode = !!options.objectMode;
      if (isDuplex)
        this.objectMode = this.objectMode || !!options.readableObjectMode;
      this.highWaterMark = getHighWaterMark(this, options, "readableHighWaterMark", isDuplex);
      this.buffer = new BufferList();
      this.length = 0;
      this.pipes = null;
      this.pipesCount = 0;
      this.flowing = null;
      this.ended = false;
      this.endEmitted = false;
      this.reading = false;
      this.sync = true;
      this.needReadable = false;
      this.emittedReadable = false;
      this.readableListening = false;
      this.resumeScheduled = false;
      this.paused = true;
      this.emitClose = options.emitClose !== false;
      this.autoDestroy = !!options.autoDestroy;
      this.destroyed = false;
      this.defaultEncoding = options.defaultEncoding || "utf8";
      this.awaitDrain = 0;
      this.readingMore = false;
      this.decoder = null;
      this.encoding = null;
      if (options.encoding) {
        if (!StringDecoder)
          StringDecoder = require_string_decoder10().StringDecoder;
        this.decoder = new StringDecoder(options.encoding);
        this.encoding = options.encoding;
      }
    }
    function Readable(options) {
      Duplex = Duplex || require_stream_duplex10();
      if (!(this instanceof Readable))
        return new Readable(options);
      var isDuplex = this instanceof Duplex;
      this._readableState = new ReadableState(options, this, isDuplex);
      this.readable = true;
      if (options) {
        if (typeof options.read === "function")
          this._read = options.read;
        if (typeof options.destroy === "function")
          this._destroy = options.destroy;
      }
      Stream.call(this);
    }
    Object.defineProperty(Readable.prototype, "destroyed", {
      // making it explicit this property is not enumerable
      // because otherwise some prototype manipulation in
      // userland will fail
      enumerable: false,
      get: function get() {
        if (this._readableState === void 0) {
          return false;
        }
        return this._readableState.destroyed;
      },
      set: function set(value) {
        if (!this._readableState) {
          return;
        }
        this._readableState.destroyed = value;
      }
    });
    Readable.prototype.destroy = destroyImpl.destroy;
    Readable.prototype._undestroy = destroyImpl.undestroy;
    Readable.prototype._destroy = function(err, cb) {
      cb(err);
    };
    Readable.prototype.push = function(chunk, encoding) {
      var state = this._readableState;
      var skipChunkCheck;
      if (!state.objectMode) {
        if (typeof chunk === "string") {
          encoding = encoding || state.defaultEncoding;
          if (encoding !== state.encoding) {
            chunk = Buffer2.from(chunk, encoding);
            encoding = "";
          }
          skipChunkCheck = true;
        }
      } else {
        skipChunkCheck = true;
      }
      return readableAddChunk(this, chunk, encoding, false, skipChunkCheck);
    };
    Readable.prototype.unshift = function(chunk) {
      return readableAddChunk(this, chunk, null, true, false);
    };
    function readableAddChunk(stream, chunk, encoding, addToFront, skipChunkCheck) {
      debug("readableAddChunk", chunk);
      var state = stream._readableState;
      if (chunk === null) {
        state.reading = false;
        onEofChunk(stream, state);
      } else {
        var er;
        if (!skipChunkCheck)
          er = chunkInvalid(state, chunk);
        if (er) {
          errorOrDestroy(stream, er);
        } else if (state.objectMode || chunk && chunk.length > 0) {
          if (typeof chunk !== "string" && !state.objectMode && Object.getPrototypeOf(chunk) !== Buffer2.prototype) {
            chunk = _uint8ArrayToBuffer(chunk);
          }
          if (addToFront) {
            if (state.endEmitted)
              errorOrDestroy(stream, new ERR_STREAM_UNSHIFT_AFTER_END_EVENT());
            else
              addChunk(stream, state, chunk, true);
          } else if (state.ended) {
            errorOrDestroy(stream, new ERR_STREAM_PUSH_AFTER_EOF());
          } else if (state.destroyed) {
            return false;
          } else {
            state.reading = false;
            if (state.decoder && !encoding) {
              chunk = state.decoder.write(chunk);
              if (state.objectMode || chunk.length !== 0)
                addChunk(stream, state, chunk, false);
              else
                maybeReadMore(stream, state);
            } else {
              addChunk(stream, state, chunk, false);
            }
          }
        } else if (!addToFront) {
          state.reading = false;
          maybeReadMore(stream, state);
        }
      }
      return !state.ended && (state.length < state.highWaterMark || state.length === 0);
    }
    function addChunk(stream, state, chunk, addToFront) {
      if (state.flowing && state.length === 0 && !state.sync) {
        state.awaitDrain = 0;
        stream.emit("data", chunk);
      } else {
        state.length += state.objectMode ? 1 : chunk.length;
        if (addToFront)
          state.buffer.unshift(chunk);
        else
          state.buffer.push(chunk);
        if (state.needReadable)
          emitReadable(stream);
      }
      maybeReadMore(stream, state);
    }
    function chunkInvalid(state, chunk) {
      var er;
      if (!_isUint8Array(chunk) && typeof chunk !== "string" && chunk !== void 0 && !state.objectMode) {
        er = new ERR_INVALID_ARG_TYPE("chunk", ["string", "Buffer", "Uint8Array"], chunk);
      }
      return er;
    }
    Readable.prototype.isPaused = function() {
      return this._readableState.flowing === false;
    };
    Readable.prototype.setEncoding = function(enc) {
      if (!StringDecoder)
        StringDecoder = require_string_decoder10().StringDecoder;
      var decoder = new StringDecoder(enc);
      this._readableState.decoder = decoder;
      this._readableState.encoding = this._readableState.decoder.encoding;
      var p = this._readableState.buffer.head;
      var content = "";
      while (p !== null) {
        content += decoder.write(p.data);
        p = p.next;
      }
      this._readableState.buffer.clear();
      if (content !== "")
        this._readableState.buffer.push(content);
      this._readableState.length = content.length;
      return this;
    };
    var MAX_HWM = 1073741824;
    function computeNewHighWaterMark(n) {
      if (n >= MAX_HWM) {
        n = MAX_HWM;
      } else {
        n--;
        n |= n >>> 1;
        n |= n >>> 2;
        n |= n >>> 4;
        n |= n >>> 8;
        n |= n >>> 16;
        n++;
      }
      return n;
    }
    function howMuchToRead(n, state) {
      if (n <= 0 || state.length === 0 && state.ended)
        return 0;
      if (state.objectMode)
        return 1;
      if (n !== n) {
        if (state.flowing && state.length)
          return state.buffer.head.data.length;
        else
          return state.length;
      }
      if (n > state.highWaterMark)
        state.highWaterMark = computeNewHighWaterMark(n);
      if (n <= state.length)
        return n;
      if (!state.ended) {
        state.needReadable = true;
        return 0;
      }
      return state.length;
    }
    Readable.prototype.read = function(n) {
      debug("read", n);
      n = parseInt(n, 10);
      var state = this._readableState;
      var nOrig = n;
      if (n !== 0)
        state.emittedReadable = false;
      if (n === 0 && state.needReadable && ((state.highWaterMark !== 0 ? state.length >= state.highWaterMark : state.length > 0) || state.ended)) {
        debug("read: emitReadable", state.length, state.ended);
        if (state.length === 0 && state.ended)
          endReadable(this);
        else
          emitReadable(this);
        return null;
      }
      n = howMuchToRead(n, state);
      if (n === 0 && state.ended) {
        if (state.length === 0)
          endReadable(this);
        return null;
      }
      var doRead = state.needReadable;
      debug("need readable", doRead);
      if (state.length === 0 || state.length - n < state.highWaterMark) {
        doRead = true;
        debug("length less than watermark", doRead);
      }
      if (state.ended || state.reading) {
        doRead = false;
        debug("reading or ended", doRead);
      } else if (doRead) {
        debug("do read");
        state.reading = true;
        state.sync = true;
        if (state.length === 0)
          state.needReadable = true;
        this._read(state.highWaterMark);
        state.sync = false;
        if (!state.reading)
          n = howMuchToRead(nOrig, state);
      }
      var ret2;
      if (n > 0)
        ret2 = fromList(n, state);
      else
        ret2 = null;
      if (ret2 === null) {
        state.needReadable = state.length <= state.highWaterMark;
        n = 0;
      } else {
        state.length -= n;
        state.awaitDrain = 0;
      }
      if (state.length === 0) {
        if (!state.ended)
          state.needReadable = true;
        if (nOrig !== n && state.ended)
          endReadable(this);
      }
      if (ret2 !== null)
        this.emit("data", ret2);
      return ret2;
    };
    function onEofChunk(stream, state) {
      debug("onEofChunk");
      if (state.ended)
        return;
      if (state.decoder) {
        var chunk = state.decoder.end();
        if (chunk && chunk.length) {
          state.buffer.push(chunk);
          state.length += state.objectMode ? 1 : chunk.length;
        }
      }
      state.ended = true;
      if (state.sync) {
        emitReadable(stream);
      } else {
        state.needReadable = false;
        if (!state.emittedReadable) {
          state.emittedReadable = true;
          emitReadable_(stream);
        }
      }
    }
    function emitReadable(stream) {
      var state = stream._readableState;
      debug("emitReadable", state.needReadable, state.emittedReadable);
      state.needReadable = false;
      if (!state.emittedReadable) {
        debug("emitReadable", state.flowing);
        state.emittedReadable = true;
        process.nextTick(emitReadable_, stream);
      }
    }
    function emitReadable_(stream) {
      var state = stream._readableState;
      debug("emitReadable_", state.destroyed, state.length, state.ended);
      if (!state.destroyed && (state.length || state.ended)) {
        stream.emit("readable");
        state.emittedReadable = false;
      }
      state.needReadable = !state.flowing && !state.ended && state.length <= state.highWaterMark;
      flow(stream);
    }
    function maybeReadMore(stream, state) {
      if (!state.readingMore) {
        state.readingMore = true;
        process.nextTick(maybeReadMore_, stream, state);
      }
    }
    function maybeReadMore_(stream, state) {
      while (!state.reading && !state.ended && (state.length < state.highWaterMark || state.flowing && state.length === 0)) {
        var len = state.length;
        debug("maybeReadMore read 0");
        stream.read(0);
        if (len === state.length)
          break;
      }
      state.readingMore = false;
    }
    Readable.prototype._read = function(n) {
      errorOrDestroy(this, new ERR_METHOD_NOT_IMPLEMENTED("_read()"));
    };
    Readable.prototype.pipe = function(dest, pipeOpts) {
      var src = this;
      var state = this._readableState;
      switch (state.pipesCount) {
        case 0:
          state.pipes = dest;
          break;
        case 1:
          state.pipes = [state.pipes, dest];
          break;
        default:
          state.pipes.push(dest);
          break;
      }
      state.pipesCount += 1;
      debug("pipe count=%d opts=%j", state.pipesCount, pipeOpts);
      var doEnd = (!pipeOpts || pipeOpts.end !== false) && dest !== process.stdout && dest !== process.stderr;
      var endFn = doEnd ? onend : unpipe;
      if (state.endEmitted)
        process.nextTick(endFn);
      else
        src.once("end", endFn);
      dest.on("unpipe", onunpipe);
      function onunpipe(readable, unpipeInfo) {
        debug("onunpipe");
        if (readable === src) {
          if (unpipeInfo && unpipeInfo.hasUnpiped === false) {
            unpipeInfo.hasUnpiped = true;
            cleanup();
          }
        }
      }
      function onend() {
        debug("onend");
        dest.end();
      }
      var ondrain = pipeOnDrain(src);
      dest.on("drain", ondrain);
      var cleanedUp = false;
      function cleanup() {
        debug("cleanup");
        dest.removeListener("close", onclose);
        dest.removeListener("finish", onfinish);
        dest.removeListener("drain", ondrain);
        dest.removeListener("error", onerror);
        dest.removeListener("unpipe", onunpipe);
        src.removeListener("end", onend);
        src.removeListener("end", unpipe);
        src.removeListener("data", ondata);
        cleanedUp = true;
        if (state.awaitDrain && (!dest._writableState || dest._writableState.needDrain))
          ondrain();
      }
      src.on("data", ondata);
      function ondata(chunk) {
        debug("ondata");
        var ret2 = dest.write(chunk);
        debug("dest.write", ret2);
        if (ret2 === false) {
          if ((state.pipesCount === 1 && state.pipes === dest || state.pipesCount > 1 && indexOf(state.pipes, dest) !== -1) && !cleanedUp) {
            debug("false write response, pause", state.awaitDrain);
            state.awaitDrain++;
          }
          src.pause();
        }
      }
      function onerror(er) {
        debug("onerror", er);
        unpipe();
        dest.removeListener("error", onerror);
        if (EElistenerCount(dest, "error") === 0)
          errorOrDestroy(dest, er);
      }
      prependListener(dest, "error", onerror);
      function onclose() {
        dest.removeListener("finish", onfinish);
        unpipe();
      }
      dest.once("close", onclose);
      function onfinish() {
        debug("onfinish");
        dest.removeListener("close", onclose);
        unpipe();
      }
      dest.once("finish", onfinish);
      function unpipe() {
        debug("unpipe");
        src.unpipe(dest);
      }
      dest.emit("pipe", src);
      if (!state.flowing) {
        debug("pipe resume");
        src.resume();
      }
      return dest;
    };
    function pipeOnDrain(src) {
      return function pipeOnDrainFunctionResult() {
        var state = src._readableState;
        debug("pipeOnDrain", state.awaitDrain);
        if (state.awaitDrain)
          state.awaitDrain--;
        if (state.awaitDrain === 0 && EElistenerCount(src, "data")) {
          state.flowing = true;
          flow(src);
        }
      };
    }
    Readable.prototype.unpipe = function(dest) {
      var state = this._readableState;
      var unpipeInfo = {
        hasUnpiped: false
      };
      if (state.pipesCount === 0)
        return this;
      if (state.pipesCount === 1) {
        if (dest && dest !== state.pipes)
          return this;
        if (!dest)
          dest = state.pipes;
        state.pipes = null;
        state.pipesCount = 0;
        state.flowing = false;
        if (dest)
          dest.emit("unpipe", this, unpipeInfo);
        return this;
      }
      if (!dest) {
        var dests = state.pipes;
        var len = state.pipesCount;
        state.pipes = null;
        state.pipesCount = 0;
        state.flowing = false;
        for (var i = 0; i < len; i++)
          dests[i].emit("unpipe", this, {
            hasUnpiped: false
          });
        return this;
      }
      var index = indexOf(state.pipes, dest);
      if (index === -1)
        return this;
      state.pipes.splice(index, 1);
      state.pipesCount -= 1;
      if (state.pipesCount === 1)
        state.pipes = state.pipes[0];
      dest.emit("unpipe", this, unpipeInfo);
      return this;
    };
    Readable.prototype.on = function(ev, fn) {
      var res = Stream.prototype.on.call(this, ev, fn);
      var state = this._readableState;
      if (ev === "data") {
        state.readableListening = this.listenerCount("readable") > 0;
        if (state.flowing !== false)
          this.resume();
      } else if (ev === "readable") {
        if (!state.endEmitted && !state.readableListening) {
          state.readableListening = state.needReadable = true;
          state.flowing = false;
          state.emittedReadable = false;
          debug("on readable", state.length, state.reading);
          if (state.length) {
            emitReadable(this);
          } else if (!state.reading) {
            process.nextTick(nReadingNextTick, this);
          }
        }
      }
      return res;
    };
    Readable.prototype.addListener = Readable.prototype.on;
    Readable.prototype.removeListener = function(ev, fn) {
      var res = Stream.prototype.removeListener.call(this, ev, fn);
      if (ev === "readable") {
        process.nextTick(updateReadableListening, this);
      }
      return res;
    };
    Readable.prototype.removeAllListeners = function(ev) {
      var res = Stream.prototype.removeAllListeners.apply(this, arguments);
      if (ev === "readable" || ev === void 0) {
        process.nextTick(updateReadableListening, this);
      }
      return res;
    };
    function updateReadableListening(self2) {
      var state = self2._readableState;
      state.readableListening = self2.listenerCount("readable") > 0;
      if (state.resumeScheduled && !state.paused) {
        state.flowing = true;
      } else if (self2.listenerCount("data") > 0) {
        self2.resume();
      }
    }
    function nReadingNextTick(self2) {
      debug("readable nexttick read 0");
      self2.read(0);
    }
    Readable.prototype.resume = function() {
      var state = this._readableState;
      if (!state.flowing) {
        debug("resume");
        state.flowing = !state.readableListening;
        resume(this, state);
      }
      state.paused = false;
      return this;
    };
    function resume(stream, state) {
      if (!state.resumeScheduled) {
        state.resumeScheduled = true;
        process.nextTick(resume_, stream, state);
      }
    }
    function resume_(stream, state) {
      debug("resume", state.reading);
      if (!state.reading) {
        stream.read(0);
      }
      state.resumeScheduled = false;
      stream.emit("resume");
      flow(stream);
      if (state.flowing && !state.reading)
        stream.read(0);
    }
    Readable.prototype.pause = function() {
      debug("call pause flowing=%j", this._readableState.flowing);
      if (this._readableState.flowing !== false) {
        debug("pause");
        this._readableState.flowing = false;
        this.emit("pause");
      }
      this._readableState.paused = true;
      return this;
    };
    function flow(stream) {
      var state = stream._readableState;
      debug("flow", state.flowing);
      while (state.flowing && stream.read() !== null)
        ;
    }
    Readable.prototype.wrap = function(stream) {
      var _this = this;
      var state = this._readableState;
      var paused = false;
      stream.on("end", function() {
        debug("wrapped end");
        if (state.decoder && !state.ended) {
          var chunk = state.decoder.end();
          if (chunk && chunk.length)
            _this.push(chunk);
        }
        _this.push(null);
      });
      stream.on("data", function(chunk) {
        debug("wrapped data");
        if (state.decoder)
          chunk = state.decoder.write(chunk);
        if (state.objectMode && (chunk === null || chunk === void 0))
          return;
        else if (!state.objectMode && (!chunk || !chunk.length))
          return;
        var ret2 = _this.push(chunk);
        if (!ret2) {
          paused = true;
          stream.pause();
        }
      });
      for (var i in stream) {
        if (this[i] === void 0 && typeof stream[i] === "function") {
          this[i] = /* @__PURE__ */ function methodWrap(method) {
            return function methodWrapReturnFunction() {
              return stream[method].apply(stream, arguments);
            };
          }(i);
        }
      }
      for (var n = 0; n < kProxyEvents.length; n++) {
        stream.on(kProxyEvents[n], this.emit.bind(this, kProxyEvents[n]));
      }
      this._read = function(n2) {
        debug("wrapped _read", n2);
        if (paused) {
          paused = false;
          stream.resume();
        }
      };
      return this;
    };
    if (typeof Symbol === "function") {
      Readable.prototype[Symbol.asyncIterator] = function() {
        if (createReadableStreamAsyncIterator === void 0) {
          createReadableStreamAsyncIterator = require_async_iterator7();
        }
        return createReadableStreamAsyncIterator(this);
      };
    }
    Object.defineProperty(Readable.prototype, "readableHighWaterMark", {
      // making it explicit this property is not enumerable
      // because otherwise some prototype manipulation in
      // userland will fail
      enumerable: false,
      get: function get() {
        return this._readableState.highWaterMark;
      }
    });
    Object.defineProperty(Readable.prototype, "readableBuffer", {
      // making it explicit this property is not enumerable
      // because otherwise some prototype manipulation in
      // userland will fail
      enumerable: false,
      get: function get() {
        return this._readableState && this._readableState.buffer;
      }
    });
    Object.defineProperty(Readable.prototype, "readableFlowing", {
      // making it explicit this property is not enumerable
      // because otherwise some prototype manipulation in
      // userland will fail
      enumerable: false,
      get: function get() {
        return this._readableState.flowing;
      },
      set: function set(state) {
        if (this._readableState) {
          this._readableState.flowing = state;
        }
      }
    });
    Readable._fromList = fromList;
    Object.defineProperty(Readable.prototype, "readableLength", {
      // making it explicit this property is not enumerable
      // because otherwise some prototype manipulation in
      // userland will fail
      enumerable: false,
      get: function get() {
        return this._readableState.length;
      }
    });
    function fromList(n, state) {
      if (state.length === 0)
        return null;
      var ret2;
      if (state.objectMode)
        ret2 = state.buffer.shift();
      else if (!n || n >= state.length) {
        if (state.decoder)
          ret2 = state.buffer.join("");
        else if (state.buffer.length === 1)
          ret2 = state.buffer.first();
        else
          ret2 = state.buffer.concat(state.length);
        state.buffer.clear();
      } else {
        ret2 = state.buffer.consume(n, state.decoder);
      }
      return ret2;
    }
    function endReadable(stream) {
      var state = stream._readableState;
      debug("endReadable", state.endEmitted);
      if (!state.endEmitted) {
        state.ended = true;
        process.nextTick(endReadableNT, state, stream);
      }
    }
    function endReadableNT(state, stream) {
      debug("endReadableNT", state.endEmitted, state.length);
      if (!state.endEmitted && state.length === 0) {
        state.endEmitted = true;
        stream.readable = false;
        stream.emit("end");
        if (state.autoDestroy) {
          var wState = stream._writableState;
          if (!wState || wState.autoDestroy && wState.finished) {
            stream.destroy();
          }
        }
      }
    }
    if (typeof Symbol === "function") {
      Readable.from = function(iterable, opts) {
        if (from === void 0) {
          from = require_from7();
        }
        return from(Readable, iterable, opts);
      };
    }
    function indexOf(xs, x) {
      for (var i = 0, l2 = xs.length; i < l2; i++) {
        if (xs[i] === x)
          return i;
      }
      return -1;
    }
  }
});

// ../../../node_modules/tar-stream/node_modules/readable-stream/lib/_stream_transform.js
var require_stream_transform10 = __commonJS({
  "../../../node_modules/tar-stream/node_modules/readable-stream/lib/_stream_transform.js"(exports2, module2) {
    "use strict";
    module2.exports = Transform;
    var _require$codes = require_errors7().codes;
    var ERR_METHOD_NOT_IMPLEMENTED = _require$codes.ERR_METHOD_NOT_IMPLEMENTED;
    var ERR_MULTIPLE_CALLBACK = _require$codes.ERR_MULTIPLE_CALLBACK;
    var ERR_TRANSFORM_ALREADY_TRANSFORMING = _require$codes.ERR_TRANSFORM_ALREADY_TRANSFORMING;
    var ERR_TRANSFORM_WITH_LENGTH_0 = _require$codes.ERR_TRANSFORM_WITH_LENGTH_0;
    var Duplex = require_stream_duplex10();
    require_inherits()(Transform, Duplex);
    function afterTransform(er, data) {
      var ts = this._transformState;
      ts.transforming = false;
      var cb = ts.writecb;
      if (cb === null) {
        return this.emit("error", new ERR_MULTIPLE_CALLBACK());
      }
      ts.writechunk = null;
      ts.writecb = null;
      if (data != null)
        this.push(data);
      cb(er);
      var rs = this._readableState;
      rs.reading = false;
      if (rs.needReadable || rs.length < rs.highWaterMark) {
        this._read(rs.highWaterMark);
      }
    }
    function Transform(options) {
      if (!(this instanceof Transform))
        return new Transform(options);
      Duplex.call(this, options);
      this._transformState = {
        afterTransform: afterTransform.bind(this),
        needTransform: false,
        transforming: false,
        writecb: null,
        writechunk: null,
        writeencoding: null
      };
      this._readableState.needReadable = true;
      this._readableState.sync = false;
      if (options) {
        if (typeof options.transform === "function")
          this._transform = options.transform;
        if (typeof options.flush === "function")
          this._flush = options.flush;
      }
      this.on("prefinish", prefinish);
    }
    function prefinish() {
      var _this = this;
      if (typeof this._flush === "function" && !this._readableState.destroyed) {
        this._flush(function(er, data) {
          done(_this, er, data);
        });
      } else {
        done(this, null, null);
      }
    }
    Transform.prototype.push = function(chunk, encoding) {
      this._transformState.needTransform = false;
      return Duplex.prototype.push.call(this, chunk, encoding);
    };
    Transform.prototype._transform = function(chunk, encoding, cb) {
      cb(new ERR_METHOD_NOT_IMPLEMENTED("_transform()"));
    };
    Transform.prototype._write = function(chunk, encoding, cb) {
      var ts = this._transformState;
      ts.writecb = cb;
      ts.writechunk = chunk;
      ts.writeencoding = encoding;
      if (!ts.transforming) {
        var rs = this._readableState;
        if (ts.needTransform || rs.needReadable || rs.length < rs.highWaterMark)
          this._read(rs.highWaterMark);
      }
    };
    Transform.prototype._read = function(n) {
      var ts = this._transformState;
      if (ts.writechunk !== null && !ts.transforming) {
        ts.transforming = true;
        this._transform(ts.writechunk, ts.writeencoding, ts.afterTransform);
      } else {
        ts.needTransform = true;
      }
    };
    Transform.prototype._destroy = function(err, cb) {
      Duplex.prototype._destroy.call(this, err, function(err2) {
        cb(err2);
      });
    };
    function done(stream, er, data) {
      if (er)
        return stream.emit("error", er);
      if (data != null)
        stream.push(data);
      if (stream._writableState.length)
        throw new ERR_TRANSFORM_WITH_LENGTH_0();
      if (stream._transformState.transforming)
        throw new ERR_TRANSFORM_ALREADY_TRANSFORMING();
      return stream.push(null);
    }
  }
});

// ../../../node_modules/tar-stream/node_modules/readable-stream/lib/_stream_passthrough.js
var require_stream_passthrough10 = __commonJS({
  "../../../node_modules/tar-stream/node_modules/readable-stream/lib/_stream_passthrough.js"(exports2, module2) {
    "use strict";
    module2.exports = PassThrough;
    var Transform = require_stream_transform10();
    require_inherits()(PassThrough, Transform);
    function PassThrough(options) {
      if (!(this instanceof PassThrough))
        return new PassThrough(options);
      Transform.call(this, options);
    }
    PassThrough.prototype._transform = function(chunk, encoding, cb) {
      cb(null, chunk);
    };
  }
});

// ../../../node_modules/tar-stream/node_modules/readable-stream/lib/internal/streams/pipeline.js
var require_pipeline7 = __commonJS({
  "../../../node_modules/tar-stream/node_modules/readable-stream/lib/internal/streams/pipeline.js"(exports2, module2) {
    "use strict";
    var eos;
    function once(callback) {
      var called = false;
      return function() {
        if (called)
          return;
        called = true;
        callback.apply(void 0, arguments);
      };
    }
    var _require$codes = require_errors7().codes;
    var ERR_MISSING_ARGS = _require$codes.ERR_MISSING_ARGS;
    var ERR_STREAM_DESTROYED = _require$codes.ERR_STREAM_DESTROYED;
    function noop(err) {
      if (err)
        throw err;
    }
    function isRequest(stream) {
      return stream.setHeader && typeof stream.abort === "function";
    }
    function destroyer(stream, reading, writing, callback) {
      callback = once(callback);
      var closed = false;
      stream.on("close", function() {
        closed = true;
      });
      if (eos === void 0)
        eos = require_end_of_stream7();
      eos(stream, {
        readable: reading,
        writable: writing
      }, function(err) {
        if (err)
          return callback(err);
        closed = true;
        callback();
      });
      var destroyed = false;
      return function(err) {
        if (closed)
          return;
        if (destroyed)
          return;
        destroyed = true;
        if (isRequest(stream))
          return stream.abort();
        if (typeof stream.destroy === "function")
          return stream.destroy();
        callback(err || new ERR_STREAM_DESTROYED("pipe"));
      };
    }
    function call(fn) {
      fn();
    }
    function pipe(from, to) {
      return from.pipe(to);
    }
    function popCallback(streams) {
      if (!streams.length)
        return noop;
      if (typeof streams[streams.length - 1] !== "function")
        return noop;
      return streams.pop();
    }
    function pipeline() {
      for (var _len = arguments.length, streams = new Array(_len), _key = 0; _key < _len; _key++) {
        streams[_key] = arguments[_key];
      }
      var callback = popCallback(streams);
      if (Array.isArray(streams[0]))
        streams = streams[0];
      if (streams.length < 2) {
        throw new ERR_MISSING_ARGS("streams");
      }
      var error;
      var destroys = streams.map(function(stream, i) {
        var reading = i < streams.length - 1;
        var writing = i > 0;
        return destroyer(stream, reading, writing, function(err) {
          if (!error)
            error = err;
          if (err)
            destroys.forEach(call);
          if (reading)
            return;
          destroys.forEach(call);
          callback(error);
        });
      });
      return streams.reduce(pipe);
    }
    module2.exports = pipeline;
  }
});

// ../../../node_modules/tar-stream/node_modules/readable-stream/readable.js
var require_readable10 = __commonJS({
  "../../../node_modules/tar-stream/node_modules/readable-stream/readable.js"(exports2, module2) {
    var Stream = require("stream");
    if (process.env.READABLE_STREAM === "disable" && Stream) {
      module2.exports = Stream.Readable;
      Object.assign(module2.exports, Stream);
      module2.exports.Stream = Stream;
    } else {
      exports2 = module2.exports = require_stream_readable10();
      exports2.Stream = Stream || exports2;
      exports2.Readable = exports2;
      exports2.Writable = require_stream_writable10();
      exports2.Duplex = require_stream_duplex10();
      exports2.Transform = require_stream_transform10();
      exports2.PassThrough = require_stream_passthrough10();
      exports2.finished = require_end_of_stream7();
      exports2.pipeline = require_pipeline7();
    }
  }
});

// ../../../node_modules/tar-stream/extract.js
var require_extract = __commonJS({
  "../../../node_modules/tar-stream/extract.js"(exports2, module2) {
    var util = require("util");
    var bl = require_bl();
    var headers = require_headers();
    var Writable = require_readable10().Writable;
    var PassThrough = require_readable10().PassThrough;
    var noop = function() {
    };
    var overflow = function(size) {
      size &= 511;
      return size && 512 - size;
    };
    var emptyStream = function(self2, offset) {
      var s = new Source(self2, offset);
      s.end();
      return s;
    };
    var mixinPax = function(header, pax) {
      if (pax.path)
        header.name = pax.path;
      if (pax.linkpath)
        header.linkname = pax.linkpath;
      if (pax.size)
        header.size = parseInt(pax.size, 10);
      header.pax = pax;
      return header;
    };
    var Source = function(self2, offset) {
      this._parent = self2;
      this.offset = offset;
      PassThrough.call(this, { autoDestroy: false });
    };
    util.inherits(Source, PassThrough);
    Source.prototype.destroy = function(err) {
      this._parent.destroy(err);
    };
    var Extract = function(opts) {
      if (!(this instanceof Extract))
        return new Extract(opts);
      Writable.call(this, opts);
      opts = opts || {};
      this._offset = 0;
      this._buffer = bl();
      this._missing = 0;
      this._partial = false;
      this._onparse = noop;
      this._header = null;
      this._stream = null;
      this._overflow = null;
      this._cb = null;
      this._locked = false;
      this._destroyed = false;
      this._pax = null;
      this._paxGlobal = null;
      this._gnuLongPath = null;
      this._gnuLongLinkPath = null;
      var self2 = this;
      var b = self2._buffer;
      var oncontinue = function() {
        self2._continue();
      };
      var onunlock = function(err) {
        self2._locked = false;
        if (err)
          return self2.destroy(err);
        if (!self2._stream)
          oncontinue();
      };
      var onstreamend = function() {
        self2._stream = null;
        var drain = overflow(self2._header.size);
        if (drain)
          self2._parse(drain, ondrain);
        else
          self2._parse(512, onheader);
        if (!self2._locked)
          oncontinue();
      };
      var ondrain = function() {
        self2._buffer.consume(overflow(self2._header.size));
        self2._parse(512, onheader);
        oncontinue();
      };
      var onpaxglobalheader = function() {
        var size = self2._header.size;
        self2._paxGlobal = headers.decodePax(b.slice(0, size));
        b.consume(size);
        onstreamend();
      };
      var onpaxheader = function() {
        var size = self2._header.size;
        self2._pax = headers.decodePax(b.slice(0, size));
        if (self2._paxGlobal)
          self2._pax = Object.assign({}, self2._paxGlobal, self2._pax);
        b.consume(size);
        onstreamend();
      };
      var ongnulongpath = function() {
        var size = self2._header.size;
        this._gnuLongPath = headers.decodeLongPath(b.slice(0, size), opts.filenameEncoding);
        b.consume(size);
        onstreamend();
      };
      var ongnulonglinkpath = function() {
        var size = self2._header.size;
        this._gnuLongLinkPath = headers.decodeLongPath(b.slice(0, size), opts.filenameEncoding);
        b.consume(size);
        onstreamend();
      };
      var onheader = function() {
        var offset = self2._offset;
        var header;
        try {
          header = self2._header = headers.decode(b.slice(0, 512), opts.filenameEncoding, opts.allowUnknownFormat);
        } catch (err) {
          self2.emit("error", err);
        }
        b.consume(512);
        if (!header) {
          self2._parse(512, onheader);
          oncontinue();
          return;
        }
        if (header.type === "gnu-long-path") {
          self2._parse(header.size, ongnulongpath);
          oncontinue();
          return;
        }
        if (header.type === "gnu-long-link-path") {
          self2._parse(header.size, ongnulonglinkpath);
          oncontinue();
          return;
        }
        if (header.type === "pax-global-header") {
          self2._parse(header.size, onpaxglobalheader);
          oncontinue();
          return;
        }
        if (header.type === "pax-header") {
          self2._parse(header.size, onpaxheader);
          oncontinue();
          return;
        }
        if (self2._gnuLongPath) {
          header.name = self2._gnuLongPath;
          self2._gnuLongPath = null;
        }
        if (self2._gnuLongLinkPath) {
          header.linkname = self2._gnuLongLinkPath;
          self2._gnuLongLinkPath = null;
        }
        if (self2._pax) {
          self2._header = header = mixinPax(header, self2._pax);
          self2._pax = null;
        }
        self2._locked = true;
        if (!header.size || header.type === "directory") {
          self2._parse(512, onheader);
          self2.emit("entry", header, emptyStream(self2, offset), onunlock);
          return;
        }
        self2._stream = new Source(self2, offset);
        self2.emit("entry", header, self2._stream, onunlock);
        self2._parse(header.size, onstreamend);
        oncontinue();
      };
      this._onheader = onheader;
      this._parse(512, onheader);
    };
    util.inherits(Extract, Writable);
    Extract.prototype.destroy = function(err) {
      if (this._destroyed)
        return;
      this._destroyed = true;
      if (err)
        this.emit("error", err);
      this.emit("close");
      if (this._stream)
        this._stream.emit("close");
    };
    Extract.prototype._parse = function(size, onparse) {
      if (this._destroyed)
        return;
      this._offset += size;
      this._missing = size;
      if (onparse === this._onheader)
        this._partial = false;
      this._onparse = onparse;
    };
    Extract.prototype._continue = function() {
      if (this._destroyed)
        return;
      var cb = this._cb;
      this._cb = noop;
      if (this._overflow)
        this._write(this._overflow, void 0, cb);
      else
        cb();
    };
    Extract.prototype._write = function(data, enc, cb) {
      if (this._destroyed)
        return;
      var s = this._stream;
      var b = this._buffer;
      var missing = this._missing;
      if (data.length)
        this._partial = true;
      if (data.length < missing) {
        this._missing -= data.length;
        this._overflow = null;
        if (s)
          return s.write(data, cb);
        b.append(data);
        return cb();
      }
      this._cb = cb;
      this._missing = 0;
      var overflow2 = null;
      if (data.length > missing) {
        overflow2 = data.slice(missing);
        data = data.slice(0, missing);
      }
      if (s)
        s.end(data);
      else
        b.append(data);
      this._overflow = overflow2;
      this._onparse();
    };
    Extract.prototype._final = function(cb) {
      if (this._partial)
        return this.destroy(new Error("Unexpected end of data"));
      cb();
    };
    module2.exports = Extract;
  }
});

// ../../../node_modules/fs-constants/index.js
var require_fs_constants = __commonJS({
  "../../../node_modules/fs-constants/index.js"(exports2, module2) {
    module2.exports = require("fs").constants || require("constants");
  }
});

// ../../../node_modules/end-of-stream/index.js
var require_end_of_stream8 = __commonJS({
  "../../../node_modules/end-of-stream/index.js"(exports2, module2) {
    var once = require_once();
    var noop = function() {
    };
    var isRequest = function(stream) {
      return stream.setHeader && typeof stream.abort === "function";
    };
    var isChildProcess = function(stream) {
      return stream.stdio && Array.isArray(stream.stdio) && stream.stdio.length === 3;
    };
    var eos = function(stream, opts, callback) {
      if (typeof opts === "function")
        return eos(stream, null, opts);
      if (!opts)
        opts = {};
      callback = once(callback || noop);
      var ws = stream._writableState;
      var rs = stream._readableState;
      var readable = opts.readable || opts.readable !== false && stream.readable;
      var writable = opts.writable || opts.writable !== false && stream.writable;
      var cancelled = false;
      var onlegacyfinish = function() {
        if (!stream.writable)
          onfinish();
      };
      var onfinish = function() {
        writable = false;
        if (!readable)
          callback.call(stream);
      };
      var onend = function() {
        readable = false;
        if (!writable)
          callback.call(stream);
      };
      var onexit = function(exitCode) {
        callback.call(stream, exitCode ? new Error("exited with error code: " + exitCode) : null);
      };
      var onerror = function(err) {
        callback.call(stream, err);
      };
      var onclose = function() {
        process.nextTick(onclosenexttick);
      };
      var onclosenexttick = function() {
        if (cancelled)
          return;
        if (readable && !(rs && (rs.ended && !rs.destroyed)))
          return callback.call(stream, new Error("premature close"));
        if (writable && !(ws && (ws.ended && !ws.destroyed)))
          return callback.call(stream, new Error("premature close"));
      };
      var onrequest = function() {
        stream.req.on("finish", onfinish);
      };
      if (isRequest(stream)) {
        stream.on("complete", onfinish);
        stream.on("abort", onclose);
        if (stream.req)
          onrequest();
        else
          stream.on("request", onrequest);
      } else if (writable && !ws) {
        stream.on("end", onlegacyfinish);
        stream.on("close", onlegacyfinish);
      }
      if (isChildProcess(stream))
        stream.on("exit", onexit);
      stream.on("end", onend);
      stream.on("finish", onfinish);
      if (opts.error !== false)
        stream.on("error", onerror);
      stream.on("close", onclose);
      return function() {
        cancelled = true;
        stream.removeListener("complete", onfinish);
        stream.removeListener("abort", onclose);
        stream.removeListener("request", onrequest);
        if (stream.req)
          stream.req.removeListener("finish", onfinish);
        stream.removeListener("end", onlegacyfinish);
        stream.removeListener("close", onlegacyfinish);
        stream.removeListener("finish", onfinish);
        stream.removeListener("exit", onexit);
        stream.removeListener("end", onend);
        stream.removeListener("error", onerror);
        stream.removeListener("close", onclose);
      };
    };
    module2.exports = eos;
  }
});

// ../../../node_modules/tar-stream/pack.js
var require_pack = __commonJS({
  "../../../node_modules/tar-stream/pack.js"(exports2, module2) {
    var constants = require_fs_constants();
    var eos = require_end_of_stream8();
    var inherits2 = require_inherits();
    var alloc = Buffer.alloc;
    var Readable = require_readable10().Readable;
    var Writable = require_readable10().Writable;
    var StringDecoder = require("string_decoder").StringDecoder;
    var headers = require_headers();
    var DMODE = parseInt("755", 8);
    var FMODE = parseInt("644", 8);
    var END_OF_TAR = alloc(1024);
    var noop = function() {
    };
    var overflow = function(self2, size) {
      size &= 511;
      if (size)
        self2.push(END_OF_TAR.slice(0, 512 - size));
    };
    function modeToType(mode) {
      switch (mode & constants.S_IFMT) {
        case constants.S_IFBLK:
          return "block-device";
        case constants.S_IFCHR:
          return "character-device";
        case constants.S_IFDIR:
          return "directory";
        case constants.S_IFIFO:
          return "fifo";
        case constants.S_IFLNK:
          return "symlink";
      }
      return "file";
    }
    var Sink = function(to) {
      Writable.call(this);
      this.written = 0;
      this._to = to;
      this._destroyed = false;
    };
    inherits2(Sink, Writable);
    Sink.prototype._write = function(data, enc, cb) {
      this.written += data.length;
      if (this._to.push(data))
        return cb();
      this._to._drain = cb;
    };
    Sink.prototype.destroy = function() {
      if (this._destroyed)
        return;
      this._destroyed = true;
      this.emit("close");
    };
    var LinkSink = function() {
      Writable.call(this);
      this.linkname = "";
      this._decoder = new StringDecoder("utf-8");
      this._destroyed = false;
    };
    inherits2(LinkSink, Writable);
    LinkSink.prototype._write = function(data, enc, cb) {
      this.linkname += this._decoder.write(data);
      cb();
    };
    LinkSink.prototype.destroy = function() {
      if (this._destroyed)
        return;
      this._destroyed = true;
      this.emit("close");
    };
    var Void = function() {
      Writable.call(this);
      this._destroyed = false;
    };
    inherits2(Void, Writable);
    Void.prototype._write = function(data, enc, cb) {
      cb(new Error("No body allowed for this entry"));
    };
    Void.prototype.destroy = function() {
      if (this._destroyed)
        return;
      this._destroyed = true;
      this.emit("close");
    };
    var Pack = function(opts) {
      if (!(this instanceof Pack))
        return new Pack(opts);
      Readable.call(this, opts);
      this._drain = noop;
      this._finalized = false;
      this._finalizing = false;
      this._destroyed = false;
      this._stream = null;
    };
    inherits2(Pack, Readable);
    Pack.prototype.entry = function(header, buffer, callback) {
      if (this._stream)
        throw new Error("already piping an entry");
      if (this._finalized || this._destroyed)
        return;
      if (typeof buffer === "function") {
        callback = buffer;
        buffer = null;
      }
      if (!callback)
        callback = noop;
      var self2 = this;
      if (!header.size || header.type === "symlink")
        header.size = 0;
      if (!header.type)
        header.type = modeToType(header.mode);
      if (!header.mode)
        header.mode = header.type === "directory" ? DMODE : FMODE;
      if (!header.uid)
        header.uid = 0;
      if (!header.gid)
        header.gid = 0;
      if (!header.mtime)
        header.mtime = /* @__PURE__ */ new Date();
      if (typeof buffer === "string")
        buffer = Buffer.from(buffer);
      if (Buffer.isBuffer(buffer)) {
        header.size = buffer.length;
        this._encode(header);
        var ok = this.push(buffer);
        overflow(self2, header.size);
        if (ok)
          process.nextTick(callback);
        else
          this._drain = callback;
        return new Void();
      }
      if (header.type === "symlink" && !header.linkname) {
        var linkSink = new LinkSink();
        eos(linkSink, function(err) {
          if (err) {
            self2.destroy();
            return callback(err);
          }
          header.linkname = linkSink.linkname;
          self2._encode(header);
          callback();
        });
        return linkSink;
      }
      this._encode(header);
      if (header.type !== "file" && header.type !== "contiguous-file") {
        process.nextTick(callback);
        return new Void();
      }
      var sink = new Sink(this);
      this._stream = sink;
      eos(sink, function(err) {
        self2._stream = null;
        if (err) {
          self2.destroy();
          return callback(err);
        }
        if (sink.written !== header.size) {
          self2.destroy();
          return callback(new Error("size mismatch"));
        }
        overflow(self2, header.size);
        if (self2._finalizing)
          self2.finalize();
        callback();
      });
      return sink;
    };
    Pack.prototype.finalize = function() {
      if (this._stream) {
        this._finalizing = true;
        return;
      }
      if (this._finalized)
        return;
      this._finalized = true;
      this.push(END_OF_TAR);
      this.push(null);
    };
    Pack.prototype.destroy = function(err) {
      if (this._destroyed)
        return;
      this._destroyed = true;
      if (err)
        this.emit("error", err);
      this.emit("close");
      if (this._stream && this._stream.destroy)
        this._stream.destroy();
    };
    Pack.prototype._encode = function(header) {
      if (!header.pax) {
        var buf = headers.encode(header);
        if (buf) {
          this.push(buf);
          return;
        }
      }
      this._encodePax(header);
    };
    Pack.prototype._encodePax = function(header) {
      var paxHeader = headers.encodePax({
        name: header.name,
        linkname: header.linkname,
        pax: header.pax
      });
      var newHeader = {
        name: "PaxHeader",
        mode: header.mode,
        uid: header.uid,
        gid: header.gid,
        size: paxHeader.length,
        mtime: header.mtime,
        type: "pax-header",
        linkname: header.linkname && "PaxHeader",
        uname: header.uname,
        gname: header.gname,
        devmajor: header.devmajor,
        devminor: header.devminor
      };
      this.push(headers.encode(newHeader));
      this.push(paxHeader);
      overflow(this, paxHeader.length);
      newHeader.size = header.size;
      newHeader.type = header.type;
      this.push(headers.encode(newHeader));
    };
    Pack.prototype._read = function(n) {
      var drain = this._drain;
      this._drain = noop;
      drain();
    };
    module2.exports = Pack;
  }
});

// ../../../node_modules/tar-stream/index.js
var require_tar_stream = __commonJS({
  "../../../node_modules/tar-stream/index.js"(exports2) {
    exports2.extract = require_extract();
    exports2.pack = require_pack();
  }
});

// ../../../node_modules/archiver/lib/plugins/tar.js
var require_tar = __commonJS({
  "../../../node_modules/archiver/lib/plugins/tar.js"(exports2, module2) {
    var zlib = require("zlib");
    var engine = require_tar_stream();
    var util = require_archiver_utils();
    var Tar = function(options) {
      if (!(this instanceof Tar)) {
        return new Tar(options);
      }
      options = this.options = util.defaults(options, {
        gzip: false
      });
      if (typeof options.gzipOptions !== "object") {
        options.gzipOptions = {};
      }
      this.supports = {
        directory: true,
        symlink: true
      };
      this.engine = engine.pack(options);
      this.compressor = false;
      if (options.gzip) {
        this.compressor = zlib.createGzip(options.gzipOptions);
        this.compressor.on("error", this._onCompressorError.bind(this));
      }
    };
    Tar.prototype._onCompressorError = function(err) {
      this.engine.emit("error", err);
    };
    Tar.prototype.append = function(source, data, callback) {
      var self2 = this;
      data.mtime = data.date;
      function append(err, sourceBuffer) {
        if (err) {
          callback(err);
          return;
        }
        self2.engine.entry(data, sourceBuffer, function(err2) {
          callback(err2, data);
        });
      }
      if (data.sourceType === "buffer") {
        append(null, source);
      } else if (data.sourceType === "stream" && data.stats) {
        data.size = data.stats.size;
        var entry = self2.engine.entry(data, function(err) {
          callback(err, data);
        });
        source.pipe(entry);
      } else if (data.sourceType === "stream") {
        util.collectStream(source, append);
      }
    };
    Tar.prototype.finalize = function() {
      this.engine.finalize();
    };
    Tar.prototype.on = function() {
      return this.engine.on.apply(this.engine, arguments);
    };
    Tar.prototype.pipe = function(destination, options) {
      if (this.compressor) {
        return this.engine.pipe.apply(this.engine, [this.compressor]).pipe(destination, options);
      } else {
        return this.engine.pipe.apply(this.engine, arguments);
      }
    };
    Tar.prototype.unpipe = function() {
      if (this.compressor) {
        return this.compressor.unpipe.apply(this.compressor, arguments);
      } else {
        return this.engine.unpipe.apply(this.engine, arguments);
      }
    };
    module2.exports = Tar;
  }
});

// ../../../node_modules/archiver/lib/plugins/json.js
var require_json = __commonJS({
  "../../../node_modules/archiver/lib/plugins/json.js"(exports2, module2) {
    var inherits2 = require("util").inherits;
    var Transform = require_readable5().Transform;
    var crc32 = require_buffer_crc32();
    var util = require_archiver_utils();
    var Json = function(options) {
      if (!(this instanceof Json)) {
        return new Json(options);
      }
      options = this.options = util.defaults(options, {});
      Transform.call(this, options);
      this.supports = {
        directory: true,
        symlink: true
      };
      this.files = [];
    };
    inherits2(Json, Transform);
    Json.prototype._transform = function(chunk, encoding, callback) {
      callback(null, chunk);
    };
    Json.prototype._writeStringified = function() {
      var fileString = JSON.stringify(this.files);
      this.write(fileString);
    };
    Json.prototype.append = function(source, data, callback) {
      var self2 = this;
      data.crc32 = 0;
      function onend(err, sourceBuffer) {
        if (err) {
          callback(err);
          return;
        }
        data.size = sourceBuffer.length || 0;
        data.crc32 = crc32.unsigned(sourceBuffer);
        self2.files.push(data);
        callback(null, data);
      }
      if (data.sourceType === "buffer") {
        onend(null, source);
      } else if (data.sourceType === "stream") {
        util.collectStream(source, onend);
      }
    };
    Json.prototype.finalize = function() {
      this._writeStringified();
      this.end();
    };
    module2.exports = Json;
  }
});

// ../../../node_modules/archiver/index.js
var require_archiver = __commonJS({
  "../../../node_modules/archiver/index.js"(exports2, module2) {
    var Archiver = require_core();
    var formats = {};
    var vending = function(format, options) {
      return vending.create(format, options);
    };
    vending.create = function(format, options) {
      if (formats[format]) {
        var instance = new Archiver(format, options);
        instance.setFormat(format);
        instance.setModule(new formats[format](options));
        return instance;
      } else {
        throw new Error("create(" + format + "): format not registered");
      }
    };
    vending.registerFormat = function(format, module3) {
      if (formats[format]) {
        throw new Error("register(" + format + "): format already registered");
      }
      if (typeof module3 !== "function") {
        throw new Error("register(" + format + "): format module invalid");
      }
      if (typeof module3.prototype.append !== "function" || typeof module3.prototype.finalize !== "function") {
        throw new Error("register(" + format + "): format module missing methods");
      }
      formats[format] = module3;
    };
    vending.isRegisteredFormat = function(format) {
      if (formats[format]) {
        return true;
      }
      return false;
    };
    vending.registerFormat("zip", require_zip());
    vending.registerFormat("tar", require_tar());
    vending.registerFormat("json", require_json());
    module2.exports = vending;
  }
});

// ../../../node_modules/exceljs/lib/utils/shared-strings.js
var require_shared_strings = __commonJS({
  "../../../node_modules/exceljs/lib/utils/shared-strings.js"(exports2, module2) {
    var SharedStrings = class {
      constructor() {
        this._values = [];
        this._totalRefs = 0;
        this._hash = /* @__PURE__ */ Object.create(null);
      }
      get count() {
        return this._values.length;
      }
      get values() {
        return this._values;
      }
      get totalRefs() {
        return this._totalRefs;
      }
      getString(index) {
        return this._values[index];
      }
      add(value) {
        let index = this._hash[value];
        if (index === void 0) {
          index = this._hash[value] = this._values.length;
          this._values.push(value);
        }
        this._totalRefs++;
        return index;
      }
    };
    module2.exports = SharedStrings;
  }
});

// ../../../node_modules/exceljs/lib/stream/xlsx/sheet-rels-writer.js
var require_sheet_rels_writer = __commonJS({
  "../../../node_modules/exceljs/lib/stream/xlsx/sheet-rels-writer.js"(exports2, module2) {
    var utils = require_utils2();
    var RelType = require_rel_type();
    var HyperlinksProxy = class {
      constructor(sheetRelsWriter) {
        this.writer = sheetRelsWriter;
      }
      push(hyperlink) {
        this.writer.addHyperlink(hyperlink);
      }
    };
    var SheetRelsWriter = class {
      constructor(options) {
        this.id = options.id;
        this.count = 0;
        this._hyperlinks = [];
        this._workbook = options.workbook;
      }
      get stream() {
        if (!this._stream) {
          this._stream = this._workbook._openStream(`/xl/worksheets/_rels/sheet${this.id}.xml.rels`);
        }
        return this._stream;
      }
      get length() {
        return this._hyperlinks.length;
      }
      each(fn) {
        return this._hyperlinks.forEach(fn);
      }
      get hyperlinksProxy() {
        return this._hyperlinksProxy || (this._hyperlinksProxy = new HyperlinksProxy(this));
      }
      addHyperlink(hyperlink) {
        const relationship = {
          Target: hyperlink.target,
          Type: RelType.Hyperlink,
          TargetMode: "External"
        };
        const rId = this._writeRelationship(relationship);
        this._hyperlinks.push({
          rId,
          address: hyperlink.address
        });
      }
      addMedia(media) {
        return this._writeRelationship(media);
      }
      addRelationship(rel) {
        return this._writeRelationship(rel);
      }
      commit() {
        if (this.count) {
          this._writeClose();
          this.stream.end();
        }
      }
      // ================================================================================
      _writeOpen() {
        this.stream.write(
          `<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
       <Relationships xmlns="http://schemas.openxmlformats.org/package/2006/relationships">`
        );
      }
      _writeRelationship(relationship) {
        if (!this.count) {
          this._writeOpen();
        }
        const rId = `rId${++this.count}`;
        if (relationship.TargetMode) {
          this.stream.write(
            `<Relationship Id="${rId}" Type="${relationship.Type}" Target="${utils.xmlEncode(relationship.Target)}" TargetMode="${relationship.TargetMode}"/>`
          );
        } else {
          this.stream.write(
            `<Relationship Id="${rId}" Type="${relationship.Type}" Target="${relationship.Target}"/>`
          );
        }
        return rId;
      }
      _writeClose() {
        this.stream.write("</Relationships>");
      }
    };
    module2.exports = SheetRelsWriter;
  }
});

// ../../../node_modules/exceljs/lib/stream/xlsx/sheet-comments-writer.js
var require_sheet_comments_writer = __commonJS({
  "../../../node_modules/exceljs/lib/stream/xlsx/sheet-comments-writer.js"(exports2, module2) {
    var XmlStream = require_xml_stream();
    var RelType = require_rel_type();
    var colCache = require_col_cache();
    var CommentXform = require_comment_xform();
    var VmlShapeXform = require_vml_shape_xform();
    var SheetCommentsWriter = class {
      constructor(worksheet, sheetRelsWriter, options) {
        this.id = options.id;
        this.count = 0;
        this._worksheet = worksheet;
        this._workbook = options.workbook;
        this._sheetRelsWriter = sheetRelsWriter;
      }
      get commentsStream() {
        if (!this._commentsStream) {
          this._commentsStream = this._workbook._openStream(`/xl/comments${this.id}.xml`);
        }
        return this._commentsStream;
      }
      get vmlStream() {
        if (!this._vmlStream) {
          this._vmlStream = this._workbook._openStream(`xl/drawings/vmlDrawing${this.id}.vml`);
        }
        return this._vmlStream;
      }
      _addRelationships() {
        const commentRel = {
          Type: RelType.Comments,
          Target: `../comments${this.id}.xml`
        };
        this._sheetRelsWriter.addRelationship(commentRel);
        const vmlDrawingRel = {
          Type: RelType.VmlDrawing,
          Target: `../drawings/vmlDrawing${this.id}.vml`
        };
        this.vmlRelId = this._sheetRelsWriter.addRelationship(vmlDrawingRel);
      }
      _addCommentRefs() {
        this._workbook.commentRefs.push({
          commentName: `comments${this.id}`,
          vmlDrawing: `vmlDrawing${this.id}`
        });
      }
      _writeOpen() {
        this.commentsStream.write(
          '<?xml version="1.0" encoding="UTF-8" standalone="yes"?><comments xmlns="http://schemas.openxmlformats.org/spreadsheetml/2006/main"><authors><author>Author</author></authors><commentList>'
        );
        this.vmlStream.write(
          '<?xml version="1.0" encoding="UTF-8"?><xml xmlns:o="urn:schemas-microsoft-com:office:office" xmlns:v="urn:schemas-microsoft-com:vml" xmlns:x="urn:schemas-microsoft-com:office:excel"><o:shapelayout v:ext="edit"><o:idmap v:ext="edit" data="1" /></o:shapelayout><v:shapetype id="_x0000_t202" coordsize="21600,21600" o:spt="202" path="m,l,21600r21600,l21600,xe"><v:stroke joinstyle="miter" /><v:path gradientshapeok="t" o:connecttype="rect" /></v:shapetype>'
        );
      }
      _writeComment(comment, index) {
        const commentXform = new CommentXform();
        const commentsXmlStream = new XmlStream();
        commentXform.render(commentsXmlStream, comment);
        this.commentsStream.write(commentsXmlStream.xml);
        const vmlShapeXform = new VmlShapeXform();
        const vmlXmlStream = new XmlStream();
        vmlShapeXform.render(vmlXmlStream, comment, index);
        this.vmlStream.write(vmlXmlStream.xml);
      }
      _writeClose() {
        this.commentsStream.write("</commentList></comments>");
        this.vmlStream.write("</xml>");
      }
      addComments(comments) {
        if (comments && comments.length) {
          if (!this.startedData) {
            this._worksheet.comments = [];
            this._writeOpen();
            this._addRelationships();
            this._addCommentRefs();
            this.startedData = true;
          }
          comments.forEach((item) => {
            item.refAddress = colCache.decodeAddress(item.ref);
          });
          comments.forEach((comment) => {
            this._writeComment(comment, this.count);
            this.count += 1;
          });
        }
      }
      commit() {
        if (this.count) {
          this._writeClose();
          this.commentsStream.end();
          this.vmlStream.end();
        }
      }
    };
    module2.exports = SheetCommentsWriter;
  }
});

// ../../../node_modules/exceljs/lib/stream/xlsx/worksheet-writer.js
var require_worksheet_writer = __commonJS({
  "../../../node_modules/exceljs/lib/stream/xlsx/worksheet-writer.js"(exports2, module2) {
    var _2 = require_under_dash();
    var RelType = require_rel_type();
    var colCache = require_col_cache();
    var Encryptor = require_encryptor();
    var Dimensions = require_range();
    var StringBuf = require_string_buf();
    var Row = require_row();
    var Column = require_column();
    var SheetRelsWriter = require_sheet_rels_writer();
    var SheetCommentsWriter = require_sheet_comments_writer();
    var DataValidations = require_data_validations();
    var xmlBuffer = new StringBuf();
    var ListXform = require_list_xform();
    var DataValidationsXform = require_data_validations_xform();
    var SheetPropertiesXform = require_sheet_properties_xform();
    var SheetFormatPropertiesXform = require_sheet_format_properties_xform();
    var ColXform = require_col_xform();
    var RowXform = require_row_xform();
    var HyperlinkXform = require_hyperlink_xform();
    var SheetViewXform = require_sheet_view_xform();
    var SheetProtectionXform = require_sheet_protection_xform();
    var PageMarginsXform = require_page_margins_xform();
    var PageSetupXform = require_page_setup_xform();
    var AutoFilterXform = require_auto_filter_xform();
    var PictureXform = require_picture_xform();
    var ConditionalFormattingsXform = require_conditional_formattings_xform();
    var HeaderFooterXform = require_header_footer_xform();
    var RowBreaksXform = require_row_breaks_xform();
    var xform = {
      dataValidations: new DataValidationsXform(),
      sheetProperties: new SheetPropertiesXform(),
      sheetFormatProperties: new SheetFormatPropertiesXform(),
      columns: new ListXform({ tag: "cols", length: false, childXform: new ColXform() }),
      row: new RowXform(),
      hyperlinks: new ListXform({ tag: "hyperlinks", length: false, childXform: new HyperlinkXform() }),
      sheetViews: new ListXform({ tag: "sheetViews", length: false, childXform: new SheetViewXform() }),
      sheetProtection: new SheetProtectionXform(),
      pageMargins: new PageMarginsXform(),
      pageSeteup: new PageSetupXform(),
      autoFilter: new AutoFilterXform(),
      picture: new PictureXform(),
      conditionalFormattings: new ConditionalFormattingsXform(),
      headerFooter: new HeaderFooterXform(),
      rowBreaks: new RowBreaksXform()
    };
    var WorksheetWriter = class {
      constructor(options) {
        this.id = options.id;
        this.name = options.name || `Sheet${this.id}`;
        this.state = options.state || "visible";
        this._rows = [];
        this._columns = null;
        this._keys = {};
        this._merges = [];
        this._merges.add = function() {
        };
        this._sheetRelsWriter = new SheetRelsWriter(options);
        this._sheetCommentsWriter = new SheetCommentsWriter(this, this._sheetRelsWriter, options);
        this._dimensions = new Dimensions();
        this._rowZero = 1;
        this.committed = false;
        this.dataValidations = new DataValidations();
        this._formulae = {};
        this._siFormulae = 0;
        this.conditionalFormatting = [];
        this.rowBreaks = [];
        this.properties = Object.assign(
          {},
          {
            defaultRowHeight: 15,
            dyDescent: 55,
            outlineLevelCol: 0,
            outlineLevelRow: 0
          },
          options.properties
        );
        this.headerFooter = Object.assign(
          {},
          {
            differentFirst: false,
            differentOddEven: false,
            oddHeader: null,
            oddFooter: null,
            evenHeader: null,
            evenFooter: null,
            firstHeader: null,
            firstFooter: null
          },
          options.headerFooter
        );
        this.pageSetup = Object.assign(
          {},
          {
            margins: { left: 0.7, right: 0.7, top: 0.75, bottom: 0.75, header: 0.3, footer: 0.3 },
            orientation: "portrait",
            horizontalDpi: 4294967295,
            verticalDpi: 4294967295,
            fitToPage: !!(options.pageSetup && (options.pageSetup.fitToWidth || options.pageSetup.fitToHeight) && !options.pageSetup.scale),
            pageOrder: "downThenOver",
            blackAndWhite: false,
            draft: false,
            cellComments: "None",
            errors: "displayed",
            scale: 100,
            fitToWidth: 1,
            fitToHeight: 1,
            paperSize: void 0,
            showRowColHeaders: false,
            showGridLines: false,
            horizontalCentered: false,
            verticalCentered: false,
            rowBreaks: null,
            colBreaks: null
          },
          options.pageSetup
        );
        this.useSharedStrings = options.useSharedStrings || false;
        this._workbook = options.workbook;
        this.hasComments = false;
        this._views = options.views || [];
        this.autoFilter = options.autoFilter || null;
        this._media = [];
        this.sheetProtection = null;
        this._writeOpenWorksheet();
        this.startedData = false;
      }
      get workbook() {
        return this._workbook;
      }
      get stream() {
        if (!this._stream) {
          this._stream = this._workbook._openStream(`/xl/worksheets/sheet${this.id}.xml`);
          this._stream.pause();
        }
        return this._stream;
      }
      // destroy - not a valid operation for a streaming writer
      // even though some streamers might be able to, it's a bad idea.
      destroy() {
        throw new Error("Invalid Operation: destroy");
      }
      commit() {
        if (this.committed) {
          return;
        }
        this._rows.forEach((cRow) => {
          if (cRow) {
            this._writeRow(cRow);
          }
        });
        this._rows = null;
        if (!this.startedData) {
          this._writeOpenSheetData();
        }
        this._writeCloseSheetData();
        this._writeAutoFilter();
        this._writeMergeCells();
        this._writeHyperlinks();
        this._writeConditionalFormatting();
        this._writeDataValidations();
        this._writeSheetProtection();
        this._writePageMargins();
        this._writePageSetup();
        this._writeBackground();
        this._writeHeaderFooter();
        this._writeRowBreaks();
        this._writeLegacyData();
        this._writeCloseWorksheet();
        this.stream.end();
        this._sheetCommentsWriter.commit();
        this._sheetRelsWriter.commit();
        this.committed = true;
      }
      // return the current dimensions of the writer
      get dimensions() {
        return this._dimensions;
      }
      get views() {
        return this._views;
      }
      // =========================================================================
      // Columns
      // get the current columns array.
      get columns() {
        return this._columns;
      }
      // set the columns from an array of column definitions.
      // Note: any headers defined will overwrite existing values.
      set columns(value) {
        this._headerRowCount = value.reduce((pv, cv) => {
          const headerCount = cv.header && 1 || cv.headers && cv.headers.length || 0;
          return Math.max(pv, headerCount);
        }, 0);
        let count = 1;
        const columns = this._columns = [];
        value.forEach((defn) => {
          const column = new Column(this, count++, false);
          columns.push(column);
          column.defn = defn;
        });
      }
      getColumnKey(key) {
        return this._keys[key];
      }
      setColumnKey(key, value) {
        this._keys[key] = value;
      }
      deleteColumnKey(key) {
        delete this._keys[key];
      }
      eachColumnKey(f) {
        _2.each(this._keys, f);
      }
      // get a single column by col number. If it doesn't exist, it and any gaps before it
      // are created.
      getColumn(c) {
        if (typeof c === "string") {
          const col = this._keys[c];
          if (col)
            return col;
          c = colCache.l2n(c);
        }
        if (!this._columns) {
          this._columns = [];
        }
        if (c > this._columns.length) {
          let n = this._columns.length + 1;
          while (n <= c) {
            this._columns.push(new Column(this, n++));
          }
        }
        return this._columns[c - 1];
      }
      // =========================================================================
      // Rows
      get _nextRow() {
        return this._rowZero + this._rows.length;
      }
      // iterate over every uncommitted row in the worksheet, including maybe empty rows
      eachRow(options, iteratee) {
        if (!iteratee) {
          iteratee = options;
          options = void 0;
        }
        if (options && options.includeEmpty) {
          const n = this._nextRow;
          for (let i = this._rowZero; i < n; i++) {
            iteratee(this.getRow(i), i);
          }
        } else {
          this._rows.forEach((row) => {
            if (row.hasValues) {
              iteratee(row, row.number);
            }
          });
        }
      }
      _commitRow(cRow) {
        let found = false;
        while (this._rows.length && !found) {
          const row = this._rows.shift();
          this._rowZero++;
          if (row) {
            this._writeRow(row);
            found = row.number === cRow.number;
            this._rowZero = row.number + 1;
          }
        }
      }
      get lastRow() {
        if (this._rows.length) {
          return this._rows[this._rows.length - 1];
        }
        return void 0;
      }
      // find a row (if exists) by row number
      findRow(rowNumber) {
        const index = rowNumber - this._rowZero;
        return this._rows[index];
      }
      getRow(rowNumber) {
        const index = rowNumber - this._rowZero;
        if (index < 0) {
          throw new Error("Out of bounds: this row has been committed");
        }
        let row = this._rows[index];
        if (!row) {
          this._rows[index] = row = new Row(this, rowNumber);
        }
        return row;
      }
      addRow(value) {
        const row = new Row(this, this._nextRow);
        this._rows[row.number - this._rowZero] = row;
        row.values = value;
        return row;
      }
      // ================================================================================
      // Cells
      // returns the cell at [r,c] or address given by r. If not found, return undefined
      findCell(r, c) {
        const address = colCache.getAddress(r, c);
        const row = this.findRow(address.row);
        return row ? row.findCell(address.column) : void 0;
      }
      // return the cell at [r,c] or address given by r. If not found, create a new one.
      getCell(r, c) {
        const address = colCache.getAddress(r, c);
        const row = this.getRow(address.row);
        return row.getCellEx(address);
      }
      mergeCells(...cells) {
        const dimensions = new Dimensions(cells);
        this._merges.forEach((merge) => {
          if (merge.intersects(dimensions)) {
            throw new Error("Cannot merge already merged cells");
          }
        });
        const master = this.getCell(dimensions.top, dimensions.left);
        for (let i = dimensions.top; i <= dimensions.bottom; i++) {
          for (let j = dimensions.left; j <= dimensions.right; j++) {
            if (i > dimensions.top || j > dimensions.left) {
              this.getCell(i, j).merge(master);
            }
          }
        }
        this._merges.push(dimensions);
      }
      // ===========================================================================
      // Conditional Formatting
      addConditionalFormatting(cf) {
        this.conditionalFormatting.push(cf);
      }
      removeConditionalFormatting(filter) {
        if (typeof filter === "number") {
          this.conditionalFormatting.splice(filter, 1);
        } else if (filter instanceof Function) {
          this.conditionalFormatting = this.conditionalFormatting.filter(filter);
        } else {
          this.conditionalFormatting = [];
        }
      }
      // =========================================================================
      addBackgroundImage(imageId) {
        this._background = {
          imageId
        };
      }
      getBackgroundImageId() {
        return this._background && this._background.imageId;
      }
      // =========================================================================
      // Worksheet Protection
      protect(password, options) {
        return new Promise((resolve) => {
          this.sheetProtection = {
            sheet: true
          };
          if (options && "spinCount" in options) {
            options.spinCount = Number.isFinite(options.spinCount) ? Math.round(Math.max(0, options.spinCount)) : 1e5;
          }
          if (password) {
            this.sheetProtection.algorithmName = "SHA-512";
            this.sheetProtection.saltValue = Encryptor.randomBytes(16).toString("base64");
            this.sheetProtection.spinCount = options && "spinCount" in options ? options.spinCount : 1e5;
            this.sheetProtection.hashValue = Encryptor.convertPasswordToHash(
              password,
              "SHA512",
              this.sheetProtection.saltValue,
              this.sheetProtection.spinCount
            );
          }
          if (options) {
            this.sheetProtection = Object.assign(this.sheetProtection, options);
            if (!password && "spinCount" in options) {
              delete this.sheetProtection.spinCount;
            }
          }
          resolve();
        });
      }
      unprotect() {
        this.sheetProtection = null;
      }
      // ================================================================================
      _write(text) {
        xmlBuffer.reset();
        xmlBuffer.addText(text);
        this.stream.write(xmlBuffer);
      }
      _writeSheetProperties(xmlBuf, properties, pageSetup) {
        const sheetPropertiesModel = {
          outlineProperties: properties && properties.outlineProperties,
          tabColor: properties && properties.tabColor,
          pageSetup: pageSetup && pageSetup.fitToPage ? {
            fitToPage: pageSetup.fitToPage
          } : void 0
        };
        xmlBuf.addText(xform.sheetProperties.toXml(sheetPropertiesModel));
      }
      _writeSheetFormatProperties(xmlBuf, properties) {
        const sheetFormatPropertiesModel = properties ? {
          defaultRowHeight: properties.defaultRowHeight,
          dyDescent: properties.dyDescent,
          outlineLevelCol: properties.outlineLevelCol,
          outlineLevelRow: properties.outlineLevelRow
        } : void 0;
        if (properties.defaultColWidth) {
          sheetFormatPropertiesModel.defaultColWidth = properties.defaultColWidth;
        }
        xmlBuf.addText(xform.sheetFormatProperties.toXml(sheetFormatPropertiesModel));
      }
      _writeOpenWorksheet() {
        xmlBuffer.reset();
        xmlBuffer.addText('<?xml version="1.0" encoding="UTF-8" standalone="yes"?>');
        xmlBuffer.addText(
          '<worksheet xmlns="http://schemas.openxmlformats.org/spreadsheetml/2006/main" xmlns:r="http://schemas.openxmlformats.org/officeDocument/2006/relationships" xmlns:mc="http://schemas.openxmlformats.org/markup-compatibility/2006" mc:Ignorable="x14ac" xmlns:x14ac="http://schemas.microsoft.com/office/spreadsheetml/2009/9/ac">'
        );
        this._writeSheetProperties(xmlBuffer, this.properties, this.pageSetup);
        xmlBuffer.addText(xform.sheetViews.toXml(this.views));
        this._writeSheetFormatProperties(xmlBuffer, this.properties);
        this.stream.write(xmlBuffer);
      }
      _writeColumns() {
        const cols = Column.toModel(this.columns);
        if (cols) {
          xform.columns.prepare(cols, { styles: this._workbook.styles });
          this.stream.write(xform.columns.toXml(cols));
        }
      }
      _writeOpenSheetData() {
        this._write("<sheetData>");
      }
      _writeRow(row) {
        if (!this.startedData) {
          this._writeColumns();
          this._writeOpenSheetData();
          this.startedData = true;
        }
        if (row.hasValues || row.height) {
          const { model } = row;
          const options = {
            styles: this._workbook.styles,
            sharedStrings: this.useSharedStrings ? this._workbook.sharedStrings : void 0,
            hyperlinks: this._sheetRelsWriter.hyperlinksProxy,
            merges: this._merges,
            formulae: this._formulae,
            siFormulae: this._siFormulae,
            comments: []
          };
          xform.row.prepare(model, options);
          this.stream.write(xform.row.toXml(model));
          if (options.comments.length) {
            this.hasComments = true;
            this._sheetCommentsWriter.addComments(options.comments);
          }
        }
      }
      _writeCloseSheetData() {
        this._write("</sheetData>");
      }
      _writeMergeCells() {
        if (this._merges.length) {
          xmlBuffer.reset();
          xmlBuffer.addText(`<mergeCells count="${this._merges.length}">`);
          this._merges.forEach((merge) => {
            xmlBuffer.addText(`<mergeCell ref="${merge}"/>`);
          });
          xmlBuffer.addText("</mergeCells>");
          this.stream.write(xmlBuffer);
        }
      }
      _writeHyperlinks() {
        this.stream.write(xform.hyperlinks.toXml(this._sheetRelsWriter._hyperlinks));
      }
      _writeConditionalFormatting() {
        const options = {
          styles: this._workbook.styles
        };
        xform.conditionalFormattings.prepare(this.conditionalFormatting, options);
        this.stream.write(xform.conditionalFormattings.toXml(this.conditionalFormatting));
      }
      _writeRowBreaks() {
        this.stream.write(xform.rowBreaks.toXml(this.rowBreaks));
      }
      _writeDataValidations() {
        this.stream.write(xform.dataValidations.toXml(this.dataValidations.model));
      }
      _writeSheetProtection() {
        this.stream.write(xform.sheetProtection.toXml(this.sheetProtection));
      }
      _writePageMargins() {
        this.stream.write(xform.pageMargins.toXml(this.pageSetup.margins));
      }
      _writePageSetup() {
        this.stream.write(xform.pageSeteup.toXml(this.pageSetup));
      }
      _writeHeaderFooter() {
        this.stream.write(xform.headerFooter.toXml(this.headerFooter));
      }
      _writeAutoFilter() {
        this.stream.write(xform.autoFilter.toXml(this.autoFilter));
      }
      _writeBackground() {
        if (this._background) {
          if (this._background.imageId !== void 0) {
            const image = this._workbook.getImage(this._background.imageId);
            const pictureId = this._sheetRelsWriter.addMedia({
              Target: `../media/${image.name}`,
              Type: RelType.Image
            });
            this._background = {
              ...this._background,
              rId: pictureId
            };
          }
          this.stream.write(xform.picture.toXml({ rId: this._background.rId }));
        }
      }
      _writeLegacyData() {
        if (this.hasComments) {
          xmlBuffer.reset();
          xmlBuffer.addText(`<legacyDrawing r:id="${this._sheetCommentsWriter.vmlRelId}"/>`);
          this.stream.write(xmlBuffer);
        }
      }
      _writeDimensions() {
      }
      _writeCloseWorksheet() {
        this._write("</worksheet>");
      }
    };
    module2.exports = WorksheetWriter;
  }
});

// ../../../node_modules/exceljs/lib/stream/xlsx/workbook-writer.js
var require_workbook_writer = __commonJS({
  "../../../node_modules/exceljs/lib/stream/xlsx/workbook-writer.js"(exports2, module2) {
    var fs = require("fs");
    var Archiver = require_archiver();
    var StreamBuf = require_stream_buf();
    var RelType = require_rel_type();
    var StylesXform = require_styles_xform();
    var SharedStrings = require_shared_strings();
    var DefinedNames = require_defined_names();
    var CoreXform = require_core_xform();
    var RelationshipsXform = require_relationships_xform();
    var ContentTypesXform = require_content_types_xform();
    var AppXform = require_app_xform();
    var WorkbookXform = require_workbook_xform();
    var SharedStringsXform = require_shared_strings_xform();
    var WorksheetWriter = require_worksheet_writer();
    var theme1Xml = require_theme1();
    var WorkbookWriter = class {
      constructor(options) {
        options = options || {};
        this.created = options.created || /* @__PURE__ */ new Date();
        this.modified = options.modified || this.created;
        this.creator = options.creator || "ExcelJS";
        this.lastModifiedBy = options.lastModifiedBy || "ExcelJS";
        this.lastPrinted = options.lastPrinted;
        this.useSharedStrings = options.useSharedStrings || false;
        this.sharedStrings = new SharedStrings();
        this.styles = options.useStyles ? new StylesXform(true) : new StylesXform.Mock(true);
        this._definedNames = new DefinedNames();
        this._worksheets = [];
        this.views = [];
        this.zipOptions = options.zip;
        this.media = [];
        this.commentRefs = [];
        this.zip = Archiver("zip", this.zipOptions);
        if (options.stream) {
          this.stream = options.stream;
        } else if (options.filename) {
          this.stream = fs.createWriteStream(options.filename);
        } else {
          this.stream = new StreamBuf();
        }
        this.zip.pipe(this.stream);
        this.promise = Promise.all([this.addThemes(), this.addOfficeRels()]);
      }
      get definedNames() {
        return this._definedNames;
      }
      _openStream(path) {
        const stream = new StreamBuf({ bufSize: 65536, batch: true });
        this.zip.append(stream, { name: path });
        stream.on("finish", () => {
          stream.emit("zipped");
        });
        return stream;
      }
      _commitWorksheets() {
        const commitWorksheet = function(worksheet) {
          if (!worksheet.committed) {
            return new Promise((resolve) => {
              worksheet.stream.on("zipped", () => {
                resolve();
              });
              worksheet.commit();
            });
          }
          return Promise.resolve();
        };
        const promises = this._worksheets.map(commitWorksheet);
        if (promises.length) {
          return Promise.all(promises);
        }
        return Promise.resolve();
      }
      async commit() {
        await this.promise;
        await this.addMedia();
        await this._commitWorksheets();
        await Promise.all([
          this.addContentTypes(),
          this.addApp(),
          this.addCore(),
          this.addSharedStrings(),
          this.addStyles(),
          this.addWorkbookRels()
        ]);
        await this.addWorkbook();
        return this._finalize();
      }
      get nextId() {
        let i;
        for (i = 1; i < this._worksheets.length; i++) {
          if (!this._worksheets[i]) {
            return i;
          }
        }
        return this._worksheets.length || 1;
      }
      addImage(image) {
        const id = this.media.length;
        const medium = Object.assign({}, image, { type: "image", name: `image${id}.${image.extension}` });
        this.media.push(medium);
        return id;
      }
      getImage(id) {
        return this.media[id];
      }
      addWorksheet(name, options) {
        options = options || {};
        const useSharedStrings = options.useSharedStrings !== void 0 ? options.useSharedStrings : this.useSharedStrings;
        if (options.tabColor) {
          console.trace("tabColor option has moved to { properties: tabColor: {...} }");
          options.properties = Object.assign(
            {
              tabColor: options.tabColor
            },
            options.properties
          );
        }
        const id = this.nextId;
        name = name || `sheet${id}`;
        const worksheet = new WorksheetWriter({
          id,
          name,
          workbook: this,
          useSharedStrings,
          properties: options.properties,
          state: options.state,
          pageSetup: options.pageSetup,
          views: options.views,
          autoFilter: options.autoFilter,
          headerFooter: options.headerFooter
        });
        this._worksheets[id] = worksheet;
        return worksheet;
      }
      getWorksheet(id) {
        if (id === void 0) {
          return this._worksheets.find(() => true);
        }
        if (typeof id === "number") {
          return this._worksheets[id];
        }
        if (typeof id === "string") {
          return this._worksheets.find((worksheet) => worksheet && worksheet.name === id);
        }
        return void 0;
      }
      addStyles() {
        return new Promise((resolve) => {
          this.zip.append(this.styles.xml, { name: "xl/styles.xml" });
          resolve();
        });
      }
      addThemes() {
        return new Promise((resolve) => {
          this.zip.append(theme1Xml, { name: "xl/theme/theme1.xml" });
          resolve();
        });
      }
      addOfficeRels() {
        return new Promise((resolve) => {
          const xform = new RelationshipsXform();
          const xml = xform.toXml([
            { Id: "rId1", Type: RelType.OfficeDocument, Target: "xl/workbook.xml" },
            { Id: "rId2", Type: RelType.CoreProperties, Target: "docProps/core.xml" },
            { Id: "rId3", Type: RelType.ExtenderProperties, Target: "docProps/app.xml" }
          ]);
          this.zip.append(xml, { name: "/_rels/.rels" });
          resolve();
        });
      }
      addContentTypes() {
        return new Promise((resolve) => {
          const model = {
            worksheets: this._worksheets.filter(Boolean),
            sharedStrings: this.sharedStrings,
            commentRefs: this.commentRefs,
            media: this.media
          };
          const xform = new ContentTypesXform();
          const xml = xform.toXml(model);
          this.zip.append(xml, { name: "[Content_Types].xml" });
          resolve();
        });
      }
      addMedia() {
        return Promise.all(
          this.media.map((medium) => {
            if (medium.type === "image") {
              const filename = `xl/media/${medium.name}`;
              if (medium.filename) {
                return this.zip.file(medium.filename, { name: filename });
              }
              if (medium.buffer) {
                return this.zip.append(medium.buffer, { name: filename });
              }
              if (medium.base64) {
                const dataimg64 = medium.base64;
                const content = dataimg64.substring(dataimg64.indexOf(",") + 1);
                return this.zip.append(content, { name: filename, base64: true });
              }
            }
            throw new Error("Unsupported media");
          })
        );
      }
      addApp() {
        return new Promise((resolve) => {
          const model = {
            worksheets: this._worksheets.filter(Boolean)
          };
          const xform = new AppXform();
          const xml = xform.toXml(model);
          this.zip.append(xml, { name: "docProps/app.xml" });
          resolve();
        });
      }
      addCore() {
        return new Promise((resolve) => {
          const coreXform = new CoreXform();
          const xml = coreXform.toXml(this);
          this.zip.append(xml, { name: "docProps/core.xml" });
          resolve();
        });
      }
      addSharedStrings() {
        if (this.sharedStrings.count) {
          return new Promise((resolve) => {
            const sharedStringsXform = new SharedStringsXform();
            const xml = sharedStringsXform.toXml(this.sharedStrings);
            this.zip.append(xml, { name: "/xl/sharedStrings.xml" });
            resolve();
          });
        }
        return Promise.resolve();
      }
      addWorkbookRels() {
        let count = 1;
        const relationships = [
          { Id: `rId${count++}`, Type: RelType.Styles, Target: "styles.xml" },
          { Id: `rId${count++}`, Type: RelType.Theme, Target: "theme/theme1.xml" }
        ];
        if (this.sharedStrings.count) {
          relationships.push({
            Id: `rId${count++}`,
            Type: RelType.SharedStrings,
            Target: "sharedStrings.xml"
          });
        }
        this._worksheets.forEach((worksheet) => {
          if (worksheet) {
            worksheet.rId = `rId${count++}`;
            relationships.push({
              Id: worksheet.rId,
              Type: RelType.Worksheet,
              Target: `worksheets/sheet${worksheet.id}.xml`
            });
          }
        });
        return new Promise((resolve) => {
          const xform = new RelationshipsXform();
          const xml = xform.toXml(relationships);
          this.zip.append(xml, { name: "/xl/_rels/workbook.xml.rels" });
          resolve();
        });
      }
      addWorkbook() {
        const { zip } = this;
        const model = {
          worksheets: this._worksheets.filter(Boolean),
          definedNames: this._definedNames.model,
          views: this.views,
          properties: {},
          calcProperties: {}
        };
        return new Promise((resolve) => {
          const xform = new WorkbookXform();
          xform.prepare(model);
          zip.append(xform.toXml(model), { name: "/xl/workbook.xml" });
          resolve();
        });
      }
      _finalize() {
        return new Promise((resolve, reject) => {
          this.stream.on("error", reject);
          this.stream.on("finish", () => {
            resolve(this);
          });
          this.zip.on("error", reject);
          this.zip.finalize();
        });
      }
    };
    module2.exports = WorkbookWriter;
  }
});

// ../../../node_modules/listenercount/index.js
var require_listenercount = __commonJS({
  "../../../node_modules/listenercount/index.js"(exports2, module2) {
    "use strict";
    var listenerCount = require("events").listenerCount;
    listenerCount = listenerCount || function(ee, event) {
      var listeners = ee && ee._events && ee._events[event];
      if (Array.isArray(listeners)) {
        return listeners.length;
      } else if (typeof listeners === "function") {
        return 1;
      } else {
        return 0;
      }
    };
    module2.exports = listenerCount;
  }
});

// ../../../node_modules/buffer-indexof-polyfill/init-buffer.js
var require_init_buffer = __commonJS({
  "../../../node_modules/buffer-indexof-polyfill/init-buffer.js"(exports2, module2) {
    module2.exports = function initBuffer(val) {
      var nodeVersion = process && process.version ? process.version : "v5.0.0";
      var major = nodeVersion.split(".")[0].replace("v", "");
      return major < 6 ? new Buffer(val) : Buffer.from(val);
    };
  }
});

// ../../../node_modules/buffer-indexof-polyfill/index.js
var require_buffer_indexof_polyfill = __commonJS({
  "../../../node_modules/buffer-indexof-polyfill/index.js"() {
    "use strict";
    var initBuffer = require_init_buffer();
    if (!Buffer.prototype.indexOf) {
      Buffer.prototype.indexOf = function(value, offset) {
        offset = offset || 0;
        if (typeof value === "string" || value instanceof String) {
          value = initBuffer(value);
        } else if (typeof value === "number" || value instanceof Number) {
          value = initBuffer([value]);
        }
        var len = value.length;
        for (var i = offset; i <= this.length - len; i++) {
          var mismatch = false;
          for (var j = 0; j < len; j++) {
            if (this[i + j] != value[j]) {
              mismatch = true;
              break;
            }
          }
          if (!mismatch) {
            return i;
          }
        }
        return -1;
      };
    }
    function bufferLastIndexOf(value, offset) {
      if (typeof value === "string" || value instanceof String) {
        value = initBuffer(value);
      } else if (typeof value === "number" || value instanceof Number) {
        value = initBuffer([value]);
      }
      var len = value.length;
      offset = offset || this.length - len;
      for (var i = offset; i >= 0; i--) {
        var mismatch = false;
        for (var j = 0; j < len; j++) {
          if (this[i + j] != value[j]) {
            mismatch = true;
            break;
          }
        }
        if (!mismatch) {
          return i;
        }
      }
      return -1;
    }
    if (Buffer.prototype.lastIndexOf) {
      if (initBuffer("ABC").lastIndexOf("ABC") === -1)
        Buffer.prototype.lastIndexOf = bufferLastIndexOf;
    } else {
      Buffer.prototype.lastIndexOf = bufferLastIndexOf;
    }
  }
});

// ../../../node_modules/traverse/index.js
var require_traverse = __commonJS({
  "../../../node_modules/traverse/index.js"(exports2, module2) {
    module2.exports = Traverse;
    function Traverse(obj2) {
      if (!(this instanceof Traverse))
        return new Traverse(obj2);
      this.value = obj2;
    }
    Traverse.prototype.get = function(ps) {
      var node = this.value;
      for (var i = 0; i < ps.length; i++) {
        var key = ps[i];
        if (!Object.hasOwnProperty.call(node, key)) {
          node = void 0;
          break;
        }
        node = node[key];
      }
      return node;
    };
    Traverse.prototype.set = function(ps, value) {
      var node = this.value;
      for (var i = 0; i < ps.length - 1; i++) {
        var key = ps[i];
        if (!Object.hasOwnProperty.call(node, key))
          node[key] = {};
        node = node[key];
      }
      node[ps[i]] = value;
      return value;
    };
    Traverse.prototype.map = function(cb) {
      return walk(this.value, cb, true);
    };
    Traverse.prototype.forEach = function(cb) {
      this.value = walk(this.value, cb, false);
      return this.value;
    };
    Traverse.prototype.reduce = function(cb, init) {
      var skip = arguments.length === 1;
      var acc = skip ? this.value : init;
      this.forEach(function(x) {
        if (!this.isRoot || !skip) {
          acc = cb.call(this, acc, x);
        }
      });
      return acc;
    };
    Traverse.prototype.deepEqual = function(obj2) {
      if (arguments.length !== 1) {
        throw new Error(
          "deepEqual requires exactly one object to compare against"
        );
      }
      var equal = true;
      var node = obj2;
      this.forEach(function(y) {
        var notEqual = function() {
          equal = false;
          return void 0;
        }.bind(this);
        if (!this.isRoot) {
          if (typeof node !== "object")
            return notEqual();
          node = node[this.key];
        }
        var x = node;
        this.post(function() {
          node = x;
        });
        var toS = function(o) {
          return Object.prototype.toString.call(o);
        };
        if (this.circular) {
          if (Traverse(obj2).get(this.circular.path) !== x)
            notEqual();
        } else if (typeof x !== typeof y) {
          notEqual();
        } else if (x === null || y === null || x === void 0 || y === void 0) {
          if (x !== y)
            notEqual();
        } else if (x.__proto__ !== y.__proto__) {
          notEqual();
        } else if (x === y) {
        } else if (typeof x === "function") {
          if (x instanceof RegExp) {
            if (x.toString() != y.toString())
              notEqual();
          } else if (x !== y)
            notEqual();
        } else if (typeof x === "object") {
          if (toS(y) === "[object Arguments]" || toS(x) === "[object Arguments]") {
            if (toS(x) !== toS(y)) {
              notEqual();
            }
          } else if (x instanceof Date || y instanceof Date) {
            if (!(x instanceof Date) || !(y instanceof Date) || x.getTime() !== y.getTime()) {
              notEqual();
            }
          } else {
            var kx = Object.keys(x);
            var ky = Object.keys(y);
            if (kx.length !== ky.length)
              return notEqual();
            for (var i = 0; i < kx.length; i++) {
              var k = kx[i];
              if (!Object.hasOwnProperty.call(y, k)) {
                notEqual();
              }
            }
          }
        }
      });
      return equal;
    };
    Traverse.prototype.paths = function() {
      var acc = [];
      this.forEach(function(x) {
        acc.push(this.path);
      });
      return acc;
    };
    Traverse.prototype.nodes = function() {
      var acc = [];
      this.forEach(function(x) {
        acc.push(this.node);
      });
      return acc;
    };
    Traverse.prototype.clone = function() {
      var parents = [], nodes = [];
      return function clone(src) {
        for (var i = 0; i < parents.length; i++) {
          if (parents[i] === src) {
            return nodes[i];
          }
        }
        if (typeof src === "object" && src !== null) {
          var dst = copy(src);
          parents.push(src);
          nodes.push(dst);
          Object.keys(src).forEach(function(key) {
            dst[key] = clone(src[key]);
          });
          parents.pop();
          nodes.pop();
          return dst;
        } else {
          return src;
        }
      }(this.value);
    };
    function walk(root, cb, immutable) {
      var path = [];
      var parents = [];
      var alive = true;
      return function walker(node_) {
        var node = immutable ? copy(node_) : node_;
        var modifiers = {};
        var state = {
          node,
          node_,
          path: [].concat(path),
          parent: parents.slice(-1)[0],
          key: path.slice(-1)[0],
          isRoot: path.length === 0,
          level: path.length,
          circular: null,
          update: function(x) {
            if (!state.isRoot) {
              state.parent.node[state.key] = x;
            }
            state.node = x;
          },
          "delete": function() {
            delete state.parent.node[state.key];
          },
          remove: function() {
            if (Array.isArray(state.parent.node)) {
              state.parent.node.splice(state.key, 1);
            } else {
              delete state.parent.node[state.key];
            }
          },
          before: function(f) {
            modifiers.before = f;
          },
          after: function(f) {
            modifiers.after = f;
          },
          pre: function(f) {
            modifiers.pre = f;
          },
          post: function(f) {
            modifiers.post = f;
          },
          stop: function() {
            alive = false;
          }
        };
        if (!alive)
          return state;
        if (typeof node === "object" && node !== null) {
          state.isLeaf = Object.keys(node).length == 0;
          for (var i = 0; i < parents.length; i++) {
            if (parents[i].node_ === node_) {
              state.circular = parents[i];
              break;
            }
          }
        } else {
          state.isLeaf = true;
        }
        state.notLeaf = !state.isLeaf;
        state.notRoot = !state.isRoot;
        var ret2 = cb.call(state, state.node);
        if (ret2 !== void 0 && state.update)
          state.update(ret2);
        if (modifiers.before)
          modifiers.before.call(state, state.node);
        if (typeof state.node == "object" && state.node !== null && !state.circular) {
          parents.push(state);
          var keys = Object.keys(state.node);
          keys.forEach(function(key, i2) {
            path.push(key);
            if (modifiers.pre)
              modifiers.pre.call(state, state.node[key], key);
            var child = walker(state.node[key]);
            if (immutable && Object.hasOwnProperty.call(state.node, key)) {
              state.node[key] = child.node;
            }
            child.isLast = i2 == keys.length - 1;
            child.isFirst = i2 == 0;
            if (modifiers.post)
              modifiers.post.call(state, child);
            path.pop();
          });
          parents.pop();
        }
        if (modifiers.after)
          modifiers.after.call(state, state.node);
        return state;
      }(root).node;
    }
    Object.keys(Traverse.prototype).forEach(function(key) {
      Traverse[key] = function(obj2) {
        var args = [].slice.call(arguments, 1);
        var t = Traverse(obj2);
        return t[key].apply(t, args);
      };
    });
    function copy(src) {
      if (typeof src === "object" && src !== null) {
        var dst;
        if (Array.isArray(src)) {
          dst = [];
        } else if (src instanceof Date) {
          dst = new Date(src);
        } else if (src instanceof Boolean) {
          dst = new Boolean(src);
        } else if (src instanceof Number) {
          dst = new Number(src);
        } else if (src instanceof String) {
          dst = new String(src);
        } else {
          dst = Object.create(Object.getPrototypeOf(src));
        }
        Object.keys(src).forEach(function(key) {
          dst[key] = src[key];
        });
        return dst;
      } else
        return src;
    }
  }
});

// ../../../node_modules/chainsaw/index.js
var require_chainsaw = __commonJS({
  "../../../node_modules/chainsaw/index.js"(exports2, module2) {
    var Traverse = require_traverse();
    var EventEmitter = require("events").EventEmitter;
    module2.exports = Chainsaw;
    function Chainsaw(builder) {
      var saw = Chainsaw.saw(builder, {});
      var r = builder.call(saw.handlers, saw);
      if (r !== void 0)
        saw.handlers = r;
      saw.record();
      return saw.chain();
    }
    Chainsaw.light = function ChainsawLight(builder) {
      var saw = Chainsaw.saw(builder, {});
      var r = builder.call(saw.handlers, saw);
      if (r !== void 0)
        saw.handlers = r;
      return saw.chain();
    };
    Chainsaw.saw = function(builder, handlers) {
      var saw = new EventEmitter();
      saw.handlers = handlers;
      saw.actions = [];
      saw.chain = function() {
        var ch = Traverse(saw.handlers).map(function(node) {
          if (this.isRoot)
            return node;
          var ps = this.path;
          if (typeof node === "function") {
            this.update(function() {
              saw.actions.push({
                path: ps,
                args: [].slice.call(arguments)
              });
              return ch;
            });
          }
        });
        process.nextTick(function() {
          saw.emit("begin");
          saw.next();
        });
        return ch;
      };
      saw.pop = function() {
        return saw.actions.shift();
      };
      saw.next = function() {
        var action = saw.pop();
        if (!action) {
          saw.emit("end");
        } else if (!action.trap) {
          var node = saw.handlers;
          action.path.forEach(function(key) {
            node = node[key];
          });
          node.apply(saw.handlers, action.args);
        }
      };
      saw.nest = function(cb) {
        var args = [].slice.call(arguments, 1);
        var autonext = true;
        if (typeof cb === "boolean") {
          var autonext = cb;
          cb = args.shift();
        }
        var s = Chainsaw.saw(builder, {});
        var r = builder.call(s.handlers, s);
        if (r !== void 0)
          s.handlers = r;
        if ("undefined" !== typeof saw.step) {
          s.record();
        }
        cb.apply(s.chain(), args);
        if (autonext !== false)
          s.on("end", saw.next);
      };
      saw.record = function() {
        upgradeChainsaw(saw);
      };
      ["trap", "down", "jump"].forEach(function(method) {
        saw[method] = function() {
          throw new Error("To use the trap, down and jump features, please call record() first to start recording actions.");
        };
      });
      return saw;
    };
    function upgradeChainsaw(saw) {
      saw.step = 0;
      saw.pop = function() {
        return saw.actions[saw.step++];
      };
      saw.trap = function(name, cb) {
        var ps = Array.isArray(name) ? name : [name];
        saw.actions.push({
          path: ps,
          step: saw.step,
          cb,
          trap: true
        });
      };
      saw.down = function(name) {
        var ps = (Array.isArray(name) ? name : [name]).join("/");
        var i = saw.actions.slice(saw.step).map(function(x) {
          if (x.trap && x.step <= saw.step)
            return false;
          return x.path.join("/") == ps;
        }).indexOf(true);
        if (i >= 0)
          saw.step += i;
        else
          saw.step = saw.actions.length;
        var act = saw.actions[saw.step - 1];
        if (act && act.trap) {
          saw.step = act.step;
          act.cb();
        } else
          saw.next();
      };
      saw.jump = function(step) {
        saw.step = step;
        saw.next();
      };
    }
  }
});

// ../../../node_modules/buffers/index.js
var require_buffers = __commonJS({
  "../../../node_modules/buffers/index.js"(exports2, module2) {
    module2.exports = Buffers;
    function Buffers(bufs) {
      if (!(this instanceof Buffers))
        return new Buffers(bufs);
      this.buffers = bufs || [];
      this.length = this.buffers.reduce(function(size, buf) {
        return size + buf.length;
      }, 0);
    }
    Buffers.prototype.push = function() {
      for (var i = 0; i < arguments.length; i++) {
        if (!Buffer.isBuffer(arguments[i])) {
          throw new TypeError("Tried to push a non-buffer");
        }
      }
      for (var i = 0; i < arguments.length; i++) {
        var buf = arguments[i];
        this.buffers.push(buf);
        this.length += buf.length;
      }
      return this.length;
    };
    Buffers.prototype.unshift = function() {
      for (var i = 0; i < arguments.length; i++) {
        if (!Buffer.isBuffer(arguments[i])) {
          throw new TypeError("Tried to unshift a non-buffer");
        }
      }
      for (var i = 0; i < arguments.length; i++) {
        var buf = arguments[i];
        this.buffers.unshift(buf);
        this.length += buf.length;
      }
      return this.length;
    };
    Buffers.prototype.copy = function(dst, dStart, start, end) {
      return this.slice(start, end).copy(dst, dStart, 0, end - start);
    };
    Buffers.prototype.splice = function(i, howMany) {
      var buffers = this.buffers;
      var index = i >= 0 ? i : this.length - i;
      var reps = [].slice.call(arguments, 2);
      if (howMany === void 0) {
        howMany = this.length - index;
      } else if (howMany > this.length - index) {
        howMany = this.length - index;
      }
      for (var i = 0; i < reps.length; i++) {
        this.length += reps[i].length;
      }
      var removed = new Buffers();
      var bytes = 0;
      var startBytes = 0;
      for (var ii = 0; ii < buffers.length && startBytes + buffers[ii].length < index; ii++) {
        startBytes += buffers[ii].length;
      }
      if (index - startBytes > 0) {
        var start = index - startBytes;
        if (start + howMany < buffers[ii].length) {
          removed.push(buffers[ii].slice(start, start + howMany));
          var orig = buffers[ii];
          var buf0 = new Buffer(start);
          for (var i = 0; i < start; i++) {
            buf0[i] = orig[i];
          }
          var buf1 = new Buffer(orig.length - start - howMany);
          for (var i = start + howMany; i < orig.length; i++) {
            buf1[i - howMany - start] = orig[i];
          }
          if (reps.length > 0) {
            var reps_ = reps.slice();
            reps_.unshift(buf0);
            reps_.push(buf1);
            buffers.splice.apply(buffers, [ii, 1].concat(reps_));
            ii += reps_.length;
            reps = [];
          } else {
            buffers.splice(ii, 1, buf0, buf1);
            ii += 2;
          }
        } else {
          removed.push(buffers[ii].slice(start));
          buffers[ii] = buffers[ii].slice(0, start);
          ii++;
        }
      }
      if (reps.length > 0) {
        buffers.splice.apply(buffers, [ii, 0].concat(reps));
        ii += reps.length;
      }
      while (removed.length < howMany) {
        var buf = buffers[ii];
        var len = buf.length;
        var take = Math.min(len, howMany - removed.length);
        if (take === len) {
          removed.push(buf);
          buffers.splice(ii, 1);
        } else {
          removed.push(buf.slice(0, take));
          buffers[ii] = buffers[ii].slice(take);
        }
      }
      this.length -= removed.length;
      return removed;
    };
    Buffers.prototype.slice = function(i, j) {
      var buffers = this.buffers;
      if (j === void 0)
        j = this.length;
      if (i === void 0)
        i = 0;
      if (j > this.length)
        j = this.length;
      var startBytes = 0;
      for (var si = 0; si < buffers.length && startBytes + buffers[si].length <= i; si++) {
        startBytes += buffers[si].length;
      }
      var target = new Buffer(j - i);
      var ti = 0;
      for (var ii = si; ti < j - i && ii < buffers.length; ii++) {
        var len = buffers[ii].length;
        var start = ti === 0 ? i - startBytes : 0;
        var end = ti + len >= j - i ? Math.min(start + (j - i) - ti, len) : len;
        buffers[ii].copy(target, ti, start, end);
        ti += end - start;
      }
      return target;
    };
    Buffers.prototype.pos = function(i) {
      if (i < 0 || i >= this.length)
        throw new Error("oob");
      var l2 = i, bi = 0, bu = null;
      for (; ; ) {
        bu = this.buffers[bi];
        if (l2 < bu.length) {
          return { buf: bi, offset: l2 };
        } else {
          l2 -= bu.length;
        }
        bi++;
      }
    };
    Buffers.prototype.get = function get(i) {
      var pos = this.pos(i);
      return this.buffers[pos.buf].get(pos.offset);
    };
    Buffers.prototype.set = function set(i, b) {
      var pos = this.pos(i);
      return this.buffers[pos.buf].set(pos.offset, b);
    };
    Buffers.prototype.indexOf = function(needle, offset) {
      if ("string" === typeof needle) {
        needle = new Buffer(needle);
      } else if (needle instanceof Buffer) {
      } else {
        throw new Error("Invalid type for a search string");
      }
      if (!needle.length) {
        return 0;
      }
      if (!this.length) {
        return -1;
      }
      var i = 0, j = 0, match = 0, mstart, pos = 0;
      if (offset) {
        var p = this.pos(offset);
        i = p.buf;
        j = p.offset;
        pos = offset;
      }
      for (; ; ) {
        while (j >= this.buffers[i].length) {
          j = 0;
          i++;
          if (i >= this.buffers.length) {
            return -1;
          }
        }
        var char = this.buffers[i][j];
        if (char == needle[match]) {
          if (match == 0) {
            mstart = {
              i,
              j,
              pos
            };
          }
          match++;
          if (match == needle.length) {
            return mstart.pos;
          }
        } else if (match != 0) {
          i = mstart.i;
          j = mstart.j;
          pos = mstart.pos;
          match = 0;
        }
        j++;
        pos++;
      }
    };
    Buffers.prototype.toBuffer = function() {
      return this.slice();
    };
    Buffers.prototype.toString = function(encoding, start, end) {
      return this.slice(start, end).toString(encoding);
    };
  }
});

// ../../../node_modules/binary/lib/vars.js
var require_vars = __commonJS({
  "../../../node_modules/binary/lib/vars.js"(exports2, module2) {
    module2.exports = function(store) {
      function getset(name, value) {
        var node = vars.store;
        var keys = name.split(".");
        keys.slice(0, -1).forEach(function(k) {
          if (node[k] === void 0)
            node[k] = {};
          node = node[k];
        });
        var key = keys[keys.length - 1];
        if (arguments.length == 1) {
          return node[key];
        } else {
          return node[key] = value;
        }
      }
      var vars = {
        get: function(name) {
          return getset(name);
        },
        set: function(name, value) {
          return getset(name, value);
        },
        store: store || {}
      };
      return vars;
    };
  }
});

// ../../../node_modules/binary/index.js
var require_binary = __commonJS({
  "../../../node_modules/binary/index.js"(exports2, module2) {
    var Chainsaw = require_chainsaw();
    var EventEmitter = require("events").EventEmitter;
    var Buffers = require_buffers();
    var Vars = require_vars();
    var Stream = require("stream").Stream;
    exports2 = module2.exports = function(bufOrEm, eventName) {
      if (Buffer.isBuffer(bufOrEm)) {
        return exports2.parse(bufOrEm);
      }
      var s = exports2.stream();
      if (bufOrEm && bufOrEm.pipe) {
        bufOrEm.pipe(s);
      } else if (bufOrEm) {
        bufOrEm.on(eventName || "data", function(buf) {
          s.write(buf);
        });
        bufOrEm.on("end", function() {
          s.end();
        });
      }
      return s;
    };
    exports2.stream = function(input) {
      if (input)
        return exports2.apply(null, arguments);
      var pending = null;
      function getBytes(bytes, cb, skip) {
        pending = {
          bytes,
          skip,
          cb: function(buf) {
            pending = null;
            cb(buf);
          }
        };
        dispatch();
      }
      var offset = null;
      function dispatch() {
        if (!pending) {
          if (caughtEnd)
            done = true;
          return;
        }
        if (typeof pending === "function") {
          pending();
        } else {
          var bytes = offset + pending.bytes;
          if (buffers.length >= bytes) {
            var buf;
            if (offset == null) {
              buf = buffers.splice(0, bytes);
              if (!pending.skip) {
                buf = buf.slice();
              }
            } else {
              if (!pending.skip) {
                buf = buffers.slice(offset, bytes);
              }
              offset = bytes;
            }
            if (pending.skip) {
              pending.cb();
            } else {
              pending.cb(buf);
            }
          }
        }
      }
      function builder(saw) {
        function next() {
          if (!done)
            saw.next();
        }
        var self2 = words(function(bytes, cb) {
          return function(name) {
            getBytes(bytes, function(buf) {
              vars.set(name, cb(buf));
              next();
            });
          };
        });
        self2.tap = function(cb) {
          saw.nest(cb, vars.store);
        };
        self2.into = function(key, cb) {
          if (!vars.get(key))
            vars.set(key, {});
          var parent = vars;
          vars = Vars(parent.get(key));
          saw.nest(function() {
            cb.apply(this, arguments);
            this.tap(function() {
              vars = parent;
            });
          }, vars.store);
        };
        self2.flush = function() {
          vars.store = {};
          next();
        };
        self2.loop = function(cb) {
          var end = false;
          saw.nest(false, function loop() {
            this.vars = vars.store;
            cb.call(this, function() {
              end = true;
              next();
            }, vars.store);
            this.tap(function() {
              if (end)
                saw.next();
              else
                loop.call(this);
            }.bind(this));
          }, vars.store);
        };
        self2.buffer = function(name, bytes) {
          if (typeof bytes === "string") {
            bytes = vars.get(bytes);
          }
          getBytes(bytes, function(buf) {
            vars.set(name, buf);
            next();
          });
        };
        self2.skip = function(bytes) {
          if (typeof bytes === "string") {
            bytes = vars.get(bytes);
          }
          getBytes(bytes, function() {
            next();
          });
        };
        self2.scan = function find(name, search) {
          if (typeof search === "string") {
            search = new Buffer(search);
          } else if (!Buffer.isBuffer(search)) {
            throw new Error("search must be a Buffer or a string");
          }
          var taken = 0;
          pending = function() {
            var pos = buffers.indexOf(search, offset + taken);
            var i = pos - offset - taken;
            if (pos !== -1) {
              pending = null;
              if (offset != null) {
                vars.set(
                  name,
                  buffers.slice(offset, offset + taken + i)
                );
                offset += taken + i + search.length;
              } else {
                vars.set(
                  name,
                  buffers.slice(0, taken + i)
                );
                buffers.splice(0, taken + i + search.length);
              }
              next();
              dispatch();
            } else {
              i = Math.max(buffers.length - search.length - offset - taken, 0);
            }
            taken += i;
          };
          dispatch();
        };
        self2.peek = function(cb) {
          offset = 0;
          saw.nest(function() {
            cb.call(this, vars.store);
            this.tap(function() {
              offset = null;
            });
          });
        };
        return self2;
      }
      ;
      var stream = Chainsaw.light(builder);
      stream.writable = true;
      var buffers = Buffers();
      stream.write = function(buf) {
        buffers.push(buf);
        dispatch();
      };
      var vars = Vars();
      var done = false, caughtEnd = false;
      stream.end = function() {
        caughtEnd = true;
      };
      stream.pipe = Stream.prototype.pipe;
      Object.getOwnPropertyNames(EventEmitter.prototype).forEach(function(name) {
        stream[name] = EventEmitter.prototype[name];
      });
      return stream;
    };
    exports2.parse = function parse2(buffer) {
      var self2 = words(function(bytes, cb) {
        return function(name) {
          if (offset + bytes <= buffer.length) {
            var buf = buffer.slice(offset, offset + bytes);
            offset += bytes;
            vars.set(name, cb(buf));
          } else {
            vars.set(name, null);
          }
          return self2;
        };
      });
      var offset = 0;
      var vars = Vars();
      self2.vars = vars.store;
      self2.tap = function(cb) {
        cb.call(self2, vars.store);
        return self2;
      };
      self2.into = function(key, cb) {
        if (!vars.get(key)) {
          vars.set(key, {});
        }
        var parent = vars;
        vars = Vars(parent.get(key));
        cb.call(self2, vars.store);
        vars = parent;
        return self2;
      };
      self2.loop = function(cb) {
        var end = false;
        var ender = function() {
          end = true;
        };
        while (end === false) {
          cb.call(self2, ender, vars.store);
        }
        return self2;
      };
      self2.buffer = function(name, size) {
        if (typeof size === "string") {
          size = vars.get(size);
        }
        var buf = buffer.slice(offset, Math.min(buffer.length, offset + size));
        offset += size;
        vars.set(name, buf);
        return self2;
      };
      self2.skip = function(bytes) {
        if (typeof bytes === "string") {
          bytes = vars.get(bytes);
        }
        offset += bytes;
        return self2;
      };
      self2.scan = function(name, search) {
        if (typeof search === "string") {
          search = new Buffer(search);
        } else if (!Buffer.isBuffer(search)) {
          throw new Error("search must be a Buffer or a string");
        }
        vars.set(name, null);
        for (var i = 0; i + offset <= buffer.length - search.length + 1; i++) {
          for (var j = 0; j < search.length && buffer[offset + i + j] === search[j]; j++)
            ;
          if (j === search.length)
            break;
        }
        vars.set(name, buffer.slice(offset, offset + i));
        offset += i + search.length;
        return self2;
      };
      self2.peek = function(cb) {
        var was = offset;
        cb.call(self2, vars.store);
        offset = was;
        return self2;
      };
      self2.flush = function() {
        vars.store = {};
        return self2;
      };
      self2.eof = function() {
        return offset >= buffer.length;
      };
      return self2;
    };
    function decodeLEu(bytes) {
      var acc = 0;
      for (var i = 0; i < bytes.length; i++) {
        acc += Math.pow(256, i) * bytes[i];
      }
      return acc;
    }
    function decodeBEu(bytes) {
      var acc = 0;
      for (var i = 0; i < bytes.length; i++) {
        acc += Math.pow(256, bytes.length - i - 1) * bytes[i];
      }
      return acc;
    }
    function decodeBEs(bytes) {
      var val = decodeBEu(bytes);
      if ((bytes[0] & 128) == 128) {
        val -= Math.pow(256, bytes.length);
      }
      return val;
    }
    function decodeLEs(bytes) {
      var val = decodeLEu(bytes);
      if ((bytes[bytes.length - 1] & 128) == 128) {
        val -= Math.pow(256, bytes.length);
      }
      return val;
    }
    function words(decode) {
      var self2 = {};
      [1, 2, 4, 8].forEach(function(bytes) {
        var bits = bytes * 8;
        self2["word" + bits + "le"] = self2["word" + bits + "lu"] = decode(bytes, decodeLEu);
        self2["word" + bits + "ls"] = decode(bytes, decodeLEs);
        self2["word" + bits + "be"] = self2["word" + bits + "bu"] = decode(bytes, decodeBEu);
        self2["word" + bits + "bs"] = decode(bytes, decodeBEs);
      });
      self2.word8 = self2.word8u = self2.word8be;
      self2.word8s = self2.word8bs;
      return self2;
    }
  }
});

// ../../../node_modules/bluebird/js/release/es5.js
var require_es5 = __commonJS({
  "../../../node_modules/bluebird/js/release/es5.js"(exports2, module2) {
    var isES5 = function() {
      "use strict";
      return this === void 0;
    }();
    if (isES5) {
      module2.exports = {
        freeze: Object.freeze,
        defineProperty: Object.defineProperty,
        getDescriptor: Object.getOwnPropertyDescriptor,
        keys: Object.keys,
        names: Object.getOwnPropertyNames,
        getPrototypeOf: Object.getPrototypeOf,
        isArray: Array.isArray,
        isES5,
        propertyIsWritable: function(obj2, prop) {
          var descriptor = Object.getOwnPropertyDescriptor(obj2, prop);
          return !!(!descriptor || descriptor.writable || descriptor.set);
        }
      };
    } else {
      has = {}.hasOwnProperty;
      str = {}.toString;
      proto = {}.constructor.prototype;
      ObjectKeys = function(o) {
        var ret2 = [];
        for (var key in o) {
          if (has.call(o, key)) {
            ret2.push(key);
          }
        }
        return ret2;
      };
      ObjectGetDescriptor = function(o, key) {
        return { value: o[key] };
      };
      ObjectDefineProperty = function(o, key, desc) {
        o[key] = desc.value;
        return o;
      };
      ObjectFreeze = function(obj2) {
        return obj2;
      };
      ObjectGetPrototypeOf = function(obj2) {
        try {
          return Object(obj2).constructor.prototype;
        } catch (e) {
          return proto;
        }
      };
      ArrayIsArray = function(obj2) {
        try {
          return str.call(obj2) === "[object Array]";
        } catch (e) {
          return false;
        }
      };
      module2.exports = {
        isArray: ArrayIsArray,
        keys: ObjectKeys,
        names: ObjectKeys,
        defineProperty: ObjectDefineProperty,
        getDescriptor: ObjectGetDescriptor,
        freeze: ObjectFreeze,
        getPrototypeOf: ObjectGetPrototypeOf,
        isES5,
        propertyIsWritable: function() {
          return true;
        }
      };
    }
    var has;
    var str;
    var proto;
    var ObjectKeys;
    var ObjectGetDescriptor;
    var ObjectDefineProperty;
    var ObjectFreeze;
    var ObjectGetPrototypeOf;
    var ArrayIsArray;
  }
});

// ../../../node_modules/bluebird/js/release/util.js
var require_util4 = __commonJS({
  "../../../node_modules/bluebird/js/release/util.js"(exports, module) {
    "use strict";
    var es5 = require_es5();
    var canEvaluate = typeof navigator == "undefined";
    var errorObj = { e: {} };
    var tryCatchTarget;
    var globalObject = typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : exports !== void 0 ? exports : null;
    function tryCatcher() {
      try {
        var target = tryCatchTarget;
        tryCatchTarget = null;
        return target.apply(this, arguments);
      } catch (e) {
        errorObj.e = e;
        return errorObj;
      }
    }
    function tryCatch(fn) {
      tryCatchTarget = fn;
      return tryCatcher;
    }
    var inherits = function(Child, Parent) {
      var hasProp = {}.hasOwnProperty;
      function T() {
        this.constructor = Child;
        this.constructor$ = Parent;
        for (var propertyName in Parent.prototype) {
          if (hasProp.call(Parent.prototype, propertyName) && propertyName.charAt(propertyName.length - 1) !== "$") {
            this[propertyName + "$"] = Parent.prototype[propertyName];
          }
        }
      }
      T.prototype = Parent.prototype;
      Child.prototype = new T();
      return Child.prototype;
    };
    function isPrimitive(val) {
      return val == null || val === true || val === false || typeof val === "string" || typeof val === "number";
    }
    function isObject(value) {
      return typeof value === "function" || typeof value === "object" && value !== null;
    }
    function maybeWrapAsError(maybeError) {
      if (!isPrimitive(maybeError))
        return maybeError;
      return new Error(safeToString(maybeError));
    }
    function withAppended(target, appendee) {
      var len = target.length;
      var ret2 = new Array(len + 1);
      var i;
      for (i = 0; i < len; ++i) {
        ret2[i] = target[i];
      }
      ret2[i] = appendee;
      return ret2;
    }
    function getDataPropertyOrDefault(obj2, key, defaultValue) {
      if (es5.isES5) {
        var desc = Object.getOwnPropertyDescriptor(obj2, key);
        if (desc != null) {
          return desc.get == null && desc.set == null ? desc.value : defaultValue;
        }
      } else {
        return {}.hasOwnProperty.call(obj2, key) ? obj2[key] : void 0;
      }
    }
    function notEnumerableProp(obj2, name, value) {
      if (isPrimitive(obj2))
        return obj2;
      var descriptor = {
        value,
        configurable: true,
        enumerable: false,
        writable: true
      };
      es5.defineProperty(obj2, name, descriptor);
      return obj2;
    }
    function thrower(r) {
      throw r;
    }
    var inheritedDataKeys = function() {
      var excludedPrototypes = [
        Array.prototype,
        Object.prototype,
        Function.prototype
      ];
      var isExcludedProto = function(val) {
        for (var i = 0; i < excludedPrototypes.length; ++i) {
          if (excludedPrototypes[i] === val) {
            return true;
          }
        }
        return false;
      };
      if (es5.isES5) {
        var getKeys = Object.getOwnPropertyNames;
        return function(obj2) {
          var ret2 = [];
          var visitedKeys = /* @__PURE__ */ Object.create(null);
          while (obj2 != null && !isExcludedProto(obj2)) {
            var keys;
            try {
              keys = getKeys(obj2);
            } catch (e) {
              return ret2;
            }
            for (var i = 0; i < keys.length; ++i) {
              var key = keys[i];
              if (visitedKeys[key])
                continue;
              visitedKeys[key] = true;
              var desc = Object.getOwnPropertyDescriptor(obj2, key);
              if (desc != null && desc.get == null && desc.set == null) {
                ret2.push(key);
              }
            }
            obj2 = es5.getPrototypeOf(obj2);
          }
          return ret2;
        };
      } else {
        var hasProp = {}.hasOwnProperty;
        return function(obj2) {
          if (isExcludedProto(obj2))
            return [];
          var ret2 = [];
          enumeration:
            for (var key in obj2) {
              if (hasProp.call(obj2, key)) {
                ret2.push(key);
              } else {
                for (var i = 0; i < excludedPrototypes.length; ++i) {
                  if (hasProp.call(excludedPrototypes[i], key)) {
                    continue enumeration;
                  }
                }
                ret2.push(key);
              }
            }
          return ret2;
        };
      }
    }();
    var thisAssignmentPattern = /this\s*\.\s*\S+\s*=/;
    function isClass(fn) {
      try {
        if (typeof fn === "function") {
          var keys = es5.names(fn.prototype);
          var hasMethods = es5.isES5 && keys.length > 1;
          var hasMethodsOtherThanConstructor = keys.length > 0 && !(keys.length === 1 && keys[0] === "constructor");
          var hasThisAssignmentAndStaticMethods = thisAssignmentPattern.test(fn + "") && es5.names(fn).length > 0;
          if (hasMethods || hasMethodsOtherThanConstructor || hasThisAssignmentAndStaticMethods) {
            return true;
          }
        }
        return false;
      } catch (e) {
        return false;
      }
    }
    function toFastProperties(obj) {
      function FakeConstructor() {
      }
      FakeConstructor.prototype = obj;
      var l = 8;
      while (l--)
        new FakeConstructor();
      return obj;
      eval(obj);
    }
    var rident = /^[a-z$_][a-z$_0-9]*$/i;
    function isIdentifier(str) {
      return rident.test(str);
    }
    function filledRange(count, prefix, suffix) {
      var ret2 = new Array(count);
      for (var i = 0; i < count; ++i) {
        ret2[i] = prefix + i + suffix;
      }
      return ret2;
    }
    function safeToString(obj2) {
      try {
        return obj2 + "";
      } catch (e) {
        return "[no string representation]";
      }
    }
    function isError(obj2) {
      return obj2 !== null && typeof obj2 === "object" && typeof obj2.message === "string" && typeof obj2.name === "string";
    }
    function markAsOriginatingFromRejection(e) {
      try {
        notEnumerableProp(e, "isOperational", true);
      } catch (ignore) {
      }
    }
    function originatesFromRejection(e) {
      if (e == null)
        return false;
      return e instanceof Error["__BluebirdErrorTypes__"].OperationalError || e["isOperational"] === true;
    }
    function canAttachTrace(obj2) {
      return isError(obj2) && es5.propertyIsWritable(obj2, "stack");
    }
    var ensureErrorObject = function() {
      if (!("stack" in new Error())) {
        return function(value) {
          if (canAttachTrace(value))
            return value;
          try {
            throw new Error(safeToString(value));
          } catch (err) {
            return err;
          }
        };
      } else {
        return function(value) {
          if (canAttachTrace(value))
            return value;
          return new Error(safeToString(value));
        };
      }
    }();
    function classString(obj2) {
      return {}.toString.call(obj2);
    }
    function copyDescriptors(from, to, filter) {
      var keys = es5.names(from);
      for (var i = 0; i < keys.length; ++i) {
        var key = keys[i];
        if (filter(key)) {
          try {
            es5.defineProperty(to, key, es5.getDescriptor(from, key));
          } catch (ignore) {
          }
        }
      }
    }
    var asArray = function(v) {
      if (es5.isArray(v)) {
        return v;
      }
      return null;
    };
    if (typeof Symbol !== "undefined" && Symbol.iterator) {
      ArrayFrom = typeof Array.from === "function" ? function(v) {
        return Array.from(v);
      } : function(v) {
        var ret2 = [];
        var it = v[Symbol.iterator]();
        var itResult;
        while (!(itResult = it.next()).done) {
          ret2.push(itResult.value);
        }
        return ret2;
      };
      asArray = function(v) {
        if (es5.isArray(v)) {
          return v;
        } else if (v != null && typeof v[Symbol.iterator] === "function") {
          return ArrayFrom(v);
        }
        return null;
      };
    }
    var ArrayFrom;
    var isNode = typeof process !== "undefined" && classString(process).toLowerCase() === "[object process]";
    var hasEnvVariables = typeof process !== "undefined" && typeof process.env !== "undefined";
    function env(key) {
      return hasEnvVariables ? process.env[key] : void 0;
    }
    function getNativePromise() {
      if (typeof Promise === "function") {
        try {
          var promise = new Promise(function() {
          });
          if ({}.toString.call(promise) === "[object Promise]") {
            return Promise;
          }
        } catch (e) {
        }
      }
    }
    function domainBind(self2, cb) {
      return self2.bind(cb);
    }
    var ret = {
      isClass,
      isIdentifier,
      inheritedDataKeys,
      getDataPropertyOrDefault,
      thrower,
      isArray: es5.isArray,
      asArray,
      notEnumerableProp,
      isPrimitive,
      isObject,
      isError,
      canEvaluate,
      errorObj,
      tryCatch,
      inherits,
      withAppended,
      maybeWrapAsError,
      toFastProperties,
      filledRange,
      toString: safeToString,
      canAttachTrace,
      ensureErrorObject,
      originatesFromRejection,
      markAsOriginatingFromRejection,
      classString,
      copyDescriptors,
      hasDevTools: typeof chrome !== "undefined" && chrome && typeof chrome.loadTimes === "function",
      isNode,
      hasEnvVariables,
      env,
      global: globalObject,
      getNativePromise,
      domainBind
    };
    ret.isRecentNode = ret.isNode && function() {
      var version2 = process.versions.node.split(".").map(Number);
      return version2[0] === 0 && version2[1] > 10 || version2[0] > 0;
    }();
    if (ret.isNode)
      ret.toFastProperties(process);
    try {
      throw new Error();
    } catch (e) {
      ret.lastLineError = e;
    }
    module.exports = ret;
  }
});

// ../../../node_modules/bluebird/js/release/schedule.js
var require_schedule = __commonJS({
  "../../../node_modules/bluebird/js/release/schedule.js"(exports2, module2) {
    "use strict";
    var util = require_util4();
    var schedule;
    var noAsyncScheduler = function() {
      throw new Error("No async scheduler available\n\n    See http://goo.gl/MqrFmX\n");
    };
    var NativePromise = util.getNativePromise();
    if (util.isNode && typeof MutationObserver === "undefined") {
      GlobalSetImmediate = global.setImmediate;
      ProcessNextTick = process.nextTick;
      schedule = util.isRecentNode ? function(fn) {
        GlobalSetImmediate.call(global, fn);
      } : function(fn) {
        ProcessNextTick.call(process, fn);
      };
    } else if (typeof NativePromise === "function" && typeof NativePromise.resolve === "function") {
      nativePromise = NativePromise.resolve();
      schedule = function(fn) {
        nativePromise.then(fn);
      };
    } else if (typeof MutationObserver !== "undefined" && !(typeof window !== "undefined" && window.navigator && (window.navigator.standalone || window.cordova))) {
      schedule = function() {
        var div = document.createElement("div");
        var opts = { attributes: true };
        var toggleScheduled = false;
        var div2 = document.createElement("div");
        var o2 = new MutationObserver(function() {
          div.classList.toggle("foo");
          toggleScheduled = false;
        });
        o2.observe(div2, opts);
        var scheduleToggle = function() {
          if (toggleScheduled)
            return;
          toggleScheduled = true;
          div2.classList.toggle("foo");
        };
        return function schedule2(fn) {
          var o = new MutationObserver(function() {
            o.disconnect();
            fn();
          });
          o.observe(div, opts);
          scheduleToggle();
        };
      }();
    } else if (typeof setImmediate !== "undefined") {
      schedule = function(fn) {
        setImmediate(fn);
      };
    } else if (typeof setTimeout !== "undefined") {
      schedule = function(fn) {
        setTimeout(fn, 0);
      };
    } else {
      schedule = noAsyncScheduler;
    }
    var GlobalSetImmediate;
    var ProcessNextTick;
    var nativePromise;
    module2.exports = schedule;
  }
});

// ../../../node_modules/bluebird/js/release/queue.js
var require_queue = __commonJS({
  "../../../node_modules/bluebird/js/release/queue.js"(exports2, module2) {
    "use strict";
    function arrayMove(src, srcIndex, dst, dstIndex, len) {
      for (var j = 0; j < len; ++j) {
        dst[j + dstIndex] = src[j + srcIndex];
        src[j + srcIndex] = void 0;
      }
    }
    function Queue(capacity) {
      this._capacity = capacity;
      this._length = 0;
      this._front = 0;
    }
    Queue.prototype._willBeOverCapacity = function(size) {
      return this._capacity < size;
    };
    Queue.prototype._pushOne = function(arg) {
      var length = this.length();
      this._checkCapacity(length + 1);
      var i = this._front + length & this._capacity - 1;
      this[i] = arg;
      this._length = length + 1;
    };
    Queue.prototype.push = function(fn, receiver, arg) {
      var length = this.length() + 3;
      if (this._willBeOverCapacity(length)) {
        this._pushOne(fn);
        this._pushOne(receiver);
        this._pushOne(arg);
        return;
      }
      var j = this._front + length - 3;
      this._checkCapacity(length);
      var wrapMask = this._capacity - 1;
      this[j + 0 & wrapMask] = fn;
      this[j + 1 & wrapMask] = receiver;
      this[j + 2 & wrapMask] = arg;
      this._length = length;
    };
    Queue.prototype.shift = function() {
      var front = this._front, ret2 = this[front];
      this[front] = void 0;
      this._front = front + 1 & this._capacity - 1;
      this._length--;
      return ret2;
    };
    Queue.prototype.length = function() {
      return this._length;
    };
    Queue.prototype._checkCapacity = function(size) {
      if (this._capacity < size) {
        this._resizeTo(this._capacity << 1);
      }
    };
    Queue.prototype._resizeTo = function(capacity) {
      var oldCapacity = this._capacity;
      this._capacity = capacity;
      var front = this._front;
      var length = this._length;
      var moveItemsCount = front + length & oldCapacity - 1;
      arrayMove(this, 0, this, oldCapacity, moveItemsCount);
    };
    module2.exports = Queue;
  }
});

// ../../../node_modules/bluebird/js/release/async.js
var require_async2 = __commonJS({
  "../../../node_modules/bluebird/js/release/async.js"(exports2, module2) {
    "use strict";
    var firstLineError;
    try {
      throw new Error();
    } catch (e) {
      firstLineError = e;
    }
    var schedule = require_schedule();
    var Queue = require_queue();
    var util = require_util4();
    function Async() {
      this._customScheduler = false;
      this._isTickUsed = false;
      this._lateQueue = new Queue(16);
      this._normalQueue = new Queue(16);
      this._haveDrainedQueues = false;
      this._trampolineEnabled = true;
      var self2 = this;
      this.drainQueues = function() {
        self2._drainQueues();
      };
      this._schedule = schedule;
    }
    Async.prototype.setScheduler = function(fn) {
      var prev = this._schedule;
      this._schedule = fn;
      this._customScheduler = true;
      return prev;
    };
    Async.prototype.hasCustomScheduler = function() {
      return this._customScheduler;
    };
    Async.prototype.enableTrampoline = function() {
      this._trampolineEnabled = true;
    };
    Async.prototype.disableTrampolineIfNecessary = function() {
      if (util.hasDevTools) {
        this._trampolineEnabled = false;
      }
    };
    Async.prototype.haveItemsQueued = function() {
      return this._isTickUsed || this._haveDrainedQueues;
    };
    Async.prototype.fatalError = function(e, isNode2) {
      if (isNode2) {
        process.stderr.write("Fatal " + (e instanceof Error ? e.stack : e) + "\n");
        process.exit(2);
      } else {
        this.throwLater(e);
      }
    };
    Async.prototype.throwLater = function(fn, arg) {
      if (arguments.length === 1) {
        arg = fn;
        fn = function() {
          throw arg;
        };
      }
      if (typeof setTimeout !== "undefined") {
        setTimeout(function() {
          fn(arg);
        }, 0);
      } else
        try {
          this._schedule(function() {
            fn(arg);
          });
        } catch (e) {
          throw new Error("No async scheduler available\n\n    See http://goo.gl/MqrFmX\n");
        }
    };
    function AsyncInvokeLater(fn, receiver, arg) {
      this._lateQueue.push(fn, receiver, arg);
      this._queueTick();
    }
    function AsyncInvoke(fn, receiver, arg) {
      this._normalQueue.push(fn, receiver, arg);
      this._queueTick();
    }
    function AsyncSettlePromises(promise) {
      this._normalQueue._pushOne(promise);
      this._queueTick();
    }
    if (!util.hasDevTools) {
      Async.prototype.invokeLater = AsyncInvokeLater;
      Async.prototype.invoke = AsyncInvoke;
      Async.prototype.settlePromises = AsyncSettlePromises;
    } else {
      Async.prototype.invokeLater = function(fn, receiver, arg) {
        if (this._trampolineEnabled) {
          AsyncInvokeLater.call(this, fn, receiver, arg);
        } else {
          this._schedule(function() {
            setTimeout(function() {
              fn.call(receiver, arg);
            }, 100);
          });
        }
      };
      Async.prototype.invoke = function(fn, receiver, arg) {
        if (this._trampolineEnabled) {
          AsyncInvoke.call(this, fn, receiver, arg);
        } else {
          this._schedule(function() {
            fn.call(receiver, arg);
          });
        }
      };
      Async.prototype.settlePromises = function(promise) {
        if (this._trampolineEnabled) {
          AsyncSettlePromises.call(this, promise);
        } else {
          this._schedule(function() {
            promise._settlePromises();
          });
        }
      };
    }
    Async.prototype._drainQueue = function(queue) {
      while (queue.length() > 0) {
        var fn = queue.shift();
        if (typeof fn !== "function") {
          fn._settlePromises();
          continue;
        }
        var receiver = queue.shift();
        var arg = queue.shift();
        fn.call(receiver, arg);
      }
    };
    Async.prototype._drainQueues = function() {
      this._drainQueue(this._normalQueue);
      this._reset();
      this._haveDrainedQueues = true;
      this._drainQueue(this._lateQueue);
    };
    Async.prototype._queueTick = function() {
      if (!this._isTickUsed) {
        this._isTickUsed = true;
        this._schedule(this.drainQueues);
      }
    };
    Async.prototype._reset = function() {
      this._isTickUsed = false;
    };
    module2.exports = Async;
    module2.exports.firstLineError = firstLineError;
  }
});

// ../../../node_modules/bluebird/js/release/errors.js
var require_errors8 = __commonJS({
  "../../../node_modules/bluebird/js/release/errors.js"(exports2, module2) {
    "use strict";
    var es52 = require_es5();
    var Objectfreeze = es52.freeze;
    var util = require_util4();
    var inherits2 = util.inherits;
    var notEnumerableProp2 = util.notEnumerableProp;
    function subError(nameProperty, defaultMessage) {
      function SubError(message) {
        if (!(this instanceof SubError))
          return new SubError(message);
        notEnumerableProp2(
          this,
          "message",
          typeof message === "string" ? message : defaultMessage
        );
        notEnumerableProp2(this, "name", nameProperty);
        if (Error.captureStackTrace) {
          Error.captureStackTrace(this, this.constructor);
        } else {
          Error.call(this);
        }
      }
      inherits2(SubError, Error);
      return SubError;
    }
    var _TypeError;
    var _RangeError;
    var Warning = subError("Warning", "warning");
    var CancellationError = subError("CancellationError", "cancellation error");
    var TimeoutError = subError("TimeoutError", "timeout error");
    var AggregateError = subError("AggregateError", "aggregate error");
    try {
      _TypeError = TypeError;
      _RangeError = RangeError;
    } catch (e) {
      _TypeError = subError("TypeError", "type error");
      _RangeError = subError("RangeError", "range error");
    }
    var methods = "join pop push shift unshift slice filter forEach some every map indexOf lastIndexOf reduce reduceRight sort reverse".split(" ");
    for (i = 0; i < methods.length; ++i) {
      if (typeof Array.prototype[methods[i]] === "function") {
        AggregateError.prototype[methods[i]] = Array.prototype[methods[i]];
      }
    }
    var i;
    es52.defineProperty(AggregateError.prototype, "length", {
      value: 0,
      configurable: false,
      writable: true,
      enumerable: true
    });
    AggregateError.prototype["isOperational"] = true;
    var level = 0;
    AggregateError.prototype.toString = function() {
      var indent = Array(level * 4 + 1).join(" ");
      var ret2 = "\n" + indent + "AggregateError of:\n";
      level++;
      indent = Array(level * 4 + 1).join(" ");
      for (var i2 = 0; i2 < this.length; ++i2) {
        var str = this[i2] === this ? "[Circular AggregateError]" : this[i2] + "";
        var lines = str.split("\n");
        for (var j = 0; j < lines.length; ++j) {
          lines[j] = indent + lines[j];
        }
        str = lines.join("\n");
        ret2 += str + "\n";
      }
      level--;
      return ret2;
    };
    function OperationalError(message) {
      if (!(this instanceof OperationalError))
        return new OperationalError(message);
      notEnumerableProp2(this, "name", "OperationalError");
      notEnumerableProp2(this, "message", message);
      this.cause = message;
      this["isOperational"] = true;
      if (message instanceof Error) {
        notEnumerableProp2(this, "message", message.message);
        notEnumerableProp2(this, "stack", message.stack);
      } else if (Error.captureStackTrace) {
        Error.captureStackTrace(this, this.constructor);
      }
    }
    inherits2(OperationalError, Error);
    var errorTypes = Error["__BluebirdErrorTypes__"];
    if (!errorTypes) {
      errorTypes = Objectfreeze({
        CancellationError,
        TimeoutError,
        OperationalError,
        RejectionError: OperationalError,
        AggregateError
      });
      es52.defineProperty(Error, "__BluebirdErrorTypes__", {
        value: errorTypes,
        writable: false,
        enumerable: false,
        configurable: false
      });
    }
    module2.exports = {
      Error,
      TypeError: _TypeError,
      RangeError: _RangeError,
      CancellationError: errorTypes.CancellationError,
      OperationalError: errorTypes.OperationalError,
      TimeoutError: errorTypes.TimeoutError,
      AggregateError: errorTypes.AggregateError,
      Warning
    };
  }
});

// ../../../node_modules/bluebird/js/release/thenables.js
var require_thenables = __commonJS({
  "../../../node_modules/bluebird/js/release/thenables.js"(exports2, module2) {
    "use strict";
    module2.exports = function(Promise2, INTERNAL) {
      var util = require_util4();
      var errorObj2 = util.errorObj;
      var isObject2 = util.isObject;
      function tryConvertToPromise(obj2, context) {
        if (isObject2(obj2)) {
          if (obj2 instanceof Promise2)
            return obj2;
          var then = getThen(obj2);
          if (then === errorObj2) {
            if (context)
              context._pushContext();
            var ret2 = Promise2.reject(then.e);
            if (context)
              context._popContext();
            return ret2;
          } else if (typeof then === "function") {
            if (isAnyBluebirdPromise(obj2)) {
              var ret2 = new Promise2(INTERNAL);
              obj2._then(
                ret2._fulfill,
                ret2._reject,
                void 0,
                ret2,
                null
              );
              return ret2;
            }
            return doThenable(obj2, then, context);
          }
        }
        return obj2;
      }
      function doGetThen(obj2) {
        return obj2.then;
      }
      function getThen(obj2) {
        try {
          return doGetThen(obj2);
        } catch (e) {
          errorObj2.e = e;
          return errorObj2;
        }
      }
      var hasProp = {}.hasOwnProperty;
      function isAnyBluebirdPromise(obj2) {
        try {
          return hasProp.call(obj2, "_promise0");
        } catch (e) {
          return false;
        }
      }
      function doThenable(x, then, context) {
        var promise = new Promise2(INTERNAL);
        var ret2 = promise;
        if (context)
          context._pushContext();
        promise._captureStackTrace();
        if (context)
          context._popContext();
        var synchronous = true;
        var result = util.tryCatch(then).call(x, resolve, reject);
        synchronous = false;
        if (promise && result === errorObj2) {
          promise._rejectCallback(result.e, true, true);
          promise = null;
        }
        function resolve(value) {
          if (!promise)
            return;
          promise._resolveCallback(value);
          promise = null;
        }
        function reject(reason) {
          if (!promise)
            return;
          promise._rejectCallback(reason, synchronous, true);
          promise = null;
        }
        return ret2;
      }
      return tryConvertToPromise;
    };
  }
});

// ../../../node_modules/bluebird/js/release/promise_array.js
var require_promise_array = __commonJS({
  "../../../node_modules/bluebird/js/release/promise_array.js"(exports2, module2) {
    "use strict";
    module2.exports = function(Promise2, INTERNAL, tryConvertToPromise, apiRejection, Proxyable) {
      var util = require_util4();
      var isArray = util.isArray;
      function toResolutionValue(val) {
        switch (val) {
          case -2:
            return [];
          case -3:
            return {};
        }
      }
      function PromiseArray(values) {
        var promise = this._promise = new Promise2(INTERNAL);
        if (values instanceof Promise2) {
          promise._propagateFrom(values, 3);
        }
        promise._setOnCancel(this);
        this._values = values;
        this._length = 0;
        this._totalResolved = 0;
        this._init(void 0, -2);
      }
      util.inherits(PromiseArray, Proxyable);
      PromiseArray.prototype.length = function() {
        return this._length;
      };
      PromiseArray.prototype.promise = function() {
        return this._promise;
      };
      PromiseArray.prototype._init = function init(_2, resolveValueIfEmpty) {
        var values = tryConvertToPromise(this._values, this._promise);
        if (values instanceof Promise2) {
          values = values._target();
          var bitField = values._bitField;
          ;
          this._values = values;
          if ((bitField & 50397184) === 0) {
            this._promise._setAsyncGuaranteed();
            return values._then(
              init,
              this._reject,
              void 0,
              this,
              resolveValueIfEmpty
            );
          } else if ((bitField & 33554432) !== 0) {
            values = values._value();
          } else if ((bitField & 16777216) !== 0) {
            return this._reject(values._reason());
          } else {
            return this._cancel();
          }
        }
        values = util.asArray(values);
        if (values === null) {
          var err = apiRejection(
            "expecting an array or an iterable object but got " + util.classString(values)
          ).reason();
          this._promise._rejectCallback(err, false);
          return;
        }
        if (values.length === 0) {
          if (resolveValueIfEmpty === -5) {
            this._resolveEmptyArray();
          } else {
            this._resolve(toResolutionValue(resolveValueIfEmpty));
          }
          return;
        }
        this._iterate(values);
      };
      PromiseArray.prototype._iterate = function(values) {
        var len = this.getActualLength(values.length);
        this._length = len;
        this._values = this.shouldCopyValues() ? new Array(len) : this._values;
        var result = this._promise;
        var isResolved = false;
        var bitField = null;
        for (var i = 0; i < len; ++i) {
          var maybePromise = tryConvertToPromise(values[i], result);
          if (maybePromise instanceof Promise2) {
            maybePromise = maybePromise._target();
            bitField = maybePromise._bitField;
          } else {
            bitField = null;
          }
          if (isResolved) {
            if (bitField !== null) {
              maybePromise.suppressUnhandledRejections();
            }
          } else if (bitField !== null) {
            if ((bitField & 50397184) === 0) {
              maybePromise._proxy(this, i);
              this._values[i] = maybePromise;
            } else if ((bitField & 33554432) !== 0) {
              isResolved = this._promiseFulfilled(maybePromise._value(), i);
            } else if ((bitField & 16777216) !== 0) {
              isResolved = this._promiseRejected(maybePromise._reason(), i);
            } else {
              isResolved = this._promiseCancelled(i);
            }
          } else {
            isResolved = this._promiseFulfilled(maybePromise, i);
          }
        }
        if (!isResolved)
          result._setAsyncGuaranteed();
      };
      PromiseArray.prototype._isResolved = function() {
        return this._values === null;
      };
      PromiseArray.prototype._resolve = function(value) {
        this._values = null;
        this._promise._fulfill(value);
      };
      PromiseArray.prototype._cancel = function() {
        if (this._isResolved() || !this._promise._isCancellable())
          return;
        this._values = null;
        this._promise._cancel();
      };
      PromiseArray.prototype._reject = function(reason) {
        this._values = null;
        this._promise._rejectCallback(reason, false);
      };
      PromiseArray.prototype._promiseFulfilled = function(value, index) {
        this._values[index] = value;
        var totalResolved = ++this._totalResolved;
        if (totalResolved >= this._length) {
          this._resolve(this._values);
          return true;
        }
        return false;
      };
      PromiseArray.prototype._promiseCancelled = function() {
        this._cancel();
        return true;
      };
      PromiseArray.prototype._promiseRejected = function(reason) {
        this._totalResolved++;
        this._reject(reason);
        return true;
      };
      PromiseArray.prototype._resultCancelled = function() {
        if (this._isResolved())
          return;
        var values = this._values;
        this._cancel();
        if (values instanceof Promise2) {
          values.cancel();
        } else {
          for (var i = 0; i < values.length; ++i) {
            if (values[i] instanceof Promise2) {
              values[i].cancel();
            }
          }
        }
      };
      PromiseArray.prototype.shouldCopyValues = function() {
        return true;
      };
      PromiseArray.prototype.getActualLength = function(len) {
        return len;
      };
      return PromiseArray;
    };
  }
});

// ../../../node_modules/bluebird/js/release/context.js
var require_context = __commonJS({
  "../../../node_modules/bluebird/js/release/context.js"(exports2, module2) {
    "use strict";
    module2.exports = function(Promise2) {
      var longStackTraces = false;
      var contextStack = [];
      Promise2.prototype._promiseCreated = function() {
      };
      Promise2.prototype._pushContext = function() {
      };
      Promise2.prototype._popContext = function() {
        return null;
      };
      Promise2._peekContext = Promise2.prototype._peekContext = function() {
      };
      function Context() {
        this._trace = new Context.CapturedTrace(peekContext());
      }
      Context.prototype._pushContext = function() {
        if (this._trace !== void 0) {
          this._trace._promiseCreated = null;
          contextStack.push(this._trace);
        }
      };
      Context.prototype._popContext = function() {
        if (this._trace !== void 0) {
          var trace = contextStack.pop();
          var ret2 = trace._promiseCreated;
          trace._promiseCreated = null;
          return ret2;
        }
        return null;
      };
      function createContext() {
        if (longStackTraces)
          return new Context();
      }
      function peekContext() {
        var lastIndex = contextStack.length - 1;
        if (lastIndex >= 0) {
          return contextStack[lastIndex];
        }
        return void 0;
      }
      Context.CapturedTrace = null;
      Context.create = createContext;
      Context.deactivateLongStackTraces = function() {
      };
      Context.activateLongStackTraces = function() {
        var Promise_pushContext = Promise2.prototype._pushContext;
        var Promise_popContext = Promise2.prototype._popContext;
        var Promise_PeekContext = Promise2._peekContext;
        var Promise_peekContext = Promise2.prototype._peekContext;
        var Promise_promiseCreated = Promise2.prototype._promiseCreated;
        Context.deactivateLongStackTraces = function() {
          Promise2.prototype._pushContext = Promise_pushContext;
          Promise2.prototype._popContext = Promise_popContext;
          Promise2._peekContext = Promise_PeekContext;
          Promise2.prototype._peekContext = Promise_peekContext;
          Promise2.prototype._promiseCreated = Promise_promiseCreated;
          longStackTraces = false;
        };
        longStackTraces = true;
        Promise2.prototype._pushContext = Context.prototype._pushContext;
        Promise2.prototype._popContext = Context.prototype._popContext;
        Promise2._peekContext = Promise2.prototype._peekContext = peekContext;
        Promise2.prototype._promiseCreated = function() {
          var ctx = this._peekContext();
          if (ctx && ctx._promiseCreated == null)
            ctx._promiseCreated = this;
        };
      };
      return Context;
    };
  }
});

// ../../../node_modules/bluebird/js/release/debuggability.js
var require_debuggability = __commonJS({
  "../../../node_modules/bluebird/js/release/debuggability.js"(exports2, module2) {
    "use strict";
    module2.exports = function(Promise2, Context) {
      var getDomain = Promise2._getDomain;
      var async = Promise2._async;
      var Warning = require_errors8().Warning;
      var util = require_util4();
      var canAttachTrace2 = util.canAttachTrace;
      var unhandledRejectionHandled;
      var possiblyUnhandledRejection;
      var bluebirdFramePattern = /[\\\/]bluebird[\\\/]js[\\\/](release|debug|instrumented)/;
      var nodeFramePattern = /\((?:timers\.js):\d+:\d+\)/;
      var parseLinePattern = /[\/<\(](.+?):(\d+):(\d+)\)?\s*$/;
      var stackFramePattern = null;
      var formatStack = null;
      var indentStackFrames = false;
      var printWarning;
      var debugging = !!(util.env("BLUEBIRD_DEBUG") != 0 && (util.env("BLUEBIRD_DEBUG") || util.env("NODE_ENV") === "development"));
      var warnings = !!(util.env("BLUEBIRD_WARNINGS") != 0 && (debugging || util.env("BLUEBIRD_WARNINGS")));
      var longStackTraces = !!(util.env("BLUEBIRD_LONG_STACK_TRACES") != 0 && (debugging || util.env("BLUEBIRD_LONG_STACK_TRACES")));
      var wForgottenReturn = util.env("BLUEBIRD_W_FORGOTTEN_RETURN") != 0 && (warnings || !!util.env("BLUEBIRD_W_FORGOTTEN_RETURN"));
      Promise2.prototype.suppressUnhandledRejections = function() {
        var target = this._target();
        target._bitField = target._bitField & ~1048576 | 524288;
      };
      Promise2.prototype._ensurePossibleRejectionHandled = function() {
        if ((this._bitField & 524288) !== 0)
          return;
        this._setRejectionIsUnhandled();
        async.invokeLater(this._notifyUnhandledRejection, this, void 0);
      };
      Promise2.prototype._notifyUnhandledRejectionIsHandled = function() {
        fireRejectionEvent(
          "rejectionHandled",
          unhandledRejectionHandled,
          void 0,
          this
        );
      };
      Promise2.prototype._setReturnedNonUndefined = function() {
        this._bitField = this._bitField | 268435456;
      };
      Promise2.prototype._returnedNonUndefined = function() {
        return (this._bitField & 268435456) !== 0;
      };
      Promise2.prototype._notifyUnhandledRejection = function() {
        if (this._isRejectionUnhandled()) {
          var reason = this._settledValue();
          this._setUnhandledRejectionIsNotified();
          fireRejectionEvent(
            "unhandledRejection",
            possiblyUnhandledRejection,
            reason,
            this
          );
        }
      };
      Promise2.prototype._setUnhandledRejectionIsNotified = function() {
        this._bitField = this._bitField | 262144;
      };
      Promise2.prototype._unsetUnhandledRejectionIsNotified = function() {
        this._bitField = this._bitField & ~262144;
      };
      Promise2.prototype._isUnhandledRejectionNotified = function() {
        return (this._bitField & 262144) > 0;
      };
      Promise2.prototype._setRejectionIsUnhandled = function() {
        this._bitField = this._bitField | 1048576;
      };
      Promise2.prototype._unsetRejectionIsUnhandled = function() {
        this._bitField = this._bitField & ~1048576;
        if (this._isUnhandledRejectionNotified()) {
          this._unsetUnhandledRejectionIsNotified();
          this._notifyUnhandledRejectionIsHandled();
        }
      };
      Promise2.prototype._isRejectionUnhandled = function() {
        return (this._bitField & 1048576) > 0;
      };
      Promise2.prototype._warn = function(message, shouldUseOwnTrace, promise) {
        return warn(message, shouldUseOwnTrace, promise || this);
      };
      Promise2.onPossiblyUnhandledRejection = function(fn) {
        var domain = getDomain();
        possiblyUnhandledRejection = typeof fn === "function" ? domain === null ? fn : util.domainBind(domain, fn) : void 0;
      };
      Promise2.onUnhandledRejectionHandled = function(fn) {
        var domain = getDomain();
        unhandledRejectionHandled = typeof fn === "function" ? domain === null ? fn : util.domainBind(domain, fn) : void 0;
      };
      var disableLongStackTraces = function() {
      };
      Promise2.longStackTraces = function() {
        if (async.haveItemsQueued() && !config.longStackTraces) {
          throw new Error("cannot enable long stack traces after promises have been created\n\n    See http://goo.gl/MqrFmX\n");
        }
        if (!config.longStackTraces && longStackTracesIsSupported()) {
          var Promise_captureStackTrace = Promise2.prototype._captureStackTrace;
          var Promise_attachExtraTrace = Promise2.prototype._attachExtraTrace;
          config.longStackTraces = true;
          disableLongStackTraces = function() {
            if (async.haveItemsQueued() && !config.longStackTraces) {
              throw new Error("cannot enable long stack traces after promises have been created\n\n    See http://goo.gl/MqrFmX\n");
            }
            Promise2.prototype._captureStackTrace = Promise_captureStackTrace;
            Promise2.prototype._attachExtraTrace = Promise_attachExtraTrace;
            Context.deactivateLongStackTraces();
            async.enableTrampoline();
            config.longStackTraces = false;
          };
          Promise2.prototype._captureStackTrace = longStackTracesCaptureStackTrace;
          Promise2.prototype._attachExtraTrace = longStackTracesAttachExtraTrace;
          Context.activateLongStackTraces();
          async.disableTrampolineIfNecessary();
        }
      };
      Promise2.hasLongStackTraces = function() {
        return config.longStackTraces && longStackTracesIsSupported();
      };
      var fireDomEvent = function() {
        try {
          if (typeof CustomEvent === "function") {
            var event = new CustomEvent("CustomEvent");
            util.global.dispatchEvent(event);
            return function(name, event2) {
              var domEvent = new CustomEvent(name.toLowerCase(), {
                detail: event2,
                cancelable: true
              });
              return !util.global.dispatchEvent(domEvent);
            };
          } else if (typeof Event === "function") {
            var event = new Event("CustomEvent");
            util.global.dispatchEvent(event);
            return function(name, event2) {
              var domEvent = new Event(name.toLowerCase(), {
                cancelable: true
              });
              domEvent.detail = event2;
              return !util.global.dispatchEvent(domEvent);
            };
          } else {
            var event = document.createEvent("CustomEvent");
            event.initCustomEvent("testingtheevent", false, true, {});
            util.global.dispatchEvent(event);
            return function(name, event2) {
              var domEvent = document.createEvent("CustomEvent");
              domEvent.initCustomEvent(
                name.toLowerCase(),
                false,
                true,
                event2
              );
              return !util.global.dispatchEvent(domEvent);
            };
          }
        } catch (e) {
        }
        return function() {
          return false;
        };
      }();
      var fireGlobalEvent = function() {
        if (util.isNode) {
          return function() {
            return process.emit.apply(process, arguments);
          };
        } else {
          if (!util.global) {
            return function() {
              return false;
            };
          }
          return function(name) {
            var methodName = "on" + name.toLowerCase();
            var method = util.global[methodName];
            if (!method)
              return false;
            method.apply(util.global, [].slice.call(arguments, 1));
            return true;
          };
        }
      }();
      function generatePromiseLifecycleEventObject(name, promise) {
        return { promise };
      }
      var eventToObjectGenerator = {
        promiseCreated: generatePromiseLifecycleEventObject,
        promiseFulfilled: generatePromiseLifecycleEventObject,
        promiseRejected: generatePromiseLifecycleEventObject,
        promiseResolved: generatePromiseLifecycleEventObject,
        promiseCancelled: generatePromiseLifecycleEventObject,
        promiseChained: function(name, promise, child) {
          return { promise, child };
        },
        warning: function(name, warning) {
          return { warning };
        },
        unhandledRejection: function(name, reason, promise) {
          return { reason, promise };
        },
        rejectionHandled: generatePromiseLifecycleEventObject
      };
      var activeFireEvent = function(name) {
        var globalEventFired = false;
        try {
          globalEventFired = fireGlobalEvent.apply(null, arguments);
        } catch (e) {
          async.throwLater(e);
          globalEventFired = true;
        }
        var domEventFired = false;
        try {
          domEventFired = fireDomEvent(
            name,
            eventToObjectGenerator[name].apply(null, arguments)
          );
        } catch (e) {
          async.throwLater(e);
          domEventFired = true;
        }
        return domEventFired || globalEventFired;
      };
      Promise2.config = function(opts) {
        opts = Object(opts);
        if ("longStackTraces" in opts) {
          if (opts.longStackTraces) {
            Promise2.longStackTraces();
          } else if (!opts.longStackTraces && Promise2.hasLongStackTraces()) {
            disableLongStackTraces();
          }
        }
        if ("warnings" in opts) {
          var warningsOption = opts.warnings;
          config.warnings = !!warningsOption;
          wForgottenReturn = config.warnings;
          if (util.isObject(warningsOption)) {
            if ("wForgottenReturn" in warningsOption) {
              wForgottenReturn = !!warningsOption.wForgottenReturn;
            }
          }
        }
        if ("cancellation" in opts && opts.cancellation && !config.cancellation) {
          if (async.haveItemsQueued()) {
            throw new Error(
              "cannot enable cancellation after promises are in use"
            );
          }
          Promise2.prototype._clearCancellationData = cancellationClearCancellationData;
          Promise2.prototype._propagateFrom = cancellationPropagateFrom;
          Promise2.prototype._onCancel = cancellationOnCancel;
          Promise2.prototype._setOnCancel = cancellationSetOnCancel;
          Promise2.prototype._attachCancellationCallback = cancellationAttachCancellationCallback;
          Promise2.prototype._execute = cancellationExecute;
          propagateFromFunction = cancellationPropagateFrom;
          config.cancellation = true;
        }
        if ("monitoring" in opts) {
          if (opts.monitoring && !config.monitoring) {
            config.monitoring = true;
            Promise2.prototype._fireEvent = activeFireEvent;
          } else if (!opts.monitoring && config.monitoring) {
            config.monitoring = false;
            Promise2.prototype._fireEvent = defaultFireEvent;
          }
        }
        return Promise2;
      };
      function defaultFireEvent() {
        return false;
      }
      Promise2.prototype._fireEvent = defaultFireEvent;
      Promise2.prototype._execute = function(executor, resolve, reject) {
        try {
          executor(resolve, reject);
        } catch (e) {
          return e;
        }
      };
      Promise2.prototype._onCancel = function() {
      };
      Promise2.prototype._setOnCancel = function(handler) {
        ;
      };
      Promise2.prototype._attachCancellationCallback = function(onCancel) {
        ;
      };
      Promise2.prototype._captureStackTrace = function() {
      };
      Promise2.prototype._attachExtraTrace = function() {
      };
      Promise2.prototype._clearCancellationData = function() {
      };
      Promise2.prototype._propagateFrom = function(parent, flags) {
        ;
        ;
      };
      function cancellationExecute(executor, resolve, reject) {
        var promise = this;
        try {
          executor(resolve, reject, function(onCancel) {
            if (typeof onCancel !== "function") {
              throw new TypeError("onCancel must be a function, got: " + util.toString(onCancel));
            }
            promise._attachCancellationCallback(onCancel);
          });
        } catch (e) {
          return e;
        }
      }
      function cancellationAttachCancellationCallback(onCancel) {
        if (!this._isCancellable())
          return this;
        var previousOnCancel = this._onCancel();
        if (previousOnCancel !== void 0) {
          if (util.isArray(previousOnCancel)) {
            previousOnCancel.push(onCancel);
          } else {
            this._setOnCancel([previousOnCancel, onCancel]);
          }
        } else {
          this._setOnCancel(onCancel);
        }
      }
      function cancellationOnCancel() {
        return this._onCancelField;
      }
      function cancellationSetOnCancel(onCancel) {
        this._onCancelField = onCancel;
      }
      function cancellationClearCancellationData() {
        this._cancellationParent = void 0;
        this._onCancelField = void 0;
      }
      function cancellationPropagateFrom(parent, flags) {
        if ((flags & 1) !== 0) {
          this._cancellationParent = parent;
          var branchesRemainingToCancel = parent._branchesRemainingToCancel;
          if (branchesRemainingToCancel === void 0) {
            branchesRemainingToCancel = 0;
          }
          parent._branchesRemainingToCancel = branchesRemainingToCancel + 1;
        }
        if ((flags & 2) !== 0 && parent._isBound()) {
          this._setBoundTo(parent._boundTo);
        }
      }
      function bindingPropagateFrom(parent, flags) {
        if ((flags & 2) !== 0 && parent._isBound()) {
          this._setBoundTo(parent._boundTo);
        }
      }
      var propagateFromFunction = bindingPropagateFrom;
      function boundValueFunction() {
        var ret2 = this._boundTo;
        if (ret2 !== void 0) {
          if (ret2 instanceof Promise2) {
            if (ret2.isFulfilled()) {
              return ret2.value();
            } else {
              return void 0;
            }
          }
        }
        return ret2;
      }
      function longStackTracesCaptureStackTrace() {
        this._trace = new CapturedTrace(this._peekContext());
      }
      function longStackTracesAttachExtraTrace(error, ignoreSelf) {
        if (canAttachTrace2(error)) {
          var trace = this._trace;
          if (trace !== void 0) {
            if (ignoreSelf)
              trace = trace._parent;
          }
          if (trace !== void 0) {
            trace.attachExtraTrace(error);
          } else if (!error.__stackCleaned__) {
            var parsed = parseStackAndMessage(error);
            util.notEnumerableProp(
              error,
              "stack",
              parsed.message + "\n" + parsed.stack.join("\n")
            );
            util.notEnumerableProp(error, "__stackCleaned__", true);
          }
        }
      }
      function checkForgottenReturns(returnValue, promiseCreated, name, promise, parent) {
        if (returnValue === void 0 && promiseCreated !== null && wForgottenReturn) {
          if (parent !== void 0 && parent._returnedNonUndefined())
            return;
          if ((promise._bitField & 65535) === 0)
            return;
          if (name)
            name = name + " ";
          var handlerLine = "";
          var creatorLine = "";
          if (promiseCreated._trace) {
            var traceLines = promiseCreated._trace.stack.split("\n");
            var stack = cleanStack(traceLines);
            for (var i = stack.length - 1; i >= 0; --i) {
              var line = stack[i];
              if (!nodeFramePattern.test(line)) {
                var lineMatches = line.match(parseLinePattern);
                if (lineMatches) {
                  handlerLine = "at " + lineMatches[1] + ":" + lineMatches[2] + ":" + lineMatches[3] + " ";
                }
                break;
              }
            }
            if (stack.length > 0) {
              var firstUserLine = stack[0];
              for (var i = 0; i < traceLines.length; ++i) {
                if (traceLines[i] === firstUserLine) {
                  if (i > 0) {
                    creatorLine = "\n" + traceLines[i - 1];
                  }
                  break;
                }
              }
            }
          }
          var msg = "a promise was created in a " + name + "handler " + handlerLine + "but was not returned from it, see http://goo.gl/rRqMUw" + creatorLine;
          promise._warn(msg, true, promiseCreated);
        }
      }
      function deprecated(name, replacement) {
        var message = name + " is deprecated and will be removed in a future version.";
        if (replacement)
          message += " Use " + replacement + " instead.";
        return warn(message);
      }
      function warn(message, shouldUseOwnTrace, promise) {
        if (!config.warnings)
          return;
        var warning = new Warning(message);
        var ctx;
        if (shouldUseOwnTrace) {
          promise._attachExtraTrace(warning);
        } else if (config.longStackTraces && (ctx = Promise2._peekContext())) {
          ctx.attachExtraTrace(warning);
        } else {
          var parsed = parseStackAndMessage(warning);
          warning.stack = parsed.message + "\n" + parsed.stack.join("\n");
        }
        if (!activeFireEvent("warning", warning)) {
          formatAndLogError(warning, "", true);
        }
      }
      function reconstructStack(message, stacks) {
        for (var i = 0; i < stacks.length - 1; ++i) {
          stacks[i].push("From previous event:");
          stacks[i] = stacks[i].join("\n");
        }
        if (i < stacks.length) {
          stacks[i] = stacks[i].join("\n");
        }
        return message + "\n" + stacks.join("\n");
      }
      function removeDuplicateOrEmptyJumps(stacks) {
        for (var i = 0; i < stacks.length; ++i) {
          if (stacks[i].length === 0 || i + 1 < stacks.length && stacks[i][0] === stacks[i + 1][0]) {
            stacks.splice(i, 1);
            i--;
          }
        }
      }
      function removeCommonRoots(stacks) {
        var current = stacks[0];
        for (var i = 1; i < stacks.length; ++i) {
          var prev = stacks[i];
          var currentLastIndex = current.length - 1;
          var currentLastLine = current[currentLastIndex];
          var commonRootMeetPoint = -1;
          for (var j = prev.length - 1; j >= 0; --j) {
            if (prev[j] === currentLastLine) {
              commonRootMeetPoint = j;
              break;
            }
          }
          for (var j = commonRootMeetPoint; j >= 0; --j) {
            var line = prev[j];
            if (current[currentLastIndex] === line) {
              current.pop();
              currentLastIndex--;
            } else {
              break;
            }
          }
          current = prev;
        }
      }
      function cleanStack(stack) {
        var ret2 = [];
        for (var i = 0; i < stack.length; ++i) {
          var line = stack[i];
          var isTraceLine = "    (No stack trace)" === line || stackFramePattern.test(line);
          var isInternalFrame = isTraceLine && shouldIgnore(line);
          if (isTraceLine && !isInternalFrame) {
            if (indentStackFrames && line.charAt(0) !== " ") {
              line = "    " + line;
            }
            ret2.push(line);
          }
        }
        return ret2;
      }
      function stackFramesAsArray(error) {
        var stack = error.stack.replace(/\s+$/g, "").split("\n");
        for (var i = 0; i < stack.length; ++i) {
          var line = stack[i];
          if ("    (No stack trace)" === line || stackFramePattern.test(line)) {
            break;
          }
        }
        if (i > 0 && error.name != "SyntaxError") {
          stack = stack.slice(i);
        }
        return stack;
      }
      function parseStackAndMessage(error) {
        var stack = error.stack;
        var message = error.toString();
        stack = typeof stack === "string" && stack.length > 0 ? stackFramesAsArray(error) : ["    (No stack trace)"];
        return {
          message,
          stack: error.name == "SyntaxError" ? stack : cleanStack(stack)
        };
      }
      function formatAndLogError(error, title, isSoft) {
        if (typeof console !== "undefined") {
          var message;
          if (util.isObject(error)) {
            var stack = error.stack;
            message = title + formatStack(stack, error);
          } else {
            message = title + String(error);
          }
          if (typeof printWarning === "function") {
            printWarning(message, isSoft);
          } else if (typeof console.log === "function" || typeof console.log === "object") {
            console.log(message);
          }
        }
      }
      function fireRejectionEvent(name, localHandler, reason, promise) {
        var localEventFired = false;
        try {
          if (typeof localHandler === "function") {
            localEventFired = true;
            if (name === "rejectionHandled") {
              localHandler(promise);
            } else {
              localHandler(reason, promise);
            }
          }
        } catch (e) {
          async.throwLater(e);
        }
        if (name === "unhandledRejection") {
          if (!activeFireEvent(name, reason, promise) && !localEventFired) {
            formatAndLogError(reason, "Unhandled rejection ");
          }
        } else {
          activeFireEvent(name, promise);
        }
      }
      function formatNonError(obj2) {
        var str;
        if (typeof obj2 === "function") {
          str = "[function " + (obj2.name || "anonymous") + "]";
        } else {
          str = obj2 && typeof obj2.toString === "function" ? obj2.toString() : util.toString(obj2);
          var ruselessToString = /\[object [a-zA-Z0-9$_]+\]/;
          if (ruselessToString.test(str)) {
            try {
              var newStr = JSON.stringify(obj2);
              str = newStr;
            } catch (e) {
            }
          }
          if (str.length === 0) {
            str = "(empty array)";
          }
        }
        return "(<" + snip(str) + ">, no stack trace)";
      }
      function snip(str) {
        var maxChars = 41;
        if (str.length < maxChars) {
          return str;
        }
        return str.substr(0, maxChars - 3) + "...";
      }
      function longStackTracesIsSupported() {
        return typeof captureStackTrace === "function";
      }
      var shouldIgnore = function() {
        return false;
      };
      var parseLineInfoRegex = /[\/<\(]([^:\/]+):(\d+):(?:\d+)\)?\s*$/;
      function parseLineInfo(line) {
        var matches = line.match(parseLineInfoRegex);
        if (matches) {
          return {
            fileName: matches[1],
            line: parseInt(matches[2], 10)
          };
        }
      }
      function setBounds(firstLineError, lastLineError) {
        if (!longStackTracesIsSupported())
          return;
        var firstStackLines = firstLineError.stack.split("\n");
        var lastStackLines = lastLineError.stack.split("\n");
        var firstIndex = -1;
        var lastIndex = -1;
        var firstFileName;
        var lastFileName;
        for (var i = 0; i < firstStackLines.length; ++i) {
          var result = parseLineInfo(firstStackLines[i]);
          if (result) {
            firstFileName = result.fileName;
            firstIndex = result.line;
            break;
          }
        }
        for (var i = 0; i < lastStackLines.length; ++i) {
          var result = parseLineInfo(lastStackLines[i]);
          if (result) {
            lastFileName = result.fileName;
            lastIndex = result.line;
            break;
          }
        }
        if (firstIndex < 0 || lastIndex < 0 || !firstFileName || !lastFileName || firstFileName !== lastFileName || firstIndex >= lastIndex) {
          return;
        }
        shouldIgnore = function(line) {
          if (bluebirdFramePattern.test(line))
            return true;
          var info = parseLineInfo(line);
          if (info) {
            if (info.fileName === firstFileName && (firstIndex <= info.line && info.line <= lastIndex)) {
              return true;
            }
          }
          return false;
        };
      }
      function CapturedTrace(parent) {
        this._parent = parent;
        this._promisesCreated = 0;
        var length = this._length = 1 + (parent === void 0 ? 0 : parent._length);
        captureStackTrace(this, CapturedTrace);
        if (length > 32)
          this.uncycle();
      }
      util.inherits(CapturedTrace, Error);
      Context.CapturedTrace = CapturedTrace;
      CapturedTrace.prototype.uncycle = function() {
        var length = this._length;
        if (length < 2)
          return;
        var nodes = [];
        var stackToIndex = {};
        for (var i = 0, node = this; node !== void 0; ++i) {
          nodes.push(node);
          node = node._parent;
        }
        length = this._length = i;
        for (var i = length - 1; i >= 0; --i) {
          var stack = nodes[i].stack;
          if (stackToIndex[stack] === void 0) {
            stackToIndex[stack] = i;
          }
        }
        for (var i = 0; i < length; ++i) {
          var currentStack = nodes[i].stack;
          var index = stackToIndex[currentStack];
          if (index !== void 0 && index !== i) {
            if (index > 0) {
              nodes[index - 1]._parent = void 0;
              nodes[index - 1]._length = 1;
            }
            nodes[i]._parent = void 0;
            nodes[i]._length = 1;
            var cycleEdgeNode = i > 0 ? nodes[i - 1] : this;
            if (index < length - 1) {
              cycleEdgeNode._parent = nodes[index + 1];
              cycleEdgeNode._parent.uncycle();
              cycleEdgeNode._length = cycleEdgeNode._parent._length + 1;
            } else {
              cycleEdgeNode._parent = void 0;
              cycleEdgeNode._length = 1;
            }
            var currentChildLength = cycleEdgeNode._length + 1;
            for (var j = i - 2; j >= 0; --j) {
              nodes[j]._length = currentChildLength;
              currentChildLength++;
            }
            return;
          }
        }
      };
      CapturedTrace.prototype.attachExtraTrace = function(error) {
        if (error.__stackCleaned__)
          return;
        this.uncycle();
        var parsed = parseStackAndMessage(error);
        var message = parsed.message;
        var stacks = [parsed.stack];
        var trace = this;
        while (trace !== void 0) {
          stacks.push(cleanStack(trace.stack.split("\n")));
          trace = trace._parent;
        }
        removeCommonRoots(stacks);
        removeDuplicateOrEmptyJumps(stacks);
        util.notEnumerableProp(error, "stack", reconstructStack(message, stacks));
        util.notEnumerableProp(error, "__stackCleaned__", true);
      };
      var captureStackTrace = function stackDetection() {
        var v8stackFramePattern = /^\s*at\s*/;
        var v8stackFormatter = function(stack, error) {
          if (typeof stack === "string")
            return stack;
          if (error.name !== void 0 && error.message !== void 0) {
            return error.toString();
          }
          return formatNonError(error);
        };
        if (typeof Error.stackTraceLimit === "number" && typeof Error.captureStackTrace === "function") {
          Error.stackTraceLimit += 6;
          stackFramePattern = v8stackFramePattern;
          formatStack = v8stackFormatter;
          var captureStackTrace2 = Error.captureStackTrace;
          shouldIgnore = function(line) {
            return bluebirdFramePattern.test(line);
          };
          return function(receiver, ignoreUntil) {
            Error.stackTraceLimit += 6;
            captureStackTrace2(receiver, ignoreUntil);
            Error.stackTraceLimit -= 6;
          };
        }
        var err = new Error();
        if (typeof err.stack === "string" && err.stack.split("\n")[0].indexOf("stackDetection@") >= 0) {
          stackFramePattern = /@/;
          formatStack = v8stackFormatter;
          indentStackFrames = true;
          return function captureStackTrace3(o) {
            o.stack = new Error().stack;
          };
        }
        var hasStackAfterThrow;
        try {
          throw new Error();
        } catch (e) {
          hasStackAfterThrow = "stack" in e;
        }
        if (!("stack" in err) && hasStackAfterThrow && typeof Error.stackTraceLimit === "number") {
          stackFramePattern = v8stackFramePattern;
          formatStack = v8stackFormatter;
          return function captureStackTrace3(o) {
            Error.stackTraceLimit += 6;
            try {
              throw new Error();
            } catch (e) {
              o.stack = e.stack;
            }
            Error.stackTraceLimit -= 6;
          };
        }
        formatStack = function(stack, error) {
          if (typeof stack === "string")
            return stack;
          if ((typeof error === "object" || typeof error === "function") && error.name !== void 0 && error.message !== void 0) {
            return error.toString();
          }
          return formatNonError(error);
        };
        return null;
      }([]);
      if (typeof console !== "undefined" && typeof console.warn !== "undefined") {
        printWarning = function(message) {
          console.warn(message);
        };
        if (util.isNode && process.stderr.isTTY) {
          printWarning = function(message, isSoft) {
            var color = isSoft ? "\x1B[33m" : "\x1B[31m";
            console.warn(color + message + "\x1B[0m\n");
          };
        } else if (!util.isNode && typeof new Error().stack === "string") {
          printWarning = function(message, isSoft) {
            console.warn(
              "%c" + message,
              isSoft ? "color: darkorange" : "color: red"
            );
          };
        }
      }
      var config = {
        warnings,
        longStackTraces: false,
        cancellation: false,
        monitoring: false
      };
      if (longStackTraces)
        Promise2.longStackTraces();
      return {
        longStackTraces: function() {
          return config.longStackTraces;
        },
        warnings: function() {
          return config.warnings;
        },
        cancellation: function() {
          return config.cancellation;
        },
        monitoring: function() {
          return config.monitoring;
        },
        propagateFromFunction: function() {
          return propagateFromFunction;
        },
        boundValueFunction: function() {
          return boundValueFunction;
        },
        checkForgottenReturns,
        setBounds,
        warn,
        deprecated,
        CapturedTrace,
        fireDomEvent,
        fireGlobalEvent
      };
    };
  }
});

// ../../../node_modules/bluebird/js/release/finally.js
var require_finally = __commonJS({
  "../../../node_modules/bluebird/js/release/finally.js"(exports2, module2) {
    "use strict";
    module2.exports = function(Promise2, tryConvertToPromise) {
      var util = require_util4();
      var CancellationError = Promise2.CancellationError;
      var errorObj2 = util.errorObj;
      function PassThroughHandlerContext(promise, type, handler) {
        this.promise = promise;
        this.type = type;
        this.handler = handler;
        this.called = false;
        this.cancelPromise = null;
      }
      PassThroughHandlerContext.prototype.isFinallyHandler = function() {
        return this.type === 0;
      };
      function FinallyHandlerCancelReaction(finallyHandler2) {
        this.finallyHandler = finallyHandler2;
      }
      FinallyHandlerCancelReaction.prototype._resultCancelled = function() {
        checkCancel(this.finallyHandler);
      };
      function checkCancel(ctx, reason) {
        if (ctx.cancelPromise != null) {
          if (arguments.length > 1) {
            ctx.cancelPromise._reject(reason);
          } else {
            ctx.cancelPromise._cancel();
          }
          ctx.cancelPromise = null;
          return true;
        }
        return false;
      }
      function succeed() {
        return finallyHandler.call(this, this.promise._target()._settledValue());
      }
      function fail(reason) {
        if (checkCancel(this, reason))
          return;
        errorObj2.e = reason;
        return errorObj2;
      }
      function finallyHandler(reasonOrValue) {
        var promise = this.promise;
        var handler = this.handler;
        if (!this.called) {
          this.called = true;
          var ret2 = this.isFinallyHandler() ? handler.call(promise._boundValue()) : handler.call(promise._boundValue(), reasonOrValue);
          if (ret2 !== void 0) {
            promise._setReturnedNonUndefined();
            var maybePromise = tryConvertToPromise(ret2, promise);
            if (maybePromise instanceof Promise2) {
              if (this.cancelPromise != null) {
                if (maybePromise._isCancelled()) {
                  var reason = new CancellationError("late cancellation observer");
                  promise._attachExtraTrace(reason);
                  errorObj2.e = reason;
                  return errorObj2;
                } else if (maybePromise.isPending()) {
                  maybePromise._attachCancellationCallback(
                    new FinallyHandlerCancelReaction(this)
                  );
                }
              }
              return maybePromise._then(
                succeed,
                fail,
                void 0,
                this,
                void 0
              );
            }
          }
        }
        if (promise.isRejected()) {
          checkCancel(this);
          errorObj2.e = reasonOrValue;
          return errorObj2;
        } else {
          checkCancel(this);
          return reasonOrValue;
        }
      }
      Promise2.prototype._passThrough = function(handler, type, success, fail2) {
        if (typeof handler !== "function")
          return this.then();
        return this._then(
          success,
          fail2,
          void 0,
          new PassThroughHandlerContext(this, type, handler),
          void 0
        );
      };
      Promise2.prototype.lastly = Promise2.prototype["finally"] = function(handler) {
        return this._passThrough(
          handler,
          0,
          finallyHandler,
          finallyHandler
        );
      };
      Promise2.prototype.tap = function(handler) {
        return this._passThrough(handler, 1, finallyHandler);
      };
      return PassThroughHandlerContext;
    };
  }
});

// ../../../node_modules/bluebird/js/release/catch_filter.js
var require_catch_filter = __commonJS({
  "../../../node_modules/bluebird/js/release/catch_filter.js"(exports2, module2) {
    "use strict";
    module2.exports = function(NEXT_FILTER) {
      var util = require_util4();
      var getKeys = require_es5().keys;
      var tryCatch2 = util.tryCatch;
      var errorObj2 = util.errorObj;
      function catchFilter(instances, cb, promise) {
        return function(e) {
          var boundTo = promise._boundValue();
          predicateLoop:
            for (var i = 0; i < instances.length; ++i) {
              var item = instances[i];
              if (item === Error || item != null && item.prototype instanceof Error) {
                if (e instanceof item) {
                  return tryCatch2(cb).call(boundTo, e);
                }
              } else if (typeof item === "function") {
                var matchesPredicate = tryCatch2(item).call(boundTo, e);
                if (matchesPredicate === errorObj2) {
                  return matchesPredicate;
                } else if (matchesPredicate) {
                  return tryCatch2(cb).call(boundTo, e);
                }
              } else if (util.isObject(e)) {
                var keys = getKeys(item);
                for (var j = 0; j < keys.length; ++j) {
                  var key = keys[j];
                  if (item[key] != e[key]) {
                    continue predicateLoop;
                  }
                }
                return tryCatch2(cb).call(boundTo, e);
              }
            }
          return NEXT_FILTER;
        };
      }
      return catchFilter;
    };
  }
});

// ../../../node_modules/bluebird/js/release/nodeback.js
var require_nodeback = __commonJS({
  "../../../node_modules/bluebird/js/release/nodeback.js"(exports2, module2) {
    "use strict";
    var util = require_util4();
    var maybeWrapAsError2 = util.maybeWrapAsError;
    var errors = require_errors8();
    var OperationalError = errors.OperationalError;
    var es52 = require_es5();
    function isUntypedError(obj2) {
      return obj2 instanceof Error && es52.getPrototypeOf(obj2) === Error.prototype;
    }
    var rErrorKey = /^(?:name|message|stack|cause)$/;
    function wrapAsOperationalError(obj2) {
      var ret2;
      if (isUntypedError(obj2)) {
        ret2 = new OperationalError(obj2);
        ret2.name = obj2.name;
        ret2.message = obj2.message;
        ret2.stack = obj2.stack;
        var keys = es52.keys(obj2);
        for (var i = 0; i < keys.length; ++i) {
          var key = keys[i];
          if (!rErrorKey.test(key)) {
            ret2[key] = obj2[key];
          }
        }
        return ret2;
      }
      util.markAsOriginatingFromRejection(obj2);
      return obj2;
    }
    function nodebackForPromise(promise, multiArgs) {
      return function(err, value) {
        if (promise === null)
          return;
        if (err) {
          var wrapped = wrapAsOperationalError(maybeWrapAsError2(err));
          promise._attachExtraTrace(wrapped);
          promise._reject(wrapped);
        } else if (!multiArgs) {
          promise._fulfill(value);
        } else {
          var $_len = arguments.length;
          var args = new Array(Math.max($_len - 1, 0));
          for (var $_i = 1; $_i < $_len; ++$_i) {
            args[$_i - 1] = arguments[$_i];
          }
          ;
          promise._fulfill(args);
        }
        promise = null;
      };
    }
    module2.exports = nodebackForPromise;
  }
});

// ../../../node_modules/bluebird/js/release/method.js
var require_method = __commonJS({
  "../../../node_modules/bluebird/js/release/method.js"(exports2, module2) {
    "use strict";
    module2.exports = function(Promise2, INTERNAL, tryConvertToPromise, apiRejection, debug) {
      var util = require_util4();
      var tryCatch2 = util.tryCatch;
      Promise2.method = function(fn) {
        if (typeof fn !== "function") {
          throw new Promise2.TypeError("expecting a function but got " + util.classString(fn));
        }
        return function() {
          var ret2 = new Promise2(INTERNAL);
          ret2._captureStackTrace();
          ret2._pushContext();
          var value = tryCatch2(fn).apply(this, arguments);
          var promiseCreated = ret2._popContext();
          debug.checkForgottenReturns(
            value,
            promiseCreated,
            "Promise.method",
            ret2
          );
          ret2._resolveFromSyncValue(value);
          return ret2;
        };
      };
      Promise2.attempt = Promise2["try"] = function(fn) {
        if (typeof fn !== "function") {
          return apiRejection("expecting a function but got " + util.classString(fn));
        }
        var ret2 = new Promise2(INTERNAL);
        ret2._captureStackTrace();
        ret2._pushContext();
        var value;
        if (arguments.length > 1) {
          debug.deprecated("calling Promise.try with more than 1 argument");
          var arg = arguments[1];
          var ctx = arguments[2];
          value = util.isArray(arg) ? tryCatch2(fn).apply(ctx, arg) : tryCatch2(fn).call(ctx, arg);
        } else {
          value = tryCatch2(fn)();
        }
        var promiseCreated = ret2._popContext();
        debug.checkForgottenReturns(
          value,
          promiseCreated,
          "Promise.try",
          ret2
        );
        ret2._resolveFromSyncValue(value);
        return ret2;
      };
      Promise2.prototype._resolveFromSyncValue = function(value) {
        if (value === util.errorObj) {
          this._rejectCallback(value.e, false);
        } else {
          this._resolveCallback(value, true);
        }
      };
    };
  }
});

// ../../../node_modules/bluebird/js/release/bind.js
var require_bind = __commonJS({
  "../../../node_modules/bluebird/js/release/bind.js"(exports2, module2) {
    "use strict";
    module2.exports = function(Promise2, INTERNAL, tryConvertToPromise, debug) {
      var calledBind = false;
      var rejectThis = function(_2, e) {
        this._reject(e);
      };
      var targetRejected = function(e, context) {
        context.promiseRejectionQueued = true;
        context.bindingPromise._then(rejectThis, rejectThis, null, this, e);
      };
      var bindingResolved = function(thisArg, context) {
        if ((this._bitField & 50397184) === 0) {
          this._resolveCallback(context.target);
        }
      };
      var bindingRejected = function(e, context) {
        if (!context.promiseRejectionQueued)
          this._reject(e);
      };
      Promise2.prototype.bind = function(thisArg) {
        if (!calledBind) {
          calledBind = true;
          Promise2.prototype._propagateFrom = debug.propagateFromFunction();
          Promise2.prototype._boundValue = debug.boundValueFunction();
        }
        var maybePromise = tryConvertToPromise(thisArg);
        var ret2 = new Promise2(INTERNAL);
        ret2._propagateFrom(this, 1);
        var target = this._target();
        ret2._setBoundTo(maybePromise);
        if (maybePromise instanceof Promise2) {
          var context = {
            promiseRejectionQueued: false,
            promise: ret2,
            target,
            bindingPromise: maybePromise
          };
          target._then(INTERNAL, targetRejected, void 0, ret2, context);
          maybePromise._then(
            bindingResolved,
            bindingRejected,
            void 0,
            ret2,
            context
          );
          ret2._setOnCancel(maybePromise);
        } else {
          ret2._resolveCallback(target);
        }
        return ret2;
      };
      Promise2.prototype._setBoundTo = function(obj2) {
        if (obj2 !== void 0) {
          this._bitField = this._bitField | 2097152;
          this._boundTo = obj2;
        } else {
          this._bitField = this._bitField & ~2097152;
        }
      };
      Promise2.prototype._isBound = function() {
        return (this._bitField & 2097152) === 2097152;
      };
      Promise2.bind = function(thisArg, value) {
        return Promise2.resolve(value).bind(thisArg);
      };
    };
  }
});

// ../../../node_modules/bluebird/js/release/cancel.js
var require_cancel = __commonJS({
  "../../../node_modules/bluebird/js/release/cancel.js"(exports2, module2) {
    "use strict";
    module2.exports = function(Promise2, PromiseArray, apiRejection, debug) {
      var util = require_util4();
      var tryCatch2 = util.tryCatch;
      var errorObj2 = util.errorObj;
      var async = Promise2._async;
      Promise2.prototype["break"] = Promise2.prototype.cancel = function() {
        if (!debug.cancellation())
          return this._warn("cancellation is disabled");
        var promise = this;
        var child = promise;
        while (promise._isCancellable()) {
          if (!promise._cancelBy(child)) {
            if (child._isFollowing()) {
              child._followee().cancel();
            } else {
              child._cancelBranched();
            }
            break;
          }
          var parent = promise._cancellationParent;
          if (parent == null || !parent._isCancellable()) {
            if (promise._isFollowing()) {
              promise._followee().cancel();
            } else {
              promise._cancelBranched();
            }
            break;
          } else {
            if (promise._isFollowing())
              promise._followee().cancel();
            promise._setWillBeCancelled();
            child = promise;
            promise = parent;
          }
        }
      };
      Promise2.prototype._branchHasCancelled = function() {
        this._branchesRemainingToCancel--;
      };
      Promise2.prototype._enoughBranchesHaveCancelled = function() {
        return this._branchesRemainingToCancel === void 0 || this._branchesRemainingToCancel <= 0;
      };
      Promise2.prototype._cancelBy = function(canceller) {
        if (canceller === this) {
          this._branchesRemainingToCancel = 0;
          this._invokeOnCancel();
          return true;
        } else {
          this._branchHasCancelled();
          if (this._enoughBranchesHaveCancelled()) {
            this._invokeOnCancel();
            return true;
          }
        }
        return false;
      };
      Promise2.prototype._cancelBranched = function() {
        if (this._enoughBranchesHaveCancelled()) {
          this._cancel();
        }
      };
      Promise2.prototype._cancel = function() {
        if (!this._isCancellable())
          return;
        this._setCancelled();
        async.invoke(this._cancelPromises, this, void 0);
      };
      Promise2.prototype._cancelPromises = function() {
        if (this._length() > 0)
          this._settlePromises();
      };
      Promise2.prototype._unsetOnCancel = function() {
        this._onCancelField = void 0;
      };
      Promise2.prototype._isCancellable = function() {
        return this.isPending() && !this._isCancelled();
      };
      Promise2.prototype.isCancellable = function() {
        return this.isPending() && !this.isCancelled();
      };
      Promise2.prototype._doInvokeOnCancel = function(onCancelCallback, internalOnly) {
        if (util.isArray(onCancelCallback)) {
          for (var i = 0; i < onCancelCallback.length; ++i) {
            this._doInvokeOnCancel(onCancelCallback[i], internalOnly);
          }
        } else if (onCancelCallback !== void 0) {
          if (typeof onCancelCallback === "function") {
            if (!internalOnly) {
              var e = tryCatch2(onCancelCallback).call(this._boundValue());
              if (e === errorObj2) {
                this._attachExtraTrace(e.e);
                async.throwLater(e.e);
              }
            }
          } else {
            onCancelCallback._resultCancelled(this);
          }
        }
      };
      Promise2.prototype._invokeOnCancel = function() {
        var onCancelCallback = this._onCancel();
        this._unsetOnCancel();
        async.invoke(this._doInvokeOnCancel, this, onCancelCallback);
      };
      Promise2.prototype._invokeInternalOnCancel = function() {
        if (this._isCancellable()) {
          this._doInvokeOnCancel(this._onCancel(), true);
          this._unsetOnCancel();
        }
      };
      Promise2.prototype._resultCancelled = function() {
        this.cancel();
      };
    };
  }
});

// ../../../node_modules/bluebird/js/release/direct_resolve.js
var require_direct_resolve = __commonJS({
  "../../../node_modules/bluebird/js/release/direct_resolve.js"(exports2, module2) {
    "use strict";
    module2.exports = function(Promise2) {
      function returner() {
        return this.value;
      }
      function thrower2() {
        throw this.reason;
      }
      Promise2.prototype["return"] = Promise2.prototype.thenReturn = function(value) {
        if (value instanceof Promise2)
          value.suppressUnhandledRejections();
        return this._then(
          returner,
          void 0,
          void 0,
          { value },
          void 0
        );
      };
      Promise2.prototype["throw"] = Promise2.prototype.thenThrow = function(reason) {
        return this._then(
          thrower2,
          void 0,
          void 0,
          { reason },
          void 0
        );
      };
      Promise2.prototype.catchThrow = function(reason) {
        if (arguments.length <= 1) {
          return this._then(
            void 0,
            thrower2,
            void 0,
            { reason },
            void 0
          );
        } else {
          var _reason = arguments[1];
          var handler = function() {
            throw _reason;
          };
          return this.caught(reason, handler);
        }
      };
      Promise2.prototype.catchReturn = function(value) {
        if (arguments.length <= 1) {
          if (value instanceof Promise2)
            value.suppressUnhandledRejections();
          return this._then(
            void 0,
            returner,
            void 0,
            { value },
            void 0
          );
        } else {
          var _value = arguments[1];
          if (_value instanceof Promise2)
            _value.suppressUnhandledRejections();
          var handler = function() {
            return _value;
          };
          return this.caught(value, handler);
        }
      };
    };
  }
});

// ../../../node_modules/bluebird/js/release/synchronous_inspection.js
var require_synchronous_inspection = __commonJS({
  "../../../node_modules/bluebird/js/release/synchronous_inspection.js"(exports2, module2) {
    "use strict";
    module2.exports = function(Promise2) {
      function PromiseInspection(promise) {
        if (promise !== void 0) {
          promise = promise._target();
          this._bitField = promise._bitField;
          this._settledValueField = promise._isFateSealed() ? promise._settledValue() : void 0;
        } else {
          this._bitField = 0;
          this._settledValueField = void 0;
        }
      }
      PromiseInspection.prototype._settledValue = function() {
        return this._settledValueField;
      };
      var value = PromiseInspection.prototype.value = function() {
        if (!this.isFulfilled()) {
          throw new TypeError("cannot get fulfillment value of a non-fulfilled promise\n\n    See http://goo.gl/MqrFmX\n");
        }
        return this._settledValue();
      };
      var reason = PromiseInspection.prototype.error = PromiseInspection.prototype.reason = function() {
        if (!this.isRejected()) {
          throw new TypeError("cannot get rejection reason of a non-rejected promise\n\n    See http://goo.gl/MqrFmX\n");
        }
        return this._settledValue();
      };
      var isFulfilled = PromiseInspection.prototype.isFulfilled = function() {
        return (this._bitField & 33554432) !== 0;
      };
      var isRejected = PromiseInspection.prototype.isRejected = function() {
        return (this._bitField & 16777216) !== 0;
      };
      var isPending = PromiseInspection.prototype.isPending = function() {
        return (this._bitField & 50397184) === 0;
      };
      var isResolved = PromiseInspection.prototype.isResolved = function() {
        return (this._bitField & 50331648) !== 0;
      };
      PromiseInspection.prototype.isCancelled = function() {
        return (this._bitField & 8454144) !== 0;
      };
      Promise2.prototype.__isCancelled = function() {
        return (this._bitField & 65536) === 65536;
      };
      Promise2.prototype._isCancelled = function() {
        return this._target().__isCancelled();
      };
      Promise2.prototype.isCancelled = function() {
        return (this._target()._bitField & 8454144) !== 0;
      };
      Promise2.prototype.isPending = function() {
        return isPending.call(this._target());
      };
      Promise2.prototype.isRejected = function() {
        return isRejected.call(this._target());
      };
      Promise2.prototype.isFulfilled = function() {
        return isFulfilled.call(this._target());
      };
      Promise2.prototype.isResolved = function() {
        return isResolved.call(this._target());
      };
      Promise2.prototype.value = function() {
        return value.call(this._target());
      };
      Promise2.prototype.reason = function() {
        var target = this._target();
        target._unsetRejectionIsUnhandled();
        return reason.call(target);
      };
      Promise2.prototype._value = function() {
        return this._settledValue();
      };
      Promise2.prototype._reason = function() {
        this._unsetRejectionIsUnhandled();
        return this._settledValue();
      };
      Promise2.PromiseInspection = PromiseInspection;
    };
  }
});

// ../../../node_modules/bluebird/js/release/join.js
var require_join = __commonJS({
  "../../../node_modules/bluebird/js/release/join.js"(exports2, module2) {
    "use strict";
    module2.exports = function(Promise2, PromiseArray, tryConvertToPromise, INTERNAL, async, getDomain) {
      var util = require_util4();
      var canEvaluate2 = util.canEvaluate;
      var tryCatch2 = util.tryCatch;
      var errorObj2 = util.errorObj;
      var reject;
      if (true) {
        if (canEvaluate2) {
          var thenCallback = function(i2) {
            return new Function("value", "holder", "                             \n            'use strict';                                                    \n            holder.pIndex = value;                                           \n            holder.checkFulfillment(this);                                   \n            ".replace(/Index/g, i2));
          };
          var promiseSetter = function(i2) {
            return new Function("promise", "holder", "                           \n            'use strict';                                                    \n            holder.pIndex = promise;                                         \n            ".replace(/Index/g, i2));
          };
          var generateHolderClass = function(total) {
            var props = new Array(total);
            for (var i2 = 0; i2 < props.length; ++i2) {
              props[i2] = "this.p" + (i2 + 1);
            }
            var assignment = props.join(" = ") + " = null;";
            var cancellationCode = "var promise;\n" + props.map(function(prop) {
              return "                                                         \n                promise = " + prop + ";                                      \n                if (promise instanceof Promise) {                            \n                    promise.cancel();                                        \n                }                                                            \n            ";
            }).join("\n");
            var passedArguments = props.join(", ");
            var name = "Holder$" + total;
            var code = "return function(tryCatch, errorObj, Promise, async) {    \n            'use strict';                                                    \n            function [TheName](fn) {                                         \n                [TheProperties]                                              \n                this.fn = fn;                                                \n                this.asyncNeeded = true;                                     \n                this.now = 0;                                                \n            }                                                                \n                                                                             \n            [TheName].prototype._callFunction = function(promise) {          \n                promise._pushContext();                                      \n                var ret = tryCatch(this.fn)([ThePassedArguments]);           \n                promise._popContext();                                       \n                if (ret === errorObj) {                                      \n                    promise._rejectCallback(ret.e, false);                   \n                } else {                                                     \n                    promise._resolveCallback(ret);                           \n                }                                                            \n            };                                                               \n                                                                             \n            [TheName].prototype.checkFulfillment = function(promise) {       \n                var now = ++this.now;                                        \n                if (now === [TheTotal]) {                                    \n                    if (this.asyncNeeded) {                                  \n                        async.invoke(this._callFunction, this, promise);     \n                    } else {                                                 \n                        this._callFunction(promise);                         \n                    }                                                        \n                                                                             \n                }                                                            \n            };                                                               \n                                                                             \n            [TheName].prototype._resultCancelled = function() {              \n                [CancellationCode]                                           \n            };                                                               \n                                                                             \n            return [TheName];                                                \n        }(tryCatch, errorObj, Promise, async);                               \n        ";
            code = code.replace(/\[TheName\]/g, name).replace(/\[TheTotal\]/g, total).replace(/\[ThePassedArguments\]/g, passedArguments).replace(/\[TheProperties\]/g, assignment).replace(/\[CancellationCode\]/g, cancellationCode);
            return new Function("tryCatch", "errorObj", "Promise", "async", code)(tryCatch2, errorObj2, Promise2, async);
          };
          var holderClasses = [];
          var thenCallbacks = [];
          var promiseSetters = [];
          for (var i = 0; i < 8; ++i) {
            holderClasses.push(generateHolderClass(i + 1));
            thenCallbacks.push(thenCallback(i + 1));
            promiseSetters.push(promiseSetter(i + 1));
          }
          reject = function(reason) {
            this._reject(reason);
          };
        }
      }
      Promise2.join = function() {
        var last = arguments.length - 1;
        var fn;
        if (last > 0 && typeof arguments[last] === "function") {
          fn = arguments[last];
          if (true) {
            if (last <= 8 && canEvaluate2) {
              var ret2 = new Promise2(INTERNAL);
              ret2._captureStackTrace();
              var HolderClass = holderClasses[last - 1];
              var holder = new HolderClass(fn);
              var callbacks = thenCallbacks;
              for (var i2 = 0; i2 < last; ++i2) {
                var maybePromise = tryConvertToPromise(arguments[i2], ret2);
                if (maybePromise instanceof Promise2) {
                  maybePromise = maybePromise._target();
                  var bitField = maybePromise._bitField;
                  ;
                  if ((bitField & 50397184) === 0) {
                    maybePromise._then(
                      callbacks[i2],
                      reject,
                      void 0,
                      ret2,
                      holder
                    );
                    promiseSetters[i2](maybePromise, holder);
                    holder.asyncNeeded = false;
                  } else if ((bitField & 33554432) !== 0) {
                    callbacks[i2].call(
                      ret2,
                      maybePromise._value(),
                      holder
                    );
                  } else if ((bitField & 16777216) !== 0) {
                    ret2._reject(maybePromise._reason());
                  } else {
                    ret2._cancel();
                  }
                } else {
                  callbacks[i2].call(ret2, maybePromise, holder);
                }
              }
              if (!ret2._isFateSealed()) {
                if (holder.asyncNeeded) {
                  var domain = getDomain();
                  if (domain !== null) {
                    holder.fn = util.domainBind(domain, holder.fn);
                  }
                }
                ret2._setAsyncGuaranteed();
                ret2._setOnCancel(holder);
              }
              return ret2;
            }
          }
        }
        var $_len = arguments.length;
        var args = new Array($_len);
        for (var $_i = 0; $_i < $_len; ++$_i) {
          args[$_i] = arguments[$_i];
        }
        ;
        if (fn)
          args.pop();
        var ret2 = new PromiseArray(args).promise();
        return fn !== void 0 ? ret2.spread(fn) : ret2;
      };
    };
  }
});

// ../../../node_modules/bluebird/js/release/map.js
var require_map = __commonJS({
  "../../../node_modules/bluebird/js/release/map.js"(exports2, module2) {
    "use strict";
    module2.exports = function(Promise2, PromiseArray, apiRejection, tryConvertToPromise, INTERNAL, debug) {
      var getDomain = Promise2._getDomain;
      var util = require_util4();
      var tryCatch2 = util.tryCatch;
      var errorObj2 = util.errorObj;
      var async = Promise2._async;
      function MappingPromiseArray(promises, fn, limit, _filter) {
        this.constructor$(promises);
        this._promise._captureStackTrace();
        var domain = getDomain();
        this._callback = domain === null ? fn : util.domainBind(domain, fn);
        this._preservedValues = _filter === INTERNAL ? new Array(this.length()) : null;
        this._limit = limit;
        this._inFlight = 0;
        this._queue = [];
        async.invoke(this._asyncInit, this, void 0);
      }
      util.inherits(MappingPromiseArray, PromiseArray);
      MappingPromiseArray.prototype._asyncInit = function() {
        this._init$(void 0, -2);
      };
      MappingPromiseArray.prototype._init = function() {
      };
      MappingPromiseArray.prototype._promiseFulfilled = function(value, index) {
        var values = this._values;
        var length = this.length();
        var preservedValues = this._preservedValues;
        var limit = this._limit;
        if (index < 0) {
          index = index * -1 - 1;
          values[index] = value;
          if (limit >= 1) {
            this._inFlight--;
            this._drainQueue();
            if (this._isResolved())
              return true;
          }
        } else {
          if (limit >= 1 && this._inFlight >= limit) {
            values[index] = value;
            this._queue.push(index);
            return false;
          }
          if (preservedValues !== null)
            preservedValues[index] = value;
          var promise = this._promise;
          var callback = this._callback;
          var receiver = promise._boundValue();
          promise._pushContext();
          var ret2 = tryCatch2(callback).call(receiver, value, index, length);
          var promiseCreated = promise._popContext();
          debug.checkForgottenReturns(
            ret2,
            promiseCreated,
            preservedValues !== null ? "Promise.filter" : "Promise.map",
            promise
          );
          if (ret2 === errorObj2) {
            this._reject(ret2.e);
            return true;
          }
          var maybePromise = tryConvertToPromise(ret2, this._promise);
          if (maybePromise instanceof Promise2) {
            maybePromise = maybePromise._target();
            var bitField = maybePromise._bitField;
            ;
            if ((bitField & 50397184) === 0) {
              if (limit >= 1)
                this._inFlight++;
              values[index] = maybePromise;
              maybePromise._proxy(this, (index + 1) * -1);
              return false;
            } else if ((bitField & 33554432) !== 0) {
              ret2 = maybePromise._value();
            } else if ((bitField & 16777216) !== 0) {
              this._reject(maybePromise._reason());
              return true;
            } else {
              this._cancel();
              return true;
            }
          }
          values[index] = ret2;
        }
        var totalResolved = ++this._totalResolved;
        if (totalResolved >= length) {
          if (preservedValues !== null) {
            this._filter(values, preservedValues);
          } else {
            this._resolve(values);
          }
          return true;
        }
        return false;
      };
      MappingPromiseArray.prototype._drainQueue = function() {
        var queue = this._queue;
        var limit = this._limit;
        var values = this._values;
        while (queue.length > 0 && this._inFlight < limit) {
          if (this._isResolved())
            return;
          var index = queue.pop();
          this._promiseFulfilled(values[index], index);
        }
      };
      MappingPromiseArray.prototype._filter = function(booleans, values) {
        var len = values.length;
        var ret2 = new Array(len);
        var j = 0;
        for (var i = 0; i < len; ++i) {
          if (booleans[i])
            ret2[j++] = values[i];
        }
        ret2.length = j;
        this._resolve(ret2);
      };
      MappingPromiseArray.prototype.preservedValues = function() {
        return this._preservedValues;
      };
      function map(promises, fn, options, _filter) {
        if (typeof fn !== "function") {
          return apiRejection("expecting a function but got " + util.classString(fn));
        }
        var limit = 0;
        if (options !== void 0) {
          if (typeof options === "object" && options !== null) {
            if (typeof options.concurrency !== "number") {
              return Promise2.reject(
                new TypeError("'concurrency' must be a number but it is " + util.classString(options.concurrency))
              );
            }
            limit = options.concurrency;
          } else {
            return Promise2.reject(new TypeError(
              "options argument must be an object but it is " + util.classString(options)
            ));
          }
        }
        limit = typeof limit === "number" && isFinite(limit) && limit >= 1 ? limit : 0;
        return new MappingPromiseArray(promises, fn, limit, _filter).promise();
      }
      Promise2.prototype.map = function(fn, options) {
        return map(this, fn, options, null);
      };
      Promise2.map = function(promises, fn, options, _filter) {
        return map(promises, fn, options, _filter);
      };
    };
  }
});

// ../../../node_modules/bluebird/js/release/call_get.js
var require_call_get = __commonJS({
  "../../../node_modules/bluebird/js/release/call_get.js"(exports2, module2) {
    "use strict";
    var cr = Object.create;
    if (cr) {
      callerCache = cr(null);
      getterCache = cr(null);
      callerCache[" size"] = getterCache[" size"] = 0;
    }
    var callerCache;
    var getterCache;
    module2.exports = function(Promise2) {
      var util = require_util4();
      var canEvaluate2 = util.canEvaluate;
      var isIdentifier2 = util.isIdentifier;
      var getMethodCaller;
      var getGetter;
      if (true) {
        var makeMethodCaller = function(methodName) {
          return new Function("ensureMethod", "                                    \n        return function(obj) {                                               \n            'use strict'                                                     \n            var len = this.length;                                           \n            ensureMethod(obj, 'methodName');                                 \n            switch(len) {                                                    \n                case 1: return obj.methodName(this[0]);                      \n                case 2: return obj.methodName(this[0], this[1]);             \n                case 3: return obj.methodName(this[0], this[1], this[2]);    \n                case 0: return obj.methodName();                             \n                default:                                                     \n                    return obj.methodName.apply(obj, this);                  \n            }                                                                \n        };                                                                   \n        ".replace(/methodName/g, methodName))(ensureMethod);
        };
        var makeGetter = function(propertyName) {
          return new Function("obj", "                                             \n        'use strict';                                                        \n        return obj.propertyName;                                             \n        ".replace("propertyName", propertyName));
        };
        var getCompiled = function(name, compiler, cache) {
          var ret2 = cache[name];
          if (typeof ret2 !== "function") {
            if (!isIdentifier2(name)) {
              return null;
            }
            ret2 = compiler(name);
            cache[name] = ret2;
            cache[" size"]++;
            if (cache[" size"] > 512) {
              var keys = Object.keys(cache);
              for (var i = 0; i < 256; ++i)
                delete cache[keys[i]];
              cache[" size"] = keys.length - 256;
            }
          }
          return ret2;
        };
        getMethodCaller = function(name) {
          return getCompiled(name, makeMethodCaller, callerCache);
        };
        getGetter = function(name) {
          return getCompiled(name, makeGetter, getterCache);
        };
      }
      function ensureMethod(obj2, methodName) {
        var fn;
        if (obj2 != null)
          fn = obj2[methodName];
        if (typeof fn !== "function") {
          var message = "Object " + util.classString(obj2) + " has no method '" + util.toString(methodName) + "'";
          throw new Promise2.TypeError(message);
        }
        return fn;
      }
      function caller(obj2) {
        var methodName = this.pop();
        var fn = ensureMethod(obj2, methodName);
        return fn.apply(obj2, this);
      }
      Promise2.prototype.call = function(methodName) {
        var $_len = arguments.length;
        var args = new Array(Math.max($_len - 1, 0));
        for (var $_i = 1; $_i < $_len; ++$_i) {
          args[$_i - 1] = arguments[$_i];
        }
        ;
        if (true) {
          if (canEvaluate2) {
            var maybeCaller = getMethodCaller(methodName);
            if (maybeCaller !== null) {
              return this._then(
                maybeCaller,
                void 0,
                void 0,
                args,
                void 0
              );
            }
          }
        }
        args.push(methodName);
        return this._then(caller, void 0, void 0, args, void 0);
      };
      function namedGetter(obj2) {
        return obj2[this];
      }
      function indexedGetter(obj2) {
        var index = +this;
        if (index < 0)
          index = Math.max(0, index + obj2.length);
        return obj2[index];
      }
      Promise2.prototype.get = function(propertyName) {
        var isIndex = typeof propertyName === "number";
        var getter;
        if (!isIndex) {
          if (canEvaluate2) {
            var maybeGetter = getGetter(propertyName);
            getter = maybeGetter !== null ? maybeGetter : namedGetter;
          } else {
            getter = namedGetter;
          }
        } else {
          getter = indexedGetter;
        }
        return this._then(getter, void 0, void 0, propertyName, void 0);
      };
    };
  }
});

// ../../../node_modules/bluebird/js/release/using.js
var require_using = __commonJS({
  "../../../node_modules/bluebird/js/release/using.js"(exports2, module2) {
    "use strict";
    module2.exports = function(Promise2, apiRejection, tryConvertToPromise, createContext, INTERNAL, debug) {
      var util = require_util4();
      var TypeError2 = require_errors8().TypeError;
      var inherits2 = require_util4().inherits;
      var errorObj2 = util.errorObj;
      var tryCatch2 = util.tryCatch;
      var NULL = {};
      function thrower2(e) {
        setTimeout(function() {
          throw e;
        }, 0);
      }
      function castPreservingDisposable(thenable) {
        var maybePromise = tryConvertToPromise(thenable);
        if (maybePromise !== thenable && typeof thenable._isDisposable === "function" && typeof thenable._getDisposer === "function" && thenable._isDisposable()) {
          maybePromise._setDisposable(thenable._getDisposer());
        }
        return maybePromise;
      }
      function dispose(resources, inspection) {
        var i = 0;
        var len = resources.length;
        var ret2 = new Promise2(INTERNAL);
        function iterator() {
          if (i >= len)
            return ret2._fulfill();
          var maybePromise = castPreservingDisposable(resources[i++]);
          if (maybePromise instanceof Promise2 && maybePromise._isDisposable()) {
            try {
              maybePromise = tryConvertToPromise(
                maybePromise._getDisposer().tryDispose(inspection),
                resources.promise
              );
            } catch (e) {
              return thrower2(e);
            }
            if (maybePromise instanceof Promise2) {
              return maybePromise._then(
                iterator,
                thrower2,
                null,
                null,
                null
              );
            }
          }
          iterator();
        }
        iterator();
        return ret2;
      }
      function Disposer(data, promise, context) {
        this._data = data;
        this._promise = promise;
        this._context = context;
      }
      Disposer.prototype.data = function() {
        return this._data;
      };
      Disposer.prototype.promise = function() {
        return this._promise;
      };
      Disposer.prototype.resource = function() {
        if (this.promise().isFulfilled()) {
          return this.promise().value();
        }
        return NULL;
      };
      Disposer.prototype.tryDispose = function(inspection) {
        var resource = this.resource();
        var context = this._context;
        if (context !== void 0)
          context._pushContext();
        var ret2 = resource !== NULL ? this.doDispose(resource, inspection) : null;
        if (context !== void 0)
          context._popContext();
        this._promise._unsetDisposable();
        this._data = null;
        return ret2;
      };
      Disposer.isDisposer = function(d) {
        return d != null && typeof d.resource === "function" && typeof d.tryDispose === "function";
      };
      function FunctionDisposer(fn, promise, context) {
        this.constructor$(fn, promise, context);
      }
      inherits2(FunctionDisposer, Disposer);
      FunctionDisposer.prototype.doDispose = function(resource, inspection) {
        var fn = this.data();
        return fn.call(resource, resource, inspection);
      };
      function maybeUnwrapDisposer(value) {
        if (Disposer.isDisposer(value)) {
          this.resources[this.index]._setDisposable(value);
          return value.promise();
        }
        return value;
      }
      function ResourceList(length) {
        this.length = length;
        this.promise = null;
        this[length - 1] = null;
      }
      ResourceList.prototype._resultCancelled = function() {
        var len = this.length;
        for (var i = 0; i < len; ++i) {
          var item = this[i];
          if (item instanceof Promise2) {
            item.cancel();
          }
        }
      };
      Promise2.using = function() {
        var len = arguments.length;
        if (len < 2)
          return apiRejection(
            "you must pass at least 2 arguments to Promise.using"
          );
        var fn = arguments[len - 1];
        if (typeof fn !== "function") {
          return apiRejection("expecting a function but got " + util.classString(fn));
        }
        var input;
        var spreadArgs = true;
        if (len === 2 && Array.isArray(arguments[0])) {
          input = arguments[0];
          len = input.length;
          spreadArgs = false;
        } else {
          input = arguments;
          len--;
        }
        var resources = new ResourceList(len);
        for (var i = 0; i < len; ++i) {
          var resource = input[i];
          if (Disposer.isDisposer(resource)) {
            var disposer = resource;
            resource = resource.promise();
            resource._setDisposable(disposer);
          } else {
            var maybePromise = tryConvertToPromise(resource);
            if (maybePromise instanceof Promise2) {
              resource = maybePromise._then(maybeUnwrapDisposer, null, null, {
                resources,
                index: i
              }, void 0);
            }
          }
          resources[i] = resource;
        }
        var reflectedResources = new Array(resources.length);
        for (var i = 0; i < reflectedResources.length; ++i) {
          reflectedResources[i] = Promise2.resolve(resources[i]).reflect();
        }
        var resultPromise = Promise2.all(reflectedResources).then(function(inspections) {
          for (var i2 = 0; i2 < inspections.length; ++i2) {
            var inspection = inspections[i2];
            if (inspection.isRejected()) {
              errorObj2.e = inspection.error();
              return errorObj2;
            } else if (!inspection.isFulfilled()) {
              resultPromise.cancel();
              return;
            }
            inspections[i2] = inspection.value();
          }
          promise._pushContext();
          fn = tryCatch2(fn);
          var ret2 = spreadArgs ? fn.apply(void 0, inspections) : fn(inspections);
          var promiseCreated = promise._popContext();
          debug.checkForgottenReturns(
            ret2,
            promiseCreated,
            "Promise.using",
            promise
          );
          return ret2;
        });
        var promise = resultPromise.lastly(function() {
          var inspection = new Promise2.PromiseInspection(resultPromise);
          return dispose(resources, inspection);
        });
        resources.promise = promise;
        promise._setOnCancel(resources);
        return promise;
      };
      Promise2.prototype._setDisposable = function(disposer) {
        this._bitField = this._bitField | 131072;
        this._disposer = disposer;
      };
      Promise2.prototype._isDisposable = function() {
        return (this._bitField & 131072) > 0;
      };
      Promise2.prototype._getDisposer = function() {
        return this._disposer;
      };
      Promise2.prototype._unsetDisposable = function() {
        this._bitField = this._bitField & ~131072;
        this._disposer = void 0;
      };
      Promise2.prototype.disposer = function(fn) {
        if (typeof fn === "function") {
          return new FunctionDisposer(fn, this, createContext());
        }
        throw new TypeError2();
      };
    };
  }
});

// ../../../node_modules/bluebird/js/release/timers.js
var require_timers = __commonJS({
  "../../../node_modules/bluebird/js/release/timers.js"(exports2, module2) {
    "use strict";
    module2.exports = function(Promise2, INTERNAL, debug) {
      var util = require_util4();
      var TimeoutError = Promise2.TimeoutError;
      function HandleWrapper(handle) {
        this.handle = handle;
      }
      HandleWrapper.prototype._resultCancelled = function() {
        clearTimeout(this.handle);
      };
      var afterValue = function(value) {
        return delay(+this).thenReturn(value);
      };
      var delay = Promise2.delay = function(ms, value) {
        var ret2;
        var handle;
        if (value !== void 0) {
          ret2 = Promise2.resolve(value)._then(afterValue, null, null, ms, void 0);
          if (debug.cancellation() && value instanceof Promise2) {
            ret2._setOnCancel(value);
          }
        } else {
          ret2 = new Promise2(INTERNAL);
          handle = setTimeout(function() {
            ret2._fulfill();
          }, +ms);
          if (debug.cancellation()) {
            ret2._setOnCancel(new HandleWrapper(handle));
          }
          ret2._captureStackTrace();
        }
        ret2._setAsyncGuaranteed();
        return ret2;
      };
      Promise2.prototype.delay = function(ms) {
        return delay(ms, this);
      };
      var afterTimeout = function(promise, message, parent) {
        var err;
        if (typeof message !== "string") {
          if (message instanceof Error) {
            err = message;
          } else {
            err = new TimeoutError("operation timed out");
          }
        } else {
          err = new TimeoutError(message);
        }
        util.markAsOriginatingFromRejection(err);
        promise._attachExtraTrace(err);
        promise._reject(err);
        if (parent != null) {
          parent.cancel();
        }
      };
      function successClear(value) {
        clearTimeout(this.handle);
        return value;
      }
      function failureClear(reason) {
        clearTimeout(this.handle);
        throw reason;
      }
      Promise2.prototype.timeout = function(ms, message) {
        ms = +ms;
        var ret2, parent;
        var handleWrapper = new HandleWrapper(setTimeout(function timeoutTimeout() {
          if (ret2.isPending()) {
            afterTimeout(ret2, message, parent);
          }
        }, ms));
        if (debug.cancellation()) {
          parent = this.then();
          ret2 = parent._then(
            successClear,
            failureClear,
            void 0,
            handleWrapper,
            void 0
          );
          ret2._setOnCancel(handleWrapper);
        } else {
          ret2 = this._then(
            successClear,
            failureClear,
            void 0,
            handleWrapper,
            void 0
          );
        }
        return ret2;
      };
    };
  }
});

// ../../../node_modules/bluebird/js/release/generators.js
var require_generators = __commonJS({
  "../../../node_modules/bluebird/js/release/generators.js"(exports2, module2) {
    "use strict";
    module2.exports = function(Promise2, apiRejection, INTERNAL, tryConvertToPromise, Proxyable, debug) {
      var errors = require_errors8();
      var TypeError2 = errors.TypeError;
      var util = require_util4();
      var errorObj2 = util.errorObj;
      var tryCatch2 = util.tryCatch;
      var yieldHandlers = [];
      function promiseFromYieldHandler(value, yieldHandlers2, traceParent) {
        for (var i = 0; i < yieldHandlers2.length; ++i) {
          traceParent._pushContext();
          var result = tryCatch2(yieldHandlers2[i])(value);
          traceParent._popContext();
          if (result === errorObj2) {
            traceParent._pushContext();
            var ret2 = Promise2.reject(errorObj2.e);
            traceParent._popContext();
            return ret2;
          }
          var maybePromise = tryConvertToPromise(result, traceParent);
          if (maybePromise instanceof Promise2)
            return maybePromise;
        }
        return null;
      }
      function PromiseSpawn(generatorFunction, receiver, yieldHandler, stack) {
        if (debug.cancellation()) {
          var internal = new Promise2(INTERNAL);
          var _finallyPromise = this._finallyPromise = new Promise2(INTERNAL);
          this._promise = internal.lastly(function() {
            return _finallyPromise;
          });
          internal._captureStackTrace();
          internal._setOnCancel(this);
        } else {
          var promise = this._promise = new Promise2(INTERNAL);
          promise._captureStackTrace();
        }
        this._stack = stack;
        this._generatorFunction = generatorFunction;
        this._receiver = receiver;
        this._generator = void 0;
        this._yieldHandlers = typeof yieldHandler === "function" ? [yieldHandler].concat(yieldHandlers) : yieldHandlers;
        this._yieldedPromise = null;
        this._cancellationPhase = false;
      }
      util.inherits(PromiseSpawn, Proxyable);
      PromiseSpawn.prototype._isResolved = function() {
        return this._promise === null;
      };
      PromiseSpawn.prototype._cleanup = function() {
        this._promise = this._generator = null;
        if (debug.cancellation() && this._finallyPromise !== null) {
          this._finallyPromise._fulfill();
          this._finallyPromise = null;
        }
      };
      PromiseSpawn.prototype._promiseCancelled = function() {
        if (this._isResolved())
          return;
        var implementsReturn = typeof this._generator["return"] !== "undefined";
        var result;
        if (!implementsReturn) {
          var reason = new Promise2.CancellationError(
            "generator .return() sentinel"
          );
          Promise2.coroutine.returnSentinel = reason;
          this._promise._attachExtraTrace(reason);
          this._promise._pushContext();
          result = tryCatch2(this._generator["throw"]).call(
            this._generator,
            reason
          );
          this._promise._popContext();
        } else {
          this._promise._pushContext();
          result = tryCatch2(this._generator["return"]).call(
            this._generator,
            void 0
          );
          this._promise._popContext();
        }
        this._cancellationPhase = true;
        this._yieldedPromise = null;
        this._continue(result);
      };
      PromiseSpawn.prototype._promiseFulfilled = function(value) {
        this._yieldedPromise = null;
        this._promise._pushContext();
        var result = tryCatch2(this._generator.next).call(this._generator, value);
        this._promise._popContext();
        this._continue(result);
      };
      PromiseSpawn.prototype._promiseRejected = function(reason) {
        this._yieldedPromise = null;
        this._promise._attachExtraTrace(reason);
        this._promise._pushContext();
        var result = tryCatch2(this._generator["throw"]).call(this._generator, reason);
        this._promise._popContext();
        this._continue(result);
      };
      PromiseSpawn.prototype._resultCancelled = function() {
        if (this._yieldedPromise instanceof Promise2) {
          var promise = this._yieldedPromise;
          this._yieldedPromise = null;
          promise.cancel();
        }
      };
      PromiseSpawn.prototype.promise = function() {
        return this._promise;
      };
      PromiseSpawn.prototype._run = function() {
        this._generator = this._generatorFunction.call(this._receiver);
        this._receiver = this._generatorFunction = void 0;
        this._promiseFulfilled(void 0);
      };
      PromiseSpawn.prototype._continue = function(result) {
        var promise = this._promise;
        if (result === errorObj2) {
          this._cleanup();
          if (this._cancellationPhase) {
            return promise.cancel();
          } else {
            return promise._rejectCallback(result.e, false);
          }
        }
        var value = result.value;
        if (result.done === true) {
          this._cleanup();
          if (this._cancellationPhase) {
            return promise.cancel();
          } else {
            return promise._resolveCallback(value);
          }
        } else {
          var maybePromise = tryConvertToPromise(value, this._promise);
          if (!(maybePromise instanceof Promise2)) {
            maybePromise = promiseFromYieldHandler(
              maybePromise,
              this._yieldHandlers,
              this._promise
            );
            if (maybePromise === null) {
              this._promiseRejected(
                new TypeError2(
                  "A value %s was yielded that could not be treated as a promise\n\n    See http://goo.gl/MqrFmX\n\n".replace("%s", value) + "From coroutine:\n" + this._stack.split("\n").slice(1, -7).join("\n")
                )
              );
              return;
            }
          }
          maybePromise = maybePromise._target();
          var bitField = maybePromise._bitField;
          ;
          if ((bitField & 50397184) === 0) {
            this._yieldedPromise = maybePromise;
            maybePromise._proxy(this, null);
          } else if ((bitField & 33554432) !== 0) {
            Promise2._async.invoke(
              this._promiseFulfilled,
              this,
              maybePromise._value()
            );
          } else if ((bitField & 16777216) !== 0) {
            Promise2._async.invoke(
              this._promiseRejected,
              this,
              maybePromise._reason()
            );
          } else {
            this._promiseCancelled();
          }
        }
      };
      Promise2.coroutine = function(generatorFunction, options) {
        if (typeof generatorFunction !== "function") {
          throw new TypeError2("generatorFunction must be a function\n\n    See http://goo.gl/MqrFmX\n");
        }
        var yieldHandler = Object(options).yieldHandler;
        var PromiseSpawn$ = PromiseSpawn;
        var stack = new Error().stack;
        return function() {
          var generator = generatorFunction.apply(this, arguments);
          var spawn = new PromiseSpawn$(
            void 0,
            void 0,
            yieldHandler,
            stack
          );
          var ret2 = spawn.promise();
          spawn._generator = generator;
          spawn._promiseFulfilled(void 0);
          return ret2;
        };
      };
      Promise2.coroutine.addYieldHandler = function(fn) {
        if (typeof fn !== "function") {
          throw new TypeError2("expecting a function but got " + util.classString(fn));
        }
        yieldHandlers.push(fn);
      };
      Promise2.spawn = function(generatorFunction) {
        debug.deprecated("Promise.spawn()", "Promise.coroutine()");
        if (typeof generatorFunction !== "function") {
          return apiRejection("generatorFunction must be a function\n\n    See http://goo.gl/MqrFmX\n");
        }
        var spawn = new PromiseSpawn(generatorFunction, this);
        var ret2 = spawn.promise();
        spawn._run(Promise2.spawn);
        return ret2;
      };
    };
  }
});

// ../../../node_modules/bluebird/js/release/nodeify.js
var require_nodeify = __commonJS({
  "../../../node_modules/bluebird/js/release/nodeify.js"(exports2, module2) {
    "use strict";
    module2.exports = function(Promise2) {
      var util = require_util4();
      var async = Promise2._async;
      var tryCatch2 = util.tryCatch;
      var errorObj2 = util.errorObj;
      function spreadAdapter(val, nodeback) {
        var promise = this;
        if (!util.isArray(val))
          return successAdapter.call(promise, val, nodeback);
        var ret2 = tryCatch2(nodeback).apply(promise._boundValue(), [null].concat(val));
        if (ret2 === errorObj2) {
          async.throwLater(ret2.e);
        }
      }
      function successAdapter(val, nodeback) {
        var promise = this;
        var receiver = promise._boundValue();
        var ret2 = val === void 0 ? tryCatch2(nodeback).call(receiver, null) : tryCatch2(nodeback).call(receiver, null, val);
        if (ret2 === errorObj2) {
          async.throwLater(ret2.e);
        }
      }
      function errorAdapter(reason, nodeback) {
        var promise = this;
        if (!reason) {
          var newReason = new Error(reason + "");
          newReason.cause = reason;
          reason = newReason;
        }
        var ret2 = tryCatch2(nodeback).call(promise._boundValue(), reason);
        if (ret2 === errorObj2) {
          async.throwLater(ret2.e);
        }
      }
      Promise2.prototype.asCallback = Promise2.prototype.nodeify = function(nodeback, options) {
        if (typeof nodeback == "function") {
          var adapter = successAdapter;
          if (options !== void 0 && Object(options).spread) {
            adapter = spreadAdapter;
          }
          this._then(
            adapter,
            errorAdapter,
            void 0,
            this,
            nodeback
          );
        }
        return this;
      };
    };
  }
});

// ../../../node_modules/bluebird/js/release/promisify.js
var require_promisify = __commonJS({
  "../../../node_modules/bluebird/js/release/promisify.js"(exports2, module2) {
    "use strict";
    module2.exports = function(Promise2, INTERNAL) {
      var THIS = {};
      var util = require_util4();
      var nodebackForPromise = require_nodeback();
      var withAppended2 = util.withAppended;
      var maybeWrapAsError2 = util.maybeWrapAsError;
      var canEvaluate2 = util.canEvaluate;
      var TypeError2 = require_errors8().TypeError;
      var defaultSuffix = "Async";
      var defaultPromisified = { __isPromisified__: true };
      var noCopyProps = [
        "arity",
        "length",
        "name",
        "arguments",
        "caller",
        "callee",
        "prototype",
        "__isPromisified__"
      ];
      var noCopyPropsPattern = new RegExp("^(?:" + noCopyProps.join("|") + ")$");
      var defaultFilter = function(name) {
        return util.isIdentifier(name) && name.charAt(0) !== "_" && name !== "constructor";
      };
      function propsFilter(key) {
        return !noCopyPropsPattern.test(key);
      }
      function isPromisified(fn) {
        try {
          return fn.__isPromisified__ === true;
        } catch (e) {
          return false;
        }
      }
      function hasPromisified(obj2, key, suffix) {
        var val = util.getDataPropertyOrDefault(
          obj2,
          key + suffix,
          defaultPromisified
        );
        return val ? isPromisified(val) : false;
      }
      function checkValid(ret2, suffix, suffixRegexp) {
        for (var i = 0; i < ret2.length; i += 2) {
          var key = ret2[i];
          if (suffixRegexp.test(key)) {
            var keyWithoutAsyncSuffix = key.replace(suffixRegexp, "");
            for (var j = 0; j < ret2.length; j += 2) {
              if (ret2[j] === keyWithoutAsyncSuffix) {
                throw new TypeError2("Cannot promisify an API that has normal methods with '%s'-suffix\n\n    See http://goo.gl/MqrFmX\n".replace("%s", suffix));
              }
            }
          }
        }
      }
      function promisifiableMethods(obj2, suffix, suffixRegexp, filter) {
        var keys = util.inheritedDataKeys(obj2);
        var ret2 = [];
        for (var i = 0; i < keys.length; ++i) {
          var key = keys[i];
          var value = obj2[key];
          var passesDefaultFilter = filter === defaultFilter ? true : defaultFilter(key, value, obj2);
          if (typeof value === "function" && !isPromisified(value) && !hasPromisified(obj2, key, suffix) && filter(key, value, obj2, passesDefaultFilter)) {
            ret2.push(key, value);
          }
        }
        checkValid(ret2, suffix, suffixRegexp);
        return ret2;
      }
      var escapeIdentRegex = function(str) {
        return str.replace(/([$])/, "\\$");
      };
      var makeNodePromisifiedEval;
      if (true) {
        var switchCaseArgumentOrder = function(likelyArgumentCount) {
          var ret2 = [likelyArgumentCount];
          var min = Math.max(0, likelyArgumentCount - 1 - 3);
          for (var i = likelyArgumentCount - 1; i >= min; --i) {
            ret2.push(i);
          }
          for (var i = likelyArgumentCount + 1; i <= 3; ++i) {
            ret2.push(i);
          }
          return ret2;
        };
        var argumentSequence = function(argumentCount) {
          return util.filledRange(argumentCount, "_arg", "");
        };
        var parameterDeclaration = function(parameterCount2) {
          return util.filledRange(
            Math.max(parameterCount2, 3),
            "_arg",
            ""
          );
        };
        var parameterCount = function(fn) {
          if (typeof fn.length === "number") {
            return Math.max(Math.min(fn.length, 1023 + 1), 0);
          }
          return 0;
        };
        makeNodePromisifiedEval = function(callback, receiver, originalName, fn, _2, multiArgs) {
          var newParameterCount = Math.max(0, parameterCount(fn) - 1);
          var argumentOrder = switchCaseArgumentOrder(newParameterCount);
          var shouldProxyThis = typeof callback === "string" || receiver === THIS;
          function generateCallForArgumentCount(count) {
            var args = argumentSequence(count).join(", ");
            var comma = count > 0 ? ", " : "";
            var ret2;
            if (shouldProxyThis) {
              ret2 = "ret = callback.call(this, {{args}}, nodeback); break;\n";
            } else {
              ret2 = receiver === void 0 ? "ret = callback({{args}}, nodeback); break;\n" : "ret = callback.call(receiver, {{args}}, nodeback); break;\n";
            }
            return ret2.replace("{{args}}", args).replace(", ", comma);
          }
          function generateArgumentSwitchCase() {
            var ret2 = "";
            for (var i = 0; i < argumentOrder.length; ++i) {
              ret2 += "case " + argumentOrder[i] + ":" + generateCallForArgumentCount(argumentOrder[i]);
            }
            ret2 += "                                                             \n        default:                                                             \n            var args = new Array(len + 1);                                   \n            var i = 0;                                                       \n            for (var i = 0; i < len; ++i) {                                  \n               args[i] = arguments[i];                                       \n            }                                                                \n            args[i] = nodeback;                                              \n            [CodeForCall]                                                    \n            break;                                                           \n        ".replace("[CodeForCall]", shouldProxyThis ? "ret = callback.apply(this, args);\n" : "ret = callback.apply(receiver, args);\n");
            return ret2;
          }
          var getFunctionCode = typeof callback === "string" ? "this != null ? this['" + callback + "'] : fn" : "fn";
          var body = "'use strict';                                                \n        var ret = function (Parameters) {                                    \n            'use strict';                                                    \n            var len = arguments.length;                                      \n            var promise = new Promise(INTERNAL);                             \n            promise._captureStackTrace();                                    \n            var nodeback = nodebackForPromise(promise, " + multiArgs + ");   \n            var ret;                                                         \n            var callback = tryCatch([GetFunctionCode]);                      \n            switch(len) {                                                    \n                [CodeForSwitchCase]                                          \n            }                                                                \n            if (ret === errorObj) {                                          \n                promise._rejectCallback(maybeWrapAsError(ret.e), true, true);\n            }                                                                \n            if (!promise._isFateSealed()) promise._setAsyncGuaranteed();     \n            return promise;                                                  \n        };                                                                   \n        notEnumerableProp(ret, '__isPromisified__', true);                   \n        return ret;                                                          \n    ".replace("[CodeForSwitchCase]", generateArgumentSwitchCase()).replace("[GetFunctionCode]", getFunctionCode);
          body = body.replace("Parameters", parameterDeclaration(newParameterCount));
          return new Function(
            "Promise",
            "fn",
            "receiver",
            "withAppended",
            "maybeWrapAsError",
            "nodebackForPromise",
            "tryCatch",
            "errorObj",
            "notEnumerableProp",
            "INTERNAL",
            body
          )(
            Promise2,
            fn,
            receiver,
            withAppended2,
            maybeWrapAsError2,
            nodebackForPromise,
            util.tryCatch,
            util.errorObj,
            util.notEnumerableProp,
            INTERNAL
          );
        };
      }
      function makeNodePromisifiedClosure(callback, receiver, _2, fn, __, multiArgs) {
        var defaultThis = /* @__PURE__ */ function() {
          return this;
        }();
        var method = callback;
        if (typeof method === "string") {
          callback = fn;
        }
        function promisified() {
          var _receiver = receiver;
          if (receiver === THIS)
            _receiver = this;
          var promise = new Promise2(INTERNAL);
          promise._captureStackTrace();
          var cb = typeof method === "string" && this !== defaultThis ? this[method] : callback;
          var fn2 = nodebackForPromise(promise, multiArgs);
          try {
            cb.apply(_receiver, withAppended2(arguments, fn2));
          } catch (e) {
            promise._rejectCallback(maybeWrapAsError2(e), true, true);
          }
          if (!promise._isFateSealed())
            promise._setAsyncGuaranteed();
          return promise;
        }
        util.notEnumerableProp(promisified, "__isPromisified__", true);
        return promisified;
      }
      var makeNodePromisified = canEvaluate2 ? makeNodePromisifiedEval : makeNodePromisifiedClosure;
      function promisifyAll(obj2, suffix, filter, promisifier, multiArgs) {
        var suffixRegexp = new RegExp(escapeIdentRegex(suffix) + "$");
        var methods = promisifiableMethods(obj2, suffix, suffixRegexp, filter);
        for (var i = 0, len = methods.length; i < len; i += 2) {
          var key = methods[i];
          var fn = methods[i + 1];
          var promisifiedKey = key + suffix;
          if (promisifier === makeNodePromisified) {
            obj2[promisifiedKey] = makeNodePromisified(key, THIS, key, fn, suffix, multiArgs);
          } else {
            var promisified = promisifier(fn, function() {
              return makeNodePromisified(
                key,
                THIS,
                key,
                fn,
                suffix,
                multiArgs
              );
            });
            util.notEnumerableProp(promisified, "__isPromisified__", true);
            obj2[promisifiedKey] = promisified;
          }
        }
        util.toFastProperties(obj2);
        return obj2;
      }
      function promisify(callback, receiver, multiArgs) {
        return makeNodePromisified(
          callback,
          receiver,
          void 0,
          callback,
          null,
          multiArgs
        );
      }
      Promise2.promisify = function(fn, options) {
        if (typeof fn !== "function") {
          throw new TypeError2("expecting a function but got " + util.classString(fn));
        }
        if (isPromisified(fn)) {
          return fn;
        }
        options = Object(options);
        var receiver = options.context === void 0 ? THIS : options.context;
        var multiArgs = !!options.multiArgs;
        var ret2 = promisify(fn, receiver, multiArgs);
        util.copyDescriptors(fn, ret2, propsFilter);
        return ret2;
      };
      Promise2.promisifyAll = function(target, options) {
        if (typeof target !== "function" && typeof target !== "object") {
          throw new TypeError2("the target of promisifyAll must be an object or a function\n\n    See http://goo.gl/MqrFmX\n");
        }
        options = Object(options);
        var multiArgs = !!options.multiArgs;
        var suffix = options.suffix;
        if (typeof suffix !== "string")
          suffix = defaultSuffix;
        var filter = options.filter;
        if (typeof filter !== "function")
          filter = defaultFilter;
        var promisifier = options.promisifier;
        if (typeof promisifier !== "function")
          promisifier = makeNodePromisified;
        if (!util.isIdentifier(suffix)) {
          throw new RangeError("suffix must be a valid identifier\n\n    See http://goo.gl/MqrFmX\n");
        }
        var keys = util.inheritedDataKeys(target);
        for (var i = 0; i < keys.length; ++i) {
          var value = target[keys[i]];
          if (keys[i] !== "constructor" && util.isClass(value)) {
            promisifyAll(
              value.prototype,
              suffix,
              filter,
              promisifier,
              multiArgs
            );
            promisifyAll(value, suffix, filter, promisifier, multiArgs);
          }
        }
        return promisifyAll(target, suffix, filter, promisifier, multiArgs);
      };
    };
  }
});

// ../../../node_modules/bluebird/js/release/props.js
var require_props = __commonJS({
  "../../../node_modules/bluebird/js/release/props.js"(exports2, module2) {
    "use strict";
    module2.exports = function(Promise2, PromiseArray, tryConvertToPromise, apiRejection) {
      var util = require_util4();
      var isObject2 = util.isObject;
      var es52 = require_es5();
      var Es6Map;
      if (typeof Map === "function")
        Es6Map = Map;
      var mapToEntries = /* @__PURE__ */ function() {
        var index = 0;
        var size = 0;
        function extractEntry(value, key) {
          this[index] = value;
          this[index + size] = key;
          index++;
        }
        return function mapToEntries2(map) {
          size = map.size;
          index = 0;
          var ret2 = new Array(map.size * 2);
          map.forEach(extractEntry, ret2);
          return ret2;
        };
      }();
      var entriesToMap = function(entries) {
        var ret2 = new Es6Map();
        var length = entries.length / 2 | 0;
        for (var i = 0; i < length; ++i) {
          var key = entries[length + i];
          var value = entries[i];
          ret2.set(key, value);
        }
        return ret2;
      };
      function PropertiesPromiseArray(obj2) {
        var isMap = false;
        var entries;
        if (Es6Map !== void 0 && obj2 instanceof Es6Map) {
          entries = mapToEntries(obj2);
          isMap = true;
        } else {
          var keys = es52.keys(obj2);
          var len = keys.length;
          entries = new Array(len * 2);
          for (var i = 0; i < len; ++i) {
            var key = keys[i];
            entries[i] = obj2[key];
            entries[i + len] = key;
          }
        }
        this.constructor$(entries);
        this._isMap = isMap;
        this._init$(void 0, -3);
      }
      util.inherits(PropertiesPromiseArray, PromiseArray);
      PropertiesPromiseArray.prototype._init = function() {
      };
      PropertiesPromiseArray.prototype._promiseFulfilled = function(value, index) {
        this._values[index] = value;
        var totalResolved = ++this._totalResolved;
        if (totalResolved >= this._length) {
          var val;
          if (this._isMap) {
            val = entriesToMap(this._values);
          } else {
            val = {};
            var keyOffset = this.length();
            for (var i = 0, len = this.length(); i < len; ++i) {
              val[this._values[i + keyOffset]] = this._values[i];
            }
          }
          this._resolve(val);
          return true;
        }
        return false;
      };
      PropertiesPromiseArray.prototype.shouldCopyValues = function() {
        return false;
      };
      PropertiesPromiseArray.prototype.getActualLength = function(len) {
        return len >> 1;
      };
      function props(promises) {
        var ret2;
        var castValue = tryConvertToPromise(promises);
        if (!isObject2(castValue)) {
          return apiRejection("cannot await properties of a non-object\n\n    See http://goo.gl/MqrFmX\n");
        } else if (castValue instanceof Promise2) {
          ret2 = castValue._then(
            Promise2.props,
            void 0,
            void 0,
            void 0,
            void 0
          );
        } else {
          ret2 = new PropertiesPromiseArray(castValue).promise();
        }
        if (castValue instanceof Promise2) {
          ret2._propagateFrom(castValue, 2);
        }
        return ret2;
      }
      Promise2.prototype.props = function() {
        return props(this);
      };
      Promise2.props = function(promises) {
        return props(promises);
      };
    };
  }
});

// ../../../node_modules/bluebird/js/release/race.js
var require_race = __commonJS({
  "../../../node_modules/bluebird/js/release/race.js"(exports2, module2) {
    "use strict";
    module2.exports = function(Promise2, INTERNAL, tryConvertToPromise, apiRejection) {
      var util = require_util4();
      var raceLater = function(promise) {
        return promise.then(function(array) {
          return race(array, promise);
        });
      };
      function race(promises, parent) {
        var maybePromise = tryConvertToPromise(promises);
        if (maybePromise instanceof Promise2) {
          return raceLater(maybePromise);
        } else {
          promises = util.asArray(promises);
          if (promises === null)
            return apiRejection("expecting an array or an iterable object but got " + util.classString(promises));
        }
        var ret2 = new Promise2(INTERNAL);
        if (parent !== void 0) {
          ret2._propagateFrom(parent, 3);
        }
        var fulfill = ret2._fulfill;
        var reject = ret2._reject;
        for (var i = 0, len = promises.length; i < len; ++i) {
          var val = promises[i];
          if (val === void 0 && !(i in promises)) {
            continue;
          }
          Promise2.cast(val)._then(fulfill, reject, void 0, ret2, null);
        }
        return ret2;
      }
      Promise2.race = function(promises) {
        return race(promises, void 0);
      };
      Promise2.prototype.race = function() {
        return race(this, void 0);
      };
    };
  }
});

// ../../../node_modules/bluebird/js/release/reduce.js
var require_reduce = __commonJS({
  "../../../node_modules/bluebird/js/release/reduce.js"(exports2, module2) {
    "use strict";
    module2.exports = function(Promise2, PromiseArray, apiRejection, tryConvertToPromise, INTERNAL, debug) {
      var getDomain = Promise2._getDomain;
      var util = require_util4();
      var tryCatch2 = util.tryCatch;
      function ReductionPromiseArray(promises, fn, initialValue, _each) {
        this.constructor$(promises);
        var domain = getDomain();
        this._fn = domain === null ? fn : util.domainBind(domain, fn);
        if (initialValue !== void 0) {
          initialValue = Promise2.resolve(initialValue);
          initialValue._attachCancellationCallback(this);
        }
        this._initialValue = initialValue;
        this._currentCancellable = null;
        if (_each === INTERNAL) {
          this._eachValues = Array(this._length);
        } else if (_each === 0) {
          this._eachValues = null;
        } else {
          this._eachValues = void 0;
        }
        this._promise._captureStackTrace();
        this._init$(void 0, -5);
      }
      util.inherits(ReductionPromiseArray, PromiseArray);
      ReductionPromiseArray.prototype._gotAccum = function(accum) {
        if (this._eachValues !== void 0 && this._eachValues !== null && accum !== INTERNAL) {
          this._eachValues.push(accum);
        }
      };
      ReductionPromiseArray.prototype._eachComplete = function(value) {
        if (this._eachValues !== null) {
          this._eachValues.push(value);
        }
        return this._eachValues;
      };
      ReductionPromiseArray.prototype._init = function() {
      };
      ReductionPromiseArray.prototype._resolveEmptyArray = function() {
        this._resolve(this._eachValues !== void 0 ? this._eachValues : this._initialValue);
      };
      ReductionPromiseArray.prototype.shouldCopyValues = function() {
        return false;
      };
      ReductionPromiseArray.prototype._resolve = function(value) {
        this._promise._resolveCallback(value);
        this._values = null;
      };
      ReductionPromiseArray.prototype._resultCancelled = function(sender) {
        if (sender === this._initialValue)
          return this._cancel();
        if (this._isResolved())
          return;
        this._resultCancelled$();
        if (this._currentCancellable instanceof Promise2) {
          this._currentCancellable.cancel();
        }
        if (this._initialValue instanceof Promise2) {
          this._initialValue.cancel();
        }
      };
      ReductionPromiseArray.prototype._iterate = function(values) {
        this._values = values;
        var value;
        var i;
        var length = values.length;
        if (this._initialValue !== void 0) {
          value = this._initialValue;
          i = 0;
        } else {
          value = Promise2.resolve(values[0]);
          i = 1;
        }
        this._currentCancellable = value;
        if (!value.isRejected()) {
          for (; i < length; ++i) {
            var ctx = {
              accum: null,
              value: values[i],
              index: i,
              length,
              array: this
            };
            value = value._then(gotAccum, void 0, void 0, ctx, void 0);
          }
        }
        if (this._eachValues !== void 0) {
          value = value._then(this._eachComplete, void 0, void 0, this, void 0);
        }
        value._then(completed, completed, void 0, value, this);
      };
      Promise2.prototype.reduce = function(fn, initialValue) {
        return reduce(this, fn, initialValue, null);
      };
      Promise2.reduce = function(promises, fn, initialValue, _each) {
        return reduce(promises, fn, initialValue, _each);
      };
      function completed(valueOrReason, array) {
        if (this.isFulfilled()) {
          array._resolve(valueOrReason);
        } else {
          array._reject(valueOrReason);
        }
      }
      function reduce(promises, fn, initialValue, _each) {
        if (typeof fn !== "function") {
          return apiRejection("expecting a function but got " + util.classString(fn));
        }
        var array = new ReductionPromiseArray(promises, fn, initialValue, _each);
        return array.promise();
      }
      function gotAccum(accum) {
        this.accum = accum;
        this.array._gotAccum(accum);
        var value = tryConvertToPromise(this.value, this.array._promise);
        if (value instanceof Promise2) {
          this.array._currentCancellable = value;
          return value._then(gotValue, void 0, void 0, this, void 0);
        } else {
          return gotValue.call(this, value);
        }
      }
      function gotValue(value) {
        var array = this.array;
        var promise = array._promise;
        var fn = tryCatch2(array._fn);
        promise._pushContext();
        var ret2;
        if (array._eachValues !== void 0) {
          ret2 = fn.call(promise._boundValue(), value, this.index, this.length);
        } else {
          ret2 = fn.call(
            promise._boundValue(),
            this.accum,
            value,
            this.index,
            this.length
          );
        }
        if (ret2 instanceof Promise2) {
          array._currentCancellable = ret2;
        }
        var promiseCreated = promise._popContext();
        debug.checkForgottenReturns(
          ret2,
          promiseCreated,
          array._eachValues !== void 0 ? "Promise.each" : "Promise.reduce",
          promise
        );
        return ret2;
      }
    };
  }
});

// ../../../node_modules/bluebird/js/release/settle.js
var require_settle = __commonJS({
  "../../../node_modules/bluebird/js/release/settle.js"(exports2, module2) {
    "use strict";
    module2.exports = function(Promise2, PromiseArray, debug) {
      var PromiseInspection = Promise2.PromiseInspection;
      var util = require_util4();
      function SettledPromiseArray(values) {
        this.constructor$(values);
      }
      util.inherits(SettledPromiseArray, PromiseArray);
      SettledPromiseArray.prototype._promiseResolved = function(index, inspection) {
        this._values[index] = inspection;
        var totalResolved = ++this._totalResolved;
        if (totalResolved >= this._length) {
          this._resolve(this._values);
          return true;
        }
        return false;
      };
      SettledPromiseArray.prototype._promiseFulfilled = function(value, index) {
        var ret2 = new PromiseInspection();
        ret2._bitField = 33554432;
        ret2._settledValueField = value;
        return this._promiseResolved(index, ret2);
      };
      SettledPromiseArray.prototype._promiseRejected = function(reason, index) {
        var ret2 = new PromiseInspection();
        ret2._bitField = 16777216;
        ret2._settledValueField = reason;
        return this._promiseResolved(index, ret2);
      };
      Promise2.settle = function(promises) {
        debug.deprecated(".settle()", ".reflect()");
        return new SettledPromiseArray(promises).promise();
      };
      Promise2.prototype.settle = function() {
        return Promise2.settle(this);
      };
    };
  }
});

// ../../../node_modules/bluebird/js/release/some.js
var require_some = __commonJS({
  "../../../node_modules/bluebird/js/release/some.js"(exports2, module2) {
    "use strict";
    module2.exports = function(Promise2, PromiseArray, apiRejection) {
      var util = require_util4();
      var RangeError2 = require_errors8().RangeError;
      var AggregateError = require_errors8().AggregateError;
      var isArray = util.isArray;
      var CANCELLATION = {};
      function SomePromiseArray(values) {
        this.constructor$(values);
        this._howMany = 0;
        this._unwrap = false;
        this._initialized = false;
      }
      util.inherits(SomePromiseArray, PromiseArray);
      SomePromiseArray.prototype._init = function() {
        if (!this._initialized) {
          return;
        }
        if (this._howMany === 0) {
          this._resolve([]);
          return;
        }
        this._init$(void 0, -5);
        var isArrayResolved = isArray(this._values);
        if (!this._isResolved() && isArrayResolved && this._howMany > this._canPossiblyFulfill()) {
          this._reject(this._getRangeError(this.length()));
        }
      };
      SomePromiseArray.prototype.init = function() {
        this._initialized = true;
        this._init();
      };
      SomePromiseArray.prototype.setUnwrap = function() {
        this._unwrap = true;
      };
      SomePromiseArray.prototype.howMany = function() {
        return this._howMany;
      };
      SomePromiseArray.prototype.setHowMany = function(count) {
        this._howMany = count;
      };
      SomePromiseArray.prototype._promiseFulfilled = function(value) {
        this._addFulfilled(value);
        if (this._fulfilled() === this.howMany()) {
          this._values.length = this.howMany();
          if (this.howMany() === 1 && this._unwrap) {
            this._resolve(this._values[0]);
          } else {
            this._resolve(this._values);
          }
          return true;
        }
        return false;
      };
      SomePromiseArray.prototype._promiseRejected = function(reason) {
        this._addRejected(reason);
        return this._checkOutcome();
      };
      SomePromiseArray.prototype._promiseCancelled = function() {
        if (this._values instanceof Promise2 || this._values == null) {
          return this._cancel();
        }
        this._addRejected(CANCELLATION);
        return this._checkOutcome();
      };
      SomePromiseArray.prototype._checkOutcome = function() {
        if (this.howMany() > this._canPossiblyFulfill()) {
          var e = new AggregateError();
          for (var i = this.length(); i < this._values.length; ++i) {
            if (this._values[i] !== CANCELLATION) {
              e.push(this._values[i]);
            }
          }
          if (e.length > 0) {
            this._reject(e);
          } else {
            this._cancel();
          }
          return true;
        }
        return false;
      };
      SomePromiseArray.prototype._fulfilled = function() {
        return this._totalResolved;
      };
      SomePromiseArray.prototype._rejected = function() {
        return this._values.length - this.length();
      };
      SomePromiseArray.prototype._addRejected = function(reason) {
        this._values.push(reason);
      };
      SomePromiseArray.prototype._addFulfilled = function(value) {
        this._values[this._totalResolved++] = value;
      };
      SomePromiseArray.prototype._canPossiblyFulfill = function() {
        return this.length() - this._rejected();
      };
      SomePromiseArray.prototype._getRangeError = function(count) {
        var message = "Input array must contain at least " + this._howMany + " items but contains only " + count + " items";
        return new RangeError2(message);
      };
      SomePromiseArray.prototype._resolveEmptyArray = function() {
        this._reject(this._getRangeError(0));
      };
      function some(promises, howMany) {
        if ((howMany | 0) !== howMany || howMany < 0) {
          return apiRejection("expecting a positive integer\n\n    See http://goo.gl/MqrFmX\n");
        }
        var ret2 = new SomePromiseArray(promises);
        var promise = ret2.promise();
        ret2.setHowMany(howMany);
        ret2.init();
        return promise;
      }
      Promise2.some = function(promises, howMany) {
        return some(promises, howMany);
      };
      Promise2.prototype.some = function(howMany) {
        return some(this, howMany);
      };
      Promise2._SomePromiseArray = SomePromiseArray;
    };
  }
});

// ../../../node_modules/bluebird/js/release/filter.js
var require_filter = __commonJS({
  "../../../node_modules/bluebird/js/release/filter.js"(exports2, module2) {
    "use strict";
    module2.exports = function(Promise2, INTERNAL) {
      var PromiseMap = Promise2.map;
      Promise2.prototype.filter = function(fn, options) {
        return PromiseMap(this, fn, options, INTERNAL);
      };
      Promise2.filter = function(promises, fn, options) {
        return PromiseMap(promises, fn, options, INTERNAL);
      };
    };
  }
});

// ../../../node_modules/bluebird/js/release/each.js
var require_each = __commonJS({
  "../../../node_modules/bluebird/js/release/each.js"(exports2, module2) {
    "use strict";
    module2.exports = function(Promise2, INTERNAL) {
      var PromiseReduce = Promise2.reduce;
      var PromiseAll = Promise2.all;
      function promiseAllThis() {
        return PromiseAll(this);
      }
      function PromiseMapSeries(promises, fn) {
        return PromiseReduce(promises, fn, INTERNAL, INTERNAL);
      }
      Promise2.prototype.each = function(fn) {
        return PromiseReduce(this, fn, INTERNAL, 0)._then(promiseAllThis, void 0, void 0, this, void 0);
      };
      Promise2.prototype.mapSeries = function(fn) {
        return PromiseReduce(this, fn, INTERNAL, INTERNAL);
      };
      Promise2.each = function(promises, fn) {
        return PromiseReduce(promises, fn, INTERNAL, 0)._then(promiseAllThis, void 0, void 0, promises, void 0);
      };
      Promise2.mapSeries = PromiseMapSeries;
    };
  }
});

// ../../../node_modules/bluebird/js/release/any.js
var require_any = __commonJS({
  "../../../node_modules/bluebird/js/release/any.js"(exports2, module2) {
    "use strict";
    module2.exports = function(Promise2) {
      var SomePromiseArray = Promise2._SomePromiseArray;
      function any(promises) {
        var ret2 = new SomePromiseArray(promises);
        var promise = ret2.promise();
        ret2.setHowMany(1);
        ret2.setUnwrap();
        ret2.init();
        return promise;
      }
      Promise2.any = function(promises) {
        return any(promises);
      };
      Promise2.prototype.any = function() {
        return any(this);
      };
    };
  }
});

// ../../../node_modules/bluebird/js/release/promise.js
var require_promise = __commonJS({
  "../../../node_modules/bluebird/js/release/promise.js"(exports2, module2) {
    "use strict";
    module2.exports = function() {
      var makeSelfResolutionError = function() {
        return new TypeError2("circular promise resolution chain\n\n    See http://goo.gl/MqrFmX\n");
      };
      var reflectHandler = function() {
        return new Promise2.PromiseInspection(this._target());
      };
      var apiRejection = function(msg) {
        return Promise2.reject(new TypeError2(msg));
      };
      function Proxyable() {
      }
      var UNDEFINED_BINDING = {};
      var util = require_util4();
      var getDomain;
      if (util.isNode) {
        getDomain = function() {
          var ret2 = process.domain;
          if (ret2 === void 0)
            ret2 = null;
          return ret2;
        };
      } else {
        getDomain = function() {
          return null;
        };
      }
      util.notEnumerableProp(Promise2, "_getDomain", getDomain);
      var es52 = require_es5();
      var Async = require_async2();
      var async = new Async();
      es52.defineProperty(Promise2, "_async", { value: async });
      var errors = require_errors8();
      var TypeError2 = Promise2.TypeError = errors.TypeError;
      Promise2.RangeError = errors.RangeError;
      var CancellationError = Promise2.CancellationError = errors.CancellationError;
      Promise2.TimeoutError = errors.TimeoutError;
      Promise2.OperationalError = errors.OperationalError;
      Promise2.RejectionError = errors.OperationalError;
      Promise2.AggregateError = errors.AggregateError;
      var INTERNAL = function() {
      };
      var APPLY = {};
      var NEXT_FILTER = {};
      var tryConvertToPromise = require_thenables()(Promise2, INTERNAL);
      var PromiseArray = require_promise_array()(
        Promise2,
        INTERNAL,
        tryConvertToPromise,
        apiRejection,
        Proxyable
      );
      var Context = require_context()(Promise2);
      var createContext = Context.create;
      var debug = require_debuggability()(Promise2, Context);
      var CapturedTrace = debug.CapturedTrace;
      var PassThroughHandlerContext = require_finally()(Promise2, tryConvertToPromise);
      var catchFilter = require_catch_filter()(NEXT_FILTER);
      var nodebackForPromise = require_nodeback();
      var errorObj2 = util.errorObj;
      var tryCatch2 = util.tryCatch;
      function check(self2, executor) {
        if (typeof executor !== "function") {
          throw new TypeError2("expecting a function but got " + util.classString(executor));
        }
        if (self2.constructor !== Promise2) {
          throw new TypeError2("the promise constructor cannot be invoked directly\n\n    See http://goo.gl/MqrFmX\n");
        }
      }
      function Promise2(executor) {
        this._bitField = 0;
        this._fulfillmentHandler0 = void 0;
        this._rejectionHandler0 = void 0;
        this._promise0 = void 0;
        this._receiver0 = void 0;
        if (executor !== INTERNAL) {
          check(this, executor);
          this._resolveFromExecutor(executor);
        }
        this._promiseCreated();
        this._fireEvent("promiseCreated", this);
      }
      Promise2.prototype.toString = function() {
        return "[object Promise]";
      };
      Promise2.prototype.caught = Promise2.prototype["catch"] = function(fn) {
        var len = arguments.length;
        if (len > 1) {
          var catchInstances = new Array(len - 1), j = 0, i;
          for (i = 0; i < len - 1; ++i) {
            var item = arguments[i];
            if (util.isObject(item)) {
              catchInstances[j++] = item;
            } else {
              return apiRejection("expecting an object but got A catch statement predicate " + util.classString(item));
            }
          }
          catchInstances.length = j;
          fn = arguments[i];
          return this.then(void 0, catchFilter(catchInstances, fn, this));
        }
        return this.then(void 0, fn);
      };
      Promise2.prototype.reflect = function() {
        return this._then(
          reflectHandler,
          reflectHandler,
          void 0,
          this,
          void 0
        );
      };
      Promise2.prototype.then = function(didFulfill, didReject) {
        if (debug.warnings() && arguments.length > 0 && typeof didFulfill !== "function" && typeof didReject !== "function") {
          var msg = ".then() only accepts functions but was passed: " + util.classString(didFulfill);
          if (arguments.length > 1) {
            msg += ", " + util.classString(didReject);
          }
          this._warn(msg);
        }
        return this._then(didFulfill, didReject, void 0, void 0, void 0);
      };
      Promise2.prototype.done = function(didFulfill, didReject) {
        var promise = this._then(didFulfill, didReject, void 0, void 0, void 0);
        promise._setIsFinal();
      };
      Promise2.prototype.spread = function(fn) {
        if (typeof fn !== "function") {
          return apiRejection("expecting a function but got " + util.classString(fn));
        }
        return this.all()._then(fn, void 0, void 0, APPLY, void 0);
      };
      Promise2.prototype.toJSON = function() {
        var ret2 = {
          isFulfilled: false,
          isRejected: false,
          fulfillmentValue: void 0,
          rejectionReason: void 0
        };
        if (this.isFulfilled()) {
          ret2.fulfillmentValue = this.value();
          ret2.isFulfilled = true;
        } else if (this.isRejected()) {
          ret2.rejectionReason = this.reason();
          ret2.isRejected = true;
        }
        return ret2;
      };
      Promise2.prototype.all = function() {
        if (arguments.length > 0) {
          this._warn(".all() was passed arguments but it does not take any");
        }
        return new PromiseArray(this).promise();
      };
      Promise2.prototype.error = function(fn) {
        return this.caught(util.originatesFromRejection, fn);
      };
      Promise2.getNewLibraryCopy = module2.exports;
      Promise2.is = function(val) {
        return val instanceof Promise2;
      };
      Promise2.fromNode = Promise2.fromCallback = function(fn) {
        var ret2 = new Promise2(INTERNAL);
        ret2._captureStackTrace();
        var multiArgs = arguments.length > 1 ? !!Object(arguments[1]).multiArgs : false;
        var result = tryCatch2(fn)(nodebackForPromise(ret2, multiArgs));
        if (result === errorObj2) {
          ret2._rejectCallback(result.e, true);
        }
        if (!ret2._isFateSealed())
          ret2._setAsyncGuaranteed();
        return ret2;
      };
      Promise2.all = function(promises) {
        return new PromiseArray(promises).promise();
      };
      Promise2.cast = function(obj2) {
        var ret2 = tryConvertToPromise(obj2);
        if (!(ret2 instanceof Promise2)) {
          ret2 = new Promise2(INTERNAL);
          ret2._captureStackTrace();
          ret2._setFulfilled();
          ret2._rejectionHandler0 = obj2;
        }
        return ret2;
      };
      Promise2.resolve = Promise2.fulfilled = Promise2.cast;
      Promise2.reject = Promise2.rejected = function(reason) {
        var ret2 = new Promise2(INTERNAL);
        ret2._captureStackTrace();
        ret2._rejectCallback(reason, true);
        return ret2;
      };
      Promise2.setScheduler = function(fn) {
        if (typeof fn !== "function") {
          throw new TypeError2("expecting a function but got " + util.classString(fn));
        }
        return async.setScheduler(fn);
      };
      Promise2.prototype._then = function(didFulfill, didReject, _2, receiver, internalData) {
        var haveInternalData = internalData !== void 0;
        var promise = haveInternalData ? internalData : new Promise2(INTERNAL);
        var target = this._target();
        var bitField = target._bitField;
        if (!haveInternalData) {
          promise._propagateFrom(this, 3);
          promise._captureStackTrace();
          if (receiver === void 0 && (this._bitField & 2097152) !== 0) {
            if (!((bitField & 50397184) === 0)) {
              receiver = this._boundValue();
            } else {
              receiver = target === this ? void 0 : this._boundTo;
            }
          }
          this._fireEvent("promiseChained", this, promise);
        }
        var domain = getDomain();
        if (!((bitField & 50397184) === 0)) {
          var handler, value, settler = target._settlePromiseCtx;
          if ((bitField & 33554432) !== 0) {
            value = target._rejectionHandler0;
            handler = didFulfill;
          } else if ((bitField & 16777216) !== 0) {
            value = target._fulfillmentHandler0;
            handler = didReject;
            target._unsetRejectionIsUnhandled();
          } else {
            settler = target._settlePromiseLateCancellationObserver;
            value = new CancellationError("late cancellation observer");
            target._attachExtraTrace(value);
            handler = didReject;
          }
          async.invoke(settler, target, {
            handler: domain === null ? handler : typeof handler === "function" && util.domainBind(domain, handler),
            promise,
            receiver,
            value
          });
        } else {
          target._addCallbacks(didFulfill, didReject, promise, receiver, domain);
        }
        return promise;
      };
      Promise2.prototype._length = function() {
        return this._bitField & 65535;
      };
      Promise2.prototype._isFateSealed = function() {
        return (this._bitField & 117506048) !== 0;
      };
      Promise2.prototype._isFollowing = function() {
        return (this._bitField & 67108864) === 67108864;
      };
      Promise2.prototype._setLength = function(len) {
        this._bitField = this._bitField & -65536 | len & 65535;
      };
      Promise2.prototype._setFulfilled = function() {
        this._bitField = this._bitField | 33554432;
        this._fireEvent("promiseFulfilled", this);
      };
      Promise2.prototype._setRejected = function() {
        this._bitField = this._bitField | 16777216;
        this._fireEvent("promiseRejected", this);
      };
      Promise2.prototype._setFollowing = function() {
        this._bitField = this._bitField | 67108864;
        this._fireEvent("promiseResolved", this);
      };
      Promise2.prototype._setIsFinal = function() {
        this._bitField = this._bitField | 4194304;
      };
      Promise2.prototype._isFinal = function() {
        return (this._bitField & 4194304) > 0;
      };
      Promise2.prototype._unsetCancelled = function() {
        this._bitField = this._bitField & ~65536;
      };
      Promise2.prototype._setCancelled = function() {
        this._bitField = this._bitField | 65536;
        this._fireEvent("promiseCancelled", this);
      };
      Promise2.prototype._setWillBeCancelled = function() {
        this._bitField = this._bitField | 8388608;
      };
      Promise2.prototype._setAsyncGuaranteed = function() {
        if (async.hasCustomScheduler())
          return;
        this._bitField = this._bitField | 134217728;
      };
      Promise2.prototype._receiverAt = function(index) {
        var ret2 = index === 0 ? this._receiver0 : this[index * 4 - 4 + 3];
        if (ret2 === UNDEFINED_BINDING) {
          return void 0;
        } else if (ret2 === void 0 && this._isBound()) {
          return this._boundValue();
        }
        return ret2;
      };
      Promise2.prototype._promiseAt = function(index) {
        return this[index * 4 - 4 + 2];
      };
      Promise2.prototype._fulfillmentHandlerAt = function(index) {
        return this[index * 4 - 4 + 0];
      };
      Promise2.prototype._rejectionHandlerAt = function(index) {
        return this[index * 4 - 4 + 1];
      };
      Promise2.prototype._boundValue = function() {
      };
      Promise2.prototype._migrateCallback0 = function(follower) {
        var bitField = follower._bitField;
        var fulfill = follower._fulfillmentHandler0;
        var reject = follower._rejectionHandler0;
        var promise = follower._promise0;
        var receiver = follower._receiverAt(0);
        if (receiver === void 0)
          receiver = UNDEFINED_BINDING;
        this._addCallbacks(fulfill, reject, promise, receiver, null);
      };
      Promise2.prototype._migrateCallbackAt = function(follower, index) {
        var fulfill = follower._fulfillmentHandlerAt(index);
        var reject = follower._rejectionHandlerAt(index);
        var promise = follower._promiseAt(index);
        var receiver = follower._receiverAt(index);
        if (receiver === void 0)
          receiver = UNDEFINED_BINDING;
        this._addCallbacks(fulfill, reject, promise, receiver, null);
      };
      Promise2.prototype._addCallbacks = function(fulfill, reject, promise, receiver, domain) {
        var index = this._length();
        if (index >= 65535 - 4) {
          index = 0;
          this._setLength(0);
        }
        if (index === 0) {
          this._promise0 = promise;
          this._receiver0 = receiver;
          if (typeof fulfill === "function") {
            this._fulfillmentHandler0 = domain === null ? fulfill : util.domainBind(domain, fulfill);
          }
          if (typeof reject === "function") {
            this._rejectionHandler0 = domain === null ? reject : util.domainBind(domain, reject);
          }
        } else {
          var base = index * 4 - 4;
          this[base + 2] = promise;
          this[base + 3] = receiver;
          if (typeof fulfill === "function") {
            this[base + 0] = domain === null ? fulfill : util.domainBind(domain, fulfill);
          }
          if (typeof reject === "function") {
            this[base + 1] = domain === null ? reject : util.domainBind(domain, reject);
          }
        }
        this._setLength(index + 1);
        return index;
      };
      Promise2.prototype._proxy = function(proxyable, arg) {
        this._addCallbacks(void 0, void 0, arg, proxyable, null);
      };
      Promise2.prototype._resolveCallback = function(value, shouldBind) {
        if ((this._bitField & 117506048) !== 0)
          return;
        if (value === this)
          return this._rejectCallback(makeSelfResolutionError(), false);
        var maybePromise = tryConvertToPromise(value, this);
        if (!(maybePromise instanceof Promise2))
          return this._fulfill(value);
        if (shouldBind)
          this._propagateFrom(maybePromise, 2);
        var promise = maybePromise._target();
        if (promise === this) {
          this._reject(makeSelfResolutionError());
          return;
        }
        var bitField = promise._bitField;
        if ((bitField & 50397184) === 0) {
          var len = this._length();
          if (len > 0)
            promise._migrateCallback0(this);
          for (var i = 1; i < len; ++i) {
            promise._migrateCallbackAt(this, i);
          }
          this._setFollowing();
          this._setLength(0);
          this._setFollowee(promise);
        } else if ((bitField & 33554432) !== 0) {
          this._fulfill(promise._value());
        } else if ((bitField & 16777216) !== 0) {
          this._reject(promise._reason());
        } else {
          var reason = new CancellationError("late cancellation observer");
          promise._attachExtraTrace(reason);
          this._reject(reason);
        }
      };
      Promise2.prototype._rejectCallback = function(reason, synchronous, ignoreNonErrorWarnings) {
        var trace = util.ensureErrorObject(reason);
        var hasStack = trace === reason;
        if (!hasStack && !ignoreNonErrorWarnings && debug.warnings()) {
          var message = "a promise was rejected with a non-error: " + util.classString(reason);
          this._warn(message, true);
        }
        this._attachExtraTrace(trace, synchronous ? hasStack : false);
        this._reject(reason);
      };
      Promise2.prototype._resolveFromExecutor = function(executor) {
        var promise = this;
        this._captureStackTrace();
        this._pushContext();
        var synchronous = true;
        var r = this._execute(executor, function(value) {
          promise._resolveCallback(value);
        }, function(reason) {
          promise._rejectCallback(reason, synchronous);
        });
        synchronous = false;
        this._popContext();
        if (r !== void 0) {
          promise._rejectCallback(r, true);
        }
      };
      Promise2.prototype._settlePromiseFromHandler = function(handler, receiver, value, promise) {
        var bitField = promise._bitField;
        if ((bitField & 65536) !== 0)
          return;
        promise._pushContext();
        var x;
        if (receiver === APPLY) {
          if (!value || typeof value.length !== "number") {
            x = errorObj2;
            x.e = new TypeError2("cannot .spread() a non-array: " + util.classString(value));
          } else {
            x = tryCatch2(handler).apply(this._boundValue(), value);
          }
        } else {
          x = tryCatch2(handler).call(receiver, value);
        }
        var promiseCreated = promise._popContext();
        bitField = promise._bitField;
        if ((bitField & 65536) !== 0)
          return;
        if (x === NEXT_FILTER) {
          promise._reject(value);
        } else if (x === errorObj2) {
          promise._rejectCallback(x.e, false);
        } else {
          debug.checkForgottenReturns(x, promiseCreated, "", promise, this);
          promise._resolveCallback(x);
        }
      };
      Promise2.prototype._target = function() {
        var ret2 = this;
        while (ret2._isFollowing())
          ret2 = ret2._followee();
        return ret2;
      };
      Promise2.prototype._followee = function() {
        return this._rejectionHandler0;
      };
      Promise2.prototype._setFollowee = function(promise) {
        this._rejectionHandler0 = promise;
      };
      Promise2.prototype._settlePromise = function(promise, handler, receiver, value) {
        var isPromise = promise instanceof Promise2;
        var bitField = this._bitField;
        var asyncGuaranteed = (bitField & 134217728) !== 0;
        if ((bitField & 65536) !== 0) {
          if (isPromise)
            promise._invokeInternalOnCancel();
          if (receiver instanceof PassThroughHandlerContext && receiver.isFinallyHandler()) {
            receiver.cancelPromise = promise;
            if (tryCatch2(handler).call(receiver, value) === errorObj2) {
              promise._reject(errorObj2.e);
            }
          } else if (handler === reflectHandler) {
            promise._fulfill(reflectHandler.call(receiver));
          } else if (receiver instanceof Proxyable) {
            receiver._promiseCancelled(promise);
          } else if (isPromise || promise instanceof PromiseArray) {
            promise._cancel();
          } else {
            receiver.cancel();
          }
        } else if (typeof handler === "function") {
          if (!isPromise) {
            handler.call(receiver, value, promise);
          } else {
            if (asyncGuaranteed)
              promise._setAsyncGuaranteed();
            this._settlePromiseFromHandler(handler, receiver, value, promise);
          }
        } else if (receiver instanceof Proxyable) {
          if (!receiver._isResolved()) {
            if ((bitField & 33554432) !== 0) {
              receiver._promiseFulfilled(value, promise);
            } else {
              receiver._promiseRejected(value, promise);
            }
          }
        } else if (isPromise) {
          if (asyncGuaranteed)
            promise._setAsyncGuaranteed();
          if ((bitField & 33554432) !== 0) {
            promise._fulfill(value);
          } else {
            promise._reject(value);
          }
        }
      };
      Promise2.prototype._settlePromiseLateCancellationObserver = function(ctx) {
        var handler = ctx.handler;
        var promise = ctx.promise;
        var receiver = ctx.receiver;
        var value = ctx.value;
        if (typeof handler === "function") {
          if (!(promise instanceof Promise2)) {
            handler.call(receiver, value, promise);
          } else {
            this._settlePromiseFromHandler(handler, receiver, value, promise);
          }
        } else if (promise instanceof Promise2) {
          promise._reject(value);
        }
      };
      Promise2.prototype._settlePromiseCtx = function(ctx) {
        this._settlePromise(ctx.promise, ctx.handler, ctx.receiver, ctx.value);
      };
      Promise2.prototype._settlePromise0 = function(handler, value, bitField) {
        var promise = this._promise0;
        var receiver = this._receiverAt(0);
        this._promise0 = void 0;
        this._receiver0 = void 0;
        this._settlePromise(promise, handler, receiver, value);
      };
      Promise2.prototype._clearCallbackDataAtIndex = function(index) {
        var base = index * 4 - 4;
        this[base + 2] = this[base + 3] = this[base + 0] = this[base + 1] = void 0;
      };
      Promise2.prototype._fulfill = function(value) {
        var bitField = this._bitField;
        if ((bitField & 117506048) >>> 16)
          return;
        if (value === this) {
          var err = makeSelfResolutionError();
          this._attachExtraTrace(err);
          return this._reject(err);
        }
        this._setFulfilled();
        this._rejectionHandler0 = value;
        if ((bitField & 65535) > 0) {
          if ((bitField & 134217728) !== 0) {
            this._settlePromises();
          } else {
            async.settlePromises(this);
          }
        }
      };
      Promise2.prototype._reject = function(reason) {
        var bitField = this._bitField;
        if ((bitField & 117506048) >>> 16)
          return;
        this._setRejected();
        this._fulfillmentHandler0 = reason;
        if (this._isFinal()) {
          return async.fatalError(reason, util.isNode);
        }
        if ((bitField & 65535) > 0) {
          async.settlePromises(this);
        } else {
          this._ensurePossibleRejectionHandled();
        }
      };
      Promise2.prototype._fulfillPromises = function(len, value) {
        for (var i = 1; i < len; i++) {
          var handler = this._fulfillmentHandlerAt(i);
          var promise = this._promiseAt(i);
          var receiver = this._receiverAt(i);
          this._clearCallbackDataAtIndex(i);
          this._settlePromise(promise, handler, receiver, value);
        }
      };
      Promise2.prototype._rejectPromises = function(len, reason) {
        for (var i = 1; i < len; i++) {
          var handler = this._rejectionHandlerAt(i);
          var promise = this._promiseAt(i);
          var receiver = this._receiverAt(i);
          this._clearCallbackDataAtIndex(i);
          this._settlePromise(promise, handler, receiver, reason);
        }
      };
      Promise2.prototype._settlePromises = function() {
        var bitField = this._bitField;
        var len = bitField & 65535;
        if (len > 0) {
          if ((bitField & 16842752) !== 0) {
            var reason = this._fulfillmentHandler0;
            this._settlePromise0(this._rejectionHandler0, reason, bitField);
            this._rejectPromises(len, reason);
          } else {
            var value = this._rejectionHandler0;
            this._settlePromise0(this._fulfillmentHandler0, value, bitField);
            this._fulfillPromises(len, value);
          }
          this._setLength(0);
        }
        this._clearCancellationData();
      };
      Promise2.prototype._settledValue = function() {
        var bitField = this._bitField;
        if ((bitField & 33554432) !== 0) {
          return this._rejectionHandler0;
        } else if ((bitField & 16777216) !== 0) {
          return this._fulfillmentHandler0;
        }
      };
      function deferResolve(v) {
        this.promise._resolveCallback(v);
      }
      function deferReject(v) {
        this.promise._rejectCallback(v, false);
      }
      Promise2.defer = Promise2.pending = function() {
        debug.deprecated("Promise.defer", "new Promise");
        var promise = new Promise2(INTERNAL);
        return {
          promise,
          resolve: deferResolve,
          reject: deferReject
        };
      };
      util.notEnumerableProp(
        Promise2,
        "_makeSelfResolutionError",
        makeSelfResolutionError
      );
      require_method()(
        Promise2,
        INTERNAL,
        tryConvertToPromise,
        apiRejection,
        debug
      );
      require_bind()(Promise2, INTERNAL, tryConvertToPromise, debug);
      require_cancel()(Promise2, PromiseArray, apiRejection, debug);
      require_direct_resolve()(Promise2);
      require_synchronous_inspection()(Promise2);
      require_join()(
        Promise2,
        PromiseArray,
        tryConvertToPromise,
        INTERNAL,
        async,
        getDomain
      );
      Promise2.Promise = Promise2;
      Promise2.version = "3.4.7";
      require_map()(Promise2, PromiseArray, apiRejection, tryConvertToPromise, INTERNAL, debug);
      require_call_get()(Promise2);
      require_using()(Promise2, apiRejection, tryConvertToPromise, createContext, INTERNAL, debug);
      require_timers()(Promise2, INTERNAL, debug);
      require_generators()(Promise2, apiRejection, INTERNAL, tryConvertToPromise, Proxyable, debug);
      require_nodeify()(Promise2);
      require_promisify()(Promise2, INTERNAL);
      require_props()(Promise2, PromiseArray, tryConvertToPromise, apiRejection);
      require_race()(Promise2, INTERNAL, tryConvertToPromise, apiRejection);
      require_reduce()(Promise2, PromiseArray, apiRejection, tryConvertToPromise, INTERNAL, debug);
      require_settle()(Promise2, PromiseArray, debug);
      require_some()(Promise2, PromiseArray, apiRejection);
      require_filter()(Promise2, INTERNAL);
      require_each()(Promise2, INTERNAL);
      require_any()(Promise2);
      util.toFastProperties(Promise2);
      util.toFastProperties(Promise2.prototype);
      function fillTypes(value) {
        var p = new Promise2(INTERNAL);
        p._fulfillmentHandler0 = value;
        p._rejectionHandler0 = value;
        p._promise0 = value;
        p._receiver0 = value;
      }
      fillTypes({ a: 1 });
      fillTypes({ b: 2 });
      fillTypes({ c: 3 });
      fillTypes(1);
      fillTypes(function() {
      });
      fillTypes(void 0);
      fillTypes(false);
      fillTypes(new Promise2(INTERNAL));
      debug.setBounds(Async.firstLineError, util.lastLineError);
      return Promise2;
    };
  }
});

// ../../../node_modules/bluebird/js/release/bluebird.js
var require_bluebird = __commonJS({
  "../../../node_modules/bluebird/js/release/bluebird.js"(exports2, module2) {
    "use strict";
    var old;
    if (typeof Promise !== "undefined")
      old = Promise;
    function noConflict() {
      try {
        if (Promise === bluebird)
          Promise = old;
      } catch (e) {
      }
      return bluebird;
    }
    var bluebird = require_promise()();
    bluebird.noConflict = noConflict;
    module2.exports = bluebird;
  }
});

// ../../../node_modules/unzipper/lib/Buffer.js
var require_Buffer = __commonJS({
  "../../../node_modules/unzipper/lib/Buffer.js"(exports2, module2) {
    var Buffer2 = require("buffer").Buffer;
    if (Buffer2.from === void 0) {
      Buffer2.from = function(a, b, c) {
        return new Buffer2(a, b, c);
      };
      Buffer2.alloc = Buffer2.from;
    }
    module2.exports = Buffer2;
  }
});

// ../../../node_modules/unzipper/node_modules/isarray/index.js
var require_isarray4 = __commonJS({
  "../../../node_modules/unzipper/node_modules/isarray/index.js"(exports2, module2) {
    var toString = {}.toString;
    module2.exports = Array.isArray || function(arr) {
      return toString.call(arr) == "[object Array]";
    };
  }
});

// ../../../node_modules/unzipper/node_modules/readable-stream/lib/internal/streams/stream.js
var require_stream11 = __commonJS({
  "../../../node_modules/unzipper/node_modules/readable-stream/lib/internal/streams/stream.js"(exports2, module2) {
    module2.exports = require("stream");
  }
});

// ../../../node_modules/unzipper/node_modules/safe-buffer/index.js
var require_safe_buffer5 = __commonJS({
  "../../../node_modules/unzipper/node_modules/safe-buffer/index.js"(exports2, module2) {
    var buffer = require("buffer");
    var Buffer2 = buffer.Buffer;
    function copyProps(src, dst) {
      for (var key in src) {
        dst[key] = src[key];
      }
    }
    if (Buffer2.from && Buffer2.alloc && Buffer2.allocUnsafe && Buffer2.allocUnsafeSlow) {
      module2.exports = buffer;
    } else {
      copyProps(buffer, exports2);
      exports2.Buffer = SafeBuffer;
    }
    function SafeBuffer(arg, encodingOrOffset, length) {
      return Buffer2(arg, encodingOrOffset, length);
    }
    copyProps(Buffer2, SafeBuffer);
    SafeBuffer.from = function(arg, encodingOrOffset, length) {
      if (typeof arg === "number") {
        throw new TypeError("Argument must not be a number");
      }
      return Buffer2(arg, encodingOrOffset, length);
    };
    SafeBuffer.alloc = function(size, fill, encoding) {
      if (typeof size !== "number") {
        throw new TypeError("Argument must be a number");
      }
      var buf = Buffer2(size);
      if (fill !== void 0) {
        if (typeof encoding === "string") {
          buf.fill(fill, encoding);
        } else {
          buf.fill(fill);
        }
      } else {
        buf.fill(0);
      }
      return buf;
    };
    SafeBuffer.allocUnsafe = function(size) {
      if (typeof size !== "number") {
        throw new TypeError("Argument must be a number");
      }
      return Buffer2(size);
    };
    SafeBuffer.allocUnsafeSlow = function(size) {
      if (typeof size !== "number") {
        throw new TypeError("Argument must be a number");
      }
      return buffer.SlowBuffer(size);
    };
  }
});

// ../../../node_modules/unzipper/node_modules/readable-stream/lib/internal/streams/BufferList.js
var require_BufferList5 = __commonJS({
  "../../../node_modules/unzipper/node_modules/readable-stream/lib/internal/streams/BufferList.js"(exports2, module2) {
    "use strict";
    function _classCallCheck(instance, Constructor) {
      if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
      }
    }
    var Buffer2 = require_safe_buffer5().Buffer;
    var util = require("util");
    function copyBuffer(src, target, offset) {
      src.copy(target, offset);
    }
    module2.exports = function() {
      function BufferList() {
        _classCallCheck(this, BufferList);
        this.head = null;
        this.tail = null;
        this.length = 0;
      }
      BufferList.prototype.push = function push(v) {
        var entry = { data: v, next: null };
        if (this.length > 0)
          this.tail.next = entry;
        else
          this.head = entry;
        this.tail = entry;
        ++this.length;
      };
      BufferList.prototype.unshift = function unshift(v) {
        var entry = { data: v, next: this.head };
        if (this.length === 0)
          this.tail = entry;
        this.head = entry;
        ++this.length;
      };
      BufferList.prototype.shift = function shift() {
        if (this.length === 0)
          return;
        var ret2 = this.head.data;
        if (this.length === 1)
          this.head = this.tail = null;
        else
          this.head = this.head.next;
        --this.length;
        return ret2;
      };
      BufferList.prototype.clear = function clear() {
        this.head = this.tail = null;
        this.length = 0;
      };
      BufferList.prototype.join = function join(s) {
        if (this.length === 0)
          return "";
        var p = this.head;
        var ret2 = "" + p.data;
        while (p = p.next) {
          ret2 += s + p.data;
        }
        return ret2;
      };
      BufferList.prototype.concat = function concat(n) {
        if (this.length === 0)
          return Buffer2.alloc(0);
        var ret2 = Buffer2.allocUnsafe(n >>> 0);
        var p = this.head;
        var i = 0;
        while (p) {
          copyBuffer(p.data, ret2, i);
          i += p.data.length;
          p = p.next;
        }
        return ret2;
      };
      return BufferList;
    }();
    if (util && util.inspect && util.inspect.custom) {
      module2.exports.prototype[util.inspect.custom] = function() {
        var obj2 = util.inspect({ length: this.length });
        return this.constructor.name + " " + obj2;
      };
    }
  }
});

// ../../../node_modules/unzipper/node_modules/readable-stream/lib/internal/streams/destroy.js
var require_destroy11 = __commonJS({
  "../../../node_modules/unzipper/node_modules/readable-stream/lib/internal/streams/destroy.js"(exports2, module2) {
    "use strict";
    var pna = require_process_nextick_args();
    function destroy(err, cb) {
      var _this = this;
      var readableDestroyed = this._readableState && this._readableState.destroyed;
      var writableDestroyed = this._writableState && this._writableState.destroyed;
      if (readableDestroyed || writableDestroyed) {
        if (cb) {
          cb(err);
        } else if (err) {
          if (!this._writableState) {
            pna.nextTick(emitErrorNT, this, err);
          } else if (!this._writableState.errorEmitted) {
            this._writableState.errorEmitted = true;
            pna.nextTick(emitErrorNT, this, err);
          }
        }
        return this;
      }
      if (this._readableState) {
        this._readableState.destroyed = true;
      }
      if (this._writableState) {
        this._writableState.destroyed = true;
      }
      this._destroy(err || null, function(err2) {
        if (!cb && err2) {
          if (!_this._writableState) {
            pna.nextTick(emitErrorNT, _this, err2);
          } else if (!_this._writableState.errorEmitted) {
            _this._writableState.errorEmitted = true;
            pna.nextTick(emitErrorNT, _this, err2);
          }
        } else if (cb) {
          cb(err2);
        }
      });
      return this;
    }
    function undestroy() {
      if (this._readableState) {
        this._readableState.destroyed = false;
        this._readableState.reading = false;
        this._readableState.ended = false;
        this._readableState.endEmitted = false;
      }
      if (this._writableState) {
        this._writableState.destroyed = false;
        this._writableState.ended = false;
        this._writableState.ending = false;
        this._writableState.finalCalled = false;
        this._writableState.prefinished = false;
        this._writableState.finished = false;
        this._writableState.errorEmitted = false;
      }
    }
    function emitErrorNT(self2, err) {
      self2.emit("error", err);
    }
    module2.exports = {
      destroy,
      undestroy
    };
  }
});

// ../../../node_modules/unzipper/node_modules/readable-stream/lib/_stream_writable.js
var require_stream_writable11 = __commonJS({
  "../../../node_modules/unzipper/node_modules/readable-stream/lib/_stream_writable.js"(exports2, module2) {
    "use strict";
    var pna = require_process_nextick_args();
    module2.exports = Writable;
    function CorkedRequest(state) {
      var _this = this;
      this.next = null;
      this.entry = null;
      this.finish = function() {
        onCorkedFinish(_this, state);
      };
    }
    var asyncWrite = !process.browser && ["v0.10", "v0.9."].indexOf(process.version.slice(0, 5)) > -1 ? setImmediate : pna.nextTick;
    var Duplex;
    Writable.WritableState = WritableState;
    var util = Object.create(require_util());
    util.inherits = require_inherits();
    var internalUtil = {
      deprecate: require_node()
    };
    var Stream = require_stream11();
    var Buffer2 = require_safe_buffer5().Buffer;
    var OurUint8Array = (typeof global !== "undefined" ? global : typeof window !== "undefined" ? window : typeof self !== "undefined" ? self : {}).Uint8Array || function() {
    };
    function _uint8ArrayToBuffer(chunk) {
      return Buffer2.from(chunk);
    }
    function _isUint8Array(obj2) {
      return Buffer2.isBuffer(obj2) || obj2 instanceof OurUint8Array;
    }
    var destroyImpl = require_destroy11();
    util.inherits(Writable, Stream);
    function nop() {
    }
    function WritableState(options, stream) {
      Duplex = Duplex || require_stream_duplex11();
      options = options || {};
      var isDuplex = stream instanceof Duplex;
      this.objectMode = !!options.objectMode;
      if (isDuplex)
        this.objectMode = this.objectMode || !!options.writableObjectMode;
      var hwm = options.highWaterMark;
      var writableHwm = options.writableHighWaterMark;
      var defaultHwm = this.objectMode ? 16 : 16 * 1024;
      if (hwm || hwm === 0)
        this.highWaterMark = hwm;
      else if (isDuplex && (writableHwm || writableHwm === 0))
        this.highWaterMark = writableHwm;
      else
        this.highWaterMark = defaultHwm;
      this.highWaterMark = Math.floor(this.highWaterMark);
      this.finalCalled = false;
      this.needDrain = false;
      this.ending = false;
      this.ended = false;
      this.finished = false;
      this.destroyed = false;
      var noDecode = options.decodeStrings === false;
      this.decodeStrings = !noDecode;
      this.defaultEncoding = options.defaultEncoding || "utf8";
      this.length = 0;
      this.writing = false;
      this.corked = 0;
      this.sync = true;
      this.bufferProcessing = false;
      this.onwrite = function(er) {
        onwrite(stream, er);
      };
      this.writecb = null;
      this.writelen = 0;
      this.bufferedRequest = null;
      this.lastBufferedRequest = null;
      this.pendingcb = 0;
      this.prefinished = false;
      this.errorEmitted = false;
      this.bufferedRequestCount = 0;
      this.corkedRequestsFree = new CorkedRequest(this);
    }
    WritableState.prototype.getBuffer = function getBuffer() {
      var current = this.bufferedRequest;
      var out = [];
      while (current) {
        out.push(current);
        current = current.next;
      }
      return out;
    };
    (function() {
      try {
        Object.defineProperty(WritableState.prototype, "buffer", {
          get: internalUtil.deprecate(function() {
            return this.getBuffer();
          }, "_writableState.buffer is deprecated. Use _writableState.getBuffer instead.", "DEP0003")
        });
      } catch (_2) {
      }
    })();
    var realHasInstance;
    if (typeof Symbol === "function" && Symbol.hasInstance && typeof Function.prototype[Symbol.hasInstance] === "function") {
      realHasInstance = Function.prototype[Symbol.hasInstance];
      Object.defineProperty(Writable, Symbol.hasInstance, {
        value: function(object) {
          if (realHasInstance.call(this, object))
            return true;
          if (this !== Writable)
            return false;
          return object && object._writableState instanceof WritableState;
        }
      });
    } else {
      realHasInstance = function(object) {
        return object instanceof this;
      };
    }
    function Writable(options) {
      Duplex = Duplex || require_stream_duplex11();
      if (!realHasInstance.call(Writable, this) && !(this instanceof Duplex)) {
        return new Writable(options);
      }
      this._writableState = new WritableState(options, this);
      this.writable = true;
      if (options) {
        if (typeof options.write === "function")
          this._write = options.write;
        if (typeof options.writev === "function")
          this._writev = options.writev;
        if (typeof options.destroy === "function")
          this._destroy = options.destroy;
        if (typeof options.final === "function")
          this._final = options.final;
      }
      Stream.call(this);
    }
    Writable.prototype.pipe = function() {
      this.emit("error", new Error("Cannot pipe, not readable"));
    };
    function writeAfterEnd(stream, cb) {
      var er = new Error("write after end");
      stream.emit("error", er);
      pna.nextTick(cb, er);
    }
    function validChunk(stream, state, chunk, cb) {
      var valid = true;
      var er = false;
      if (chunk === null) {
        er = new TypeError("May not write null values to stream");
      } else if (typeof chunk !== "string" && chunk !== void 0 && !state.objectMode) {
        er = new TypeError("Invalid non-string/buffer chunk");
      }
      if (er) {
        stream.emit("error", er);
        pna.nextTick(cb, er);
        valid = false;
      }
      return valid;
    }
    Writable.prototype.write = function(chunk, encoding, cb) {
      var state = this._writableState;
      var ret2 = false;
      var isBuf = !state.objectMode && _isUint8Array(chunk);
      if (isBuf && !Buffer2.isBuffer(chunk)) {
        chunk = _uint8ArrayToBuffer(chunk);
      }
      if (typeof encoding === "function") {
        cb = encoding;
        encoding = null;
      }
      if (isBuf)
        encoding = "buffer";
      else if (!encoding)
        encoding = state.defaultEncoding;
      if (typeof cb !== "function")
        cb = nop;
      if (state.ended)
        writeAfterEnd(this, cb);
      else if (isBuf || validChunk(this, state, chunk, cb)) {
        state.pendingcb++;
        ret2 = writeOrBuffer(this, state, isBuf, chunk, encoding, cb);
      }
      return ret2;
    };
    Writable.prototype.cork = function() {
      var state = this._writableState;
      state.corked++;
    };
    Writable.prototype.uncork = function() {
      var state = this._writableState;
      if (state.corked) {
        state.corked--;
        if (!state.writing && !state.corked && !state.bufferProcessing && state.bufferedRequest)
          clearBuffer(this, state);
      }
    };
    Writable.prototype.setDefaultEncoding = function setDefaultEncoding(encoding) {
      if (typeof encoding === "string")
        encoding = encoding.toLowerCase();
      if (!(["hex", "utf8", "utf-8", "ascii", "binary", "base64", "ucs2", "ucs-2", "utf16le", "utf-16le", "raw"].indexOf((encoding + "").toLowerCase()) > -1))
        throw new TypeError("Unknown encoding: " + encoding);
      this._writableState.defaultEncoding = encoding;
      return this;
    };
    function decodeChunk(state, chunk, encoding) {
      if (!state.objectMode && state.decodeStrings !== false && typeof chunk === "string") {
        chunk = Buffer2.from(chunk, encoding);
      }
      return chunk;
    }
    Object.defineProperty(Writable.prototype, "writableHighWaterMark", {
      // making it explicit this property is not enumerable
      // because otherwise some prototype manipulation in
      // userland will fail
      enumerable: false,
      get: function() {
        return this._writableState.highWaterMark;
      }
    });
    function writeOrBuffer(stream, state, isBuf, chunk, encoding, cb) {
      if (!isBuf) {
        var newChunk = decodeChunk(state, chunk, encoding);
        if (chunk !== newChunk) {
          isBuf = true;
          encoding = "buffer";
          chunk = newChunk;
        }
      }
      var len = state.objectMode ? 1 : chunk.length;
      state.length += len;
      var ret2 = state.length < state.highWaterMark;
      if (!ret2)
        state.needDrain = true;
      if (state.writing || state.corked) {
        var last = state.lastBufferedRequest;
        state.lastBufferedRequest = {
          chunk,
          encoding,
          isBuf,
          callback: cb,
          next: null
        };
        if (last) {
          last.next = state.lastBufferedRequest;
        } else {
          state.bufferedRequest = state.lastBufferedRequest;
        }
        state.bufferedRequestCount += 1;
      } else {
        doWrite(stream, state, false, len, chunk, encoding, cb);
      }
      return ret2;
    }
    function doWrite(stream, state, writev, len, chunk, encoding, cb) {
      state.writelen = len;
      state.writecb = cb;
      state.writing = true;
      state.sync = true;
      if (writev)
        stream._writev(chunk, state.onwrite);
      else
        stream._write(chunk, encoding, state.onwrite);
      state.sync = false;
    }
    function onwriteError(stream, state, sync, er, cb) {
      --state.pendingcb;
      if (sync) {
        pna.nextTick(cb, er);
        pna.nextTick(finishMaybe, stream, state);
        stream._writableState.errorEmitted = true;
        stream.emit("error", er);
      } else {
        cb(er);
        stream._writableState.errorEmitted = true;
        stream.emit("error", er);
        finishMaybe(stream, state);
      }
    }
    function onwriteStateUpdate(state) {
      state.writing = false;
      state.writecb = null;
      state.length -= state.writelen;
      state.writelen = 0;
    }
    function onwrite(stream, er) {
      var state = stream._writableState;
      var sync = state.sync;
      var cb = state.writecb;
      onwriteStateUpdate(state);
      if (er)
        onwriteError(stream, state, sync, er, cb);
      else {
        var finished = needFinish(state);
        if (!finished && !state.corked && !state.bufferProcessing && state.bufferedRequest) {
          clearBuffer(stream, state);
        }
        if (sync) {
          asyncWrite(afterWrite, stream, state, finished, cb);
        } else {
          afterWrite(stream, state, finished, cb);
        }
      }
    }
    function afterWrite(stream, state, finished, cb) {
      if (!finished)
        onwriteDrain(stream, state);
      state.pendingcb--;
      cb();
      finishMaybe(stream, state);
    }
    function onwriteDrain(stream, state) {
      if (state.length === 0 && state.needDrain) {
        state.needDrain = false;
        stream.emit("drain");
      }
    }
    function clearBuffer(stream, state) {
      state.bufferProcessing = true;
      var entry = state.bufferedRequest;
      if (stream._writev && entry && entry.next) {
        var l2 = state.bufferedRequestCount;
        var buffer = new Array(l2);
        var holder = state.corkedRequestsFree;
        holder.entry = entry;
        var count = 0;
        var allBuffers = true;
        while (entry) {
          buffer[count] = entry;
          if (!entry.isBuf)
            allBuffers = false;
          entry = entry.next;
          count += 1;
        }
        buffer.allBuffers = allBuffers;
        doWrite(stream, state, true, state.length, buffer, "", holder.finish);
        state.pendingcb++;
        state.lastBufferedRequest = null;
        if (holder.next) {
          state.corkedRequestsFree = holder.next;
          holder.next = null;
        } else {
          state.corkedRequestsFree = new CorkedRequest(state);
        }
        state.bufferedRequestCount = 0;
      } else {
        while (entry) {
          var chunk = entry.chunk;
          var encoding = entry.encoding;
          var cb = entry.callback;
          var len = state.objectMode ? 1 : chunk.length;
          doWrite(stream, state, false, len, chunk, encoding, cb);
          entry = entry.next;
          state.bufferedRequestCount--;
          if (state.writing) {
            break;
          }
        }
        if (entry === null)
          state.lastBufferedRequest = null;
      }
      state.bufferedRequest = entry;
      state.bufferProcessing = false;
    }
    Writable.prototype._write = function(chunk, encoding, cb) {
      cb(new Error("_write() is not implemented"));
    };
    Writable.prototype._writev = null;
    Writable.prototype.end = function(chunk, encoding, cb) {
      var state = this._writableState;
      if (typeof chunk === "function") {
        cb = chunk;
        chunk = null;
        encoding = null;
      } else if (typeof encoding === "function") {
        cb = encoding;
        encoding = null;
      }
      if (chunk !== null && chunk !== void 0)
        this.write(chunk, encoding);
      if (state.corked) {
        state.corked = 1;
        this.uncork();
      }
      if (!state.ending)
        endWritable(this, state, cb);
    };
    function needFinish(state) {
      return state.ending && state.length === 0 && state.bufferedRequest === null && !state.finished && !state.writing;
    }
    function callFinal(stream, state) {
      stream._final(function(err) {
        state.pendingcb--;
        if (err) {
          stream.emit("error", err);
        }
        state.prefinished = true;
        stream.emit("prefinish");
        finishMaybe(stream, state);
      });
    }
    function prefinish(stream, state) {
      if (!state.prefinished && !state.finalCalled) {
        if (typeof stream._final === "function") {
          state.pendingcb++;
          state.finalCalled = true;
          pna.nextTick(callFinal, stream, state);
        } else {
          state.prefinished = true;
          stream.emit("prefinish");
        }
      }
    }
    function finishMaybe(stream, state) {
      var need = needFinish(state);
      if (need) {
        prefinish(stream, state);
        if (state.pendingcb === 0) {
          state.finished = true;
          stream.emit("finish");
        }
      }
      return need;
    }
    function endWritable(stream, state, cb) {
      state.ending = true;
      finishMaybe(stream, state);
      if (cb) {
        if (state.finished)
          pna.nextTick(cb);
        else
          stream.once("finish", cb);
      }
      state.ended = true;
      stream.writable = false;
    }
    function onCorkedFinish(corkReq, state, err) {
      var entry = corkReq.entry;
      corkReq.entry = null;
      while (entry) {
        var cb = entry.callback;
        state.pendingcb--;
        cb(err);
        entry = entry.next;
      }
      state.corkedRequestsFree.next = corkReq;
    }
    Object.defineProperty(Writable.prototype, "destroyed", {
      get: function() {
        if (this._writableState === void 0) {
          return false;
        }
        return this._writableState.destroyed;
      },
      set: function(value) {
        if (!this._writableState) {
          return;
        }
        this._writableState.destroyed = value;
      }
    });
    Writable.prototype.destroy = destroyImpl.destroy;
    Writable.prototype._undestroy = destroyImpl.undestroy;
    Writable.prototype._destroy = function(err, cb) {
      this.end();
      cb(err);
    };
  }
});

// ../../../node_modules/unzipper/node_modules/readable-stream/lib/_stream_duplex.js
var require_stream_duplex11 = __commonJS({
  "../../../node_modules/unzipper/node_modules/readable-stream/lib/_stream_duplex.js"(exports2, module2) {
    "use strict";
    var pna = require_process_nextick_args();
    var objectKeys = Object.keys || function(obj2) {
      var keys2 = [];
      for (var key in obj2) {
        keys2.push(key);
      }
      return keys2;
    };
    module2.exports = Duplex;
    var util = Object.create(require_util());
    util.inherits = require_inherits();
    var Readable = require_stream_readable11();
    var Writable = require_stream_writable11();
    util.inherits(Duplex, Readable);
    {
      keys = objectKeys(Writable.prototype);
      for (v = 0; v < keys.length; v++) {
        method = keys[v];
        if (!Duplex.prototype[method])
          Duplex.prototype[method] = Writable.prototype[method];
      }
    }
    var keys;
    var method;
    var v;
    function Duplex(options) {
      if (!(this instanceof Duplex))
        return new Duplex(options);
      Readable.call(this, options);
      Writable.call(this, options);
      if (options && options.readable === false)
        this.readable = false;
      if (options && options.writable === false)
        this.writable = false;
      this.allowHalfOpen = true;
      if (options && options.allowHalfOpen === false)
        this.allowHalfOpen = false;
      this.once("end", onend);
    }
    Object.defineProperty(Duplex.prototype, "writableHighWaterMark", {
      // making it explicit this property is not enumerable
      // because otherwise some prototype manipulation in
      // userland will fail
      enumerable: false,
      get: function() {
        return this._writableState.highWaterMark;
      }
    });
    function onend() {
      if (this.allowHalfOpen || this._writableState.ended)
        return;
      pna.nextTick(onEndNT, this);
    }
    function onEndNT(self2) {
      self2.end();
    }
    Object.defineProperty(Duplex.prototype, "destroyed", {
      get: function() {
        if (this._readableState === void 0 || this._writableState === void 0) {
          return false;
        }
        return this._readableState.destroyed && this._writableState.destroyed;
      },
      set: function(value) {
        if (this._readableState === void 0 || this._writableState === void 0) {
          return;
        }
        this._readableState.destroyed = value;
        this._writableState.destroyed = value;
      }
    });
    Duplex.prototype._destroy = function(err, cb) {
      this.push(null);
      this.end();
      pna.nextTick(cb, err);
    };
  }
});

// ../../../node_modules/unzipper/node_modules/string_decoder/lib/string_decoder.js
var require_string_decoder11 = __commonJS({
  "../../../node_modules/unzipper/node_modules/string_decoder/lib/string_decoder.js"(exports2) {
    "use strict";
    var Buffer2 = require_safe_buffer5().Buffer;
    var isEncoding = Buffer2.isEncoding || function(encoding) {
      encoding = "" + encoding;
      switch (encoding && encoding.toLowerCase()) {
        case "hex":
        case "utf8":
        case "utf-8":
        case "ascii":
        case "binary":
        case "base64":
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
        case "raw":
          return true;
        default:
          return false;
      }
    };
    function _normalizeEncoding(enc) {
      if (!enc)
        return "utf8";
      var retried;
      while (true) {
        switch (enc) {
          case "utf8":
          case "utf-8":
            return "utf8";
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
            return "utf16le";
          case "latin1":
          case "binary":
            return "latin1";
          case "base64":
          case "ascii":
          case "hex":
            return enc;
          default:
            if (retried)
              return;
            enc = ("" + enc).toLowerCase();
            retried = true;
        }
      }
    }
    function normalizeEncoding(enc) {
      var nenc = _normalizeEncoding(enc);
      if (typeof nenc !== "string" && (Buffer2.isEncoding === isEncoding || !isEncoding(enc)))
        throw new Error("Unknown encoding: " + enc);
      return nenc || enc;
    }
    exports2.StringDecoder = StringDecoder;
    function StringDecoder(encoding) {
      this.encoding = normalizeEncoding(encoding);
      var nb;
      switch (this.encoding) {
        case "utf16le":
          this.text = utf16Text;
          this.end = utf16End;
          nb = 4;
          break;
        case "utf8":
          this.fillLast = utf8FillLast;
          nb = 4;
          break;
        case "base64":
          this.text = base64Text;
          this.end = base64End;
          nb = 3;
          break;
        default:
          this.write = simpleWrite;
          this.end = simpleEnd;
          return;
      }
      this.lastNeed = 0;
      this.lastTotal = 0;
      this.lastChar = Buffer2.allocUnsafe(nb);
    }
    StringDecoder.prototype.write = function(buf) {
      if (buf.length === 0)
        return "";
      var r;
      var i;
      if (this.lastNeed) {
        r = this.fillLast(buf);
        if (r === void 0)
          return "";
        i = this.lastNeed;
        this.lastNeed = 0;
      } else {
        i = 0;
      }
      if (i < buf.length)
        return r ? r + this.text(buf, i) : this.text(buf, i);
      return r || "";
    };
    StringDecoder.prototype.end = utf8End;
    StringDecoder.prototype.text = utf8Text;
    StringDecoder.prototype.fillLast = function(buf) {
      if (this.lastNeed <= buf.length) {
        buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, this.lastNeed);
        return this.lastChar.toString(this.encoding, 0, this.lastTotal);
      }
      buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, buf.length);
      this.lastNeed -= buf.length;
    };
    function utf8CheckByte(byte) {
      if (byte <= 127)
        return 0;
      else if (byte >> 5 === 6)
        return 2;
      else if (byte >> 4 === 14)
        return 3;
      else if (byte >> 3 === 30)
        return 4;
      return byte >> 6 === 2 ? -1 : -2;
    }
    function utf8CheckIncomplete(self2, buf, i) {
      var j = buf.length - 1;
      if (j < i)
        return 0;
      var nb = utf8CheckByte(buf[j]);
      if (nb >= 0) {
        if (nb > 0)
          self2.lastNeed = nb - 1;
        return nb;
      }
      if (--j < i || nb === -2)
        return 0;
      nb = utf8CheckByte(buf[j]);
      if (nb >= 0) {
        if (nb > 0)
          self2.lastNeed = nb - 2;
        return nb;
      }
      if (--j < i || nb === -2)
        return 0;
      nb = utf8CheckByte(buf[j]);
      if (nb >= 0) {
        if (nb > 0) {
          if (nb === 2)
            nb = 0;
          else
            self2.lastNeed = nb - 3;
        }
        return nb;
      }
      return 0;
    }
    function utf8CheckExtraBytes(self2, buf, p) {
      if ((buf[0] & 192) !== 128) {
        self2.lastNeed = 0;
        return "\uFFFD";
      }
      if (self2.lastNeed > 1 && buf.length > 1) {
        if ((buf[1] & 192) !== 128) {
          self2.lastNeed = 1;
          return "\uFFFD";
        }
        if (self2.lastNeed > 2 && buf.length > 2) {
          if ((buf[2] & 192) !== 128) {
            self2.lastNeed = 2;
            return "\uFFFD";
          }
        }
      }
    }
    function utf8FillLast(buf) {
      var p = this.lastTotal - this.lastNeed;
      var r = utf8CheckExtraBytes(this, buf, p);
      if (r !== void 0)
        return r;
      if (this.lastNeed <= buf.length) {
        buf.copy(this.lastChar, p, 0, this.lastNeed);
        return this.lastChar.toString(this.encoding, 0, this.lastTotal);
      }
      buf.copy(this.lastChar, p, 0, buf.length);
      this.lastNeed -= buf.length;
    }
    function utf8Text(buf, i) {
      var total = utf8CheckIncomplete(this, buf, i);
      if (!this.lastNeed)
        return buf.toString("utf8", i);
      this.lastTotal = total;
      var end = buf.length - (total - this.lastNeed);
      buf.copy(this.lastChar, 0, end);
      return buf.toString("utf8", i, end);
    }
    function utf8End(buf) {
      var r = buf && buf.length ? this.write(buf) : "";
      if (this.lastNeed)
        return r + "\uFFFD";
      return r;
    }
    function utf16Text(buf, i) {
      if ((buf.length - i) % 2 === 0) {
        var r = buf.toString("utf16le", i);
        if (r) {
          var c = r.charCodeAt(r.length - 1);
          if (c >= 55296 && c <= 56319) {
            this.lastNeed = 2;
            this.lastTotal = 4;
            this.lastChar[0] = buf[buf.length - 2];
            this.lastChar[1] = buf[buf.length - 1];
            return r.slice(0, -1);
          }
        }
        return r;
      }
      this.lastNeed = 1;
      this.lastTotal = 2;
      this.lastChar[0] = buf[buf.length - 1];
      return buf.toString("utf16le", i, buf.length - 1);
    }
    function utf16End(buf) {
      var r = buf && buf.length ? this.write(buf) : "";
      if (this.lastNeed) {
        var end = this.lastTotal - this.lastNeed;
        return r + this.lastChar.toString("utf16le", 0, end);
      }
      return r;
    }
    function base64Text(buf, i) {
      var n = (buf.length - i) % 3;
      if (n === 0)
        return buf.toString("base64", i);
      this.lastNeed = 3 - n;
      this.lastTotal = 3;
      if (n === 1) {
        this.lastChar[0] = buf[buf.length - 1];
      } else {
        this.lastChar[0] = buf[buf.length - 2];
        this.lastChar[1] = buf[buf.length - 1];
      }
      return buf.toString("base64", i, buf.length - n);
    }
    function base64End(buf) {
      var r = buf && buf.length ? this.write(buf) : "";
      if (this.lastNeed)
        return r + this.lastChar.toString("base64", 0, 3 - this.lastNeed);
      return r;
    }
    function simpleWrite(buf) {
      return buf.toString(this.encoding);
    }
    function simpleEnd(buf) {
      return buf && buf.length ? this.write(buf) : "";
    }
  }
});

// ../../../node_modules/unzipper/node_modules/readable-stream/lib/_stream_readable.js
var require_stream_readable11 = __commonJS({
  "../../../node_modules/unzipper/node_modules/readable-stream/lib/_stream_readable.js"(exports2, module2) {
    "use strict";
    var pna = require_process_nextick_args();
    module2.exports = Readable;
    var isArray = require_isarray4();
    var Duplex;
    Readable.ReadableState = ReadableState;
    var EE = require("events").EventEmitter;
    var EElistenerCount = function(emitter, type) {
      return emitter.listeners(type).length;
    };
    var Stream = require_stream11();
    var Buffer2 = require_safe_buffer5().Buffer;
    var OurUint8Array = (typeof global !== "undefined" ? global : typeof window !== "undefined" ? window : typeof self !== "undefined" ? self : {}).Uint8Array || function() {
    };
    function _uint8ArrayToBuffer(chunk) {
      return Buffer2.from(chunk);
    }
    function _isUint8Array(obj2) {
      return Buffer2.isBuffer(obj2) || obj2 instanceof OurUint8Array;
    }
    var util = Object.create(require_util());
    util.inherits = require_inherits();
    var debugUtil = require("util");
    var debug = void 0;
    if (debugUtil && debugUtil.debuglog) {
      debug = debugUtil.debuglog("stream");
    } else {
      debug = function() {
      };
    }
    var BufferList = require_BufferList5();
    var destroyImpl = require_destroy11();
    var StringDecoder;
    util.inherits(Readable, Stream);
    var kProxyEvents = ["error", "close", "destroy", "pause", "resume"];
    function prependListener(emitter, event, fn) {
      if (typeof emitter.prependListener === "function")
        return emitter.prependListener(event, fn);
      if (!emitter._events || !emitter._events[event])
        emitter.on(event, fn);
      else if (isArray(emitter._events[event]))
        emitter._events[event].unshift(fn);
      else
        emitter._events[event] = [fn, emitter._events[event]];
    }
    function ReadableState(options, stream) {
      Duplex = Duplex || require_stream_duplex11();
      options = options || {};
      var isDuplex = stream instanceof Duplex;
      this.objectMode = !!options.objectMode;
      if (isDuplex)
        this.objectMode = this.objectMode || !!options.readableObjectMode;
      var hwm = options.highWaterMark;
      var readableHwm = options.readableHighWaterMark;
      var defaultHwm = this.objectMode ? 16 : 16 * 1024;
      if (hwm || hwm === 0)
        this.highWaterMark = hwm;
      else if (isDuplex && (readableHwm || readableHwm === 0))
        this.highWaterMark = readableHwm;
      else
        this.highWaterMark = defaultHwm;
      this.highWaterMark = Math.floor(this.highWaterMark);
      this.buffer = new BufferList();
      this.length = 0;
      this.pipes = null;
      this.pipesCount = 0;
      this.flowing = null;
      this.ended = false;
      this.endEmitted = false;
      this.reading = false;
      this.sync = true;
      this.needReadable = false;
      this.emittedReadable = false;
      this.readableListening = false;
      this.resumeScheduled = false;
      this.destroyed = false;
      this.defaultEncoding = options.defaultEncoding || "utf8";
      this.awaitDrain = 0;
      this.readingMore = false;
      this.decoder = null;
      this.encoding = null;
      if (options.encoding) {
        if (!StringDecoder)
          StringDecoder = require_string_decoder11().StringDecoder;
        this.decoder = new StringDecoder(options.encoding);
        this.encoding = options.encoding;
      }
    }
    function Readable(options) {
      Duplex = Duplex || require_stream_duplex11();
      if (!(this instanceof Readable))
        return new Readable(options);
      this._readableState = new ReadableState(options, this);
      this.readable = true;
      if (options) {
        if (typeof options.read === "function")
          this._read = options.read;
        if (typeof options.destroy === "function")
          this._destroy = options.destroy;
      }
      Stream.call(this);
    }
    Object.defineProperty(Readable.prototype, "destroyed", {
      get: function() {
        if (this._readableState === void 0) {
          return false;
        }
        return this._readableState.destroyed;
      },
      set: function(value) {
        if (!this._readableState) {
          return;
        }
        this._readableState.destroyed = value;
      }
    });
    Readable.prototype.destroy = destroyImpl.destroy;
    Readable.prototype._undestroy = destroyImpl.undestroy;
    Readable.prototype._destroy = function(err, cb) {
      this.push(null);
      cb(err);
    };
    Readable.prototype.push = function(chunk, encoding) {
      var state = this._readableState;
      var skipChunkCheck;
      if (!state.objectMode) {
        if (typeof chunk === "string") {
          encoding = encoding || state.defaultEncoding;
          if (encoding !== state.encoding) {
            chunk = Buffer2.from(chunk, encoding);
            encoding = "";
          }
          skipChunkCheck = true;
        }
      } else {
        skipChunkCheck = true;
      }
      return readableAddChunk(this, chunk, encoding, false, skipChunkCheck);
    };
    Readable.prototype.unshift = function(chunk) {
      return readableAddChunk(this, chunk, null, true, false);
    };
    function readableAddChunk(stream, chunk, encoding, addToFront, skipChunkCheck) {
      var state = stream._readableState;
      if (chunk === null) {
        state.reading = false;
        onEofChunk(stream, state);
      } else {
        var er;
        if (!skipChunkCheck)
          er = chunkInvalid(state, chunk);
        if (er) {
          stream.emit("error", er);
        } else if (state.objectMode || chunk && chunk.length > 0) {
          if (typeof chunk !== "string" && !state.objectMode && Object.getPrototypeOf(chunk) !== Buffer2.prototype) {
            chunk = _uint8ArrayToBuffer(chunk);
          }
          if (addToFront) {
            if (state.endEmitted)
              stream.emit("error", new Error("stream.unshift() after end event"));
            else
              addChunk(stream, state, chunk, true);
          } else if (state.ended) {
            stream.emit("error", new Error("stream.push() after EOF"));
          } else {
            state.reading = false;
            if (state.decoder && !encoding) {
              chunk = state.decoder.write(chunk);
              if (state.objectMode || chunk.length !== 0)
                addChunk(stream, state, chunk, false);
              else
                maybeReadMore(stream, state);
            } else {
              addChunk(stream, state, chunk, false);
            }
          }
        } else if (!addToFront) {
          state.reading = false;
        }
      }
      return needMoreData(state);
    }
    function addChunk(stream, state, chunk, addToFront) {
      if (state.flowing && state.length === 0 && !state.sync) {
        stream.emit("data", chunk);
        stream.read(0);
      } else {
        state.length += state.objectMode ? 1 : chunk.length;
        if (addToFront)
          state.buffer.unshift(chunk);
        else
          state.buffer.push(chunk);
        if (state.needReadable)
          emitReadable(stream);
      }
      maybeReadMore(stream, state);
    }
    function chunkInvalid(state, chunk) {
      var er;
      if (!_isUint8Array(chunk) && typeof chunk !== "string" && chunk !== void 0 && !state.objectMode) {
        er = new TypeError("Invalid non-string/buffer chunk");
      }
      return er;
    }
    function needMoreData(state) {
      return !state.ended && (state.needReadable || state.length < state.highWaterMark || state.length === 0);
    }
    Readable.prototype.isPaused = function() {
      return this._readableState.flowing === false;
    };
    Readable.prototype.setEncoding = function(enc) {
      if (!StringDecoder)
        StringDecoder = require_string_decoder11().StringDecoder;
      this._readableState.decoder = new StringDecoder(enc);
      this._readableState.encoding = enc;
      return this;
    };
    var MAX_HWM = 8388608;
    function computeNewHighWaterMark(n) {
      if (n >= MAX_HWM) {
        n = MAX_HWM;
      } else {
        n--;
        n |= n >>> 1;
        n |= n >>> 2;
        n |= n >>> 4;
        n |= n >>> 8;
        n |= n >>> 16;
        n++;
      }
      return n;
    }
    function howMuchToRead(n, state) {
      if (n <= 0 || state.length === 0 && state.ended)
        return 0;
      if (state.objectMode)
        return 1;
      if (n !== n) {
        if (state.flowing && state.length)
          return state.buffer.head.data.length;
        else
          return state.length;
      }
      if (n > state.highWaterMark)
        state.highWaterMark = computeNewHighWaterMark(n);
      if (n <= state.length)
        return n;
      if (!state.ended) {
        state.needReadable = true;
        return 0;
      }
      return state.length;
    }
    Readable.prototype.read = function(n) {
      debug("read", n);
      n = parseInt(n, 10);
      var state = this._readableState;
      var nOrig = n;
      if (n !== 0)
        state.emittedReadable = false;
      if (n === 0 && state.needReadable && (state.length >= state.highWaterMark || state.ended)) {
        debug("read: emitReadable", state.length, state.ended);
        if (state.length === 0 && state.ended)
          endReadable(this);
        else
          emitReadable(this);
        return null;
      }
      n = howMuchToRead(n, state);
      if (n === 0 && state.ended) {
        if (state.length === 0)
          endReadable(this);
        return null;
      }
      var doRead = state.needReadable;
      debug("need readable", doRead);
      if (state.length === 0 || state.length - n < state.highWaterMark) {
        doRead = true;
        debug("length less than watermark", doRead);
      }
      if (state.ended || state.reading) {
        doRead = false;
        debug("reading or ended", doRead);
      } else if (doRead) {
        debug("do read");
        state.reading = true;
        state.sync = true;
        if (state.length === 0)
          state.needReadable = true;
        this._read(state.highWaterMark);
        state.sync = false;
        if (!state.reading)
          n = howMuchToRead(nOrig, state);
      }
      var ret2;
      if (n > 0)
        ret2 = fromList(n, state);
      else
        ret2 = null;
      if (ret2 === null) {
        state.needReadable = true;
        n = 0;
      } else {
        state.length -= n;
      }
      if (state.length === 0) {
        if (!state.ended)
          state.needReadable = true;
        if (nOrig !== n && state.ended)
          endReadable(this);
      }
      if (ret2 !== null)
        this.emit("data", ret2);
      return ret2;
    };
    function onEofChunk(stream, state) {
      if (state.ended)
        return;
      if (state.decoder) {
        var chunk = state.decoder.end();
        if (chunk && chunk.length) {
          state.buffer.push(chunk);
          state.length += state.objectMode ? 1 : chunk.length;
        }
      }
      state.ended = true;
      emitReadable(stream);
    }
    function emitReadable(stream) {
      var state = stream._readableState;
      state.needReadable = false;
      if (!state.emittedReadable) {
        debug("emitReadable", state.flowing);
        state.emittedReadable = true;
        if (state.sync)
          pna.nextTick(emitReadable_, stream);
        else
          emitReadable_(stream);
      }
    }
    function emitReadable_(stream) {
      debug("emit readable");
      stream.emit("readable");
      flow(stream);
    }
    function maybeReadMore(stream, state) {
      if (!state.readingMore) {
        state.readingMore = true;
        pna.nextTick(maybeReadMore_, stream, state);
      }
    }
    function maybeReadMore_(stream, state) {
      var len = state.length;
      while (!state.reading && !state.flowing && !state.ended && state.length < state.highWaterMark) {
        debug("maybeReadMore read 0");
        stream.read(0);
        if (len === state.length)
          break;
        else
          len = state.length;
      }
      state.readingMore = false;
    }
    Readable.prototype._read = function(n) {
      this.emit("error", new Error("_read() is not implemented"));
    };
    Readable.prototype.pipe = function(dest, pipeOpts) {
      var src = this;
      var state = this._readableState;
      switch (state.pipesCount) {
        case 0:
          state.pipes = dest;
          break;
        case 1:
          state.pipes = [state.pipes, dest];
          break;
        default:
          state.pipes.push(dest);
          break;
      }
      state.pipesCount += 1;
      debug("pipe count=%d opts=%j", state.pipesCount, pipeOpts);
      var doEnd = (!pipeOpts || pipeOpts.end !== false) && dest !== process.stdout && dest !== process.stderr;
      var endFn = doEnd ? onend : unpipe;
      if (state.endEmitted)
        pna.nextTick(endFn);
      else
        src.once("end", endFn);
      dest.on("unpipe", onunpipe);
      function onunpipe(readable, unpipeInfo) {
        debug("onunpipe");
        if (readable === src) {
          if (unpipeInfo && unpipeInfo.hasUnpiped === false) {
            unpipeInfo.hasUnpiped = true;
            cleanup();
          }
        }
      }
      function onend() {
        debug("onend");
        dest.end();
      }
      var ondrain = pipeOnDrain(src);
      dest.on("drain", ondrain);
      var cleanedUp = false;
      function cleanup() {
        debug("cleanup");
        dest.removeListener("close", onclose);
        dest.removeListener("finish", onfinish);
        dest.removeListener("drain", ondrain);
        dest.removeListener("error", onerror);
        dest.removeListener("unpipe", onunpipe);
        src.removeListener("end", onend);
        src.removeListener("end", unpipe);
        src.removeListener("data", ondata);
        cleanedUp = true;
        if (state.awaitDrain && (!dest._writableState || dest._writableState.needDrain))
          ondrain();
      }
      var increasedAwaitDrain = false;
      src.on("data", ondata);
      function ondata(chunk) {
        debug("ondata");
        increasedAwaitDrain = false;
        var ret2 = dest.write(chunk);
        if (false === ret2 && !increasedAwaitDrain) {
          if ((state.pipesCount === 1 && state.pipes === dest || state.pipesCount > 1 && indexOf(state.pipes, dest) !== -1) && !cleanedUp) {
            debug("false write response, pause", state.awaitDrain);
            state.awaitDrain++;
            increasedAwaitDrain = true;
          }
          src.pause();
        }
      }
      function onerror(er) {
        debug("onerror", er);
        unpipe();
        dest.removeListener("error", onerror);
        if (EElistenerCount(dest, "error") === 0)
          dest.emit("error", er);
      }
      prependListener(dest, "error", onerror);
      function onclose() {
        dest.removeListener("finish", onfinish);
        unpipe();
      }
      dest.once("close", onclose);
      function onfinish() {
        debug("onfinish");
        dest.removeListener("close", onclose);
        unpipe();
      }
      dest.once("finish", onfinish);
      function unpipe() {
        debug("unpipe");
        src.unpipe(dest);
      }
      dest.emit("pipe", src);
      if (!state.flowing) {
        debug("pipe resume");
        src.resume();
      }
      return dest;
    };
    function pipeOnDrain(src) {
      return function() {
        var state = src._readableState;
        debug("pipeOnDrain", state.awaitDrain);
        if (state.awaitDrain)
          state.awaitDrain--;
        if (state.awaitDrain === 0 && EElistenerCount(src, "data")) {
          state.flowing = true;
          flow(src);
        }
      };
    }
    Readable.prototype.unpipe = function(dest) {
      var state = this._readableState;
      var unpipeInfo = { hasUnpiped: false };
      if (state.pipesCount === 0)
        return this;
      if (state.pipesCount === 1) {
        if (dest && dest !== state.pipes)
          return this;
        if (!dest)
          dest = state.pipes;
        state.pipes = null;
        state.pipesCount = 0;
        state.flowing = false;
        if (dest)
          dest.emit("unpipe", this, unpipeInfo);
        return this;
      }
      if (!dest) {
        var dests = state.pipes;
        var len = state.pipesCount;
        state.pipes = null;
        state.pipesCount = 0;
        state.flowing = false;
        for (var i = 0; i < len; i++) {
          dests[i].emit("unpipe", this, { hasUnpiped: false });
        }
        return this;
      }
      var index = indexOf(state.pipes, dest);
      if (index === -1)
        return this;
      state.pipes.splice(index, 1);
      state.pipesCount -= 1;
      if (state.pipesCount === 1)
        state.pipes = state.pipes[0];
      dest.emit("unpipe", this, unpipeInfo);
      return this;
    };
    Readable.prototype.on = function(ev, fn) {
      var res = Stream.prototype.on.call(this, ev, fn);
      if (ev === "data") {
        if (this._readableState.flowing !== false)
          this.resume();
      } else if (ev === "readable") {
        var state = this._readableState;
        if (!state.endEmitted && !state.readableListening) {
          state.readableListening = state.needReadable = true;
          state.emittedReadable = false;
          if (!state.reading) {
            pna.nextTick(nReadingNextTick, this);
          } else if (state.length) {
            emitReadable(this);
          }
        }
      }
      return res;
    };
    Readable.prototype.addListener = Readable.prototype.on;
    function nReadingNextTick(self2) {
      debug("readable nexttick read 0");
      self2.read(0);
    }
    Readable.prototype.resume = function() {
      var state = this._readableState;
      if (!state.flowing) {
        debug("resume");
        state.flowing = true;
        resume(this, state);
      }
      return this;
    };
    function resume(stream, state) {
      if (!state.resumeScheduled) {
        state.resumeScheduled = true;
        pna.nextTick(resume_, stream, state);
      }
    }
    function resume_(stream, state) {
      if (!state.reading) {
        debug("resume read 0");
        stream.read(0);
      }
      state.resumeScheduled = false;
      state.awaitDrain = 0;
      stream.emit("resume");
      flow(stream);
      if (state.flowing && !state.reading)
        stream.read(0);
    }
    Readable.prototype.pause = function() {
      debug("call pause flowing=%j", this._readableState.flowing);
      if (false !== this._readableState.flowing) {
        debug("pause");
        this._readableState.flowing = false;
        this.emit("pause");
      }
      return this;
    };
    function flow(stream) {
      var state = stream._readableState;
      debug("flow", state.flowing);
      while (state.flowing && stream.read() !== null) {
      }
    }
    Readable.prototype.wrap = function(stream) {
      var _this = this;
      var state = this._readableState;
      var paused = false;
      stream.on("end", function() {
        debug("wrapped end");
        if (state.decoder && !state.ended) {
          var chunk = state.decoder.end();
          if (chunk && chunk.length)
            _this.push(chunk);
        }
        _this.push(null);
      });
      stream.on("data", function(chunk) {
        debug("wrapped data");
        if (state.decoder)
          chunk = state.decoder.write(chunk);
        if (state.objectMode && (chunk === null || chunk === void 0))
          return;
        else if (!state.objectMode && (!chunk || !chunk.length))
          return;
        var ret2 = _this.push(chunk);
        if (!ret2) {
          paused = true;
          stream.pause();
        }
      });
      for (var i in stream) {
        if (this[i] === void 0 && typeof stream[i] === "function") {
          this[i] = /* @__PURE__ */ function(method) {
            return function() {
              return stream[method].apply(stream, arguments);
            };
          }(i);
        }
      }
      for (var n = 0; n < kProxyEvents.length; n++) {
        stream.on(kProxyEvents[n], this.emit.bind(this, kProxyEvents[n]));
      }
      this._read = function(n2) {
        debug("wrapped _read", n2);
        if (paused) {
          paused = false;
          stream.resume();
        }
      };
      return this;
    };
    Object.defineProperty(Readable.prototype, "readableHighWaterMark", {
      // making it explicit this property is not enumerable
      // because otherwise some prototype manipulation in
      // userland will fail
      enumerable: false,
      get: function() {
        return this._readableState.highWaterMark;
      }
    });
    Readable._fromList = fromList;
    function fromList(n, state) {
      if (state.length === 0)
        return null;
      var ret2;
      if (state.objectMode)
        ret2 = state.buffer.shift();
      else if (!n || n >= state.length) {
        if (state.decoder)
          ret2 = state.buffer.join("");
        else if (state.buffer.length === 1)
          ret2 = state.buffer.head.data;
        else
          ret2 = state.buffer.concat(state.length);
        state.buffer.clear();
      } else {
        ret2 = fromListPartial(n, state.buffer, state.decoder);
      }
      return ret2;
    }
    function fromListPartial(n, list, hasStrings) {
      var ret2;
      if (n < list.head.data.length) {
        ret2 = list.head.data.slice(0, n);
        list.head.data = list.head.data.slice(n);
      } else if (n === list.head.data.length) {
        ret2 = list.shift();
      } else {
        ret2 = hasStrings ? copyFromBufferString(n, list) : copyFromBuffer(n, list);
      }
      return ret2;
    }
    function copyFromBufferString(n, list) {
      var p = list.head;
      var c = 1;
      var ret2 = p.data;
      n -= ret2.length;
      while (p = p.next) {
        var str = p.data;
        var nb = n > str.length ? str.length : n;
        if (nb === str.length)
          ret2 += str;
        else
          ret2 += str.slice(0, n);
        n -= nb;
        if (n === 0) {
          if (nb === str.length) {
            ++c;
            if (p.next)
              list.head = p.next;
            else
              list.head = list.tail = null;
          } else {
            list.head = p;
            p.data = str.slice(nb);
          }
          break;
        }
        ++c;
      }
      list.length -= c;
      return ret2;
    }
    function copyFromBuffer(n, list) {
      var ret2 = Buffer2.allocUnsafe(n);
      var p = list.head;
      var c = 1;
      p.data.copy(ret2);
      n -= p.data.length;
      while (p = p.next) {
        var buf = p.data;
        var nb = n > buf.length ? buf.length : n;
        buf.copy(ret2, ret2.length - n, 0, nb);
        n -= nb;
        if (n === 0) {
          if (nb === buf.length) {
            ++c;
            if (p.next)
              list.head = p.next;
            else
              list.head = list.tail = null;
          } else {
            list.head = p;
            p.data = buf.slice(nb);
          }
          break;
        }
        ++c;
      }
      list.length -= c;
      return ret2;
    }
    function endReadable(stream) {
      var state = stream._readableState;
      if (state.length > 0)
        throw new Error('"endReadable()" called on non-empty stream');
      if (!state.endEmitted) {
        state.ended = true;
        pna.nextTick(endReadableNT, state, stream);
      }
    }
    function endReadableNT(state, stream) {
      if (!state.endEmitted && state.length === 0) {
        state.endEmitted = true;
        stream.readable = false;
        stream.emit("end");
      }
    }
    function indexOf(xs, x) {
      for (var i = 0, l2 = xs.length; i < l2; i++) {
        if (xs[i] === x)
          return i;
      }
      return -1;
    }
  }
});

// ../../../node_modules/unzipper/node_modules/readable-stream/lib/_stream_transform.js
var require_stream_transform11 = __commonJS({
  "../../../node_modules/unzipper/node_modules/readable-stream/lib/_stream_transform.js"(exports2, module2) {
    "use strict";
    module2.exports = Transform;
    var Duplex = require_stream_duplex11();
    var util = Object.create(require_util());
    util.inherits = require_inherits();
    util.inherits(Transform, Duplex);
    function afterTransform(er, data) {
      var ts = this._transformState;
      ts.transforming = false;
      var cb = ts.writecb;
      if (!cb) {
        return this.emit("error", new Error("write callback called multiple times"));
      }
      ts.writechunk = null;
      ts.writecb = null;
      if (data != null)
        this.push(data);
      cb(er);
      var rs = this._readableState;
      rs.reading = false;
      if (rs.needReadable || rs.length < rs.highWaterMark) {
        this._read(rs.highWaterMark);
      }
    }
    function Transform(options) {
      if (!(this instanceof Transform))
        return new Transform(options);
      Duplex.call(this, options);
      this._transformState = {
        afterTransform: afterTransform.bind(this),
        needTransform: false,
        transforming: false,
        writecb: null,
        writechunk: null,
        writeencoding: null
      };
      this._readableState.needReadable = true;
      this._readableState.sync = false;
      if (options) {
        if (typeof options.transform === "function")
          this._transform = options.transform;
        if (typeof options.flush === "function")
          this._flush = options.flush;
      }
      this.on("prefinish", prefinish);
    }
    function prefinish() {
      var _this = this;
      if (typeof this._flush === "function") {
        this._flush(function(er, data) {
          done(_this, er, data);
        });
      } else {
        done(this, null, null);
      }
    }
    Transform.prototype.push = function(chunk, encoding) {
      this._transformState.needTransform = false;
      return Duplex.prototype.push.call(this, chunk, encoding);
    };
    Transform.prototype._transform = function(chunk, encoding, cb) {
      throw new Error("_transform() is not implemented");
    };
    Transform.prototype._write = function(chunk, encoding, cb) {
      var ts = this._transformState;
      ts.writecb = cb;
      ts.writechunk = chunk;
      ts.writeencoding = encoding;
      if (!ts.transforming) {
        var rs = this._readableState;
        if (ts.needTransform || rs.needReadable || rs.length < rs.highWaterMark)
          this._read(rs.highWaterMark);
      }
    };
    Transform.prototype._read = function(n) {
      var ts = this._transformState;
      if (ts.writechunk !== null && ts.writecb && !ts.transforming) {
        ts.transforming = true;
        this._transform(ts.writechunk, ts.writeencoding, ts.afterTransform);
      } else {
        ts.needTransform = true;
      }
    };
    Transform.prototype._destroy = function(err, cb) {
      var _this2 = this;
      Duplex.prototype._destroy.call(this, err, function(err2) {
        cb(err2);
        _this2.emit("close");
      });
    };
    function done(stream, er, data) {
      if (er)
        return stream.emit("error", er);
      if (data != null)
        stream.push(data);
      if (stream._writableState.length)
        throw new Error("Calling transform done when ws.length != 0");
      if (stream._transformState.transforming)
        throw new Error("Calling transform done when still transforming");
      return stream.push(null);
    }
  }
});

// ../../../node_modules/unzipper/node_modules/readable-stream/lib/_stream_passthrough.js
var require_stream_passthrough11 = __commonJS({
  "../../../node_modules/unzipper/node_modules/readable-stream/lib/_stream_passthrough.js"(exports2, module2) {
    "use strict";
    module2.exports = PassThrough;
    var Transform = require_stream_transform11();
    var util = Object.create(require_util());
    util.inherits = require_inherits();
    util.inherits(PassThrough, Transform);
    function PassThrough(options) {
      if (!(this instanceof PassThrough))
        return new PassThrough(options);
      Transform.call(this, options);
    }
    PassThrough.prototype._transform = function(chunk, encoding, cb) {
      cb(null, chunk);
    };
  }
});

// ../../../node_modules/unzipper/node_modules/readable-stream/readable.js
var require_readable11 = __commonJS({
  "../../../node_modules/unzipper/node_modules/readable-stream/readable.js"(exports2, module2) {
    var Stream = require("stream");
    if (process.env.READABLE_STREAM === "disable" && Stream) {
      module2.exports = Stream;
      exports2 = module2.exports = Stream.Readable;
      exports2.Readable = Stream.Readable;
      exports2.Writable = Stream.Writable;
      exports2.Duplex = Stream.Duplex;
      exports2.Transform = Stream.Transform;
      exports2.PassThrough = Stream.PassThrough;
      exports2.Stream = Stream;
    } else {
      exports2 = module2.exports = require_stream_readable11();
      exports2.Stream = Stream || exports2;
      exports2.Readable = exports2;
      exports2.Writable = require_stream_writable11();
      exports2.Duplex = require_stream_duplex11();
      exports2.Transform = require_stream_transform11();
      exports2.PassThrough = require_stream_passthrough11();
    }
  }
});

// ../../../node_modules/unzipper/lib/PullStream.js
var require_PullStream = __commonJS({
  "../../../node_modules/unzipper/lib/PullStream.js"(exports2, module2) {
    var Stream = require("stream");
    var Promise2 = require_bluebird();
    var util = require("util");
    var Buffer2 = require_Buffer();
    var strFunction = "function";
    if (!Stream.Writable || !Stream.Writable.prototype.destroy)
      Stream = require_readable11();
    function PullStream() {
      if (!(this instanceof PullStream))
        return new PullStream();
      Stream.Duplex.call(this, { decodeStrings: false, objectMode: true });
      this.buffer = Buffer2.from("");
      var self2 = this;
      self2.on("finish", function() {
        self2.finished = true;
        self2.emit("chunk", false);
      });
    }
    util.inherits(PullStream, Stream.Duplex);
    PullStream.prototype._write = function(chunk, e, cb) {
      this.buffer = Buffer2.concat([this.buffer, chunk]);
      this.cb = cb;
      this.emit("chunk");
    };
    PullStream.prototype.stream = function(eof, includeEof) {
      var p = Stream.PassThrough();
      var done, self2 = this;
      function cb() {
        if (typeof self2.cb === strFunction) {
          var callback = self2.cb;
          self2.cb = void 0;
          return callback();
        }
      }
      function pull() {
        var packet;
        if (self2.buffer && self2.buffer.length) {
          if (typeof eof === "number") {
            packet = self2.buffer.slice(0, eof);
            self2.buffer = self2.buffer.slice(eof);
            eof -= packet.length;
            done = !eof;
          } else {
            var match = self2.buffer.indexOf(eof);
            if (match !== -1) {
              self2.match = match;
              if (includeEof)
                match = match + eof.length;
              packet = self2.buffer.slice(0, match);
              self2.buffer = self2.buffer.slice(match);
              done = true;
            } else {
              var len = self2.buffer.length - eof.length;
              if (len <= 0) {
                cb();
              } else {
                packet = self2.buffer.slice(0, len);
                self2.buffer = self2.buffer.slice(len);
              }
            }
          }
          if (packet)
            p.write(packet, function() {
              if (self2.buffer.length === 0 || eof.length && self2.buffer.length <= eof.length)
                cb();
            });
        }
        if (!done) {
          if (self2.finished) {
            self2.removeListener("chunk", pull);
            self2.emit("error", new Error("FILE_ENDED"));
            return;
          }
        } else {
          self2.removeListener("chunk", pull);
          p.end();
        }
      }
      self2.on("chunk", pull);
      pull();
      return p;
    };
    PullStream.prototype.pull = function(eof, includeEof) {
      if (eof === 0)
        return Promise2.resolve("");
      if (!isNaN(eof) && this.buffer.length > eof) {
        var data = this.buffer.slice(0, eof);
        this.buffer = this.buffer.slice(eof);
        return Promise2.resolve(data);
      }
      var buffer = Buffer2.from(""), self2 = this;
      var concatStream = Stream.Transform();
      concatStream._transform = function(d, e, cb) {
        buffer = Buffer2.concat([buffer, d]);
        cb();
      };
      var rejectHandler;
      var pullStreamRejectHandler;
      return new Promise2(function(resolve, reject) {
        rejectHandler = reject;
        pullStreamRejectHandler = function(e) {
          self2.__emittedError = e;
          reject(e);
        };
        if (self2.finished)
          return reject(new Error("FILE_ENDED"));
        self2.once("error", pullStreamRejectHandler);
        self2.stream(eof, includeEof).on("error", reject).pipe(concatStream).on("finish", function() {
          resolve(buffer);
        }).on("error", reject);
      }).finally(function() {
        self2.removeListener("error", rejectHandler);
        self2.removeListener("error", pullStreamRejectHandler);
      });
    };
    PullStream.prototype._read = function() {
    };
    module2.exports = PullStream;
  }
});

// ../../../node_modules/unzipper/lib/NoopStream.js
var require_NoopStream = __commonJS({
  "../../../node_modules/unzipper/lib/NoopStream.js"(exports2, module2) {
    var Stream = require("stream");
    var util = require("util");
    if (!Stream.Writable || !Stream.Writable.prototype.destroy)
      Stream = require_readable11();
    function NoopStream() {
      if (!(this instanceof NoopStream)) {
        return new NoopStream();
      }
      Stream.Transform.call(this);
    }
    util.inherits(NoopStream, Stream.Transform);
    NoopStream.prototype._transform = function(d, e, cb) {
      cb();
    };
    module2.exports = NoopStream;
  }
});

// ../../../node_modules/unzipper/lib/BufferStream.js
var require_BufferStream = __commonJS({
  "../../../node_modules/unzipper/lib/BufferStream.js"(exports2, module2) {
    var Promise2 = require_bluebird();
    var Stream = require("stream");
    var Buffer2 = require_Buffer();
    if (!Stream.Writable || !Stream.Writable.prototype.destroy)
      Stream = require_readable11();
    module2.exports = function(entry) {
      return new Promise2(function(resolve, reject) {
        var chunks = [];
        var bufferStream = Stream.Transform().on("finish", function() {
          resolve(Buffer2.concat(chunks));
        }).on("error", reject);
        bufferStream._transform = function(d, e, cb) {
          chunks.push(d);
          cb();
        };
        entry.on("error", reject).pipe(bufferStream);
      });
    };
  }
});

// ../../../node_modules/unzipper/lib/parseExtraField.js
var require_parseExtraField = __commonJS({
  "../../../node_modules/unzipper/lib/parseExtraField.js"(exports2, module2) {
    var binary = require_binary();
    module2.exports = function(extraField, vars) {
      var extra;
      while (!extra && extraField && extraField.length) {
        var candidateExtra = binary.parse(extraField).word16lu("signature").word16lu("partsize").word64lu("uncompressedSize").word64lu("compressedSize").word64lu("offset").word64lu("disknum").vars;
        if (candidateExtra.signature === 1) {
          extra = candidateExtra;
        } else {
          extraField = extraField.slice(candidateExtra.partsize + 4);
        }
      }
      extra = extra || {};
      if (vars.compressedSize === 4294967295)
        vars.compressedSize = extra.compressedSize;
      if (vars.uncompressedSize === 4294967295)
        vars.uncompressedSize = extra.uncompressedSize;
      if (vars.offsetToLocalFileHeader === 4294967295)
        vars.offsetToLocalFileHeader = extra.offset;
      return extra;
    };
  }
});

// ../../../node_modules/unzipper/lib/parseDateTime.js
var require_parseDateTime = __commonJS({
  "../../../node_modules/unzipper/lib/parseDateTime.js"(exports2, module2) {
    module2.exports = function parseDateTime(date, time) {
      const day = date & 31;
      const month = date >> 5 & 15;
      const year = (date >> 9 & 127) + 1980;
      const seconds = time ? (time & 31) * 2 : 0;
      const minutes = time ? time >> 5 & 63 : 0;
      const hours = time ? time >> 11 : 0;
      return new Date(Date.UTC(year, month - 1, day, hours, minutes, seconds));
    };
  }
});

// ../../../node_modules/unzipper/lib/parse.js
var require_parse = __commonJS({
  "../../../node_modules/unzipper/lib/parse.js"(exports2, module2) {
    var util = require("util");
    var zlib = require("zlib");
    var Stream = require("stream");
    var binary = require_binary();
    var Promise2 = require_bluebird();
    var PullStream = require_PullStream();
    var NoopStream = require_NoopStream();
    var BufferStream = require_BufferStream();
    var parseExtraField = require_parseExtraField();
    var Buffer2 = require_Buffer();
    var parseDateTime = require_parseDateTime();
    if (!Stream.Writable || !Stream.Writable.prototype.destroy)
      Stream = require_readable11();
    var endDirectorySignature = Buffer2.alloc(4);
    endDirectorySignature.writeUInt32LE(101010256, 0);
    function Parse(opts) {
      if (!(this instanceof Parse)) {
        return new Parse(opts);
      }
      var self2 = this;
      self2._opts = opts || { verbose: false };
      PullStream.call(self2, self2._opts);
      self2.on("finish", function() {
        self2.emit("end");
        self2.emit("close");
      });
      self2._readRecord().catch(function(e) {
        if (!self2.__emittedError || self2.__emittedError !== e)
          self2.emit("error", e);
      });
    }
    util.inherits(Parse, PullStream);
    Parse.prototype._readRecord = function() {
      var self2 = this;
      return self2.pull(4).then(function(data) {
        if (data.length === 0)
          return;
        var signature = data.readUInt32LE(0);
        if (signature === 875721283) {
          return self2._readCrxHeader();
        }
        if (signature === 67324752) {
          return self2._readFile();
        } else if (signature === 33639248) {
          self2.reachedCD = true;
          return self2._readCentralDirectoryFileHeader();
        } else if (signature === 101010256) {
          return self2._readEndOfCentralDirectoryRecord();
        } else if (self2.reachedCD) {
          var includeEof = true;
          return self2.pull(endDirectorySignature, includeEof).then(function() {
            return self2._readEndOfCentralDirectoryRecord();
          });
        } else
          self2.emit("error", new Error("invalid signature: 0x" + signature.toString(16)));
      });
    };
    Parse.prototype._readCrxHeader = function() {
      var self2 = this;
      return self2.pull(12).then(function(data) {
        self2.crxHeader = binary.parse(data).word32lu("version").word32lu("pubKeyLength").word32lu("signatureLength").vars;
        return self2.pull(self2.crxHeader.pubKeyLength + self2.crxHeader.signatureLength);
      }).then(function(data) {
        self2.crxHeader.publicKey = data.slice(0, self2.crxHeader.pubKeyLength);
        self2.crxHeader.signature = data.slice(self2.crxHeader.pubKeyLength);
        self2.emit("crx-header", self2.crxHeader);
        return self2._readRecord();
      });
    };
    Parse.prototype._readFile = function() {
      var self2 = this;
      return self2.pull(26).then(function(data) {
        var vars = binary.parse(data).word16lu("versionsNeededToExtract").word16lu("flags").word16lu("compressionMethod").word16lu("lastModifiedTime").word16lu("lastModifiedDate").word32lu("crc32").word32lu("compressedSize").word32lu("uncompressedSize").word16lu("fileNameLength").word16lu("extraFieldLength").vars;
        vars.lastModifiedDateTime = parseDateTime(vars.lastModifiedDate, vars.lastModifiedTime);
        if (self2.crxHeader)
          vars.crxHeader = self2.crxHeader;
        return self2.pull(vars.fileNameLength).then(function(fileNameBuffer) {
          var fileName = fileNameBuffer.toString("utf8");
          var entry = Stream.PassThrough();
          var __autodraining = false;
          entry.autodrain = function() {
            __autodraining = true;
            var draining = entry.pipe(NoopStream());
            draining.promise = function() {
              return new Promise2(function(resolve, reject) {
                draining.on("finish", resolve);
                draining.on("error", reject);
              });
            };
            return draining;
          };
          entry.buffer = function() {
            return BufferStream(entry);
          };
          entry.path = fileName;
          entry.props = {};
          entry.props.path = fileName;
          entry.props.pathBuffer = fileNameBuffer;
          entry.props.flags = {
            "isUnicode": (vars.flags & 2048) != 0
          };
          entry.type = vars.uncompressedSize === 0 && /[\/\\]$/.test(fileName) ? "Directory" : "File";
          if (self2._opts.verbose) {
            if (entry.type === "Directory") {
              console.log("   creating:", fileName);
            } else if (entry.type === "File") {
              if (vars.compressionMethod === 0) {
                console.log(" extracting:", fileName);
              } else {
                console.log("  inflating:", fileName);
              }
            }
          }
          return self2.pull(vars.extraFieldLength).then(function(extraField) {
            var extra = parseExtraField(extraField, vars);
            entry.vars = vars;
            entry.extra = extra;
            if (self2._opts.forceStream) {
              self2.push(entry);
            } else {
              self2.emit("entry", entry);
              if (self2._readableState.pipesCount || self2._readableState.pipes && self2._readableState.pipes.length)
                self2.push(entry);
            }
            if (self2._opts.verbose)
              console.log({
                filename: fileName,
                vars,
                extra
              });
            var fileSizeKnown = !(vars.flags & 8) || vars.compressedSize > 0, eof;
            entry.__autodraining = __autodraining;
            var inflater = vars.compressionMethod && !__autodraining ? zlib.createInflateRaw() : Stream.PassThrough();
            if (fileSizeKnown) {
              entry.size = vars.uncompressedSize;
              eof = vars.compressedSize;
            } else {
              eof = Buffer2.alloc(4);
              eof.writeUInt32LE(134695760, 0);
            }
            return new Promise2(function(resolve, reject) {
              self2.stream(eof).pipe(inflater).on("error", function(err) {
                self2.emit("error", err);
              }).pipe(entry).on("finish", function() {
                return fileSizeKnown ? self2._readRecord().then(resolve).catch(reject) : self2._processDataDescriptor(entry).then(resolve).catch(reject);
              });
            });
          });
        });
      });
    };
    Parse.prototype._processDataDescriptor = function(entry) {
      var self2 = this;
      return self2.pull(16).then(function(data) {
        var vars = binary.parse(data).word32lu("dataDescriptorSignature").word32lu("crc32").word32lu("compressedSize").word32lu("uncompressedSize").vars;
        entry.size = vars.uncompressedSize;
        return self2._readRecord();
      });
    };
    Parse.prototype._readCentralDirectoryFileHeader = function() {
      var self2 = this;
      return self2.pull(42).then(function(data) {
        var vars = binary.parse(data).word16lu("versionMadeBy").word16lu("versionsNeededToExtract").word16lu("flags").word16lu("compressionMethod").word16lu("lastModifiedTime").word16lu("lastModifiedDate").word32lu("crc32").word32lu("compressedSize").word32lu("uncompressedSize").word16lu("fileNameLength").word16lu("extraFieldLength").word16lu("fileCommentLength").word16lu("diskNumber").word16lu("internalFileAttributes").word32lu("externalFileAttributes").word32lu("offsetToLocalFileHeader").vars;
        return self2.pull(vars.fileNameLength).then(function(fileName) {
          vars.fileName = fileName.toString("utf8");
          return self2.pull(vars.extraFieldLength);
        }).then(function(extraField) {
          return self2.pull(vars.fileCommentLength);
        }).then(function(fileComment) {
          return self2._readRecord();
        });
      });
    };
    Parse.prototype._readEndOfCentralDirectoryRecord = function() {
      var self2 = this;
      return self2.pull(18).then(function(data) {
        var vars = binary.parse(data).word16lu("diskNumber").word16lu("diskStart").word16lu("numberOfRecordsOnDisk").word16lu("numberOfRecords").word32lu("sizeOfCentralDirectory").word32lu("offsetToStartOfCentralDirectory").word16lu("commentLength").vars;
        return self2.pull(vars.commentLength).then(function(comment) {
          comment = comment.toString("utf8");
          self2.end();
          self2.push(null);
        });
      });
    };
    Parse.prototype.promise = function() {
      var self2 = this;
      return new Promise2(function(resolve, reject) {
        self2.on("finish", resolve);
        self2.on("error", reject);
      });
    };
    module2.exports = Parse;
  }
});

// ../../../node_modules/duplexer2/node_modules/isarray/index.js
var require_isarray5 = __commonJS({
  "../../../node_modules/duplexer2/node_modules/isarray/index.js"(exports2, module2) {
    var toString = {}.toString;
    module2.exports = Array.isArray || function(arr) {
      return toString.call(arr) == "[object Array]";
    };
  }
});

// ../../../node_modules/duplexer2/node_modules/readable-stream/lib/internal/streams/stream.js
var require_stream12 = __commonJS({
  "../../../node_modules/duplexer2/node_modules/readable-stream/lib/internal/streams/stream.js"(exports2, module2) {
    module2.exports = require("stream");
  }
});

// ../../../node_modules/duplexer2/node_modules/safe-buffer/index.js
var require_safe_buffer6 = __commonJS({
  "../../../node_modules/duplexer2/node_modules/safe-buffer/index.js"(exports2, module2) {
    var buffer = require("buffer");
    var Buffer2 = buffer.Buffer;
    function copyProps(src, dst) {
      for (var key in src) {
        dst[key] = src[key];
      }
    }
    if (Buffer2.from && Buffer2.alloc && Buffer2.allocUnsafe && Buffer2.allocUnsafeSlow) {
      module2.exports = buffer;
    } else {
      copyProps(buffer, exports2);
      exports2.Buffer = SafeBuffer;
    }
    function SafeBuffer(arg, encodingOrOffset, length) {
      return Buffer2(arg, encodingOrOffset, length);
    }
    copyProps(Buffer2, SafeBuffer);
    SafeBuffer.from = function(arg, encodingOrOffset, length) {
      if (typeof arg === "number") {
        throw new TypeError("Argument must not be a number");
      }
      return Buffer2(arg, encodingOrOffset, length);
    };
    SafeBuffer.alloc = function(size, fill, encoding) {
      if (typeof size !== "number") {
        throw new TypeError("Argument must be a number");
      }
      var buf = Buffer2(size);
      if (fill !== void 0) {
        if (typeof encoding === "string") {
          buf.fill(fill, encoding);
        } else {
          buf.fill(fill);
        }
      } else {
        buf.fill(0);
      }
      return buf;
    };
    SafeBuffer.allocUnsafe = function(size) {
      if (typeof size !== "number") {
        throw new TypeError("Argument must be a number");
      }
      return Buffer2(size);
    };
    SafeBuffer.allocUnsafeSlow = function(size) {
      if (typeof size !== "number") {
        throw new TypeError("Argument must be a number");
      }
      return buffer.SlowBuffer(size);
    };
  }
});

// ../../../node_modules/duplexer2/node_modules/readable-stream/lib/internal/streams/BufferList.js
var require_BufferList6 = __commonJS({
  "../../../node_modules/duplexer2/node_modules/readable-stream/lib/internal/streams/BufferList.js"(exports2, module2) {
    "use strict";
    function _classCallCheck(instance, Constructor) {
      if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
      }
    }
    var Buffer2 = require_safe_buffer6().Buffer;
    var util = require("util");
    function copyBuffer(src, target, offset) {
      src.copy(target, offset);
    }
    module2.exports = function() {
      function BufferList() {
        _classCallCheck(this, BufferList);
        this.head = null;
        this.tail = null;
        this.length = 0;
      }
      BufferList.prototype.push = function push(v) {
        var entry = { data: v, next: null };
        if (this.length > 0)
          this.tail.next = entry;
        else
          this.head = entry;
        this.tail = entry;
        ++this.length;
      };
      BufferList.prototype.unshift = function unshift(v) {
        var entry = { data: v, next: this.head };
        if (this.length === 0)
          this.tail = entry;
        this.head = entry;
        ++this.length;
      };
      BufferList.prototype.shift = function shift() {
        if (this.length === 0)
          return;
        var ret2 = this.head.data;
        if (this.length === 1)
          this.head = this.tail = null;
        else
          this.head = this.head.next;
        --this.length;
        return ret2;
      };
      BufferList.prototype.clear = function clear() {
        this.head = this.tail = null;
        this.length = 0;
      };
      BufferList.prototype.join = function join(s) {
        if (this.length === 0)
          return "";
        var p = this.head;
        var ret2 = "" + p.data;
        while (p = p.next) {
          ret2 += s + p.data;
        }
        return ret2;
      };
      BufferList.prototype.concat = function concat(n) {
        if (this.length === 0)
          return Buffer2.alloc(0);
        var ret2 = Buffer2.allocUnsafe(n >>> 0);
        var p = this.head;
        var i = 0;
        while (p) {
          copyBuffer(p.data, ret2, i);
          i += p.data.length;
          p = p.next;
        }
        return ret2;
      };
      return BufferList;
    }();
    if (util && util.inspect && util.inspect.custom) {
      module2.exports.prototype[util.inspect.custom] = function() {
        var obj2 = util.inspect({ length: this.length });
        return this.constructor.name + " " + obj2;
      };
    }
  }
});

// ../../../node_modules/duplexer2/node_modules/readable-stream/lib/internal/streams/destroy.js
var require_destroy12 = __commonJS({
  "../../../node_modules/duplexer2/node_modules/readable-stream/lib/internal/streams/destroy.js"(exports2, module2) {
    "use strict";
    var pna = require_process_nextick_args();
    function destroy(err, cb) {
      var _this = this;
      var readableDestroyed = this._readableState && this._readableState.destroyed;
      var writableDestroyed = this._writableState && this._writableState.destroyed;
      if (readableDestroyed || writableDestroyed) {
        if (cb) {
          cb(err);
        } else if (err) {
          if (!this._writableState) {
            pna.nextTick(emitErrorNT, this, err);
          } else if (!this._writableState.errorEmitted) {
            this._writableState.errorEmitted = true;
            pna.nextTick(emitErrorNT, this, err);
          }
        }
        return this;
      }
      if (this._readableState) {
        this._readableState.destroyed = true;
      }
      if (this._writableState) {
        this._writableState.destroyed = true;
      }
      this._destroy(err || null, function(err2) {
        if (!cb && err2) {
          if (!_this._writableState) {
            pna.nextTick(emitErrorNT, _this, err2);
          } else if (!_this._writableState.errorEmitted) {
            _this._writableState.errorEmitted = true;
            pna.nextTick(emitErrorNT, _this, err2);
          }
        } else if (cb) {
          cb(err2);
        }
      });
      return this;
    }
    function undestroy() {
      if (this._readableState) {
        this._readableState.destroyed = false;
        this._readableState.reading = false;
        this._readableState.ended = false;
        this._readableState.endEmitted = false;
      }
      if (this._writableState) {
        this._writableState.destroyed = false;
        this._writableState.ended = false;
        this._writableState.ending = false;
        this._writableState.finalCalled = false;
        this._writableState.prefinished = false;
        this._writableState.finished = false;
        this._writableState.errorEmitted = false;
      }
    }
    function emitErrorNT(self2, err) {
      self2.emit("error", err);
    }
    module2.exports = {
      destroy,
      undestroy
    };
  }
});

// ../../../node_modules/duplexer2/node_modules/readable-stream/lib/_stream_writable.js
var require_stream_writable12 = __commonJS({
  "../../../node_modules/duplexer2/node_modules/readable-stream/lib/_stream_writable.js"(exports2, module2) {
    "use strict";
    var pna = require_process_nextick_args();
    module2.exports = Writable;
    function CorkedRequest(state) {
      var _this = this;
      this.next = null;
      this.entry = null;
      this.finish = function() {
        onCorkedFinish(_this, state);
      };
    }
    var asyncWrite = !process.browser && ["v0.10", "v0.9."].indexOf(process.version.slice(0, 5)) > -1 ? setImmediate : pna.nextTick;
    var Duplex;
    Writable.WritableState = WritableState;
    var util = Object.create(require_util());
    util.inherits = require_inherits();
    var internalUtil = {
      deprecate: require_node()
    };
    var Stream = require_stream12();
    var Buffer2 = require_safe_buffer6().Buffer;
    var OurUint8Array = (typeof global !== "undefined" ? global : typeof window !== "undefined" ? window : typeof self !== "undefined" ? self : {}).Uint8Array || function() {
    };
    function _uint8ArrayToBuffer(chunk) {
      return Buffer2.from(chunk);
    }
    function _isUint8Array(obj2) {
      return Buffer2.isBuffer(obj2) || obj2 instanceof OurUint8Array;
    }
    var destroyImpl = require_destroy12();
    util.inherits(Writable, Stream);
    function nop() {
    }
    function WritableState(options, stream) {
      Duplex = Duplex || require_stream_duplex12();
      options = options || {};
      var isDuplex = stream instanceof Duplex;
      this.objectMode = !!options.objectMode;
      if (isDuplex)
        this.objectMode = this.objectMode || !!options.writableObjectMode;
      var hwm = options.highWaterMark;
      var writableHwm = options.writableHighWaterMark;
      var defaultHwm = this.objectMode ? 16 : 16 * 1024;
      if (hwm || hwm === 0)
        this.highWaterMark = hwm;
      else if (isDuplex && (writableHwm || writableHwm === 0))
        this.highWaterMark = writableHwm;
      else
        this.highWaterMark = defaultHwm;
      this.highWaterMark = Math.floor(this.highWaterMark);
      this.finalCalled = false;
      this.needDrain = false;
      this.ending = false;
      this.ended = false;
      this.finished = false;
      this.destroyed = false;
      var noDecode = options.decodeStrings === false;
      this.decodeStrings = !noDecode;
      this.defaultEncoding = options.defaultEncoding || "utf8";
      this.length = 0;
      this.writing = false;
      this.corked = 0;
      this.sync = true;
      this.bufferProcessing = false;
      this.onwrite = function(er) {
        onwrite(stream, er);
      };
      this.writecb = null;
      this.writelen = 0;
      this.bufferedRequest = null;
      this.lastBufferedRequest = null;
      this.pendingcb = 0;
      this.prefinished = false;
      this.errorEmitted = false;
      this.bufferedRequestCount = 0;
      this.corkedRequestsFree = new CorkedRequest(this);
    }
    WritableState.prototype.getBuffer = function getBuffer() {
      var current = this.bufferedRequest;
      var out = [];
      while (current) {
        out.push(current);
        current = current.next;
      }
      return out;
    };
    (function() {
      try {
        Object.defineProperty(WritableState.prototype, "buffer", {
          get: internalUtil.deprecate(function() {
            return this.getBuffer();
          }, "_writableState.buffer is deprecated. Use _writableState.getBuffer instead.", "DEP0003")
        });
      } catch (_2) {
      }
    })();
    var realHasInstance;
    if (typeof Symbol === "function" && Symbol.hasInstance && typeof Function.prototype[Symbol.hasInstance] === "function") {
      realHasInstance = Function.prototype[Symbol.hasInstance];
      Object.defineProperty(Writable, Symbol.hasInstance, {
        value: function(object) {
          if (realHasInstance.call(this, object))
            return true;
          if (this !== Writable)
            return false;
          return object && object._writableState instanceof WritableState;
        }
      });
    } else {
      realHasInstance = function(object) {
        return object instanceof this;
      };
    }
    function Writable(options) {
      Duplex = Duplex || require_stream_duplex12();
      if (!realHasInstance.call(Writable, this) && !(this instanceof Duplex)) {
        return new Writable(options);
      }
      this._writableState = new WritableState(options, this);
      this.writable = true;
      if (options) {
        if (typeof options.write === "function")
          this._write = options.write;
        if (typeof options.writev === "function")
          this._writev = options.writev;
        if (typeof options.destroy === "function")
          this._destroy = options.destroy;
        if (typeof options.final === "function")
          this._final = options.final;
      }
      Stream.call(this);
    }
    Writable.prototype.pipe = function() {
      this.emit("error", new Error("Cannot pipe, not readable"));
    };
    function writeAfterEnd(stream, cb) {
      var er = new Error("write after end");
      stream.emit("error", er);
      pna.nextTick(cb, er);
    }
    function validChunk(stream, state, chunk, cb) {
      var valid = true;
      var er = false;
      if (chunk === null) {
        er = new TypeError("May not write null values to stream");
      } else if (typeof chunk !== "string" && chunk !== void 0 && !state.objectMode) {
        er = new TypeError("Invalid non-string/buffer chunk");
      }
      if (er) {
        stream.emit("error", er);
        pna.nextTick(cb, er);
        valid = false;
      }
      return valid;
    }
    Writable.prototype.write = function(chunk, encoding, cb) {
      var state = this._writableState;
      var ret2 = false;
      var isBuf = !state.objectMode && _isUint8Array(chunk);
      if (isBuf && !Buffer2.isBuffer(chunk)) {
        chunk = _uint8ArrayToBuffer(chunk);
      }
      if (typeof encoding === "function") {
        cb = encoding;
        encoding = null;
      }
      if (isBuf)
        encoding = "buffer";
      else if (!encoding)
        encoding = state.defaultEncoding;
      if (typeof cb !== "function")
        cb = nop;
      if (state.ended)
        writeAfterEnd(this, cb);
      else if (isBuf || validChunk(this, state, chunk, cb)) {
        state.pendingcb++;
        ret2 = writeOrBuffer(this, state, isBuf, chunk, encoding, cb);
      }
      return ret2;
    };
    Writable.prototype.cork = function() {
      var state = this._writableState;
      state.corked++;
    };
    Writable.prototype.uncork = function() {
      var state = this._writableState;
      if (state.corked) {
        state.corked--;
        if (!state.writing && !state.corked && !state.bufferProcessing && state.bufferedRequest)
          clearBuffer(this, state);
      }
    };
    Writable.prototype.setDefaultEncoding = function setDefaultEncoding(encoding) {
      if (typeof encoding === "string")
        encoding = encoding.toLowerCase();
      if (!(["hex", "utf8", "utf-8", "ascii", "binary", "base64", "ucs2", "ucs-2", "utf16le", "utf-16le", "raw"].indexOf((encoding + "").toLowerCase()) > -1))
        throw new TypeError("Unknown encoding: " + encoding);
      this._writableState.defaultEncoding = encoding;
      return this;
    };
    function decodeChunk(state, chunk, encoding) {
      if (!state.objectMode && state.decodeStrings !== false && typeof chunk === "string") {
        chunk = Buffer2.from(chunk, encoding);
      }
      return chunk;
    }
    Object.defineProperty(Writable.prototype, "writableHighWaterMark", {
      // making it explicit this property is not enumerable
      // because otherwise some prototype manipulation in
      // userland will fail
      enumerable: false,
      get: function() {
        return this._writableState.highWaterMark;
      }
    });
    function writeOrBuffer(stream, state, isBuf, chunk, encoding, cb) {
      if (!isBuf) {
        var newChunk = decodeChunk(state, chunk, encoding);
        if (chunk !== newChunk) {
          isBuf = true;
          encoding = "buffer";
          chunk = newChunk;
        }
      }
      var len = state.objectMode ? 1 : chunk.length;
      state.length += len;
      var ret2 = state.length < state.highWaterMark;
      if (!ret2)
        state.needDrain = true;
      if (state.writing || state.corked) {
        var last = state.lastBufferedRequest;
        state.lastBufferedRequest = {
          chunk,
          encoding,
          isBuf,
          callback: cb,
          next: null
        };
        if (last) {
          last.next = state.lastBufferedRequest;
        } else {
          state.bufferedRequest = state.lastBufferedRequest;
        }
        state.bufferedRequestCount += 1;
      } else {
        doWrite(stream, state, false, len, chunk, encoding, cb);
      }
      return ret2;
    }
    function doWrite(stream, state, writev, len, chunk, encoding, cb) {
      state.writelen = len;
      state.writecb = cb;
      state.writing = true;
      state.sync = true;
      if (writev)
        stream._writev(chunk, state.onwrite);
      else
        stream._write(chunk, encoding, state.onwrite);
      state.sync = false;
    }
    function onwriteError(stream, state, sync, er, cb) {
      --state.pendingcb;
      if (sync) {
        pna.nextTick(cb, er);
        pna.nextTick(finishMaybe, stream, state);
        stream._writableState.errorEmitted = true;
        stream.emit("error", er);
      } else {
        cb(er);
        stream._writableState.errorEmitted = true;
        stream.emit("error", er);
        finishMaybe(stream, state);
      }
    }
    function onwriteStateUpdate(state) {
      state.writing = false;
      state.writecb = null;
      state.length -= state.writelen;
      state.writelen = 0;
    }
    function onwrite(stream, er) {
      var state = stream._writableState;
      var sync = state.sync;
      var cb = state.writecb;
      onwriteStateUpdate(state);
      if (er)
        onwriteError(stream, state, sync, er, cb);
      else {
        var finished = needFinish(state);
        if (!finished && !state.corked && !state.bufferProcessing && state.bufferedRequest) {
          clearBuffer(stream, state);
        }
        if (sync) {
          asyncWrite(afterWrite, stream, state, finished, cb);
        } else {
          afterWrite(stream, state, finished, cb);
        }
      }
    }
    function afterWrite(stream, state, finished, cb) {
      if (!finished)
        onwriteDrain(stream, state);
      state.pendingcb--;
      cb();
      finishMaybe(stream, state);
    }
    function onwriteDrain(stream, state) {
      if (state.length === 0 && state.needDrain) {
        state.needDrain = false;
        stream.emit("drain");
      }
    }
    function clearBuffer(stream, state) {
      state.bufferProcessing = true;
      var entry = state.bufferedRequest;
      if (stream._writev && entry && entry.next) {
        var l2 = state.bufferedRequestCount;
        var buffer = new Array(l2);
        var holder = state.corkedRequestsFree;
        holder.entry = entry;
        var count = 0;
        var allBuffers = true;
        while (entry) {
          buffer[count] = entry;
          if (!entry.isBuf)
            allBuffers = false;
          entry = entry.next;
          count += 1;
        }
        buffer.allBuffers = allBuffers;
        doWrite(stream, state, true, state.length, buffer, "", holder.finish);
        state.pendingcb++;
        state.lastBufferedRequest = null;
        if (holder.next) {
          state.corkedRequestsFree = holder.next;
          holder.next = null;
        } else {
          state.corkedRequestsFree = new CorkedRequest(state);
        }
        state.bufferedRequestCount = 0;
      } else {
        while (entry) {
          var chunk = entry.chunk;
          var encoding = entry.encoding;
          var cb = entry.callback;
          var len = state.objectMode ? 1 : chunk.length;
          doWrite(stream, state, false, len, chunk, encoding, cb);
          entry = entry.next;
          state.bufferedRequestCount--;
          if (state.writing) {
            break;
          }
        }
        if (entry === null)
          state.lastBufferedRequest = null;
      }
      state.bufferedRequest = entry;
      state.bufferProcessing = false;
    }
    Writable.prototype._write = function(chunk, encoding, cb) {
      cb(new Error("_write() is not implemented"));
    };
    Writable.prototype._writev = null;
    Writable.prototype.end = function(chunk, encoding, cb) {
      var state = this._writableState;
      if (typeof chunk === "function") {
        cb = chunk;
        chunk = null;
        encoding = null;
      } else if (typeof encoding === "function") {
        cb = encoding;
        encoding = null;
      }
      if (chunk !== null && chunk !== void 0)
        this.write(chunk, encoding);
      if (state.corked) {
        state.corked = 1;
        this.uncork();
      }
      if (!state.ending)
        endWritable(this, state, cb);
    };
    function needFinish(state) {
      return state.ending && state.length === 0 && state.bufferedRequest === null && !state.finished && !state.writing;
    }
    function callFinal(stream, state) {
      stream._final(function(err) {
        state.pendingcb--;
        if (err) {
          stream.emit("error", err);
        }
        state.prefinished = true;
        stream.emit("prefinish");
        finishMaybe(stream, state);
      });
    }
    function prefinish(stream, state) {
      if (!state.prefinished && !state.finalCalled) {
        if (typeof stream._final === "function") {
          state.pendingcb++;
          state.finalCalled = true;
          pna.nextTick(callFinal, stream, state);
        } else {
          state.prefinished = true;
          stream.emit("prefinish");
        }
      }
    }
    function finishMaybe(stream, state) {
      var need = needFinish(state);
      if (need) {
        prefinish(stream, state);
        if (state.pendingcb === 0) {
          state.finished = true;
          stream.emit("finish");
        }
      }
      return need;
    }
    function endWritable(stream, state, cb) {
      state.ending = true;
      finishMaybe(stream, state);
      if (cb) {
        if (state.finished)
          pna.nextTick(cb);
        else
          stream.once("finish", cb);
      }
      state.ended = true;
      stream.writable = false;
    }
    function onCorkedFinish(corkReq, state, err) {
      var entry = corkReq.entry;
      corkReq.entry = null;
      while (entry) {
        var cb = entry.callback;
        state.pendingcb--;
        cb(err);
        entry = entry.next;
      }
      state.corkedRequestsFree.next = corkReq;
    }
    Object.defineProperty(Writable.prototype, "destroyed", {
      get: function() {
        if (this._writableState === void 0) {
          return false;
        }
        return this._writableState.destroyed;
      },
      set: function(value) {
        if (!this._writableState) {
          return;
        }
        this._writableState.destroyed = value;
      }
    });
    Writable.prototype.destroy = destroyImpl.destroy;
    Writable.prototype._undestroy = destroyImpl.undestroy;
    Writable.prototype._destroy = function(err, cb) {
      this.end();
      cb(err);
    };
  }
});

// ../../../node_modules/duplexer2/node_modules/readable-stream/lib/_stream_duplex.js
var require_stream_duplex12 = __commonJS({
  "../../../node_modules/duplexer2/node_modules/readable-stream/lib/_stream_duplex.js"(exports2, module2) {
    "use strict";
    var pna = require_process_nextick_args();
    var objectKeys = Object.keys || function(obj2) {
      var keys2 = [];
      for (var key in obj2) {
        keys2.push(key);
      }
      return keys2;
    };
    module2.exports = Duplex;
    var util = Object.create(require_util());
    util.inherits = require_inherits();
    var Readable = require_stream_readable12();
    var Writable = require_stream_writable12();
    util.inherits(Duplex, Readable);
    {
      keys = objectKeys(Writable.prototype);
      for (v = 0; v < keys.length; v++) {
        method = keys[v];
        if (!Duplex.prototype[method])
          Duplex.prototype[method] = Writable.prototype[method];
      }
    }
    var keys;
    var method;
    var v;
    function Duplex(options) {
      if (!(this instanceof Duplex))
        return new Duplex(options);
      Readable.call(this, options);
      Writable.call(this, options);
      if (options && options.readable === false)
        this.readable = false;
      if (options && options.writable === false)
        this.writable = false;
      this.allowHalfOpen = true;
      if (options && options.allowHalfOpen === false)
        this.allowHalfOpen = false;
      this.once("end", onend);
    }
    Object.defineProperty(Duplex.prototype, "writableHighWaterMark", {
      // making it explicit this property is not enumerable
      // because otherwise some prototype manipulation in
      // userland will fail
      enumerable: false,
      get: function() {
        return this._writableState.highWaterMark;
      }
    });
    function onend() {
      if (this.allowHalfOpen || this._writableState.ended)
        return;
      pna.nextTick(onEndNT, this);
    }
    function onEndNT(self2) {
      self2.end();
    }
    Object.defineProperty(Duplex.prototype, "destroyed", {
      get: function() {
        if (this._readableState === void 0 || this._writableState === void 0) {
          return false;
        }
        return this._readableState.destroyed && this._writableState.destroyed;
      },
      set: function(value) {
        if (this._readableState === void 0 || this._writableState === void 0) {
          return;
        }
        this._readableState.destroyed = value;
        this._writableState.destroyed = value;
      }
    });
    Duplex.prototype._destroy = function(err, cb) {
      this.push(null);
      this.end();
      pna.nextTick(cb, err);
    };
  }
});

// ../../../node_modules/duplexer2/node_modules/string_decoder/lib/string_decoder.js
var require_string_decoder12 = __commonJS({
  "../../../node_modules/duplexer2/node_modules/string_decoder/lib/string_decoder.js"(exports2) {
    "use strict";
    var Buffer2 = require_safe_buffer6().Buffer;
    var isEncoding = Buffer2.isEncoding || function(encoding) {
      encoding = "" + encoding;
      switch (encoding && encoding.toLowerCase()) {
        case "hex":
        case "utf8":
        case "utf-8":
        case "ascii":
        case "binary":
        case "base64":
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
        case "raw":
          return true;
        default:
          return false;
      }
    };
    function _normalizeEncoding(enc) {
      if (!enc)
        return "utf8";
      var retried;
      while (true) {
        switch (enc) {
          case "utf8":
          case "utf-8":
            return "utf8";
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
            return "utf16le";
          case "latin1":
          case "binary":
            return "latin1";
          case "base64":
          case "ascii":
          case "hex":
            return enc;
          default:
            if (retried)
              return;
            enc = ("" + enc).toLowerCase();
            retried = true;
        }
      }
    }
    function normalizeEncoding(enc) {
      var nenc = _normalizeEncoding(enc);
      if (typeof nenc !== "string" && (Buffer2.isEncoding === isEncoding || !isEncoding(enc)))
        throw new Error("Unknown encoding: " + enc);
      return nenc || enc;
    }
    exports2.StringDecoder = StringDecoder;
    function StringDecoder(encoding) {
      this.encoding = normalizeEncoding(encoding);
      var nb;
      switch (this.encoding) {
        case "utf16le":
          this.text = utf16Text;
          this.end = utf16End;
          nb = 4;
          break;
        case "utf8":
          this.fillLast = utf8FillLast;
          nb = 4;
          break;
        case "base64":
          this.text = base64Text;
          this.end = base64End;
          nb = 3;
          break;
        default:
          this.write = simpleWrite;
          this.end = simpleEnd;
          return;
      }
      this.lastNeed = 0;
      this.lastTotal = 0;
      this.lastChar = Buffer2.allocUnsafe(nb);
    }
    StringDecoder.prototype.write = function(buf) {
      if (buf.length === 0)
        return "";
      var r;
      var i;
      if (this.lastNeed) {
        r = this.fillLast(buf);
        if (r === void 0)
          return "";
        i = this.lastNeed;
        this.lastNeed = 0;
      } else {
        i = 0;
      }
      if (i < buf.length)
        return r ? r + this.text(buf, i) : this.text(buf, i);
      return r || "";
    };
    StringDecoder.prototype.end = utf8End;
    StringDecoder.prototype.text = utf8Text;
    StringDecoder.prototype.fillLast = function(buf) {
      if (this.lastNeed <= buf.length) {
        buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, this.lastNeed);
        return this.lastChar.toString(this.encoding, 0, this.lastTotal);
      }
      buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, buf.length);
      this.lastNeed -= buf.length;
    };
    function utf8CheckByte(byte) {
      if (byte <= 127)
        return 0;
      else if (byte >> 5 === 6)
        return 2;
      else if (byte >> 4 === 14)
        return 3;
      else if (byte >> 3 === 30)
        return 4;
      return byte >> 6 === 2 ? -1 : -2;
    }
    function utf8CheckIncomplete(self2, buf, i) {
      var j = buf.length - 1;
      if (j < i)
        return 0;
      var nb = utf8CheckByte(buf[j]);
      if (nb >= 0) {
        if (nb > 0)
          self2.lastNeed = nb - 1;
        return nb;
      }
      if (--j < i || nb === -2)
        return 0;
      nb = utf8CheckByte(buf[j]);
      if (nb >= 0) {
        if (nb > 0)
          self2.lastNeed = nb - 2;
        return nb;
      }
      if (--j < i || nb === -2)
        return 0;
      nb = utf8CheckByte(buf[j]);
      if (nb >= 0) {
        if (nb > 0) {
          if (nb === 2)
            nb = 0;
          else
            self2.lastNeed = nb - 3;
        }
        return nb;
      }
      return 0;
    }
    function utf8CheckExtraBytes(self2, buf, p) {
      if ((buf[0] & 192) !== 128) {
        self2.lastNeed = 0;
        return "\uFFFD";
      }
      if (self2.lastNeed > 1 && buf.length > 1) {
        if ((buf[1] & 192) !== 128) {
          self2.lastNeed = 1;
          return "\uFFFD";
        }
        if (self2.lastNeed > 2 && buf.length > 2) {
          if ((buf[2] & 192) !== 128) {
            self2.lastNeed = 2;
            return "\uFFFD";
          }
        }
      }
    }
    function utf8FillLast(buf) {
      var p = this.lastTotal - this.lastNeed;
      var r = utf8CheckExtraBytes(this, buf, p);
      if (r !== void 0)
        return r;
      if (this.lastNeed <= buf.length) {
        buf.copy(this.lastChar, p, 0, this.lastNeed);
        return this.lastChar.toString(this.encoding, 0, this.lastTotal);
      }
      buf.copy(this.lastChar, p, 0, buf.length);
      this.lastNeed -= buf.length;
    }
    function utf8Text(buf, i) {
      var total = utf8CheckIncomplete(this, buf, i);
      if (!this.lastNeed)
        return buf.toString("utf8", i);
      this.lastTotal = total;
      var end = buf.length - (total - this.lastNeed);
      buf.copy(this.lastChar, 0, end);
      return buf.toString("utf8", i, end);
    }
    function utf8End(buf) {
      var r = buf && buf.length ? this.write(buf) : "";
      if (this.lastNeed)
        return r + "\uFFFD";
      return r;
    }
    function utf16Text(buf, i) {
      if ((buf.length - i) % 2 === 0) {
        var r = buf.toString("utf16le", i);
        if (r) {
          var c = r.charCodeAt(r.length - 1);
          if (c >= 55296 && c <= 56319) {
            this.lastNeed = 2;
            this.lastTotal = 4;
            this.lastChar[0] = buf[buf.length - 2];
            this.lastChar[1] = buf[buf.length - 1];
            return r.slice(0, -1);
          }
        }
        return r;
      }
      this.lastNeed = 1;
      this.lastTotal = 2;
      this.lastChar[0] = buf[buf.length - 1];
      return buf.toString("utf16le", i, buf.length - 1);
    }
    function utf16End(buf) {
      var r = buf && buf.length ? this.write(buf) : "";
      if (this.lastNeed) {
        var end = this.lastTotal - this.lastNeed;
        return r + this.lastChar.toString("utf16le", 0, end);
      }
      return r;
    }
    function base64Text(buf, i) {
      var n = (buf.length - i) % 3;
      if (n === 0)
        return buf.toString("base64", i);
      this.lastNeed = 3 - n;
      this.lastTotal = 3;
      if (n === 1) {
        this.lastChar[0] = buf[buf.length - 1];
      } else {
        this.lastChar[0] = buf[buf.length - 2];
        this.lastChar[1] = buf[buf.length - 1];
      }
      return buf.toString("base64", i, buf.length - n);
    }
    function base64End(buf) {
      var r = buf && buf.length ? this.write(buf) : "";
      if (this.lastNeed)
        return r + this.lastChar.toString("base64", 0, 3 - this.lastNeed);
      return r;
    }
    function simpleWrite(buf) {
      return buf.toString(this.encoding);
    }
    function simpleEnd(buf) {
      return buf && buf.length ? this.write(buf) : "";
    }
  }
});

// ../../../node_modules/duplexer2/node_modules/readable-stream/lib/_stream_readable.js
var require_stream_readable12 = __commonJS({
  "../../../node_modules/duplexer2/node_modules/readable-stream/lib/_stream_readable.js"(exports2, module2) {
    "use strict";
    var pna = require_process_nextick_args();
    module2.exports = Readable;
    var isArray = require_isarray5();
    var Duplex;
    Readable.ReadableState = ReadableState;
    var EE = require("events").EventEmitter;
    var EElistenerCount = function(emitter, type) {
      return emitter.listeners(type).length;
    };
    var Stream = require_stream12();
    var Buffer2 = require_safe_buffer6().Buffer;
    var OurUint8Array = (typeof global !== "undefined" ? global : typeof window !== "undefined" ? window : typeof self !== "undefined" ? self : {}).Uint8Array || function() {
    };
    function _uint8ArrayToBuffer(chunk) {
      return Buffer2.from(chunk);
    }
    function _isUint8Array(obj2) {
      return Buffer2.isBuffer(obj2) || obj2 instanceof OurUint8Array;
    }
    var util = Object.create(require_util());
    util.inherits = require_inherits();
    var debugUtil = require("util");
    var debug = void 0;
    if (debugUtil && debugUtil.debuglog) {
      debug = debugUtil.debuglog("stream");
    } else {
      debug = function() {
      };
    }
    var BufferList = require_BufferList6();
    var destroyImpl = require_destroy12();
    var StringDecoder;
    util.inherits(Readable, Stream);
    var kProxyEvents = ["error", "close", "destroy", "pause", "resume"];
    function prependListener(emitter, event, fn) {
      if (typeof emitter.prependListener === "function")
        return emitter.prependListener(event, fn);
      if (!emitter._events || !emitter._events[event])
        emitter.on(event, fn);
      else if (isArray(emitter._events[event]))
        emitter._events[event].unshift(fn);
      else
        emitter._events[event] = [fn, emitter._events[event]];
    }
    function ReadableState(options, stream) {
      Duplex = Duplex || require_stream_duplex12();
      options = options || {};
      var isDuplex = stream instanceof Duplex;
      this.objectMode = !!options.objectMode;
      if (isDuplex)
        this.objectMode = this.objectMode || !!options.readableObjectMode;
      var hwm = options.highWaterMark;
      var readableHwm = options.readableHighWaterMark;
      var defaultHwm = this.objectMode ? 16 : 16 * 1024;
      if (hwm || hwm === 0)
        this.highWaterMark = hwm;
      else if (isDuplex && (readableHwm || readableHwm === 0))
        this.highWaterMark = readableHwm;
      else
        this.highWaterMark = defaultHwm;
      this.highWaterMark = Math.floor(this.highWaterMark);
      this.buffer = new BufferList();
      this.length = 0;
      this.pipes = null;
      this.pipesCount = 0;
      this.flowing = null;
      this.ended = false;
      this.endEmitted = false;
      this.reading = false;
      this.sync = true;
      this.needReadable = false;
      this.emittedReadable = false;
      this.readableListening = false;
      this.resumeScheduled = false;
      this.destroyed = false;
      this.defaultEncoding = options.defaultEncoding || "utf8";
      this.awaitDrain = 0;
      this.readingMore = false;
      this.decoder = null;
      this.encoding = null;
      if (options.encoding) {
        if (!StringDecoder)
          StringDecoder = require_string_decoder12().StringDecoder;
        this.decoder = new StringDecoder(options.encoding);
        this.encoding = options.encoding;
      }
    }
    function Readable(options) {
      Duplex = Duplex || require_stream_duplex12();
      if (!(this instanceof Readable))
        return new Readable(options);
      this._readableState = new ReadableState(options, this);
      this.readable = true;
      if (options) {
        if (typeof options.read === "function")
          this._read = options.read;
        if (typeof options.destroy === "function")
          this._destroy = options.destroy;
      }
      Stream.call(this);
    }
    Object.defineProperty(Readable.prototype, "destroyed", {
      get: function() {
        if (this._readableState === void 0) {
          return false;
        }
        return this._readableState.destroyed;
      },
      set: function(value) {
        if (!this._readableState) {
          return;
        }
        this._readableState.destroyed = value;
      }
    });
    Readable.prototype.destroy = destroyImpl.destroy;
    Readable.prototype._undestroy = destroyImpl.undestroy;
    Readable.prototype._destroy = function(err, cb) {
      this.push(null);
      cb(err);
    };
    Readable.prototype.push = function(chunk, encoding) {
      var state = this._readableState;
      var skipChunkCheck;
      if (!state.objectMode) {
        if (typeof chunk === "string") {
          encoding = encoding || state.defaultEncoding;
          if (encoding !== state.encoding) {
            chunk = Buffer2.from(chunk, encoding);
            encoding = "";
          }
          skipChunkCheck = true;
        }
      } else {
        skipChunkCheck = true;
      }
      return readableAddChunk(this, chunk, encoding, false, skipChunkCheck);
    };
    Readable.prototype.unshift = function(chunk) {
      return readableAddChunk(this, chunk, null, true, false);
    };
    function readableAddChunk(stream, chunk, encoding, addToFront, skipChunkCheck) {
      var state = stream._readableState;
      if (chunk === null) {
        state.reading = false;
        onEofChunk(stream, state);
      } else {
        var er;
        if (!skipChunkCheck)
          er = chunkInvalid(state, chunk);
        if (er) {
          stream.emit("error", er);
        } else if (state.objectMode || chunk && chunk.length > 0) {
          if (typeof chunk !== "string" && !state.objectMode && Object.getPrototypeOf(chunk) !== Buffer2.prototype) {
            chunk = _uint8ArrayToBuffer(chunk);
          }
          if (addToFront) {
            if (state.endEmitted)
              stream.emit("error", new Error("stream.unshift() after end event"));
            else
              addChunk(stream, state, chunk, true);
          } else if (state.ended) {
            stream.emit("error", new Error("stream.push() after EOF"));
          } else {
            state.reading = false;
            if (state.decoder && !encoding) {
              chunk = state.decoder.write(chunk);
              if (state.objectMode || chunk.length !== 0)
                addChunk(stream, state, chunk, false);
              else
                maybeReadMore(stream, state);
            } else {
              addChunk(stream, state, chunk, false);
            }
          }
        } else if (!addToFront) {
          state.reading = false;
        }
      }
      return needMoreData(state);
    }
    function addChunk(stream, state, chunk, addToFront) {
      if (state.flowing && state.length === 0 && !state.sync) {
        stream.emit("data", chunk);
        stream.read(0);
      } else {
        state.length += state.objectMode ? 1 : chunk.length;
        if (addToFront)
          state.buffer.unshift(chunk);
        else
          state.buffer.push(chunk);
        if (state.needReadable)
          emitReadable(stream);
      }
      maybeReadMore(stream, state);
    }
    function chunkInvalid(state, chunk) {
      var er;
      if (!_isUint8Array(chunk) && typeof chunk !== "string" && chunk !== void 0 && !state.objectMode) {
        er = new TypeError("Invalid non-string/buffer chunk");
      }
      return er;
    }
    function needMoreData(state) {
      return !state.ended && (state.needReadable || state.length < state.highWaterMark || state.length === 0);
    }
    Readable.prototype.isPaused = function() {
      return this._readableState.flowing === false;
    };
    Readable.prototype.setEncoding = function(enc) {
      if (!StringDecoder)
        StringDecoder = require_string_decoder12().StringDecoder;
      this._readableState.decoder = new StringDecoder(enc);
      this._readableState.encoding = enc;
      return this;
    };
    var MAX_HWM = 8388608;
    function computeNewHighWaterMark(n) {
      if (n >= MAX_HWM) {
        n = MAX_HWM;
      } else {
        n--;
        n |= n >>> 1;
        n |= n >>> 2;
        n |= n >>> 4;
        n |= n >>> 8;
        n |= n >>> 16;
        n++;
      }
      return n;
    }
    function howMuchToRead(n, state) {
      if (n <= 0 || state.length === 0 && state.ended)
        return 0;
      if (state.objectMode)
        return 1;
      if (n !== n) {
        if (state.flowing && state.length)
          return state.buffer.head.data.length;
        else
          return state.length;
      }
      if (n > state.highWaterMark)
        state.highWaterMark = computeNewHighWaterMark(n);
      if (n <= state.length)
        return n;
      if (!state.ended) {
        state.needReadable = true;
        return 0;
      }
      return state.length;
    }
    Readable.prototype.read = function(n) {
      debug("read", n);
      n = parseInt(n, 10);
      var state = this._readableState;
      var nOrig = n;
      if (n !== 0)
        state.emittedReadable = false;
      if (n === 0 && state.needReadable && (state.length >= state.highWaterMark || state.ended)) {
        debug("read: emitReadable", state.length, state.ended);
        if (state.length === 0 && state.ended)
          endReadable(this);
        else
          emitReadable(this);
        return null;
      }
      n = howMuchToRead(n, state);
      if (n === 0 && state.ended) {
        if (state.length === 0)
          endReadable(this);
        return null;
      }
      var doRead = state.needReadable;
      debug("need readable", doRead);
      if (state.length === 0 || state.length - n < state.highWaterMark) {
        doRead = true;
        debug("length less than watermark", doRead);
      }
      if (state.ended || state.reading) {
        doRead = false;
        debug("reading or ended", doRead);
      } else if (doRead) {
        debug("do read");
        state.reading = true;
        state.sync = true;
        if (state.length === 0)
          state.needReadable = true;
        this._read(state.highWaterMark);
        state.sync = false;
        if (!state.reading)
          n = howMuchToRead(nOrig, state);
      }
      var ret2;
      if (n > 0)
        ret2 = fromList(n, state);
      else
        ret2 = null;
      if (ret2 === null) {
        state.needReadable = true;
        n = 0;
      } else {
        state.length -= n;
      }
      if (state.length === 0) {
        if (!state.ended)
          state.needReadable = true;
        if (nOrig !== n && state.ended)
          endReadable(this);
      }
      if (ret2 !== null)
        this.emit("data", ret2);
      return ret2;
    };
    function onEofChunk(stream, state) {
      if (state.ended)
        return;
      if (state.decoder) {
        var chunk = state.decoder.end();
        if (chunk && chunk.length) {
          state.buffer.push(chunk);
          state.length += state.objectMode ? 1 : chunk.length;
        }
      }
      state.ended = true;
      emitReadable(stream);
    }
    function emitReadable(stream) {
      var state = stream._readableState;
      state.needReadable = false;
      if (!state.emittedReadable) {
        debug("emitReadable", state.flowing);
        state.emittedReadable = true;
        if (state.sync)
          pna.nextTick(emitReadable_, stream);
        else
          emitReadable_(stream);
      }
    }
    function emitReadable_(stream) {
      debug("emit readable");
      stream.emit("readable");
      flow(stream);
    }
    function maybeReadMore(stream, state) {
      if (!state.readingMore) {
        state.readingMore = true;
        pna.nextTick(maybeReadMore_, stream, state);
      }
    }
    function maybeReadMore_(stream, state) {
      var len = state.length;
      while (!state.reading && !state.flowing && !state.ended && state.length < state.highWaterMark) {
        debug("maybeReadMore read 0");
        stream.read(0);
        if (len === state.length)
          break;
        else
          len = state.length;
      }
      state.readingMore = false;
    }
    Readable.prototype._read = function(n) {
      this.emit("error", new Error("_read() is not implemented"));
    };
    Readable.prototype.pipe = function(dest, pipeOpts) {
      var src = this;
      var state = this._readableState;
      switch (state.pipesCount) {
        case 0:
          state.pipes = dest;
          break;
        case 1:
          state.pipes = [state.pipes, dest];
          break;
        default:
          state.pipes.push(dest);
          break;
      }
      state.pipesCount += 1;
      debug("pipe count=%d opts=%j", state.pipesCount, pipeOpts);
      var doEnd = (!pipeOpts || pipeOpts.end !== false) && dest !== process.stdout && dest !== process.stderr;
      var endFn = doEnd ? onend : unpipe;
      if (state.endEmitted)
        pna.nextTick(endFn);
      else
        src.once("end", endFn);
      dest.on("unpipe", onunpipe);
      function onunpipe(readable, unpipeInfo) {
        debug("onunpipe");
        if (readable === src) {
          if (unpipeInfo && unpipeInfo.hasUnpiped === false) {
            unpipeInfo.hasUnpiped = true;
            cleanup();
          }
        }
      }
      function onend() {
        debug("onend");
        dest.end();
      }
      var ondrain = pipeOnDrain(src);
      dest.on("drain", ondrain);
      var cleanedUp = false;
      function cleanup() {
        debug("cleanup");
        dest.removeListener("close", onclose);
        dest.removeListener("finish", onfinish);
        dest.removeListener("drain", ondrain);
        dest.removeListener("error", onerror);
        dest.removeListener("unpipe", onunpipe);
        src.removeListener("end", onend);
        src.removeListener("end", unpipe);
        src.removeListener("data", ondata);
        cleanedUp = true;
        if (state.awaitDrain && (!dest._writableState || dest._writableState.needDrain))
          ondrain();
      }
      var increasedAwaitDrain = false;
      src.on("data", ondata);
      function ondata(chunk) {
        debug("ondata");
        increasedAwaitDrain = false;
        var ret2 = dest.write(chunk);
        if (false === ret2 && !increasedAwaitDrain) {
          if ((state.pipesCount === 1 && state.pipes === dest || state.pipesCount > 1 && indexOf(state.pipes, dest) !== -1) && !cleanedUp) {
            debug("false write response, pause", state.awaitDrain);
            state.awaitDrain++;
            increasedAwaitDrain = true;
          }
          src.pause();
        }
      }
      function onerror(er) {
        debug("onerror", er);
        unpipe();
        dest.removeListener("error", onerror);
        if (EElistenerCount(dest, "error") === 0)
          dest.emit("error", er);
      }
      prependListener(dest, "error", onerror);
      function onclose() {
        dest.removeListener("finish", onfinish);
        unpipe();
      }
      dest.once("close", onclose);
      function onfinish() {
        debug("onfinish");
        dest.removeListener("close", onclose);
        unpipe();
      }
      dest.once("finish", onfinish);
      function unpipe() {
        debug("unpipe");
        src.unpipe(dest);
      }
      dest.emit("pipe", src);
      if (!state.flowing) {
        debug("pipe resume");
        src.resume();
      }
      return dest;
    };
    function pipeOnDrain(src) {
      return function() {
        var state = src._readableState;
        debug("pipeOnDrain", state.awaitDrain);
        if (state.awaitDrain)
          state.awaitDrain--;
        if (state.awaitDrain === 0 && EElistenerCount(src, "data")) {
          state.flowing = true;
          flow(src);
        }
      };
    }
    Readable.prototype.unpipe = function(dest) {
      var state = this._readableState;
      var unpipeInfo = { hasUnpiped: false };
      if (state.pipesCount === 0)
        return this;
      if (state.pipesCount === 1) {
        if (dest && dest !== state.pipes)
          return this;
        if (!dest)
          dest = state.pipes;
        state.pipes = null;
        state.pipesCount = 0;
        state.flowing = false;
        if (dest)
          dest.emit("unpipe", this, unpipeInfo);
        return this;
      }
      if (!dest) {
        var dests = state.pipes;
        var len = state.pipesCount;
        state.pipes = null;
        state.pipesCount = 0;
        state.flowing = false;
        for (var i = 0; i < len; i++) {
          dests[i].emit("unpipe", this, { hasUnpiped: false });
        }
        return this;
      }
      var index = indexOf(state.pipes, dest);
      if (index === -1)
        return this;
      state.pipes.splice(index, 1);
      state.pipesCount -= 1;
      if (state.pipesCount === 1)
        state.pipes = state.pipes[0];
      dest.emit("unpipe", this, unpipeInfo);
      return this;
    };
    Readable.prototype.on = function(ev, fn) {
      var res = Stream.prototype.on.call(this, ev, fn);
      if (ev === "data") {
        if (this._readableState.flowing !== false)
          this.resume();
      } else if (ev === "readable") {
        var state = this._readableState;
        if (!state.endEmitted && !state.readableListening) {
          state.readableListening = state.needReadable = true;
          state.emittedReadable = false;
          if (!state.reading) {
            pna.nextTick(nReadingNextTick, this);
          } else if (state.length) {
            emitReadable(this);
          }
        }
      }
      return res;
    };
    Readable.prototype.addListener = Readable.prototype.on;
    function nReadingNextTick(self2) {
      debug("readable nexttick read 0");
      self2.read(0);
    }
    Readable.prototype.resume = function() {
      var state = this._readableState;
      if (!state.flowing) {
        debug("resume");
        state.flowing = true;
        resume(this, state);
      }
      return this;
    };
    function resume(stream, state) {
      if (!state.resumeScheduled) {
        state.resumeScheduled = true;
        pna.nextTick(resume_, stream, state);
      }
    }
    function resume_(stream, state) {
      if (!state.reading) {
        debug("resume read 0");
        stream.read(0);
      }
      state.resumeScheduled = false;
      state.awaitDrain = 0;
      stream.emit("resume");
      flow(stream);
      if (state.flowing && !state.reading)
        stream.read(0);
    }
    Readable.prototype.pause = function() {
      debug("call pause flowing=%j", this._readableState.flowing);
      if (false !== this._readableState.flowing) {
        debug("pause");
        this._readableState.flowing = false;
        this.emit("pause");
      }
      return this;
    };
    function flow(stream) {
      var state = stream._readableState;
      debug("flow", state.flowing);
      while (state.flowing && stream.read() !== null) {
      }
    }
    Readable.prototype.wrap = function(stream) {
      var _this = this;
      var state = this._readableState;
      var paused = false;
      stream.on("end", function() {
        debug("wrapped end");
        if (state.decoder && !state.ended) {
          var chunk = state.decoder.end();
          if (chunk && chunk.length)
            _this.push(chunk);
        }
        _this.push(null);
      });
      stream.on("data", function(chunk) {
        debug("wrapped data");
        if (state.decoder)
          chunk = state.decoder.write(chunk);
        if (state.objectMode && (chunk === null || chunk === void 0))
          return;
        else if (!state.objectMode && (!chunk || !chunk.length))
          return;
        var ret2 = _this.push(chunk);
        if (!ret2) {
          paused = true;
          stream.pause();
        }
      });
      for (var i in stream) {
        if (this[i] === void 0 && typeof stream[i] === "function") {
          this[i] = /* @__PURE__ */ function(method) {
            return function() {
              return stream[method].apply(stream, arguments);
            };
          }(i);
        }
      }
      for (var n = 0; n < kProxyEvents.length; n++) {
        stream.on(kProxyEvents[n], this.emit.bind(this, kProxyEvents[n]));
      }
      this._read = function(n2) {
        debug("wrapped _read", n2);
        if (paused) {
          paused = false;
          stream.resume();
        }
      };
      return this;
    };
    Object.defineProperty(Readable.prototype, "readableHighWaterMark", {
      // making it explicit this property is not enumerable
      // because otherwise some prototype manipulation in
      // userland will fail
      enumerable: false,
      get: function() {
        return this._readableState.highWaterMark;
      }
    });
    Readable._fromList = fromList;
    function fromList(n, state) {
      if (state.length === 0)
        return null;
      var ret2;
      if (state.objectMode)
        ret2 = state.buffer.shift();
      else if (!n || n >= state.length) {
        if (state.decoder)
          ret2 = state.buffer.join("");
        else if (state.buffer.length === 1)
          ret2 = state.buffer.head.data;
        else
          ret2 = state.buffer.concat(state.length);
        state.buffer.clear();
      } else {
        ret2 = fromListPartial(n, state.buffer, state.decoder);
      }
      return ret2;
    }
    function fromListPartial(n, list, hasStrings) {
      var ret2;
      if (n < list.head.data.length) {
        ret2 = list.head.data.slice(0, n);
        list.head.data = list.head.data.slice(n);
      } else if (n === list.head.data.length) {
        ret2 = list.shift();
      } else {
        ret2 = hasStrings ? copyFromBufferString(n, list) : copyFromBuffer(n, list);
      }
      return ret2;
    }
    function copyFromBufferString(n, list) {
      var p = list.head;
      var c = 1;
      var ret2 = p.data;
      n -= ret2.length;
      while (p = p.next) {
        var str = p.data;
        var nb = n > str.length ? str.length : n;
        if (nb === str.length)
          ret2 += str;
        else
          ret2 += str.slice(0, n);
        n -= nb;
        if (n === 0) {
          if (nb === str.length) {
            ++c;
            if (p.next)
              list.head = p.next;
            else
              list.head = list.tail = null;
          } else {
            list.head = p;
            p.data = str.slice(nb);
          }
          break;
        }
        ++c;
      }
      list.length -= c;
      return ret2;
    }
    function copyFromBuffer(n, list) {
      var ret2 = Buffer2.allocUnsafe(n);
      var p = list.head;
      var c = 1;
      p.data.copy(ret2);
      n -= p.data.length;
      while (p = p.next) {
        var buf = p.data;
        var nb = n > buf.length ? buf.length : n;
        buf.copy(ret2, ret2.length - n, 0, nb);
        n -= nb;
        if (n === 0) {
          if (nb === buf.length) {
            ++c;
            if (p.next)
              list.head = p.next;
            else
              list.head = list.tail = null;
          } else {
            list.head = p;
            p.data = buf.slice(nb);
          }
          break;
        }
        ++c;
      }
      list.length -= c;
      return ret2;
    }
    function endReadable(stream) {
      var state = stream._readableState;
      if (state.length > 0)
        throw new Error('"endReadable()" called on non-empty stream');
      if (!state.endEmitted) {
        state.ended = true;
        pna.nextTick(endReadableNT, state, stream);
      }
    }
    function endReadableNT(state, stream) {
      if (!state.endEmitted && state.length === 0) {
        state.endEmitted = true;
        stream.readable = false;
        stream.emit("end");
      }
    }
    function indexOf(xs, x) {
      for (var i = 0, l2 = xs.length; i < l2; i++) {
        if (xs[i] === x)
          return i;
      }
      return -1;
    }
  }
});

// ../../../node_modules/duplexer2/node_modules/readable-stream/lib/_stream_transform.js
var require_stream_transform12 = __commonJS({
  "../../../node_modules/duplexer2/node_modules/readable-stream/lib/_stream_transform.js"(exports2, module2) {
    "use strict";
    module2.exports = Transform;
    var Duplex = require_stream_duplex12();
    var util = Object.create(require_util());
    util.inherits = require_inherits();
    util.inherits(Transform, Duplex);
    function afterTransform(er, data) {
      var ts = this._transformState;
      ts.transforming = false;
      var cb = ts.writecb;
      if (!cb) {
        return this.emit("error", new Error("write callback called multiple times"));
      }
      ts.writechunk = null;
      ts.writecb = null;
      if (data != null)
        this.push(data);
      cb(er);
      var rs = this._readableState;
      rs.reading = false;
      if (rs.needReadable || rs.length < rs.highWaterMark) {
        this._read(rs.highWaterMark);
      }
    }
    function Transform(options) {
      if (!(this instanceof Transform))
        return new Transform(options);
      Duplex.call(this, options);
      this._transformState = {
        afterTransform: afterTransform.bind(this),
        needTransform: false,
        transforming: false,
        writecb: null,
        writechunk: null,
        writeencoding: null
      };
      this._readableState.needReadable = true;
      this._readableState.sync = false;
      if (options) {
        if (typeof options.transform === "function")
          this._transform = options.transform;
        if (typeof options.flush === "function")
          this._flush = options.flush;
      }
      this.on("prefinish", prefinish);
    }
    function prefinish() {
      var _this = this;
      if (typeof this._flush === "function") {
        this._flush(function(er, data) {
          done(_this, er, data);
        });
      } else {
        done(this, null, null);
      }
    }
    Transform.prototype.push = function(chunk, encoding) {
      this._transformState.needTransform = false;
      return Duplex.prototype.push.call(this, chunk, encoding);
    };
    Transform.prototype._transform = function(chunk, encoding, cb) {
      throw new Error("_transform() is not implemented");
    };
    Transform.prototype._write = function(chunk, encoding, cb) {
      var ts = this._transformState;
      ts.writecb = cb;
      ts.writechunk = chunk;
      ts.writeencoding = encoding;
      if (!ts.transforming) {
        var rs = this._readableState;
        if (ts.needTransform || rs.needReadable || rs.length < rs.highWaterMark)
          this._read(rs.highWaterMark);
      }
    };
    Transform.prototype._read = function(n) {
      var ts = this._transformState;
      if (ts.writechunk !== null && ts.writecb && !ts.transforming) {
        ts.transforming = true;
        this._transform(ts.writechunk, ts.writeencoding, ts.afterTransform);
      } else {
        ts.needTransform = true;
      }
    };
    Transform.prototype._destroy = function(err, cb) {
      var _this2 = this;
      Duplex.prototype._destroy.call(this, err, function(err2) {
        cb(err2);
        _this2.emit("close");
      });
    };
    function done(stream, er, data) {
      if (er)
        return stream.emit("error", er);
      if (data != null)
        stream.push(data);
      if (stream._writableState.length)
        throw new Error("Calling transform done when ws.length != 0");
      if (stream._transformState.transforming)
        throw new Error("Calling transform done when still transforming");
      return stream.push(null);
    }
  }
});

// ../../../node_modules/duplexer2/node_modules/readable-stream/lib/_stream_passthrough.js
var require_stream_passthrough12 = __commonJS({
  "../../../node_modules/duplexer2/node_modules/readable-stream/lib/_stream_passthrough.js"(exports2, module2) {
    "use strict";
    module2.exports = PassThrough;
    var Transform = require_stream_transform12();
    var util = Object.create(require_util());
    util.inherits = require_inherits();
    util.inherits(PassThrough, Transform);
    function PassThrough(options) {
      if (!(this instanceof PassThrough))
        return new PassThrough(options);
      Transform.call(this, options);
    }
    PassThrough.prototype._transform = function(chunk, encoding, cb) {
      cb(null, chunk);
    };
  }
});

// ../../../node_modules/duplexer2/node_modules/readable-stream/readable.js
var require_readable12 = __commonJS({
  "../../../node_modules/duplexer2/node_modules/readable-stream/readable.js"(exports2, module2) {
    var Stream = require("stream");
    if (process.env.READABLE_STREAM === "disable" && Stream) {
      module2.exports = Stream;
      exports2 = module2.exports = Stream.Readable;
      exports2.Readable = Stream.Readable;
      exports2.Writable = Stream.Writable;
      exports2.Duplex = Stream.Duplex;
      exports2.Transform = Stream.Transform;
      exports2.PassThrough = Stream.PassThrough;
      exports2.Stream = Stream;
    } else {
      exports2 = module2.exports = require_stream_readable12();
      exports2.Stream = Stream || exports2;
      exports2.Readable = exports2;
      exports2.Writable = require_stream_writable12();
      exports2.Duplex = require_stream_duplex12();
      exports2.Transform = require_stream_transform12();
      exports2.PassThrough = require_stream_passthrough12();
    }
  }
});

// ../../../node_modules/duplexer2/index.js
var require_duplexer2 = __commonJS({
  "../../../node_modules/duplexer2/index.js"(exports2, module2) {
    "use strict";
    var stream = require_readable12();
    function DuplexWrapper(options, writable, readable) {
      if (typeof readable === "undefined") {
        readable = writable;
        writable = options;
        options = null;
      }
      stream.Duplex.call(this, options);
      if (typeof readable.read !== "function") {
        readable = new stream.Readable(options).wrap(readable);
      }
      this._writable = writable;
      this._readable = readable;
      this._waiting = false;
      var self2 = this;
      writable.once("finish", function() {
        self2.end();
      });
      this.once("finish", function() {
        writable.end();
      });
      readable.on("readable", function() {
        if (self2._waiting) {
          self2._waiting = false;
          self2._read();
        }
      });
      readable.once("end", function() {
        self2.push(null);
      });
      if (!options || typeof options.bubbleErrors === "undefined" || options.bubbleErrors) {
        writable.on("error", function(err) {
          self2.emit("error", err);
        });
        readable.on("error", function(err) {
          self2.emit("error", err);
        });
      }
    }
    DuplexWrapper.prototype = Object.create(stream.Duplex.prototype, { constructor: { value: DuplexWrapper } });
    DuplexWrapper.prototype._write = function _write(input, encoding, done) {
      this._writable.write(input, encoding, done);
    };
    DuplexWrapper.prototype._read = function _read() {
      var buf;
      var reads = 0;
      while ((buf = this._readable.read()) !== null) {
        this.push(buf);
        reads++;
      }
      if (reads === 0) {
        this._waiting = true;
      }
    };
    module2.exports = function duplex2(options, writable, readable) {
      return new DuplexWrapper(options, writable, readable);
    };
    module2.exports.DuplexWrapper = DuplexWrapper;
  }
});

// ../../../node_modules/unzipper/lib/parseOne.js
var require_parseOne = __commonJS({
  "../../../node_modules/unzipper/lib/parseOne.js"(exports2, module2) {
    var Stream = require("stream");
    var Parse = require_parse();
    var duplexer2 = require_duplexer2();
    var BufferStream = require_BufferStream();
    if (!Stream.Writable || !Stream.Writable.prototype.destroy)
      Stream = require_readable11();
    function parseOne(match, opts) {
      var inStream = Stream.PassThrough({ objectMode: true });
      var outStream = Stream.PassThrough();
      var transform = Stream.Transform({ objectMode: true });
      var re = match instanceof RegExp ? match : match && new RegExp(match);
      var found;
      transform._transform = function(entry, e, cb) {
        if (found || re && !re.exec(entry.path)) {
          entry.autodrain();
          return cb();
        } else {
          found = true;
          out.emit("entry", entry);
          entry.on("error", function(e2) {
            outStream.emit("error", e2);
          });
          entry.pipe(outStream).on("error", function(err) {
            cb(err);
          }).on("finish", function(d) {
            cb(null, d);
          });
        }
      };
      inStream.pipe(Parse(opts)).on("error", function(err) {
        outStream.emit("error", err);
      }).pipe(transform).on("error", Object).on("finish", function() {
        if (!found)
          outStream.emit("error", new Error("PATTERN_NOT_FOUND"));
        else
          outStream.end();
      });
      var out = duplexer2(inStream, outStream);
      out.buffer = function() {
        return BufferStream(outStream);
      };
      return out;
    }
    module2.exports = parseOne;
  }
});

// ../../../node_modules/fstream/lib/abstract.js
var require_abstract = __commonJS({
  "../../../node_modules/fstream/lib/abstract.js"(exports2, module2) {
    module2.exports = Abstract;
    var Stream = require("stream").Stream;
    var inherits2 = require_inherits();
    function Abstract() {
      Stream.call(this);
    }
    inherits2(Abstract, Stream);
    Abstract.prototype.on = function(ev, fn) {
      if (ev === "ready" && this.ready) {
        process.nextTick(fn.bind(this));
      } else {
        Stream.prototype.on.call(this, ev, fn);
      }
      return this;
    };
    Abstract.prototype.abort = function() {
      this._aborted = true;
      this.emit("abort");
    };
    Abstract.prototype.destroy = function() {
    };
    Abstract.prototype.warn = function(msg, code) {
      var self2 = this;
      var er = decorate(msg, code, self2);
      if (!self2.listeners("warn")) {
        console.error(
          "%s %s\npath = %s\nsyscall = %s\nfstream_type = %s\nfstream_path = %s\nfstream_unc_path = %s\nfstream_class = %s\nfstream_stack =\n%s\n",
          code || "UNKNOWN",
          er.stack,
          er.path,
          er.syscall,
          er.fstream_type,
          er.fstream_path,
          er.fstream_unc_path,
          er.fstream_class,
          er.fstream_stack.join("\n")
        );
      } else {
        self2.emit("warn", er);
      }
    };
    Abstract.prototype.info = function(msg, code) {
      this.emit("info", msg, code);
    };
    Abstract.prototype.error = function(msg, code, th) {
      var er = decorate(msg, code, this);
      if (th)
        throw er;
      else
        this.emit("error", er);
    };
    function decorate(er, code, self2) {
      if (!(er instanceof Error))
        er = new Error(er);
      er.code = er.code || code;
      er.path = er.path || self2.path;
      er.fstream_type = er.fstream_type || self2.type;
      er.fstream_path = er.fstream_path || self2.path;
      if (self2._path !== self2.path) {
        er.fstream_unc_path = er.fstream_unc_path || self2._path;
      }
      if (self2.linkpath) {
        er.fstream_linkpath = er.fstream_linkpath || self2.linkpath;
      }
      er.fstream_class = er.fstream_class || self2.constructor.name;
      er.fstream_stack = er.fstream_stack || new Error().stack.split(/\n/).slice(3).map(function(s) {
        return s.replace(/^ {4}at /, "");
      });
      return er;
    }
  }
});

// ../../../node_modules/fstream/lib/get-type.js
var require_get_type = __commonJS({
  "../../../node_modules/fstream/lib/get-type.js"(exports2, module2) {
    module2.exports = getType;
    function getType(st) {
      var types = [
        "Directory",
        "File",
        "SymbolicLink",
        "Link",
        // special for hardlinks from tarballs
        "BlockDevice",
        "CharacterDevice",
        "FIFO",
        "Socket"
      ];
      var type;
      if (st.type && types.indexOf(st.type) !== -1) {
        st[st.type] = true;
        return st.type;
      }
      for (var i = 0, l2 = types.length; i < l2; i++) {
        type = types[i];
        var is = st[type] || st["is" + type];
        if (typeof is === "function")
          is = is.call(st);
        if (is) {
          st[type] = true;
          st.type = type;
          return type;
        }
      }
      return null;
    }
  }
});

// ../../../node_modules/fstream/lib/link-reader.js
var require_link_reader = __commonJS({
  "../../../node_modules/fstream/lib/link-reader.js"(exports2, module2) {
    module2.exports = LinkReader;
    var fs = require_graceful_fs();
    var inherits2 = require_inherits();
    var Reader = require_reader();
    inherits2(LinkReader, Reader);
    function LinkReader(props) {
      var self2 = this;
      if (!(self2 instanceof LinkReader)) {
        throw new Error("LinkReader must be called as constructor.");
      }
      if (!(props.type === "Link" && props.Link || props.type === "SymbolicLink" && props.SymbolicLink)) {
        throw new Error("Non-link type " + props.type);
      }
      Reader.call(self2, props);
    }
    LinkReader.prototype._stat = function(currentStat) {
      var self2 = this;
      fs.readlink(self2._path, function(er, linkpath) {
        if (er)
          return self2.error(er);
        self2.linkpath = self2.props.linkpath = linkpath;
        self2.emit("linkpath", linkpath);
        Reader.prototype._stat.call(self2, currentStat);
      });
    };
    LinkReader.prototype._read = function() {
      var self2 = this;
      if (self2._paused)
        return;
      if (!self2._ended) {
        self2.emit("end");
        self2.emit("close");
        self2._ended = true;
      }
    };
  }
});

// ../../../node_modules/fstream/lib/dir-reader.js
var require_dir_reader = __commonJS({
  "../../../node_modules/fstream/lib/dir-reader.js"(exports2, module2) {
    module2.exports = DirReader;
    var fs = require_graceful_fs();
    var inherits2 = require_inherits();
    var path = require("path");
    var Reader = require_reader();
    var assert = require("assert").ok;
    inherits2(DirReader, Reader);
    function DirReader(props) {
      var self2 = this;
      if (!(self2 instanceof DirReader)) {
        throw new Error("DirReader must be called as constructor.");
      }
      if (props.type !== "Directory" || !props.Directory) {
        throw new Error("Non-directory type " + props.type);
      }
      self2.entries = null;
      self2._index = -1;
      self2._paused = false;
      self2._length = -1;
      if (props.sort) {
        this.sort = props.sort;
      }
      Reader.call(this, props);
    }
    DirReader.prototype._getEntries = function() {
      var self2 = this;
      if (self2._gotEntries)
        return;
      self2._gotEntries = true;
      fs.readdir(self2._path, function(er, entries) {
        if (er)
          return self2.error(er);
        self2.entries = entries;
        self2.emit("entries", entries);
        if (self2._paused)
          self2.once("resume", processEntries);
        else
          processEntries();
        function processEntries() {
          self2._length = self2.entries.length;
          if (typeof self2.sort === "function") {
            self2.entries = self2.entries.sort(self2.sort.bind(self2));
          }
          self2._read();
        }
      });
    };
    DirReader.prototype._read = function() {
      var self2 = this;
      if (!self2.entries)
        return self2._getEntries();
      if (self2._paused || self2._currentEntry || self2._aborted) {
        return;
      }
      self2._index++;
      if (self2._index >= self2.entries.length) {
        if (!self2._ended) {
          self2._ended = true;
          self2.emit("end");
          self2.emit("close");
        }
        return;
      }
      var p = path.resolve(self2._path, self2.entries[self2._index]);
      assert(p !== self2._path);
      assert(self2.entries[self2._index]);
      self2._currentEntry = p;
      fs[self2.props.follow ? "stat" : "lstat"](p, function(er, stat) {
        if (er)
          return self2.error(er);
        var who = self2._proxy || self2;
        stat.path = p;
        stat.basename = path.basename(p);
        stat.dirname = path.dirname(p);
        var childProps = self2.getChildProps.call(who, stat);
        childProps.path = p;
        childProps.basename = path.basename(p);
        childProps.dirname = path.dirname(p);
        var entry = Reader(childProps, stat);
        self2._currentEntry = entry;
        entry.on("pause", function(who2) {
          if (!self2._paused && !entry._disowned) {
            self2.pause(who2);
          }
        });
        entry.on("resume", function(who2) {
          if (self2._paused && !entry._disowned) {
            self2.resume(who2);
          }
        });
        entry.on("stat", function(props) {
          self2.emit("_entryStat", entry, props);
          if (entry._aborted)
            return;
          if (entry._paused) {
            entry.once("resume", function() {
              self2.emit("entryStat", entry, props);
            });
          } else
            self2.emit("entryStat", entry, props);
        });
        entry.on("ready", function EMITCHILD() {
          if (self2._paused) {
            entry.pause(self2);
            return self2.once("resume", EMITCHILD);
          }
          if (entry.type === "Socket") {
            self2.emit("socket", entry);
          } else {
            self2.emitEntry(entry);
          }
        });
        var ended = false;
        entry.on("close", onend);
        entry.on("disown", onend);
        function onend() {
          if (ended)
            return;
          ended = true;
          self2.emit("childEnd", entry);
          self2.emit("entryEnd", entry);
          self2._currentEntry = null;
          if (!self2._paused) {
            self2._read();
          }
        }
        entry.on("error", function(er2) {
          if (entry._swallowErrors) {
            self2.warn(er2);
            entry.emit("end");
            entry.emit("close");
          } else {
            self2.emit("error", er2);
          }
        });
        [
          "child",
          "childEnd",
          "warn"
        ].forEach(function(ev) {
          entry.on(ev, self2.emit.bind(self2, ev));
        });
      });
    };
    DirReader.prototype.disown = function(entry) {
      entry.emit("beforeDisown");
      entry._disowned = true;
      entry.parent = entry.root = null;
      if (entry === this._currentEntry) {
        this._currentEntry = null;
      }
      entry.emit("disown");
    };
    DirReader.prototype.getChildProps = function() {
      return {
        depth: this.depth + 1,
        root: this.root || this,
        parent: this,
        follow: this.follow,
        filter: this.filter,
        sort: this.props.sort,
        hardlinks: this.props.hardlinks
      };
    };
    DirReader.prototype.pause = function(who) {
      var self2 = this;
      if (self2._paused)
        return;
      who = who || self2;
      self2._paused = true;
      if (self2._currentEntry && self2._currentEntry.pause) {
        self2._currentEntry.pause(who);
      }
      self2.emit("pause", who);
    };
    DirReader.prototype.resume = function(who) {
      var self2 = this;
      if (!self2._paused)
        return;
      who = who || self2;
      self2._paused = false;
      self2.emit("resume", who);
      if (self2._paused) {
        return;
      }
      if (self2._currentEntry) {
        if (self2._currentEntry.resume)
          self2._currentEntry.resume(who);
      } else
        self2._read();
    };
    DirReader.prototype.emitEntry = function(entry) {
      this.emit("entry", entry);
      this.emit("child", entry);
    };
  }
});

// ../../../node_modules/fstream/lib/file-reader.js
var require_file_reader = __commonJS({
  "../../../node_modules/fstream/lib/file-reader.js"(exports2, module2) {
    module2.exports = FileReader2;
    var fs = require_graceful_fs();
    var inherits2 = require_inherits();
    var Reader = require_reader();
    var EOF = { EOF: true };
    var CLOSE = { CLOSE: true };
    inherits2(FileReader2, Reader);
    function FileReader2(props) {
      var self2 = this;
      if (!(self2 instanceof FileReader2)) {
        throw new Error("FileReader must be called as constructor.");
      }
      if (!(props.type === "Link" && props.Link || props.type === "File" && props.File)) {
        throw new Error("Non-file type " + props.type);
      }
      self2._buffer = [];
      self2._bytesEmitted = 0;
      Reader.call(self2, props);
    }
    FileReader2.prototype._getStream = function() {
      var self2 = this;
      var stream = self2._stream = fs.createReadStream(self2._path, self2.props);
      if (self2.props.blksize) {
        stream.bufferSize = self2.props.blksize;
      }
      stream.on("open", self2.emit.bind(self2, "open"));
      stream.on("data", function(c) {
        self2._bytesEmitted += c.length;
        if (!c.length) {
          return;
        } else if (self2._paused || self2._buffer.length) {
          self2._buffer.push(c);
          self2._read();
        } else
          self2.emit("data", c);
      });
      stream.on("end", function() {
        if (self2._paused || self2._buffer.length) {
          self2._buffer.push(EOF);
          self2._read();
        } else {
          self2.emit("end");
        }
        if (self2._bytesEmitted !== self2.props.size) {
          self2.error("Didn't get expected byte count\nexpect: " + self2.props.size + "\nactual: " + self2._bytesEmitted);
        }
      });
      stream.on("close", function() {
        if (self2._paused || self2._buffer.length) {
          self2._buffer.push(CLOSE);
          self2._read();
        } else {
          self2.emit("close");
        }
      });
      stream.on("error", function(e) {
        self2.emit("error", e);
      });
      self2._read();
    };
    FileReader2.prototype._read = function() {
      var self2 = this;
      if (self2._paused) {
        return;
      }
      if (!self2._stream) {
        return self2._getStream();
      }
      if (self2._buffer.length) {
        var buf = self2._buffer;
        for (var i = 0, l2 = buf.length; i < l2; i++) {
          var c = buf[i];
          if (c === EOF) {
            self2.emit("end");
          } else if (c === CLOSE) {
            self2.emit("close");
          } else {
            self2.emit("data", c);
          }
          if (self2._paused) {
            self2._buffer = buf.slice(i);
            return;
          }
        }
        self2._buffer.length = 0;
      }
    };
    FileReader2.prototype.pause = function(who) {
      var self2 = this;
      if (self2._paused)
        return;
      who = who || self2;
      self2._paused = true;
      if (self2._stream)
        self2._stream.pause();
      self2.emit("pause", who);
    };
    FileReader2.prototype.resume = function(who) {
      var self2 = this;
      if (!self2._paused)
        return;
      who = who || self2;
      self2.emit("resume", who);
      self2._paused = false;
      if (self2._stream)
        self2._stream.resume();
      self2._read();
    };
  }
});

// ../../../node_modules/fstream/lib/socket-reader.js
var require_socket_reader = __commonJS({
  "../../../node_modules/fstream/lib/socket-reader.js"(exports2, module2) {
    module2.exports = SocketReader;
    var inherits2 = require_inherits();
    var Reader = require_reader();
    inherits2(SocketReader, Reader);
    function SocketReader(props) {
      var self2 = this;
      if (!(self2 instanceof SocketReader)) {
        throw new Error("SocketReader must be called as constructor.");
      }
      if (!(props.type === "Socket" && props.Socket)) {
        throw new Error("Non-socket type " + props.type);
      }
      Reader.call(self2, props);
    }
    SocketReader.prototype._read = function() {
      var self2 = this;
      if (self2._paused)
        return;
      if (!self2._ended) {
        self2.emit("end");
        self2.emit("close");
        self2._ended = true;
      }
    };
  }
});

// ../../../node_modules/fstream/lib/proxy-reader.js
var require_proxy_reader = __commonJS({
  "../../../node_modules/fstream/lib/proxy-reader.js"(exports2, module2) {
    module2.exports = ProxyReader;
    var Reader = require_reader();
    var getType = require_get_type();
    var inherits2 = require_inherits();
    var fs = require_graceful_fs();
    inherits2(ProxyReader, Reader);
    function ProxyReader(props) {
      var self2 = this;
      if (!(self2 instanceof ProxyReader)) {
        throw new Error("ProxyReader must be called as constructor.");
      }
      self2.props = props;
      self2._buffer = [];
      self2.ready = false;
      Reader.call(self2, props);
    }
    ProxyReader.prototype._stat = function() {
      var self2 = this;
      var props = self2.props;
      var stat = props.follow ? "stat" : "lstat";
      fs[stat](props.path, function(er, current) {
        var type;
        if (er || !current) {
          type = "File";
        } else {
          type = getType(current);
        }
        props[type] = true;
        props.type = self2.type = type;
        self2._old = current;
        self2._addProxy(Reader(props, current));
      });
    };
    ProxyReader.prototype._addProxy = function(proxy) {
      var self2 = this;
      if (self2._proxyTarget) {
        return self2.error("proxy already set");
      }
      self2._proxyTarget = proxy;
      proxy._proxy = self2;
      [
        "error",
        "data",
        "end",
        "close",
        "linkpath",
        "entry",
        "entryEnd",
        "child",
        "childEnd",
        "warn",
        "stat"
      ].forEach(function(ev) {
        proxy.on(ev, self2.emit.bind(self2, ev));
      });
      self2.emit("proxy", proxy);
      proxy.on("ready", function() {
        self2.ready = true;
        self2.emit("ready");
      });
      var calls = self2._buffer;
      self2._buffer.length = 0;
      calls.forEach(function(c) {
        proxy[c[0]].apply(proxy, c[1]);
      });
    };
    ProxyReader.prototype.pause = function() {
      return this._proxyTarget ? this._proxyTarget.pause() : false;
    };
    ProxyReader.prototype.resume = function() {
      return this._proxyTarget ? this._proxyTarget.resume() : false;
    };
  }
});

// ../../../node_modules/fstream/lib/reader.js
var require_reader = __commonJS({
  "../../../node_modules/fstream/lib/reader.js"(exports2, module2) {
    module2.exports = Reader;
    var fs = require_graceful_fs();
    var Stream = require("stream").Stream;
    var inherits2 = require_inherits();
    var path = require("path");
    var getType = require_get_type();
    var hardLinks = Reader.hardLinks = {};
    var Abstract = require_abstract();
    inherits2(Reader, Abstract);
    var LinkReader = require_link_reader();
    function Reader(props, currentStat) {
      var self2 = this;
      if (!(self2 instanceof Reader))
        return new Reader(props, currentStat);
      if (typeof props === "string") {
        props = { path: props };
      }
      var type;
      var ClassType;
      if (props.type && typeof props.type === "function") {
        type = props.type;
        ClassType = type;
      } else {
        type = getType(props);
        ClassType = Reader;
      }
      if (currentStat && !type) {
        type = getType(currentStat);
        props[type] = true;
        props.type = type;
      }
      switch (type) {
        case "Directory":
          ClassType = require_dir_reader();
          break;
        case "Link":
        case "File":
          ClassType = require_file_reader();
          break;
        case "SymbolicLink":
          ClassType = LinkReader;
          break;
        case "Socket":
          ClassType = require_socket_reader();
          break;
        case null:
          ClassType = require_proxy_reader();
          break;
      }
      if (!(self2 instanceof ClassType)) {
        return new ClassType(props);
      }
      Abstract.call(self2);
      if (!props.path) {
        self2.error("Must provide a path", null, true);
      }
      self2.readable = true;
      self2.writable = false;
      self2.type = type;
      self2.props = props;
      self2.depth = props.depth = props.depth || 0;
      self2.parent = props.parent || null;
      self2.root = props.root || props.parent && props.parent.root || self2;
      self2._path = self2.path = path.resolve(props.path);
      if (process.platform === "win32") {
        self2.path = self2._path = self2.path.replace(/\?/g, "_");
        if (self2._path.length >= 260) {
          self2._swallowErrors = true;
          self2._path = "\\\\?\\" + self2.path.replace(/\//g, "\\");
        }
      }
      self2.basename = props.basename = path.basename(self2.path);
      self2.dirname = props.dirname = path.dirname(self2.path);
      props.parent = props.root = null;
      self2.size = props.size;
      self2.filter = typeof props.filter === "function" ? props.filter : null;
      if (props.sort === "alpha")
        props.sort = alphasort;
      self2._stat(currentStat);
    }
    function alphasort(a, b) {
      return a === b ? 0 : a.toLowerCase() > b.toLowerCase() ? 1 : a.toLowerCase() < b.toLowerCase() ? -1 : a > b ? 1 : -1;
    }
    Reader.prototype._stat = function(currentStat) {
      var self2 = this;
      var props = self2.props;
      var stat = props.follow ? "stat" : "lstat";
      if (currentStat)
        process.nextTick(statCb.bind(null, null, currentStat));
      else
        fs[stat](self2._path, statCb);
      function statCb(er, props_) {
        if (er)
          return self2.error(er);
        Object.keys(props_).forEach(function(k2) {
          props[k2] = props_[k2];
        });
        if (void 0 !== self2.size && props.size !== self2.size) {
          return self2.error("incorrect size");
        }
        self2.size = props.size;
        var type = getType(props);
        var handleHardlinks = props.hardlinks !== false;
        if (handleHardlinks && type !== "Directory" && props.nlink && props.nlink > 1) {
          var k = props.dev + ":" + props.ino;
          if (hardLinks[k] === self2._path || !hardLinks[k]) {
            hardLinks[k] = self2._path;
          } else {
            type = self2.type = self2.props.type = "Link";
            self2.Link = self2.props.Link = true;
            self2.linkpath = self2.props.linkpath = hardLinks[k];
            self2._stat = self2._read = LinkReader.prototype._read;
          }
        }
        if (self2.type && self2.type !== type) {
          self2.error("Unexpected type: " + type);
        }
        if (self2.filter) {
          var who = self2._proxy || self2;
          if (!self2.filter.call(who, who, props)) {
            if (!self2._disowned) {
              self2.abort();
              self2.emit("end");
              self2.emit("close");
            }
            return;
          }
        }
        var events = ["_stat", "stat", "ready"];
        var e = 0;
        (function go() {
          if (self2._aborted) {
            self2.emit("end");
            self2.emit("close");
            return;
          }
          if (self2._paused && self2.type !== "Directory") {
            self2.once("resume", go);
            return;
          }
          var ev = events[e++];
          if (!ev) {
            return self2._read();
          }
          self2.emit(ev, props);
          go();
        })();
      }
    };
    Reader.prototype.pipe = function(dest) {
      var self2 = this;
      if (typeof dest.add === "function") {
        self2.on("entry", function(entry) {
          var ret2 = dest.add(entry);
          if (ret2 === false) {
            self2.pause();
          }
        });
      }
      return Stream.prototype.pipe.apply(this, arguments);
    };
    Reader.prototype.pause = function(who) {
      this._paused = true;
      who = who || this;
      this.emit("pause", who);
      if (this._stream)
        this._stream.pause(who);
    };
    Reader.prototype.resume = function(who) {
      this._paused = false;
      who = who || this;
      this.emit("resume", who);
      if (this._stream)
        this._stream.resume(who);
      this._read();
    };
    Reader.prototype._read = function() {
      this.error("Cannot read unknown type: " + this.type);
    };
  }
});

// ../../../node_modules/fstream/node_modules/brace-expansion/index.js
var require_brace_expansion4 = __commonJS({
  "../../../node_modules/fstream/node_modules/brace-expansion/index.js"(exports2, module2) {
    var concatMap = require_concat_map();
    var balanced = require_balanced_match();
    module2.exports = expandTop;
    var escSlash = "\0SLASH" + Math.random() + "\0";
    var escOpen = "\0OPEN" + Math.random() + "\0";
    var escClose = "\0CLOSE" + Math.random() + "\0";
    var escComma = "\0COMMA" + Math.random() + "\0";
    var escPeriod = "\0PERIOD" + Math.random() + "\0";
    function numeric(str) {
      return parseInt(str, 10) == str ? parseInt(str, 10) : str.charCodeAt(0);
    }
    function escapeBraces(str) {
      return str.split("\\\\").join(escSlash).split("\\{").join(escOpen).split("\\}").join(escClose).split("\\,").join(escComma).split("\\.").join(escPeriod);
    }
    function unescapeBraces(str) {
      return str.split(escSlash).join("\\").split(escOpen).join("{").split(escClose).join("}").split(escComma).join(",").split(escPeriod).join(".");
    }
    function parseCommaParts(str) {
      if (!str)
        return [""];
      var parts = [];
      var m = balanced("{", "}", str);
      if (!m)
        return str.split(",");
      var pre = m.pre;
      var body = m.body;
      var post = m.post;
      var p = pre.split(",");
      p[p.length - 1] += "{" + body + "}";
      var postParts = parseCommaParts(post);
      if (post.length) {
        p[p.length - 1] += postParts.shift();
        p.push.apply(p, postParts);
      }
      parts.push.apply(parts, p);
      return parts;
    }
    function expandTop(str) {
      if (!str)
        return [];
      if (str.substr(0, 2) === "{}") {
        str = "\\{\\}" + str.substr(2);
      }
      return expand(escapeBraces(str), true).map(unescapeBraces);
    }
    function embrace(str) {
      return "{" + str + "}";
    }
    function isPadded(el) {
      return /^-?0\d/.test(el);
    }
    function lte(i, y) {
      return i <= y;
    }
    function gte(i, y) {
      return i >= y;
    }
    function expand(str, isTop) {
      var expansions = [];
      var m = balanced("{", "}", str);
      if (!m || /\$$/.test(m.pre))
        return [str];
      var isNumericSequence = /^-?\d+\.\.-?\d+(?:\.\.-?\d+)?$/.test(m.body);
      var isAlphaSequence = /^[a-zA-Z]\.\.[a-zA-Z](?:\.\.-?\d+)?$/.test(m.body);
      var isSequence = isNumericSequence || isAlphaSequence;
      var isOptions = m.body.indexOf(",") >= 0;
      if (!isSequence && !isOptions) {
        if (m.post.match(/,.*\}/)) {
          str = m.pre + "{" + m.body + escClose + m.post;
          return expand(str);
        }
        return [str];
      }
      var n;
      if (isSequence) {
        n = m.body.split(/\.\./);
      } else {
        n = parseCommaParts(m.body);
        if (n.length === 1) {
          n = expand(n[0], false).map(embrace);
          if (n.length === 1) {
            var post = m.post.length ? expand(m.post, false) : [""];
            return post.map(function(p) {
              return m.pre + n[0] + p;
            });
          }
        }
      }
      var pre = m.pre;
      var post = m.post.length ? expand(m.post, false) : [""];
      var N;
      if (isSequence) {
        var x = numeric(n[0]);
        var y = numeric(n[1]);
        var width = Math.max(n[0].length, n[1].length);
        var incr = n.length == 3 ? Math.abs(numeric(n[2])) : 1;
        var test = lte;
        var reverse = y < x;
        if (reverse) {
          incr *= -1;
          test = gte;
        }
        var pad = n.some(isPadded);
        N = [];
        for (var i = x; test(i, y); i += incr) {
          var c;
          if (isAlphaSequence) {
            c = String.fromCharCode(i);
            if (c === "\\")
              c = "";
          } else {
            c = String(i);
            if (pad) {
              var need = width - c.length;
              if (need > 0) {
                var z = new Array(need + 1).join("0");
                if (i < 0)
                  c = "-" + z + c.slice(1);
                else
                  c = z + c;
              }
            }
          }
          N.push(c);
        }
      } else {
        N = concatMap(n, function(el) {
          return expand(el, false);
        });
      }
      for (var j = 0; j < N.length; j++) {
        for (var k = 0; k < post.length; k++) {
          var expansion = pre + N[j] + post[k];
          if (!isTop || isSequence || expansion)
            expansions.push(expansion);
        }
      }
      return expansions;
    }
  }
});

// ../../../node_modules/fstream/node_modules/minimatch/minimatch.js
var require_minimatch4 = __commonJS({
  "../../../node_modules/fstream/node_modules/minimatch/minimatch.js"(exports2, module2) {
    module2.exports = minimatch;
    minimatch.Minimatch = Minimatch;
    var path = function() {
      try {
        return require("path");
      } catch (e) {
      }
    }() || {
      sep: "/"
    };
    minimatch.sep = path.sep;
    var GLOBSTAR = minimatch.GLOBSTAR = Minimatch.GLOBSTAR = {};
    var expand = require_brace_expansion4();
    var plTypes = {
      "!": { open: "(?:(?!(?:", close: "))[^/]*?)" },
      "?": { open: "(?:", close: ")?" },
      "+": { open: "(?:", close: ")+" },
      "*": { open: "(?:", close: ")*" },
      "@": { open: "(?:", close: ")" }
    };
    var qmark = "[^/]";
    var star = qmark + "*?";
    var twoStarDot = "(?:(?!(?:\\/|^)(?:\\.{1,2})($|\\/)).)*?";
    var twoStarNoDot = "(?:(?!(?:\\/|^)\\.).)*?";
    var reSpecials = charSet("().*{}+?[]^$\\!");
    function charSet(s) {
      return s.split("").reduce(function(set, c) {
        set[c] = true;
        return set;
      }, {});
    }
    var slashSplit = /\/+/;
    minimatch.filter = filter;
    function filter(pattern, options) {
      options = options || {};
      return function(p, i, list) {
        return minimatch(p, pattern, options);
      };
    }
    function ext(a, b) {
      b = b || {};
      var t = {};
      Object.keys(a).forEach(function(k) {
        t[k] = a[k];
      });
      Object.keys(b).forEach(function(k) {
        t[k] = b[k];
      });
      return t;
    }
    minimatch.defaults = function(def) {
      if (!def || typeof def !== "object" || !Object.keys(def).length) {
        return minimatch;
      }
      var orig = minimatch;
      var m = function minimatch2(p, pattern, options) {
        return orig(p, pattern, ext(def, options));
      };
      m.Minimatch = function Minimatch2(pattern, options) {
        return new orig.Minimatch(pattern, ext(def, options));
      };
      m.Minimatch.defaults = function defaults(options) {
        return orig.defaults(ext(def, options)).Minimatch;
      };
      m.filter = function filter2(pattern, options) {
        return orig.filter(pattern, ext(def, options));
      };
      m.defaults = function defaults(options) {
        return orig.defaults(ext(def, options));
      };
      m.makeRe = function makeRe2(pattern, options) {
        return orig.makeRe(pattern, ext(def, options));
      };
      m.braceExpand = function braceExpand2(pattern, options) {
        return orig.braceExpand(pattern, ext(def, options));
      };
      m.match = function(list, pattern, options) {
        return orig.match(list, pattern, ext(def, options));
      };
      return m;
    };
    Minimatch.defaults = function(def) {
      return minimatch.defaults(def).Minimatch;
    };
    function minimatch(p, pattern, options) {
      assertValidPattern(pattern);
      if (!options)
        options = {};
      if (!options.nocomment && pattern.charAt(0) === "#") {
        return false;
      }
      return new Minimatch(pattern, options).match(p);
    }
    function Minimatch(pattern, options) {
      if (!(this instanceof Minimatch)) {
        return new Minimatch(pattern, options);
      }
      assertValidPattern(pattern);
      if (!options)
        options = {};
      pattern = pattern.trim();
      if (!options.allowWindowsEscape && path.sep !== "/") {
        pattern = pattern.split(path.sep).join("/");
      }
      this.options = options;
      this.set = [];
      this.pattern = pattern;
      this.regexp = null;
      this.negate = false;
      this.comment = false;
      this.empty = false;
      this.partial = !!options.partial;
      this.make();
    }
    Minimatch.prototype.debug = function() {
    };
    Minimatch.prototype.make = make;
    function make() {
      var pattern = this.pattern;
      var options = this.options;
      if (!options.nocomment && pattern.charAt(0) === "#") {
        this.comment = true;
        return;
      }
      if (!pattern) {
        this.empty = true;
        return;
      }
      this.parseNegate();
      var set = this.globSet = this.braceExpand();
      if (options.debug)
        this.debug = function debug() {
          console.error.apply(console, arguments);
        };
      this.debug(this.pattern, set);
      set = this.globParts = set.map(function(s) {
        return s.split(slashSplit);
      });
      this.debug(this.pattern, set);
      set = set.map(function(s, si, set2) {
        return s.map(this.parse, this);
      }, this);
      this.debug(this.pattern, set);
      set = set.filter(function(s) {
        return s.indexOf(false) === -1;
      });
      this.debug(this.pattern, set);
      this.set = set;
    }
    Minimatch.prototype.parseNegate = parseNegate;
    function parseNegate() {
      var pattern = this.pattern;
      var negate = false;
      var options = this.options;
      var negateOffset = 0;
      if (options.nonegate)
        return;
      for (var i = 0, l2 = pattern.length; i < l2 && pattern.charAt(i) === "!"; i++) {
        negate = !negate;
        negateOffset++;
      }
      if (negateOffset)
        this.pattern = pattern.substr(negateOffset);
      this.negate = negate;
    }
    minimatch.braceExpand = function(pattern, options) {
      return braceExpand(pattern, options);
    };
    Minimatch.prototype.braceExpand = braceExpand;
    function braceExpand(pattern, options) {
      if (!options) {
        if (this instanceof Minimatch) {
          options = this.options;
        } else {
          options = {};
        }
      }
      pattern = typeof pattern === "undefined" ? this.pattern : pattern;
      assertValidPattern(pattern);
      if (options.nobrace || !/\{(?:(?!\{).)*\}/.test(pattern)) {
        return [pattern];
      }
      return expand(pattern);
    }
    var MAX_PATTERN_LENGTH = 1024 * 64;
    var assertValidPattern = function(pattern) {
      if (typeof pattern !== "string") {
        throw new TypeError("invalid pattern");
      }
      if (pattern.length > MAX_PATTERN_LENGTH) {
        throw new TypeError("pattern is too long");
      }
    };
    Minimatch.prototype.parse = parse2;
    var SUBPARSE = {};
    function parse2(pattern, isSub) {
      assertValidPattern(pattern);
      var options = this.options;
      if (pattern === "**") {
        if (!options.noglobstar)
          return GLOBSTAR;
        else
          pattern = "*";
      }
      if (pattern === "")
        return "";
      var re = "";
      var hasMagic = !!options.nocase;
      var escaping = false;
      var patternListStack = [];
      var negativeLists = [];
      var stateChar;
      var inClass = false;
      var reClassStart = -1;
      var classStart = -1;
      var patternStart = pattern.charAt(0) === "." ? "" : options.dot ? "(?!(?:^|\\/)\\.{1,2}(?:$|\\/))" : "(?!\\.)";
      var self2 = this;
      function clearStateChar() {
        if (stateChar) {
          switch (stateChar) {
            case "*":
              re += star;
              hasMagic = true;
              break;
            case "?":
              re += qmark;
              hasMagic = true;
              break;
            default:
              re += "\\" + stateChar;
              break;
          }
          self2.debug("clearStateChar %j %j", stateChar, re);
          stateChar = false;
        }
      }
      for (var i = 0, len = pattern.length, c; i < len && (c = pattern.charAt(i)); i++) {
        this.debug("%s	%s %s %j", pattern, i, re, c);
        if (escaping && reSpecials[c]) {
          re += "\\" + c;
          escaping = false;
          continue;
        }
        switch (c) {
          case "/": {
            return false;
          }
          case "\\":
            clearStateChar();
            escaping = true;
            continue;
          case "?":
          case "*":
          case "+":
          case "@":
          case "!":
            this.debug("%s	%s %s %j <-- stateChar", pattern, i, re, c);
            if (inClass) {
              this.debug("  in class");
              if (c === "!" && i === classStart + 1)
                c = "^";
              re += c;
              continue;
            }
            self2.debug("call clearStateChar %j", stateChar);
            clearStateChar();
            stateChar = c;
            if (options.noext)
              clearStateChar();
            continue;
          case "(":
            if (inClass) {
              re += "(";
              continue;
            }
            if (!stateChar) {
              re += "\\(";
              continue;
            }
            patternListStack.push({
              type: stateChar,
              start: i - 1,
              reStart: re.length,
              open: plTypes[stateChar].open,
              close: plTypes[stateChar].close
            });
            re += stateChar === "!" ? "(?:(?!(?:" : "(?:";
            this.debug("plType %j %j", stateChar, re);
            stateChar = false;
            continue;
          case ")":
            if (inClass || !patternListStack.length) {
              re += "\\)";
              continue;
            }
            clearStateChar();
            hasMagic = true;
            var pl = patternListStack.pop();
            re += pl.close;
            if (pl.type === "!") {
              negativeLists.push(pl);
            }
            pl.reEnd = re.length;
            continue;
          case "|":
            if (inClass || !patternListStack.length || escaping) {
              re += "\\|";
              escaping = false;
              continue;
            }
            clearStateChar();
            re += "|";
            continue;
          case "[":
            clearStateChar();
            if (inClass) {
              re += "\\" + c;
              continue;
            }
            inClass = true;
            classStart = i;
            reClassStart = re.length;
            re += c;
            continue;
          case "]":
            if (i === classStart + 1 || !inClass) {
              re += "\\" + c;
              escaping = false;
              continue;
            }
            var cs = pattern.substring(classStart + 1, i);
            try {
              RegExp("[" + cs + "]");
            } catch (er) {
              var sp = this.parse(cs, SUBPARSE);
              re = re.substr(0, reClassStart) + "\\[" + sp[0] + "\\]";
              hasMagic = hasMagic || sp[1];
              inClass = false;
              continue;
            }
            hasMagic = true;
            inClass = false;
            re += c;
            continue;
          default:
            clearStateChar();
            if (escaping) {
              escaping = false;
            } else if (reSpecials[c] && !(c === "^" && inClass)) {
              re += "\\";
            }
            re += c;
        }
      }
      if (inClass) {
        cs = pattern.substr(classStart + 1);
        sp = this.parse(cs, SUBPARSE);
        re = re.substr(0, reClassStart) + "\\[" + sp[0];
        hasMagic = hasMagic || sp[1];
      }
      for (pl = patternListStack.pop(); pl; pl = patternListStack.pop()) {
        var tail = re.slice(pl.reStart + pl.open.length);
        this.debug("setting tail", re, pl);
        tail = tail.replace(/((?:\\{2}){0,64})(\\?)\|/g, function(_2, $1, $2) {
          if (!$2) {
            $2 = "\\";
          }
          return $1 + $1 + $2 + "|";
        });
        this.debug("tail=%j\n   %s", tail, tail, pl, re);
        var t = pl.type === "*" ? star : pl.type === "?" ? qmark : "\\" + pl.type;
        hasMagic = true;
        re = re.slice(0, pl.reStart) + t + "\\(" + tail;
      }
      clearStateChar();
      if (escaping) {
        re += "\\\\";
      }
      var addPatternStart = false;
      switch (re.charAt(0)) {
        case "[":
        case ".":
        case "(":
          addPatternStart = true;
      }
      for (var n = negativeLists.length - 1; n > -1; n--) {
        var nl = negativeLists[n];
        var nlBefore = re.slice(0, nl.reStart);
        var nlFirst = re.slice(nl.reStart, nl.reEnd - 8);
        var nlLast = re.slice(nl.reEnd - 8, nl.reEnd);
        var nlAfter = re.slice(nl.reEnd);
        nlLast += nlAfter;
        var openParensBefore = nlBefore.split("(").length - 1;
        var cleanAfter = nlAfter;
        for (i = 0; i < openParensBefore; i++) {
          cleanAfter = cleanAfter.replace(/\)[+*?]?/, "");
        }
        nlAfter = cleanAfter;
        var dollar = "";
        if (nlAfter === "" && isSub !== SUBPARSE) {
          dollar = "$";
        }
        var newRe = nlBefore + nlFirst + nlAfter + dollar + nlLast;
        re = newRe;
      }
      if (re !== "" && hasMagic) {
        re = "(?=.)" + re;
      }
      if (addPatternStart) {
        re = patternStart + re;
      }
      if (isSub === SUBPARSE) {
        return [re, hasMagic];
      }
      if (!hasMagic) {
        return globUnescape(pattern);
      }
      var flags = options.nocase ? "i" : "";
      try {
        var regExp = new RegExp("^" + re + "$", flags);
      } catch (er) {
        return new RegExp("$.");
      }
      regExp._glob = pattern;
      regExp._src = re;
      return regExp;
    }
    minimatch.makeRe = function(pattern, options) {
      return new Minimatch(pattern, options || {}).makeRe();
    };
    Minimatch.prototype.makeRe = makeRe;
    function makeRe() {
      if (this.regexp || this.regexp === false)
        return this.regexp;
      var set = this.set;
      if (!set.length) {
        this.regexp = false;
        return this.regexp;
      }
      var options = this.options;
      var twoStar = options.noglobstar ? star : options.dot ? twoStarDot : twoStarNoDot;
      var flags = options.nocase ? "i" : "";
      var re = set.map(function(pattern) {
        return pattern.map(function(p) {
          return p === GLOBSTAR ? twoStar : typeof p === "string" ? regExpEscape(p) : p._src;
        }).join("\\/");
      }).join("|");
      re = "^(?:" + re + ")$";
      if (this.negate)
        re = "^(?!" + re + ").*$";
      try {
        this.regexp = new RegExp(re, flags);
      } catch (ex) {
        this.regexp = false;
      }
      return this.regexp;
    }
    minimatch.match = function(list, pattern, options) {
      options = options || {};
      var mm = new Minimatch(pattern, options);
      list = list.filter(function(f) {
        return mm.match(f);
      });
      if (mm.options.nonull && !list.length) {
        list.push(pattern);
      }
      return list;
    };
    Minimatch.prototype.match = function match(f, partial) {
      if (typeof partial === "undefined")
        partial = this.partial;
      this.debug("match", f, this.pattern);
      if (this.comment)
        return false;
      if (this.empty)
        return f === "";
      if (f === "/" && partial)
        return true;
      var options = this.options;
      if (path.sep !== "/") {
        f = f.split(path.sep).join("/");
      }
      f = f.split(slashSplit);
      this.debug(this.pattern, "split", f);
      var set = this.set;
      this.debug(this.pattern, "set", set);
      var filename;
      var i;
      for (i = f.length - 1; i >= 0; i--) {
        filename = f[i];
        if (filename)
          break;
      }
      for (i = 0; i < set.length; i++) {
        var pattern = set[i];
        var file = f;
        if (options.matchBase && pattern.length === 1) {
          file = [filename];
        }
        var hit = this.matchOne(file, pattern, partial);
        if (hit) {
          if (options.flipNegate)
            return true;
          return !this.negate;
        }
      }
      if (options.flipNegate)
        return false;
      return this.negate;
    };
    Minimatch.prototype.matchOne = function(file, pattern, partial) {
      var options = this.options;
      this.debug(
        "matchOne",
        { "this": this, file, pattern }
      );
      this.debug("matchOne", file.length, pattern.length);
      for (var fi = 0, pi = 0, fl = file.length, pl = pattern.length; fi < fl && pi < pl; fi++, pi++) {
        this.debug("matchOne loop");
        var p = pattern[pi];
        var f = file[fi];
        this.debug(pattern, p, f);
        if (p === false)
          return false;
        if (p === GLOBSTAR) {
          this.debug("GLOBSTAR", [pattern, p, f]);
          var fr = fi;
          var pr = pi + 1;
          if (pr === pl) {
            this.debug("** at the end");
            for (; fi < fl; fi++) {
              if (file[fi] === "." || file[fi] === ".." || !options.dot && file[fi].charAt(0) === ".")
                return false;
            }
            return true;
          }
          while (fr < fl) {
            var swallowee = file[fr];
            this.debug("\nglobstar while", file, fr, pattern, pr, swallowee);
            if (this.matchOne(file.slice(fr), pattern.slice(pr), partial)) {
              this.debug("globstar found match!", fr, fl, swallowee);
              return true;
            } else {
              if (swallowee === "." || swallowee === ".." || !options.dot && swallowee.charAt(0) === ".") {
                this.debug("dot detected!", file, fr, pattern, pr);
                break;
              }
              this.debug("globstar swallow a segment, and continue");
              fr++;
            }
          }
          if (partial) {
            this.debug("\n>>> no match, partial?", file, fr, pattern, pr);
            if (fr === fl)
              return true;
          }
          return false;
        }
        var hit;
        if (typeof p === "string") {
          hit = f === p;
          this.debug("string match", p, f, hit);
        } else {
          hit = f.match(p);
          this.debug("pattern match", p, f, hit);
        }
        if (!hit)
          return false;
      }
      if (fi === fl && pi === pl) {
        return true;
      } else if (fi === fl) {
        return partial;
      } else if (pi === pl) {
        return fi === fl - 1 && file[fi] === "";
      }
      throw new Error("wtf?");
    };
    function globUnescape(s) {
      return s.replace(/\\(.)/g, "$1");
    }
    function regExpEscape(s) {
      return s.replace(/[-[\]{}()*+?.,\\^$|#\s]/g, "\\$&");
    }
  }
});

// ../../../node_modules/fstream/node_modules/glob/common.js
var require_common4 = __commonJS({
  "../../../node_modules/fstream/node_modules/glob/common.js"(exports2) {
    exports2.setopts = setopts;
    exports2.ownProp = ownProp;
    exports2.makeAbs = makeAbs;
    exports2.finish = finish;
    exports2.mark = mark;
    exports2.isIgnored = isIgnored;
    exports2.childrenIgnored = childrenIgnored;
    function ownProp(obj2, field) {
      return Object.prototype.hasOwnProperty.call(obj2, field);
    }
    var fs = require("fs");
    var path = require("path");
    var minimatch = require_minimatch4();
    var isAbsolute = require_path_is_absolute();
    var Minimatch = minimatch.Minimatch;
    function alphasort(a, b) {
      return a.localeCompare(b, "en");
    }
    function setupIgnores(self2, options) {
      self2.ignore = options.ignore || [];
      if (!Array.isArray(self2.ignore))
        self2.ignore = [self2.ignore];
      if (self2.ignore.length) {
        self2.ignore = self2.ignore.map(ignoreMap);
      }
    }
    function ignoreMap(pattern) {
      var gmatcher = null;
      if (pattern.slice(-3) === "/**") {
        var gpattern = pattern.replace(/(\/\*\*)+$/, "");
        gmatcher = new Minimatch(gpattern, { dot: true });
      }
      return {
        matcher: new Minimatch(pattern, { dot: true }),
        gmatcher
      };
    }
    function setopts(self2, pattern, options) {
      if (!options)
        options = {};
      if (options.matchBase && -1 === pattern.indexOf("/")) {
        if (options.noglobstar) {
          throw new Error("base matching requires globstar");
        }
        pattern = "**/" + pattern;
      }
      self2.silent = !!options.silent;
      self2.pattern = pattern;
      self2.strict = options.strict !== false;
      self2.realpath = !!options.realpath;
      self2.realpathCache = options.realpathCache || /* @__PURE__ */ Object.create(null);
      self2.follow = !!options.follow;
      self2.dot = !!options.dot;
      self2.mark = !!options.mark;
      self2.nodir = !!options.nodir;
      if (self2.nodir)
        self2.mark = true;
      self2.sync = !!options.sync;
      self2.nounique = !!options.nounique;
      self2.nonull = !!options.nonull;
      self2.nosort = !!options.nosort;
      self2.nocase = !!options.nocase;
      self2.stat = !!options.stat;
      self2.noprocess = !!options.noprocess;
      self2.absolute = !!options.absolute;
      self2.fs = options.fs || fs;
      self2.maxLength = options.maxLength || Infinity;
      self2.cache = options.cache || /* @__PURE__ */ Object.create(null);
      self2.statCache = options.statCache || /* @__PURE__ */ Object.create(null);
      self2.symlinks = options.symlinks || /* @__PURE__ */ Object.create(null);
      setupIgnores(self2, options);
      self2.changedCwd = false;
      var cwd = process.cwd();
      if (!ownProp(options, "cwd"))
        self2.cwd = cwd;
      else {
        self2.cwd = path.resolve(options.cwd);
        self2.changedCwd = self2.cwd !== cwd;
      }
      self2.root = options.root || path.resolve(self2.cwd, "/");
      self2.root = path.resolve(self2.root);
      if (process.platform === "win32")
        self2.root = self2.root.replace(/\\/g, "/");
      self2.cwdAbs = isAbsolute(self2.cwd) ? self2.cwd : makeAbs(self2, self2.cwd);
      if (process.platform === "win32")
        self2.cwdAbs = self2.cwdAbs.replace(/\\/g, "/");
      self2.nomount = !!options.nomount;
      options.nonegate = true;
      options.nocomment = true;
      options.allowWindowsEscape = false;
      self2.minimatch = new Minimatch(pattern, options);
      self2.options = self2.minimatch.options;
    }
    function finish(self2) {
      var nou = self2.nounique;
      var all = nou ? [] : /* @__PURE__ */ Object.create(null);
      for (var i = 0, l2 = self2.matches.length; i < l2; i++) {
        var matches = self2.matches[i];
        if (!matches || Object.keys(matches).length === 0) {
          if (self2.nonull) {
            var literal = self2.minimatch.globSet[i];
            if (nou)
              all.push(literal);
            else
              all[literal] = true;
          }
        } else {
          var m = Object.keys(matches);
          if (nou)
            all.push.apply(all, m);
          else
            m.forEach(function(m2) {
              all[m2] = true;
            });
        }
      }
      if (!nou)
        all = Object.keys(all);
      if (!self2.nosort)
        all = all.sort(alphasort);
      if (self2.mark) {
        for (var i = 0; i < all.length; i++) {
          all[i] = self2._mark(all[i]);
        }
        if (self2.nodir) {
          all = all.filter(function(e) {
            var notDir = !/\/$/.test(e);
            var c = self2.cache[e] || self2.cache[makeAbs(self2, e)];
            if (notDir && c)
              notDir = c !== "DIR" && !Array.isArray(c);
            return notDir;
          });
        }
      }
      if (self2.ignore.length)
        all = all.filter(function(m2) {
          return !isIgnored(self2, m2);
        });
      self2.found = all;
    }
    function mark(self2, p) {
      var abs = makeAbs(self2, p);
      var c = self2.cache[abs];
      var m = p;
      if (c) {
        var isDir = c === "DIR" || Array.isArray(c);
        var slash = p.slice(-1) === "/";
        if (isDir && !slash)
          m += "/";
        else if (!isDir && slash)
          m = m.slice(0, -1);
        if (m !== p) {
          var mabs = makeAbs(self2, m);
          self2.statCache[mabs] = self2.statCache[abs];
          self2.cache[mabs] = self2.cache[abs];
        }
      }
      return m;
    }
    function makeAbs(self2, f) {
      var abs = f;
      if (f.charAt(0) === "/") {
        abs = path.join(self2.root, f);
      } else if (isAbsolute(f) || f === "") {
        abs = f;
      } else if (self2.changedCwd) {
        abs = path.resolve(self2.cwd, f);
      } else {
        abs = path.resolve(f);
      }
      if (process.platform === "win32")
        abs = abs.replace(/\\/g, "/");
      return abs;
    }
    function isIgnored(self2, path2) {
      if (!self2.ignore.length)
        return false;
      return self2.ignore.some(function(item) {
        return item.matcher.match(path2) || !!(item.gmatcher && item.gmatcher.match(path2));
      });
    }
    function childrenIgnored(self2, path2) {
      if (!self2.ignore.length)
        return false;
      return self2.ignore.some(function(item) {
        return !!(item.gmatcher && item.gmatcher.match(path2));
      });
    }
  }
});

// ../../../node_modules/fstream/node_modules/glob/sync.js
var require_sync3 = __commonJS({
  "../../../node_modules/fstream/node_modules/glob/sync.js"(exports2, module2) {
    module2.exports = globSync;
    globSync.GlobSync = GlobSync;
    var rp = require_fs();
    var minimatch = require_minimatch4();
    var Minimatch = minimatch.Minimatch;
    var Glob = require_glob3().Glob;
    var util = require("util");
    var path = require("path");
    var assert = require("assert");
    var isAbsolute = require_path_is_absolute();
    var common = require_common4();
    var setopts = common.setopts;
    var ownProp = common.ownProp;
    var childrenIgnored = common.childrenIgnored;
    var isIgnored = common.isIgnored;
    function globSync(pattern, options) {
      if (typeof options === "function" || arguments.length === 3)
        throw new TypeError("callback provided to sync glob\nSee: https://github.com/isaacs/node-glob/issues/167");
      return new GlobSync(pattern, options).found;
    }
    function GlobSync(pattern, options) {
      if (!pattern)
        throw new Error("must provide pattern");
      if (typeof options === "function" || arguments.length === 3)
        throw new TypeError("callback provided to sync glob\nSee: https://github.com/isaacs/node-glob/issues/167");
      if (!(this instanceof GlobSync))
        return new GlobSync(pattern, options);
      setopts(this, pattern, options);
      if (this.noprocess)
        return this;
      var n = this.minimatch.set.length;
      this.matches = new Array(n);
      for (var i = 0; i < n; i++) {
        this._process(this.minimatch.set[i], i, false);
      }
      this._finish();
    }
    GlobSync.prototype._finish = function() {
      assert.ok(this instanceof GlobSync);
      if (this.realpath) {
        var self2 = this;
        this.matches.forEach(function(matchset, index) {
          var set = self2.matches[index] = /* @__PURE__ */ Object.create(null);
          for (var p in matchset) {
            try {
              p = self2._makeAbs(p);
              var real = rp.realpathSync(p, self2.realpathCache);
              set[real] = true;
            } catch (er) {
              if (er.syscall === "stat")
                set[self2._makeAbs(p)] = true;
              else
                throw er;
            }
          }
        });
      }
      common.finish(this);
    };
    GlobSync.prototype._process = function(pattern, index, inGlobStar) {
      assert.ok(this instanceof GlobSync);
      var n = 0;
      while (typeof pattern[n] === "string") {
        n++;
      }
      var prefix;
      switch (n) {
        case pattern.length:
          this._processSimple(pattern.join("/"), index);
          return;
        case 0:
          prefix = null;
          break;
        default:
          prefix = pattern.slice(0, n).join("/");
          break;
      }
      var remain = pattern.slice(n);
      var read;
      if (prefix === null)
        read = ".";
      else if (isAbsolute(prefix) || isAbsolute(pattern.map(function(p) {
        return typeof p === "string" ? p : "[*]";
      }).join("/"))) {
        if (!prefix || !isAbsolute(prefix))
          prefix = "/" + prefix;
        read = prefix;
      } else
        read = prefix;
      var abs = this._makeAbs(read);
      if (childrenIgnored(this, read))
        return;
      var isGlobStar = remain[0] === minimatch.GLOBSTAR;
      if (isGlobStar)
        this._processGlobStar(prefix, read, abs, remain, index, inGlobStar);
      else
        this._processReaddir(prefix, read, abs, remain, index, inGlobStar);
    };
    GlobSync.prototype._processReaddir = function(prefix, read, abs, remain, index, inGlobStar) {
      var entries = this._readdir(abs, inGlobStar);
      if (!entries)
        return;
      var pn = remain[0];
      var negate = !!this.minimatch.negate;
      var rawGlob = pn._glob;
      var dotOk = this.dot || rawGlob.charAt(0) === ".";
      var matchedEntries = [];
      for (var i = 0; i < entries.length; i++) {
        var e = entries[i];
        if (e.charAt(0) !== "." || dotOk) {
          var m;
          if (negate && !prefix) {
            m = !e.match(pn);
          } else {
            m = e.match(pn);
          }
          if (m)
            matchedEntries.push(e);
        }
      }
      var len = matchedEntries.length;
      if (len === 0)
        return;
      if (remain.length === 1 && !this.mark && !this.stat) {
        if (!this.matches[index])
          this.matches[index] = /* @__PURE__ */ Object.create(null);
        for (var i = 0; i < len; i++) {
          var e = matchedEntries[i];
          if (prefix) {
            if (prefix.slice(-1) !== "/")
              e = prefix + "/" + e;
            else
              e = prefix + e;
          }
          if (e.charAt(0) === "/" && !this.nomount) {
            e = path.join(this.root, e);
          }
          this._emitMatch(index, e);
        }
        return;
      }
      remain.shift();
      for (var i = 0; i < len; i++) {
        var e = matchedEntries[i];
        var newPattern;
        if (prefix)
          newPattern = [prefix, e];
        else
          newPattern = [e];
        this._process(newPattern.concat(remain), index, inGlobStar);
      }
    };
    GlobSync.prototype._emitMatch = function(index, e) {
      if (isIgnored(this, e))
        return;
      var abs = this._makeAbs(e);
      if (this.mark)
        e = this._mark(e);
      if (this.absolute) {
        e = abs;
      }
      if (this.matches[index][e])
        return;
      if (this.nodir) {
        var c = this.cache[abs];
        if (c === "DIR" || Array.isArray(c))
          return;
      }
      this.matches[index][e] = true;
      if (this.stat)
        this._stat(e);
    };
    GlobSync.prototype._readdirInGlobStar = function(abs) {
      if (this.follow)
        return this._readdir(abs, false);
      var entries;
      var lstat;
      var stat;
      try {
        lstat = this.fs.lstatSync(abs);
      } catch (er) {
        if (er.code === "ENOENT") {
          return null;
        }
      }
      var isSym = lstat && lstat.isSymbolicLink();
      this.symlinks[abs] = isSym;
      if (!isSym && lstat && !lstat.isDirectory())
        this.cache[abs] = "FILE";
      else
        entries = this._readdir(abs, false);
      return entries;
    };
    GlobSync.prototype._readdir = function(abs, inGlobStar) {
      var entries;
      if (inGlobStar && !ownProp(this.symlinks, abs))
        return this._readdirInGlobStar(abs);
      if (ownProp(this.cache, abs)) {
        var c = this.cache[abs];
        if (!c || c === "FILE")
          return null;
        if (Array.isArray(c))
          return c;
      }
      try {
        return this._readdirEntries(abs, this.fs.readdirSync(abs));
      } catch (er) {
        this._readdirError(abs, er);
        return null;
      }
    };
    GlobSync.prototype._readdirEntries = function(abs, entries) {
      if (!this.mark && !this.stat) {
        for (var i = 0; i < entries.length; i++) {
          var e = entries[i];
          if (abs === "/")
            e = abs + e;
          else
            e = abs + "/" + e;
          this.cache[e] = true;
        }
      }
      this.cache[abs] = entries;
      return entries;
    };
    GlobSync.prototype._readdirError = function(f, er) {
      switch (er.code) {
        case "ENOTSUP":
        case "ENOTDIR":
          var abs = this._makeAbs(f);
          this.cache[abs] = "FILE";
          if (abs === this.cwdAbs) {
            var error = new Error(er.code + " invalid cwd " + this.cwd);
            error.path = this.cwd;
            error.code = er.code;
            throw error;
          }
          break;
        case "ENOENT":
        case "ELOOP":
        case "ENAMETOOLONG":
        case "UNKNOWN":
          this.cache[this._makeAbs(f)] = false;
          break;
        default:
          this.cache[this._makeAbs(f)] = false;
          if (this.strict)
            throw er;
          if (!this.silent)
            console.error("glob error", er);
          break;
      }
    };
    GlobSync.prototype._processGlobStar = function(prefix, read, abs, remain, index, inGlobStar) {
      var entries = this._readdir(abs, inGlobStar);
      if (!entries)
        return;
      var remainWithoutGlobStar = remain.slice(1);
      var gspref = prefix ? [prefix] : [];
      var noGlobStar = gspref.concat(remainWithoutGlobStar);
      this._process(noGlobStar, index, false);
      var len = entries.length;
      var isSym = this.symlinks[abs];
      if (isSym && inGlobStar)
        return;
      for (var i = 0; i < len; i++) {
        var e = entries[i];
        if (e.charAt(0) === "." && !this.dot)
          continue;
        var instead = gspref.concat(entries[i], remainWithoutGlobStar);
        this._process(instead, index, true);
        var below = gspref.concat(entries[i], remain);
        this._process(below, index, true);
      }
    };
    GlobSync.prototype._processSimple = function(prefix, index) {
      var exists = this._stat(prefix);
      if (!this.matches[index])
        this.matches[index] = /* @__PURE__ */ Object.create(null);
      if (!exists)
        return;
      if (prefix && isAbsolute(prefix) && !this.nomount) {
        var trail = /[\/\\]$/.test(prefix);
        if (prefix.charAt(0) === "/") {
          prefix = path.join(this.root, prefix);
        } else {
          prefix = path.resolve(this.root, prefix);
          if (trail)
            prefix += "/";
        }
      }
      if (process.platform === "win32")
        prefix = prefix.replace(/\\/g, "/");
      this._emitMatch(index, prefix);
    };
    GlobSync.prototype._stat = function(f) {
      var abs = this._makeAbs(f);
      var needDir = f.slice(-1) === "/";
      if (f.length > this.maxLength)
        return false;
      if (!this.stat && ownProp(this.cache, abs)) {
        var c = this.cache[abs];
        if (Array.isArray(c))
          c = "DIR";
        if (!needDir || c === "DIR")
          return c;
        if (needDir && c === "FILE")
          return false;
      }
      var exists;
      var stat = this.statCache[abs];
      if (!stat) {
        var lstat;
        try {
          lstat = this.fs.lstatSync(abs);
        } catch (er) {
          if (er && (er.code === "ENOENT" || er.code === "ENOTDIR")) {
            this.statCache[abs] = false;
            return false;
          }
        }
        if (lstat && lstat.isSymbolicLink()) {
          try {
            stat = this.fs.statSync(abs);
          } catch (er) {
            stat = lstat;
          }
        } else {
          stat = lstat;
        }
      }
      this.statCache[abs] = stat;
      var c = true;
      if (stat)
        c = stat.isDirectory() ? "DIR" : "FILE";
      this.cache[abs] = this.cache[abs] || c;
      if (needDir && c === "FILE")
        return false;
      return c;
    };
    GlobSync.prototype._mark = function(p) {
      return common.mark(this, p);
    };
    GlobSync.prototype._makeAbs = function(f) {
      return common.makeAbs(this, f);
    };
  }
});

// ../../../node_modules/fstream/node_modules/glob/glob.js
var require_glob3 = __commonJS({
  "../../../node_modules/fstream/node_modules/glob/glob.js"(exports2, module2) {
    module2.exports = glob;
    var rp = require_fs();
    var minimatch = require_minimatch4();
    var Minimatch = minimatch.Minimatch;
    var inherits2 = require_inherits();
    var EE = require("events").EventEmitter;
    var path = require("path");
    var assert = require("assert");
    var isAbsolute = require_path_is_absolute();
    var globSync = require_sync3();
    var common = require_common4();
    var setopts = common.setopts;
    var ownProp = common.ownProp;
    var inflight = require_inflight();
    var util = require("util");
    var childrenIgnored = common.childrenIgnored;
    var isIgnored = common.isIgnored;
    var once = require_once();
    function glob(pattern, options, cb) {
      if (typeof options === "function")
        cb = options, options = {};
      if (!options)
        options = {};
      if (options.sync) {
        if (cb)
          throw new TypeError("callback provided to sync glob");
        return globSync(pattern, options);
      }
      return new Glob(pattern, options, cb);
    }
    glob.sync = globSync;
    var GlobSync = glob.GlobSync = globSync.GlobSync;
    glob.glob = glob;
    function extend(origin, add) {
      if (add === null || typeof add !== "object") {
        return origin;
      }
      var keys = Object.keys(add);
      var i = keys.length;
      while (i--) {
        origin[keys[i]] = add[keys[i]];
      }
      return origin;
    }
    glob.hasMagic = function(pattern, options_) {
      var options = extend({}, options_);
      options.noprocess = true;
      var g = new Glob(pattern, options);
      var set = g.minimatch.set;
      if (!pattern)
        return false;
      if (set.length > 1)
        return true;
      for (var j = 0; j < set[0].length; j++) {
        if (typeof set[0][j] !== "string")
          return true;
      }
      return false;
    };
    glob.Glob = Glob;
    inherits2(Glob, EE);
    function Glob(pattern, options, cb) {
      if (typeof options === "function") {
        cb = options;
        options = null;
      }
      if (options && options.sync) {
        if (cb)
          throw new TypeError("callback provided to sync glob");
        return new GlobSync(pattern, options);
      }
      if (!(this instanceof Glob))
        return new Glob(pattern, options, cb);
      setopts(this, pattern, options);
      this._didRealPath = false;
      var n = this.minimatch.set.length;
      this.matches = new Array(n);
      if (typeof cb === "function") {
        cb = once(cb);
        this.on("error", cb);
        this.on("end", function(matches) {
          cb(null, matches);
        });
      }
      var self2 = this;
      this._processing = 0;
      this._emitQueue = [];
      this._processQueue = [];
      this.paused = false;
      if (this.noprocess)
        return this;
      if (n === 0)
        return done();
      var sync = true;
      for (var i = 0; i < n; i++) {
        this._process(this.minimatch.set[i], i, false, done);
      }
      sync = false;
      function done() {
        --self2._processing;
        if (self2._processing <= 0) {
          if (sync) {
            process.nextTick(function() {
              self2._finish();
            });
          } else {
            self2._finish();
          }
        }
      }
    }
    Glob.prototype._finish = function() {
      assert(this instanceof Glob);
      if (this.aborted)
        return;
      if (this.realpath && !this._didRealpath)
        return this._realpath();
      common.finish(this);
      this.emit("end", this.found);
    };
    Glob.prototype._realpath = function() {
      if (this._didRealpath)
        return;
      this._didRealpath = true;
      var n = this.matches.length;
      if (n === 0)
        return this._finish();
      var self2 = this;
      for (var i = 0; i < this.matches.length; i++)
        this._realpathSet(i, next);
      function next() {
        if (--n === 0)
          self2._finish();
      }
    };
    Glob.prototype._realpathSet = function(index, cb) {
      var matchset = this.matches[index];
      if (!matchset)
        return cb();
      var found = Object.keys(matchset);
      var self2 = this;
      var n = found.length;
      if (n === 0)
        return cb();
      var set = this.matches[index] = /* @__PURE__ */ Object.create(null);
      found.forEach(function(p, i) {
        p = self2._makeAbs(p);
        rp.realpath(p, self2.realpathCache, function(er, real) {
          if (!er)
            set[real] = true;
          else if (er.syscall === "stat")
            set[p] = true;
          else
            self2.emit("error", er);
          if (--n === 0) {
            self2.matches[index] = set;
            cb();
          }
        });
      });
    };
    Glob.prototype._mark = function(p) {
      return common.mark(this, p);
    };
    Glob.prototype._makeAbs = function(f) {
      return common.makeAbs(this, f);
    };
    Glob.prototype.abort = function() {
      this.aborted = true;
      this.emit("abort");
    };
    Glob.prototype.pause = function() {
      if (!this.paused) {
        this.paused = true;
        this.emit("pause");
      }
    };
    Glob.prototype.resume = function() {
      if (this.paused) {
        this.emit("resume");
        this.paused = false;
        if (this._emitQueue.length) {
          var eq = this._emitQueue.slice(0);
          this._emitQueue.length = 0;
          for (var i = 0; i < eq.length; i++) {
            var e = eq[i];
            this._emitMatch(e[0], e[1]);
          }
        }
        if (this._processQueue.length) {
          var pq = this._processQueue.slice(0);
          this._processQueue.length = 0;
          for (var i = 0; i < pq.length; i++) {
            var p = pq[i];
            this._processing--;
            this._process(p[0], p[1], p[2], p[3]);
          }
        }
      }
    };
    Glob.prototype._process = function(pattern, index, inGlobStar, cb) {
      assert(this instanceof Glob);
      assert(typeof cb === "function");
      if (this.aborted)
        return;
      this._processing++;
      if (this.paused) {
        this._processQueue.push([pattern, index, inGlobStar, cb]);
        return;
      }
      var n = 0;
      while (typeof pattern[n] === "string") {
        n++;
      }
      var prefix;
      switch (n) {
        case pattern.length:
          this._processSimple(pattern.join("/"), index, cb);
          return;
        case 0:
          prefix = null;
          break;
        default:
          prefix = pattern.slice(0, n).join("/");
          break;
      }
      var remain = pattern.slice(n);
      var read;
      if (prefix === null)
        read = ".";
      else if (isAbsolute(prefix) || isAbsolute(pattern.map(function(p) {
        return typeof p === "string" ? p : "[*]";
      }).join("/"))) {
        if (!prefix || !isAbsolute(prefix))
          prefix = "/" + prefix;
        read = prefix;
      } else
        read = prefix;
      var abs = this._makeAbs(read);
      if (childrenIgnored(this, read))
        return cb();
      var isGlobStar = remain[0] === minimatch.GLOBSTAR;
      if (isGlobStar)
        this._processGlobStar(prefix, read, abs, remain, index, inGlobStar, cb);
      else
        this._processReaddir(prefix, read, abs, remain, index, inGlobStar, cb);
    };
    Glob.prototype._processReaddir = function(prefix, read, abs, remain, index, inGlobStar, cb) {
      var self2 = this;
      this._readdir(abs, inGlobStar, function(er, entries) {
        return self2._processReaddir2(prefix, read, abs, remain, index, inGlobStar, entries, cb);
      });
    };
    Glob.prototype._processReaddir2 = function(prefix, read, abs, remain, index, inGlobStar, entries, cb) {
      if (!entries)
        return cb();
      var pn = remain[0];
      var negate = !!this.minimatch.negate;
      var rawGlob = pn._glob;
      var dotOk = this.dot || rawGlob.charAt(0) === ".";
      var matchedEntries = [];
      for (var i = 0; i < entries.length; i++) {
        var e = entries[i];
        if (e.charAt(0) !== "." || dotOk) {
          var m;
          if (negate && !prefix) {
            m = !e.match(pn);
          } else {
            m = e.match(pn);
          }
          if (m)
            matchedEntries.push(e);
        }
      }
      var len = matchedEntries.length;
      if (len === 0)
        return cb();
      if (remain.length === 1 && !this.mark && !this.stat) {
        if (!this.matches[index])
          this.matches[index] = /* @__PURE__ */ Object.create(null);
        for (var i = 0; i < len; i++) {
          var e = matchedEntries[i];
          if (prefix) {
            if (prefix !== "/")
              e = prefix + "/" + e;
            else
              e = prefix + e;
          }
          if (e.charAt(0) === "/" && !this.nomount) {
            e = path.join(this.root, e);
          }
          this._emitMatch(index, e);
        }
        return cb();
      }
      remain.shift();
      for (var i = 0; i < len; i++) {
        var e = matchedEntries[i];
        var newPattern;
        if (prefix) {
          if (prefix !== "/")
            e = prefix + "/" + e;
          else
            e = prefix + e;
        }
        this._process([e].concat(remain), index, inGlobStar, cb);
      }
      cb();
    };
    Glob.prototype._emitMatch = function(index, e) {
      if (this.aborted)
        return;
      if (isIgnored(this, e))
        return;
      if (this.paused) {
        this._emitQueue.push([index, e]);
        return;
      }
      var abs = isAbsolute(e) ? e : this._makeAbs(e);
      if (this.mark)
        e = this._mark(e);
      if (this.absolute)
        e = abs;
      if (this.matches[index][e])
        return;
      if (this.nodir) {
        var c = this.cache[abs];
        if (c === "DIR" || Array.isArray(c))
          return;
      }
      this.matches[index][e] = true;
      var st = this.statCache[abs];
      if (st)
        this.emit("stat", e, st);
      this.emit("match", e);
    };
    Glob.prototype._readdirInGlobStar = function(abs, cb) {
      if (this.aborted)
        return;
      if (this.follow)
        return this._readdir(abs, false, cb);
      var lstatkey = "lstat\0" + abs;
      var self2 = this;
      var lstatcb = inflight(lstatkey, lstatcb_);
      if (lstatcb)
        self2.fs.lstat(abs, lstatcb);
      function lstatcb_(er, lstat) {
        if (er && er.code === "ENOENT")
          return cb();
        var isSym = lstat && lstat.isSymbolicLink();
        self2.symlinks[abs] = isSym;
        if (!isSym && lstat && !lstat.isDirectory()) {
          self2.cache[abs] = "FILE";
          cb();
        } else
          self2._readdir(abs, false, cb);
      }
    };
    Glob.prototype._readdir = function(abs, inGlobStar, cb) {
      if (this.aborted)
        return;
      cb = inflight("readdir\0" + abs + "\0" + inGlobStar, cb);
      if (!cb)
        return;
      if (inGlobStar && !ownProp(this.symlinks, abs))
        return this._readdirInGlobStar(abs, cb);
      if (ownProp(this.cache, abs)) {
        var c = this.cache[abs];
        if (!c || c === "FILE")
          return cb();
        if (Array.isArray(c))
          return cb(null, c);
      }
      var self2 = this;
      self2.fs.readdir(abs, readdirCb(this, abs, cb));
    };
    function readdirCb(self2, abs, cb) {
      return function(er, entries) {
        if (er)
          self2._readdirError(abs, er, cb);
        else
          self2._readdirEntries(abs, entries, cb);
      };
    }
    Glob.prototype._readdirEntries = function(abs, entries, cb) {
      if (this.aborted)
        return;
      if (!this.mark && !this.stat) {
        for (var i = 0; i < entries.length; i++) {
          var e = entries[i];
          if (abs === "/")
            e = abs + e;
          else
            e = abs + "/" + e;
          this.cache[e] = true;
        }
      }
      this.cache[abs] = entries;
      return cb(null, entries);
    };
    Glob.prototype._readdirError = function(f, er, cb) {
      if (this.aborted)
        return;
      switch (er.code) {
        case "ENOTSUP":
        case "ENOTDIR":
          var abs = this._makeAbs(f);
          this.cache[abs] = "FILE";
          if (abs === this.cwdAbs) {
            var error = new Error(er.code + " invalid cwd " + this.cwd);
            error.path = this.cwd;
            error.code = er.code;
            this.emit("error", error);
            this.abort();
          }
          break;
        case "ENOENT":
        case "ELOOP":
        case "ENAMETOOLONG":
        case "UNKNOWN":
          this.cache[this._makeAbs(f)] = false;
          break;
        default:
          this.cache[this._makeAbs(f)] = false;
          if (this.strict) {
            this.emit("error", er);
            this.abort();
          }
          if (!this.silent)
            console.error("glob error", er);
          break;
      }
      return cb();
    };
    Glob.prototype._processGlobStar = function(prefix, read, abs, remain, index, inGlobStar, cb) {
      var self2 = this;
      this._readdir(abs, inGlobStar, function(er, entries) {
        self2._processGlobStar2(prefix, read, abs, remain, index, inGlobStar, entries, cb);
      });
    };
    Glob.prototype._processGlobStar2 = function(prefix, read, abs, remain, index, inGlobStar, entries, cb) {
      if (!entries)
        return cb();
      var remainWithoutGlobStar = remain.slice(1);
      var gspref = prefix ? [prefix] : [];
      var noGlobStar = gspref.concat(remainWithoutGlobStar);
      this._process(noGlobStar, index, false, cb);
      var isSym = this.symlinks[abs];
      var len = entries.length;
      if (isSym && inGlobStar)
        return cb();
      for (var i = 0; i < len; i++) {
        var e = entries[i];
        if (e.charAt(0) === "." && !this.dot)
          continue;
        var instead = gspref.concat(entries[i], remainWithoutGlobStar);
        this._process(instead, index, true, cb);
        var below = gspref.concat(entries[i], remain);
        this._process(below, index, true, cb);
      }
      cb();
    };
    Glob.prototype._processSimple = function(prefix, index, cb) {
      var self2 = this;
      this._stat(prefix, function(er, exists) {
        self2._processSimple2(prefix, index, er, exists, cb);
      });
    };
    Glob.prototype._processSimple2 = function(prefix, index, er, exists, cb) {
      if (!this.matches[index])
        this.matches[index] = /* @__PURE__ */ Object.create(null);
      if (!exists)
        return cb();
      if (prefix && isAbsolute(prefix) && !this.nomount) {
        var trail = /[\/\\]$/.test(prefix);
        if (prefix.charAt(0) === "/") {
          prefix = path.join(this.root, prefix);
        } else {
          prefix = path.resolve(this.root, prefix);
          if (trail)
            prefix += "/";
        }
      }
      if (process.platform === "win32")
        prefix = prefix.replace(/\\/g, "/");
      this._emitMatch(index, prefix);
      cb();
    };
    Glob.prototype._stat = function(f, cb) {
      var abs = this._makeAbs(f);
      var needDir = f.slice(-1) === "/";
      if (f.length > this.maxLength)
        return cb();
      if (!this.stat && ownProp(this.cache, abs)) {
        var c = this.cache[abs];
        if (Array.isArray(c))
          c = "DIR";
        if (!needDir || c === "DIR")
          return cb(null, c);
        if (needDir && c === "FILE")
          return cb();
      }
      var exists;
      var stat = this.statCache[abs];
      if (stat !== void 0) {
        if (stat === false)
          return cb(null, stat);
        else {
          var type = stat.isDirectory() ? "DIR" : "FILE";
          if (needDir && type === "FILE")
            return cb();
          else
            return cb(null, type, stat);
        }
      }
      var self2 = this;
      var statcb = inflight("stat\0" + abs, lstatcb_);
      if (statcb)
        self2.fs.lstat(abs, statcb);
      function lstatcb_(er, lstat) {
        if (lstat && lstat.isSymbolicLink()) {
          return self2.fs.stat(abs, function(er2, stat2) {
            if (er2)
              self2._stat2(f, abs, null, lstat, cb);
            else
              self2._stat2(f, abs, er2, stat2, cb);
          });
        } else {
          self2._stat2(f, abs, er, lstat, cb);
        }
      }
    };
    Glob.prototype._stat2 = function(f, abs, er, stat, cb) {
      if (er && (er.code === "ENOENT" || er.code === "ENOTDIR")) {
        this.statCache[abs] = false;
        return cb();
      }
      var needDir = f.slice(-1) === "/";
      this.statCache[abs] = stat;
      if (abs.slice(-1) === "/" && stat && !stat.isDirectory())
        return cb(null, false, stat);
      var c = true;
      if (stat)
        c = stat.isDirectory() ? "DIR" : "FILE";
      this.cache[abs] = this.cache[abs] || c;
      if (needDir && c === "FILE")
        return cb();
      return cb(null, c, stat);
    };
  }
});

// ../../../node_modules/fstream/node_modules/rimraf/rimraf.js
var require_rimraf = __commonJS({
  "../../../node_modules/fstream/node_modules/rimraf/rimraf.js"(exports2, module2) {
    module2.exports = rimraf;
    rimraf.sync = rimrafSync;
    var assert = require("assert");
    var path = require("path");
    var fs = require("fs");
    var glob = void 0;
    try {
      glob = require_glob3();
    } catch (_err) {
    }
    var _0666 = parseInt("666", 8);
    var defaultGlobOpts = {
      nosort: true,
      silent: true
    };
    var timeout = 0;
    var isWindows = process.platform === "win32";
    function defaults(options) {
      var methods = [
        "unlink",
        "chmod",
        "stat",
        "lstat",
        "rmdir",
        "readdir"
      ];
      methods.forEach(function(m) {
        options[m] = options[m] || fs[m];
        m = m + "Sync";
        options[m] = options[m] || fs[m];
      });
      options.maxBusyTries = options.maxBusyTries || 3;
      options.emfileWait = options.emfileWait || 1e3;
      if (options.glob === false) {
        options.disableGlob = true;
      }
      if (options.disableGlob !== true && glob === void 0) {
        throw Error("glob dependency not found, set `options.disableGlob = true` if intentional");
      }
      options.disableGlob = options.disableGlob || false;
      options.glob = options.glob || defaultGlobOpts;
    }
    function rimraf(p, options, cb) {
      if (typeof options === "function") {
        cb = options;
        options = {};
      }
      assert(p, "rimraf: missing path");
      assert.equal(typeof p, "string", "rimraf: path should be a string");
      assert.equal(typeof cb, "function", "rimraf: callback function required");
      assert(options, "rimraf: invalid options argument provided");
      assert.equal(typeof options, "object", "rimraf: options should be object");
      defaults(options);
      var busyTries = 0;
      var errState = null;
      var n = 0;
      if (options.disableGlob || !glob.hasMagic(p))
        return afterGlob(null, [p]);
      options.lstat(p, function(er, stat) {
        if (!er)
          return afterGlob(null, [p]);
        glob(p, options.glob, afterGlob);
      });
      function next(er) {
        errState = errState || er;
        if (--n === 0)
          cb(errState);
      }
      function afterGlob(er, results) {
        if (er)
          return cb(er);
        n = results.length;
        if (n === 0)
          return cb();
        results.forEach(function(p2) {
          rimraf_(p2, options, function CB(er2) {
            if (er2) {
              if ((er2.code === "EBUSY" || er2.code === "ENOTEMPTY" || er2.code === "EPERM") && busyTries < options.maxBusyTries) {
                busyTries++;
                var time = busyTries * 100;
                return setTimeout(function() {
                  rimraf_(p2, options, CB);
                }, time);
              }
              if (er2.code === "EMFILE" && timeout < options.emfileWait) {
                return setTimeout(function() {
                  rimraf_(p2, options, CB);
                }, timeout++);
              }
              if (er2.code === "ENOENT")
                er2 = null;
            }
            timeout = 0;
            next(er2);
          });
        });
      }
    }
    function rimraf_(p, options, cb) {
      assert(p);
      assert(options);
      assert(typeof cb === "function");
      options.lstat(p, function(er, st) {
        if (er && er.code === "ENOENT")
          return cb(null);
        if (er && er.code === "EPERM" && isWindows)
          fixWinEPERM(p, options, er, cb);
        if (st && st.isDirectory())
          return rmdir(p, options, er, cb);
        options.unlink(p, function(er2) {
          if (er2) {
            if (er2.code === "ENOENT")
              return cb(null);
            if (er2.code === "EPERM")
              return isWindows ? fixWinEPERM(p, options, er2, cb) : rmdir(p, options, er2, cb);
            if (er2.code === "EISDIR")
              return rmdir(p, options, er2, cb);
          }
          return cb(er2);
        });
      });
    }
    function fixWinEPERM(p, options, er, cb) {
      assert(p);
      assert(options);
      assert(typeof cb === "function");
      if (er)
        assert(er instanceof Error);
      options.chmod(p, _0666, function(er2) {
        if (er2)
          cb(er2.code === "ENOENT" ? null : er);
        else
          options.stat(p, function(er3, stats) {
            if (er3)
              cb(er3.code === "ENOENT" ? null : er);
            else if (stats.isDirectory())
              rmdir(p, options, er, cb);
            else
              options.unlink(p, cb);
          });
      });
    }
    function fixWinEPERMSync(p, options, er) {
      assert(p);
      assert(options);
      if (er)
        assert(er instanceof Error);
      try {
        options.chmodSync(p, _0666);
      } catch (er2) {
        if (er2.code === "ENOENT")
          return;
        else
          throw er;
      }
      try {
        var stats = options.statSync(p);
      } catch (er3) {
        if (er3.code === "ENOENT")
          return;
        else
          throw er;
      }
      if (stats.isDirectory())
        rmdirSync(p, options, er);
      else
        options.unlinkSync(p);
    }
    function rmdir(p, options, originalEr, cb) {
      assert(p);
      assert(options);
      if (originalEr)
        assert(originalEr instanceof Error);
      assert(typeof cb === "function");
      options.rmdir(p, function(er) {
        if (er && (er.code === "ENOTEMPTY" || er.code === "EEXIST" || er.code === "EPERM"))
          rmkids(p, options, cb);
        else if (er && er.code === "ENOTDIR")
          cb(originalEr);
        else
          cb(er);
      });
    }
    function rmkids(p, options, cb) {
      assert(p);
      assert(options);
      assert(typeof cb === "function");
      options.readdir(p, function(er, files) {
        if (er)
          return cb(er);
        var n = files.length;
        if (n === 0)
          return options.rmdir(p, cb);
        var errState;
        files.forEach(function(f) {
          rimraf(path.join(p, f), options, function(er2) {
            if (errState)
              return;
            if (er2)
              return cb(errState = er2);
            if (--n === 0)
              options.rmdir(p, cb);
          });
        });
      });
    }
    function rimrafSync(p, options) {
      options = options || {};
      defaults(options);
      assert(p, "rimraf: missing path");
      assert.equal(typeof p, "string", "rimraf: path should be a string");
      assert(options, "rimraf: missing options");
      assert.equal(typeof options, "object", "rimraf: options should be object");
      var results;
      if (options.disableGlob || !glob.hasMagic(p)) {
        results = [p];
      } else {
        try {
          options.lstatSync(p);
          results = [p];
        } catch (er) {
          results = glob.sync(p, options.glob);
        }
      }
      if (!results.length)
        return;
      for (var i = 0; i < results.length; i++) {
        var p = results[i];
        try {
          var st = options.lstatSync(p);
        } catch (er) {
          if (er.code === "ENOENT")
            return;
          if (er.code === "EPERM" && isWindows)
            fixWinEPERMSync(p, options, er);
        }
        try {
          if (st && st.isDirectory())
            rmdirSync(p, options, null);
          else
            options.unlinkSync(p);
        } catch (er) {
          if (er.code === "ENOENT")
            return;
          if (er.code === "EPERM")
            return isWindows ? fixWinEPERMSync(p, options, er) : rmdirSync(p, options, er);
          if (er.code !== "EISDIR")
            throw er;
          rmdirSync(p, options, er);
        }
      }
    }
    function rmdirSync(p, options, originalEr) {
      assert(p);
      assert(options);
      if (originalEr)
        assert(originalEr instanceof Error);
      try {
        options.rmdirSync(p);
      } catch (er) {
        if (er.code === "ENOENT")
          return;
        if (er.code === "ENOTDIR")
          throw originalEr;
        if (er.code === "ENOTEMPTY" || er.code === "EEXIST" || er.code === "EPERM")
          rmkidsSync(p, options);
      }
    }
    function rmkidsSync(p, options) {
      assert(p);
      assert(options);
      options.readdirSync(p).forEach(function(f) {
        rimrafSync(path.join(p, f), options);
      });
      var retries = isWindows ? 100 : 1;
      var i = 0;
      do {
        var threw = true;
        try {
          var ret2 = options.rmdirSync(p, options);
          threw = false;
          return ret2;
        } finally {
          if (++i < retries && threw)
            continue;
        }
      } while (true);
    }
  }
});

// ../../../node_modules/fstream/node_modules/mkdirp/index.js
var require_mkdirp = __commonJS({
  "../../../node_modules/fstream/node_modules/mkdirp/index.js"(exports2, module2) {
    var path = require("path");
    var fs = require("fs");
    var _0777 = parseInt("0777", 8);
    module2.exports = mkdirP.mkdirp = mkdirP.mkdirP = mkdirP;
    function mkdirP(p, opts, f, made) {
      if (typeof opts === "function") {
        f = opts;
        opts = {};
      } else if (!opts || typeof opts !== "object") {
        opts = { mode: opts };
      }
      var mode = opts.mode;
      var xfs = opts.fs || fs;
      if (mode === void 0) {
        mode = _0777;
      }
      if (!made)
        made = null;
      var cb = f || /* istanbul ignore next */
      function() {
      };
      p = path.resolve(p);
      xfs.mkdir(p, mode, function(er) {
        if (!er) {
          made = made || p;
          return cb(null, made);
        }
        switch (er.code) {
          case "ENOENT":
            if (path.dirname(p) === p)
              return cb(er);
            mkdirP(path.dirname(p), opts, function(er2, made2) {
              if (er2)
                cb(er2, made2);
              else
                mkdirP(p, opts, cb, made2);
            });
            break;
          default:
            xfs.stat(p, function(er2, stat) {
              if (er2 || !stat.isDirectory())
                cb(er, made);
              else
                cb(null, made);
            });
            break;
        }
      });
    }
    mkdirP.sync = function sync(p, opts, made) {
      if (!opts || typeof opts !== "object") {
        opts = { mode: opts };
      }
      var mode = opts.mode;
      var xfs = opts.fs || fs;
      if (mode === void 0) {
        mode = _0777;
      }
      if (!made)
        made = null;
      p = path.resolve(p);
      try {
        xfs.mkdirSync(p, mode);
        made = made || p;
      } catch (err0) {
        switch (err0.code) {
          case "ENOENT":
            made = sync(path.dirname(p), opts, made);
            sync(p, opts, made);
            break;
          default:
            var stat;
            try {
              stat = xfs.statSync(p);
            } catch (err1) {
              throw err0;
            }
            if (!stat.isDirectory())
              throw err0;
            break;
        }
      }
      return made;
    };
  }
});

// ../../../node_modules/fstream/lib/collect.js
var require_collect = __commonJS({
  "../../../node_modules/fstream/lib/collect.js"(exports2, module2) {
    module2.exports = collect;
    function collect(stream) {
      if (stream._collected)
        return;
      if (stream._paused)
        return stream.on("resume", collect.bind(null, stream));
      stream._collected = true;
      stream.pause();
      stream.on("data", save);
      stream.on("end", save);
      var buf = [];
      function save(b) {
        if (typeof b === "string")
          b = new Buffer(b);
        if (Buffer.isBuffer(b) && !b.length)
          return;
        buf.push(b);
      }
      stream.on("entry", saveEntry);
      var entryBuffer = [];
      function saveEntry(e) {
        collect(e);
        entryBuffer.push(e);
      }
      stream.on("proxy", proxyPause);
      function proxyPause(p) {
        p.pause();
      }
      stream.pipe = /* @__PURE__ */ function(orig) {
        return function(dest) {
          var e = 0;
          (function unblockEntry() {
            var entry = entryBuffer[e++];
            if (!entry)
              return resume();
            entry.on("end", unblockEntry);
            if (dest)
              dest.add(entry);
            else
              stream.emit("entry", entry);
          })();
          function resume() {
            stream.removeListener("entry", saveEntry);
            stream.removeListener("data", save);
            stream.removeListener("end", save);
            stream.pipe = orig;
            if (dest)
              stream.pipe(dest);
            buf.forEach(function(b) {
              if (b)
                stream.emit("data", b);
              else
                stream.emit("end");
            });
            stream.resume();
          }
          return dest;
        };
      }(stream.pipe);
    }
  }
});

// ../../../node_modules/fstream/lib/dir-writer.js
var require_dir_writer = __commonJS({
  "../../../node_modules/fstream/lib/dir-writer.js"(exports2, module2) {
    module2.exports = DirWriter;
    var Writer = require_writer();
    var inherits2 = require_inherits();
    var mkdir = require_mkdirp();
    var path = require("path");
    var collect = require_collect();
    inherits2(DirWriter, Writer);
    function DirWriter(props) {
      var self2 = this;
      if (!(self2 instanceof DirWriter)) {
        self2.error("DirWriter must be called as constructor.", null, true);
      }
      if (props.type !== "Directory" || !props.Directory) {
        self2.error("Non-directory type " + props.type + " " + JSON.stringify(props), null, true);
      }
      Writer.call(this, props);
    }
    DirWriter.prototype._create = function() {
      var self2 = this;
      mkdir(self2._path, Writer.dirmode, function(er) {
        if (er)
          return self2.error(er);
        self2.ready = true;
        self2.emit("ready");
        self2._process();
      });
    };
    DirWriter.prototype.write = function() {
      return true;
    };
    DirWriter.prototype.end = function() {
      this._ended = true;
      this._process();
    };
    DirWriter.prototype.add = function(entry) {
      var self2 = this;
      collect(entry);
      if (!self2.ready || self2._currentEntry) {
        self2._buffer.push(entry);
        return false;
      }
      if (self2._ended) {
        return self2.error("add after end");
      }
      self2._buffer.push(entry);
      self2._process();
      return this._buffer.length === 0;
    };
    DirWriter.prototype._process = function() {
      var self2 = this;
      if (self2._processing)
        return;
      var entry = self2._buffer.shift();
      if (!entry) {
        self2.emit("drain");
        if (self2._ended)
          self2._finish();
        return;
      }
      self2._processing = true;
      self2.emit("entry", entry);
      var p = entry;
      var pp;
      do {
        pp = p._path || p.path;
        if (pp === self2.root._path || pp === self2._path || pp && pp.indexOf(self2._path) === 0) {
          self2._processing = false;
          if (entry._collected)
            entry.pipe();
          return self2._process();
        }
        p = p.parent;
      } while (p);
      var props = {
        parent: self2,
        root: self2.root || self2,
        type: entry.type,
        depth: self2.depth + 1
      };
      pp = entry._path || entry.path || entry.props.path;
      if (entry.parent) {
        pp = pp.substr(entry.parent._path.length + 1);
      }
      props.path = path.join(self2.path, path.join("/", pp));
      props.filter = self2.filter;
      Object.keys(entry.props).forEach(function(k) {
        if (!props.hasOwnProperty(k)) {
          props[k] = entry.props[k];
        }
      });
      var child = self2._currentChild = new Writer(props);
      child.on("ready", function() {
        entry.pipe(child);
        entry.resume();
      });
      child.on("error", function(er) {
        if (child._swallowErrors) {
          self2.warn(er);
          child.emit("end");
          child.emit("close");
        } else {
          self2.emit("error", er);
        }
      });
      child.on("close", onend);
      var ended = false;
      function onend() {
        if (ended)
          return;
        ended = true;
        self2._currentChild = null;
        self2._processing = false;
        self2._process();
      }
    };
  }
});

// ../../../node_modules/fstream/lib/link-writer.js
var require_link_writer = __commonJS({
  "../../../node_modules/fstream/lib/link-writer.js"(exports2, module2) {
    module2.exports = LinkWriter;
    var fs = require_graceful_fs();
    var Writer = require_writer();
    var inherits2 = require_inherits();
    var path = require("path");
    var rimraf = require_rimraf();
    inherits2(LinkWriter, Writer);
    function LinkWriter(props) {
      var self2 = this;
      if (!(self2 instanceof LinkWriter)) {
        throw new Error("LinkWriter must be called as constructor.");
      }
      if (!(props.type === "Link" && props.Link || props.type === "SymbolicLink" && props.SymbolicLink)) {
        throw new Error("Non-link type " + props.type);
      }
      if (props.linkpath === "")
        props.linkpath = ".";
      if (!props.linkpath) {
        self2.error("Need linkpath property to create " + props.type);
      }
      Writer.call(this, props);
    }
    LinkWriter.prototype._create = function() {
      var self2 = this;
      var hard = self2.type === "Link" || process.platform === "win32";
      var link = hard ? "link" : "symlink";
      var lp = hard ? path.resolve(self2.dirname, self2.linkpath) : self2.linkpath;
      if (hard)
        return clobber(self2, lp, link);
      fs.readlink(self2._path, function(er, p) {
        if (p && p === lp)
          return finish(self2);
        clobber(self2, lp, link);
      });
    };
    function clobber(self2, lp, link) {
      rimraf(self2._path, function(er) {
        if (er)
          return self2.error(er);
        create(self2, lp, link);
      });
    }
    function create(self2, lp, link) {
      fs[link](lp, self2._path, function(er) {
        if (er) {
          if ((er.code === "ENOENT" || er.code === "EACCES" || er.code === "EPERM") && process.platform === "win32") {
            self2.ready = true;
            self2.emit("ready");
            self2.emit("end");
            self2.emit("close");
            self2.end = self2._finish = function() {
            };
          } else
            return self2.error(er);
        }
        finish(self2);
      });
    }
    function finish(self2) {
      self2.ready = true;
      self2.emit("ready");
      if (self2._ended && !self2._finished)
        self2._finish();
    }
    LinkWriter.prototype.end = function() {
      this._ended = true;
      if (this.ready) {
        this._finished = true;
        this._finish();
      }
    };
  }
});

// ../../../node_modules/fstream/lib/file-writer.js
var require_file_writer = __commonJS({
  "../../../node_modules/fstream/lib/file-writer.js"(exports2, module2) {
    module2.exports = FileWriter;
    var fs = require_graceful_fs();
    var Writer = require_writer();
    var inherits2 = require_inherits();
    var EOF = {};
    inherits2(FileWriter, Writer);
    function FileWriter(props) {
      var self2 = this;
      if (!(self2 instanceof FileWriter)) {
        throw new Error("FileWriter must be called as constructor.");
      }
      if (props.type !== "File" || !props.File) {
        throw new Error("Non-file type " + props.type);
      }
      self2._buffer = [];
      self2._bytesWritten = 0;
      Writer.call(this, props);
    }
    FileWriter.prototype._create = function() {
      var self2 = this;
      if (self2._stream)
        return;
      var so = {};
      if (self2.props.flags)
        so.flags = self2.props.flags;
      so.mode = Writer.filemode;
      if (self2._old && self2._old.blksize)
        so.bufferSize = self2._old.blksize;
      self2._stream = fs.createWriteStream(self2._path, so);
      self2._stream.on("open", function() {
        self2.ready = true;
        self2._buffer.forEach(function(c) {
          if (c === EOF)
            self2._stream.end();
          else
            self2._stream.write(c);
        });
        self2.emit("ready");
        self2.emit("drain");
      });
      self2._stream.on("error", function(er) {
        self2.emit("error", er);
      });
      self2._stream.on("drain", function() {
        self2.emit("drain");
      });
      self2._stream.on("close", function() {
        self2._finish();
      });
    };
    FileWriter.prototype.write = function(c) {
      var self2 = this;
      self2._bytesWritten += c.length;
      if (!self2.ready) {
        if (!Buffer.isBuffer(c) && typeof c !== "string") {
          throw new Error("invalid write data");
        }
        self2._buffer.push(c);
        return false;
      }
      var ret2 = self2._stream.write(c);
      if (ret2 === false && self2._stream._queue) {
        return self2._stream._queue.length <= 2;
      } else {
        return ret2;
      }
    };
    FileWriter.prototype.end = function(c) {
      var self2 = this;
      if (c)
        self2.write(c);
      if (!self2.ready) {
        self2._buffer.push(EOF);
        return false;
      }
      return self2._stream.end();
    };
    FileWriter.prototype._finish = function() {
      var self2 = this;
      if (typeof self2.size === "number" && self2._bytesWritten !== self2.size) {
        self2.error(
          "Did not get expected byte count.\nexpect: " + self2.size + "\nactual: " + self2._bytesWritten
        );
      }
      Writer.prototype._finish.call(self2);
    };
  }
});

// ../../../node_modules/fstream/lib/proxy-writer.js
var require_proxy_writer = __commonJS({
  "../../../node_modules/fstream/lib/proxy-writer.js"(exports2, module2) {
    module2.exports = ProxyWriter;
    var Writer = require_writer();
    var getType = require_get_type();
    var inherits2 = require_inherits();
    var collect = require_collect();
    var fs = require("fs");
    inherits2(ProxyWriter, Writer);
    function ProxyWriter(props) {
      var self2 = this;
      if (!(self2 instanceof ProxyWriter)) {
        throw new Error("ProxyWriter must be called as constructor.");
      }
      self2.props = props;
      self2._needDrain = false;
      Writer.call(self2, props);
    }
    ProxyWriter.prototype._stat = function() {
      var self2 = this;
      var props = self2.props;
      var stat = props.follow ? "stat" : "lstat";
      fs[stat](props.path, function(er, current) {
        var type;
        if (er || !current) {
          type = "File";
        } else {
          type = getType(current);
        }
        props[type] = true;
        props.type = self2.type = type;
        self2._old = current;
        self2._addProxy(Writer(props, current));
      });
    };
    ProxyWriter.prototype._addProxy = function(proxy) {
      var self2 = this;
      if (self2._proxy) {
        return self2.error("proxy already set");
      }
      self2._proxy = proxy;
      [
        "ready",
        "error",
        "close",
        "pipe",
        "drain",
        "warn"
      ].forEach(function(ev) {
        proxy.on(ev, self2.emit.bind(self2, ev));
      });
      self2.emit("proxy", proxy);
      var calls = self2._buffer;
      calls.forEach(function(c) {
        proxy[c[0]].apply(proxy, c[1]);
      });
      self2._buffer.length = 0;
      if (self2._needsDrain)
        self2.emit("drain");
    };
    ProxyWriter.prototype.add = function(entry) {
      collect(entry);
      if (!this._proxy) {
        this._buffer.push(["add", [entry]]);
        this._needDrain = true;
        return false;
      }
      return this._proxy.add(entry);
    };
    ProxyWriter.prototype.write = function(c) {
      if (!this._proxy) {
        this._buffer.push(["write", [c]]);
        this._needDrain = true;
        return false;
      }
      return this._proxy.write(c);
    };
    ProxyWriter.prototype.end = function(c) {
      if (!this._proxy) {
        this._buffer.push(["end", [c]]);
        return false;
      }
      return this._proxy.end(c);
    };
  }
});

// ../../../node_modules/fstream/lib/writer.js
var require_writer = __commonJS({
  "../../../node_modules/fstream/lib/writer.js"(exports2, module2) {
    module2.exports = Writer;
    var fs = require_graceful_fs();
    var inherits2 = require_inherits();
    var rimraf = require_rimraf();
    var mkdir = require_mkdirp();
    var path = require("path");
    var umask = process.platform === "win32" ? 0 : process.umask();
    var getType = require_get_type();
    var Abstract = require_abstract();
    inherits2(Writer, Abstract);
    Writer.dirmode = parseInt("0777", 8) & ~umask;
    Writer.filemode = parseInt("0666", 8) & ~umask;
    var DirWriter = require_dir_writer();
    var LinkWriter = require_link_writer();
    var FileWriter = require_file_writer();
    var ProxyWriter = require_proxy_writer();
    function Writer(props, current) {
      var self2 = this;
      if (typeof props === "string") {
        props = { path: props };
      }
      var type = getType(props);
      var ClassType = Writer;
      switch (type) {
        case "Directory":
          ClassType = DirWriter;
          break;
        case "File":
          ClassType = FileWriter;
          break;
        case "Link":
        case "SymbolicLink":
          ClassType = LinkWriter;
          break;
        case null:
        default:
          ClassType = ProxyWriter;
          break;
      }
      if (!(self2 instanceof ClassType))
        return new ClassType(props);
      Abstract.call(self2);
      if (!props.path)
        self2.error("Must provide a path", null, true);
      self2.type = props.type;
      self2.props = props;
      self2.depth = props.depth || 0;
      self2.clobber = props.clobber === false ? props.clobber : true;
      self2.parent = props.parent || null;
      self2.root = props.root || props.parent && props.parent.root || self2;
      self2._path = self2.path = path.resolve(props.path);
      if (process.platform === "win32") {
        self2.path = self2._path = self2.path.replace(/\?/g, "_");
        if (self2._path.length >= 260) {
          self2._swallowErrors = true;
          self2._path = "\\\\?\\" + self2.path.replace(/\//g, "\\");
        }
      }
      self2.basename = path.basename(props.path);
      self2.dirname = path.dirname(props.path);
      self2.linkpath = props.linkpath || null;
      props.parent = props.root = null;
      self2.size = props.size;
      if (typeof props.mode === "string") {
        props.mode = parseInt(props.mode, 8);
      }
      self2.readable = false;
      self2.writable = true;
      self2._buffer = [];
      self2.ready = false;
      self2.filter = typeof props.filter === "function" ? props.filter : null;
      self2._stat(current);
    }
    Writer.prototype._create = function() {
      var self2 = this;
      fs[self2.props.follow ? "stat" : "lstat"](self2._path, function(er) {
        if (er) {
          return self2.warn("Cannot create " + self2._path + "\nUnsupported type: " + self2.type, "ENOTSUP");
        }
        self2._finish();
      });
    };
    Writer.prototype._stat = function(current) {
      var self2 = this;
      var props = self2.props;
      var stat = props.follow ? "stat" : "lstat";
      var who = self2._proxy || self2;
      if (current)
        statCb(null, current);
      else
        fs[stat](self2._path, statCb);
      function statCb(er, current2) {
        if (self2.filter && !self2.filter.call(who, who, current2)) {
          self2._aborted = true;
          self2.emit("end");
          self2.emit("close");
          return;
        }
        if (er || !current2) {
          return create(self2);
        }
        self2._old = current2;
        var currentType = getType(current2);
        if (currentType !== self2.type || self2.type === "File" && current2.nlink > 1) {
          return rimraf(self2._path, function(er2) {
            if (er2)
              return self2.error(er2);
            self2._old = null;
            create(self2);
          });
        }
        create(self2);
      }
    };
    function create(self2) {
      mkdir(path.dirname(self2._path), Writer.dirmode, function(er, made) {
        if (er)
          return self2.error(er);
        self2._madeDir = made;
        return self2._create();
      });
    }
    function endChmod(self2, want, current, path2, cb) {
      var wantMode = want.mode;
      var chmod = want.follow || self2.type !== "SymbolicLink" ? "chmod" : "lchmod";
      if (!fs[chmod])
        return cb();
      if (typeof wantMode !== "number")
        return cb();
      var curMode = current.mode & parseInt("0777", 8);
      wantMode = wantMode & parseInt("0777", 8);
      if (wantMode === curMode)
        return cb();
      fs[chmod](path2, wantMode, cb);
    }
    function endChown(self2, want, current, path2, cb) {
      if (process.platform === "win32")
        return cb();
      if (!process.getuid || process.getuid() !== 0)
        return cb();
      if (typeof want.uid !== "number" && typeof want.gid !== "number")
        return cb();
      if (current.uid === want.uid && current.gid === want.gid)
        return cb();
      var chown = self2.props.follow || self2.type !== "SymbolicLink" ? "chown" : "lchown";
      if (!fs[chown])
        return cb();
      if (typeof want.uid !== "number")
        want.uid = current.uid;
      if (typeof want.gid !== "number")
        want.gid = current.gid;
      fs[chown](path2, want.uid, want.gid, cb);
    }
    function endUtimes(self2, want, current, path2, cb) {
      if (!fs.utimes || process.platform === "win32")
        return cb();
      var utimes = want.follow || self2.type !== "SymbolicLink" ? "utimes" : "lutimes";
      if (utimes === "lutimes" && !fs[utimes]) {
        utimes = "utimes";
      }
      if (!fs[utimes])
        return cb();
      var curA = current.atime;
      var curM = current.mtime;
      var meA = want.atime;
      var meM = want.mtime;
      if (meA === void 0)
        meA = curA;
      if (meM === void 0)
        meM = curM;
      if (!isDate(meA))
        meA = new Date(meA);
      if (!isDate(meM))
        meA = new Date(meM);
      if (meA.getTime() === curA.getTime() && meM.getTime() === curM.getTime())
        return cb();
      fs[utimes](path2, meA, meM, cb);
    }
    Writer.prototype._finish = function() {
      var self2 = this;
      if (self2._finishing)
        return;
      self2._finishing = true;
      var todo = 0;
      var errState = null;
      var done = false;
      if (self2._old) {
        self2._old.atime = /* @__PURE__ */ new Date(0);
        self2._old.mtime = /* @__PURE__ */ new Date(0);
        setProps(self2._old);
      } else {
        var stat = self2.props.follow ? "stat" : "lstat";
        fs[stat](self2._path, function(er, current) {
          if (er) {
            if (er.code === "ENOENT" && (self2.type === "Link" || self2.type === "SymbolicLink") && process.platform === "win32") {
              self2.ready = true;
              self2.emit("ready");
              self2.emit("end");
              self2.emit("close");
              self2.end = self2._finish = function() {
              };
              return;
            } else
              return self2.error(er);
          }
          setProps(self2._old = current);
        });
      }
      return;
      function setProps(current) {
        todo += 3;
        endChmod(self2, self2.props, current, self2._path, next("chmod"));
        endChown(self2, self2.props, current, self2._path, next("chown"));
        endUtimes(self2, self2.props, current, self2._path, next("utimes"));
      }
      function next(what) {
        return function(er) {
          if (errState)
            return;
          if (er) {
            er.fstream_finish_call = what;
            return self2.error(errState = er);
          }
          if (--todo > 0)
            return;
          if (done)
            return;
          done = true;
          if (!self2._madeDir)
            return end();
          else
            endMadeDir(self2, self2._path, end);
          function end(er2) {
            if (er2) {
              er2.fstream_finish_call = "setupMadeDir";
              return self2.error(er2);
            }
            self2.emit("end");
            self2.emit("close");
          }
        };
      }
    };
    function endMadeDir(self2, p, cb) {
      var made = self2._madeDir;
      var d = path.dirname(p);
      endMadeDir_(self2, d, function(er) {
        if (er)
          return cb(er);
        if (d === made) {
          return cb();
        }
        endMadeDir(self2, d, cb);
      });
    }
    function endMadeDir_(self2, p, cb) {
      var dirProps = {};
      Object.keys(self2.props).forEach(function(k) {
        dirProps[k] = self2.props[k];
        if (k === "mode" && self2.type !== "Directory") {
          dirProps[k] = dirProps[k] | parseInt("0111", 8);
        }
      });
      var todo = 3;
      var errState = null;
      fs.stat(p, function(er, current) {
        if (er)
          return cb(errState = er);
        endChmod(self2, dirProps, current, p, next);
        endChown(self2, dirProps, current, p, next);
        endUtimes(self2, dirProps, current, p, next);
      });
      function next(er) {
        if (errState)
          return;
        if (er)
          return cb(errState = er);
        if (--todo === 0)
          return cb();
      }
    }
    Writer.prototype.pipe = function() {
      this.error("Can't pipe from writable stream");
    };
    Writer.prototype.add = function() {
      this.error("Can't add to non-Directory type");
    };
    Writer.prototype.write = function() {
      return true;
    };
    function objectToString(d) {
      return Object.prototype.toString.call(d);
    }
    function isDate(d) {
      return typeof d === "object" && objectToString(d) === "[object Date]";
    }
  }
});

// ../../../node_modules/fstream/fstream.js
var require_fstream = __commonJS({
  "../../../node_modules/fstream/fstream.js"(exports2) {
    exports2.Abstract = require_abstract();
    exports2.Reader = require_reader();
    exports2.Writer = require_writer();
    exports2.File = {
      Reader: require_file_reader(),
      Writer: require_file_writer()
    };
    exports2.Dir = {
      Reader: require_dir_reader(),
      Writer: require_dir_writer()
    };
    exports2.Link = {
      Reader: require_link_reader(),
      Writer: require_link_writer()
    };
    exports2.Proxy = {
      Reader: require_proxy_reader(),
      Writer: require_proxy_writer()
    };
    exports2.Reader.Dir = exports2.DirReader = exports2.Dir.Reader;
    exports2.Reader.File = exports2.FileReader = exports2.File.Reader;
    exports2.Reader.Link = exports2.LinkReader = exports2.Link.Reader;
    exports2.Reader.Proxy = exports2.ProxyReader = exports2.Proxy.Reader;
    exports2.Writer.Dir = exports2.DirWriter = exports2.Dir.Writer;
    exports2.Writer.File = exports2.FileWriter = exports2.File.Writer;
    exports2.Writer.Link = exports2.LinkWriter = exports2.Link.Writer;
    exports2.Writer.Proxy = exports2.ProxyWriter = exports2.Proxy.Writer;
    exports2.collect = require_collect();
  }
});

// ../../../node_modules/unzipper/lib/extract.js
var require_extract2 = __commonJS({
  "../../../node_modules/unzipper/lib/extract.js"(exports2, module2) {
    module2.exports = Extract;
    var Parse = require_parse();
    var Writer = require_fstream().Writer;
    var path = require("path");
    var stream = require("stream");
    var duplexer2 = require_duplexer2();
    var Promise2 = require_bluebird();
    function Extract(opts) {
      opts.path = path.resolve(path.normalize(opts.path));
      var parser = new Parse(opts);
      var outStream = new stream.Writable({ objectMode: true });
      outStream._write = function(entry, encoding, cb) {
        if (entry.type == "Directory")
          return cb();
        var extractPath = path.join(opts.path, entry.path);
        if (extractPath.indexOf(opts.path) != 0) {
          return cb();
        }
        const writer = opts.getWriter ? opts.getWriter({ path: extractPath }) : Writer({ path: extractPath });
        entry.pipe(writer).on("error", cb).on("close", cb);
      };
      var extract = duplexer2(parser, outStream);
      parser.once("crx-header", function(crxHeader) {
        extract.crxHeader = crxHeader;
      });
      parser.pipe(outStream).on("finish", function() {
        extract.emit("close");
      });
      extract.promise = function() {
        return new Promise2(function(resolve, reject) {
          extract.on("close", resolve);
          extract.on("error", reject);
        });
      };
      return extract;
    }
  }
});

// ../../../node_modules/big-integer/BigInteger.js
var require_BigInteger = __commonJS({
  "../../../node_modules/big-integer/BigInteger.js"(exports2, module2) {
    var bigInt = function(undefined2) {
      "use strict";
      var BASE = 1e7, LOG_BASE = 7, MAX_INT = 9007199254740992, MAX_INT_ARR = smallToArray(MAX_INT), DEFAULT_ALPHABET = "0123456789abcdefghijklmnopqrstuvwxyz";
      var supportsNativeBigInt = typeof BigInt === "function";
      function Integer(v, radix, alphabet, caseSensitive) {
        if (typeof v === "undefined")
          return Integer[0];
        if (typeof radix !== "undefined")
          return +radix === 10 && !alphabet ? parseValue(v) : parseBase(v, radix, alphabet, caseSensitive);
        return parseValue(v);
      }
      function BigInteger(value, sign) {
        this.value = value;
        this.sign = sign;
        this.isSmall = false;
      }
      BigInteger.prototype = Object.create(Integer.prototype);
      function SmallInteger(value) {
        this.value = value;
        this.sign = value < 0;
        this.isSmall = true;
      }
      SmallInteger.prototype = Object.create(Integer.prototype);
      function NativeBigInt(value) {
        this.value = value;
      }
      NativeBigInt.prototype = Object.create(Integer.prototype);
      function isPrecise(n) {
        return -MAX_INT < n && n < MAX_INT;
      }
      function smallToArray(n) {
        if (n < 1e7)
          return [n];
        if (n < 1e14)
          return [n % 1e7, Math.floor(n / 1e7)];
        return [n % 1e7, Math.floor(n / 1e7) % 1e7, Math.floor(n / 1e14)];
      }
      function arrayToSmall(arr) {
        trim(arr);
        var length = arr.length;
        if (length < 4 && compareAbs(arr, MAX_INT_ARR) < 0) {
          switch (length) {
            case 0:
              return 0;
            case 1:
              return arr[0];
            case 2:
              return arr[0] + arr[1] * BASE;
            default:
              return arr[0] + (arr[1] + arr[2] * BASE) * BASE;
          }
        }
        return arr;
      }
      function trim(v) {
        var i2 = v.length;
        while (v[--i2] === 0)
          ;
        v.length = i2 + 1;
      }
      function createArray(length) {
        var x = new Array(length);
        var i2 = -1;
        while (++i2 < length) {
          x[i2] = 0;
        }
        return x;
      }
      function truncate(n) {
        if (n > 0)
          return Math.floor(n);
        return Math.ceil(n);
      }
      function add(a, b) {
        var l_a = a.length, l_b = b.length, r = new Array(l_a), carry = 0, base = BASE, sum, i2;
        for (i2 = 0; i2 < l_b; i2++) {
          sum = a[i2] + b[i2] + carry;
          carry = sum >= base ? 1 : 0;
          r[i2] = sum - carry * base;
        }
        while (i2 < l_a) {
          sum = a[i2] + carry;
          carry = sum === base ? 1 : 0;
          r[i2++] = sum - carry * base;
        }
        if (carry > 0)
          r.push(carry);
        return r;
      }
      function addAny(a, b) {
        if (a.length >= b.length)
          return add(a, b);
        return add(b, a);
      }
      function addSmall(a, carry) {
        var l2 = a.length, r = new Array(l2), base = BASE, sum, i2;
        for (i2 = 0; i2 < l2; i2++) {
          sum = a[i2] - base + carry;
          carry = Math.floor(sum / base);
          r[i2] = sum - carry * base;
          carry += 1;
        }
        while (carry > 0) {
          r[i2++] = carry % base;
          carry = Math.floor(carry / base);
        }
        return r;
      }
      BigInteger.prototype.add = function(v) {
        var n = parseValue(v);
        if (this.sign !== n.sign) {
          return this.subtract(n.negate());
        }
        var a = this.value, b = n.value;
        if (n.isSmall) {
          return new BigInteger(addSmall(a, Math.abs(b)), this.sign);
        }
        return new BigInteger(addAny(a, b), this.sign);
      };
      BigInteger.prototype.plus = BigInteger.prototype.add;
      SmallInteger.prototype.add = function(v) {
        var n = parseValue(v);
        var a = this.value;
        if (a < 0 !== n.sign) {
          return this.subtract(n.negate());
        }
        var b = n.value;
        if (n.isSmall) {
          if (isPrecise(a + b))
            return new SmallInteger(a + b);
          b = smallToArray(Math.abs(b));
        }
        return new BigInteger(addSmall(b, Math.abs(a)), a < 0);
      };
      SmallInteger.prototype.plus = SmallInteger.prototype.add;
      NativeBigInt.prototype.add = function(v) {
        return new NativeBigInt(this.value + parseValue(v).value);
      };
      NativeBigInt.prototype.plus = NativeBigInt.prototype.add;
      function subtract(a, b) {
        var a_l = a.length, b_l = b.length, r = new Array(a_l), borrow = 0, base = BASE, i2, difference;
        for (i2 = 0; i2 < b_l; i2++) {
          difference = a[i2] - borrow - b[i2];
          if (difference < 0) {
            difference += base;
            borrow = 1;
          } else
            borrow = 0;
          r[i2] = difference;
        }
        for (i2 = b_l; i2 < a_l; i2++) {
          difference = a[i2] - borrow;
          if (difference < 0)
            difference += base;
          else {
            r[i2++] = difference;
            break;
          }
          r[i2] = difference;
        }
        for (; i2 < a_l; i2++) {
          r[i2] = a[i2];
        }
        trim(r);
        return r;
      }
      function subtractAny(a, b, sign) {
        var value;
        if (compareAbs(a, b) >= 0) {
          value = subtract(a, b);
        } else {
          value = subtract(b, a);
          sign = !sign;
        }
        value = arrayToSmall(value);
        if (typeof value === "number") {
          if (sign)
            value = -value;
          return new SmallInteger(value);
        }
        return new BigInteger(value, sign);
      }
      function subtractSmall(a, b, sign) {
        var l2 = a.length, r = new Array(l2), carry = -b, base = BASE, i2, difference;
        for (i2 = 0; i2 < l2; i2++) {
          difference = a[i2] + carry;
          carry = Math.floor(difference / base);
          difference %= base;
          r[i2] = difference < 0 ? difference + base : difference;
        }
        r = arrayToSmall(r);
        if (typeof r === "number") {
          if (sign)
            r = -r;
          return new SmallInteger(r);
        }
        return new BigInteger(r, sign);
      }
      BigInteger.prototype.subtract = function(v) {
        var n = parseValue(v);
        if (this.sign !== n.sign) {
          return this.add(n.negate());
        }
        var a = this.value, b = n.value;
        if (n.isSmall)
          return subtractSmall(a, Math.abs(b), this.sign);
        return subtractAny(a, b, this.sign);
      };
      BigInteger.prototype.minus = BigInteger.prototype.subtract;
      SmallInteger.prototype.subtract = function(v) {
        var n = parseValue(v);
        var a = this.value;
        if (a < 0 !== n.sign) {
          return this.add(n.negate());
        }
        var b = n.value;
        if (n.isSmall) {
          return new SmallInteger(a - b);
        }
        return subtractSmall(b, Math.abs(a), a >= 0);
      };
      SmallInteger.prototype.minus = SmallInteger.prototype.subtract;
      NativeBigInt.prototype.subtract = function(v) {
        return new NativeBigInt(this.value - parseValue(v).value);
      };
      NativeBigInt.prototype.minus = NativeBigInt.prototype.subtract;
      BigInteger.prototype.negate = function() {
        return new BigInteger(this.value, !this.sign);
      };
      SmallInteger.prototype.negate = function() {
        var sign = this.sign;
        var small = new SmallInteger(-this.value);
        small.sign = !sign;
        return small;
      };
      NativeBigInt.prototype.negate = function() {
        return new NativeBigInt(-this.value);
      };
      BigInteger.prototype.abs = function() {
        return new BigInteger(this.value, false);
      };
      SmallInteger.prototype.abs = function() {
        return new SmallInteger(Math.abs(this.value));
      };
      NativeBigInt.prototype.abs = function() {
        return new NativeBigInt(this.value >= 0 ? this.value : -this.value);
      };
      function multiplyLong(a, b) {
        var a_l = a.length, b_l = b.length, l2 = a_l + b_l, r = createArray(l2), base = BASE, product, carry, i2, a_i, b_j;
        for (i2 = 0; i2 < a_l; ++i2) {
          a_i = a[i2];
          for (var j = 0; j < b_l; ++j) {
            b_j = b[j];
            product = a_i * b_j + r[i2 + j];
            carry = Math.floor(product / base);
            r[i2 + j] = product - carry * base;
            r[i2 + j + 1] += carry;
          }
        }
        trim(r);
        return r;
      }
      function multiplySmall(a, b) {
        var l2 = a.length, r = new Array(l2), base = BASE, carry = 0, product, i2;
        for (i2 = 0; i2 < l2; i2++) {
          product = a[i2] * b + carry;
          carry = Math.floor(product / base);
          r[i2] = product - carry * base;
        }
        while (carry > 0) {
          r[i2++] = carry % base;
          carry = Math.floor(carry / base);
        }
        return r;
      }
      function shiftLeft(x, n) {
        var r = [];
        while (n-- > 0)
          r.push(0);
        return r.concat(x);
      }
      function multiplyKaratsuba(x, y) {
        var n = Math.max(x.length, y.length);
        if (n <= 30)
          return multiplyLong(x, y);
        n = Math.ceil(n / 2);
        var b = x.slice(n), a = x.slice(0, n), d = y.slice(n), c = y.slice(0, n);
        var ac = multiplyKaratsuba(a, c), bd = multiplyKaratsuba(b, d), abcd = multiplyKaratsuba(addAny(a, b), addAny(c, d));
        var product = addAny(addAny(ac, shiftLeft(subtract(subtract(abcd, ac), bd), n)), shiftLeft(bd, 2 * n));
        trim(product);
        return product;
      }
      function useKaratsuba(l1, l2) {
        return -0.012 * l1 - 0.012 * l2 + 15e-6 * l1 * l2 > 0;
      }
      BigInteger.prototype.multiply = function(v) {
        var n = parseValue(v), a = this.value, b = n.value, sign = this.sign !== n.sign, abs;
        if (n.isSmall) {
          if (b === 0)
            return Integer[0];
          if (b === 1)
            return this;
          if (b === -1)
            return this.negate();
          abs = Math.abs(b);
          if (abs < BASE) {
            return new BigInteger(multiplySmall(a, abs), sign);
          }
          b = smallToArray(abs);
        }
        if (useKaratsuba(a.length, b.length))
          return new BigInteger(multiplyKaratsuba(a, b), sign);
        return new BigInteger(multiplyLong(a, b), sign);
      };
      BigInteger.prototype.times = BigInteger.prototype.multiply;
      function multiplySmallAndArray(a, b, sign) {
        if (a < BASE) {
          return new BigInteger(multiplySmall(b, a), sign);
        }
        return new BigInteger(multiplyLong(b, smallToArray(a)), sign);
      }
      SmallInteger.prototype._multiplyBySmall = function(a) {
        if (isPrecise(a.value * this.value)) {
          return new SmallInteger(a.value * this.value);
        }
        return multiplySmallAndArray(Math.abs(a.value), smallToArray(Math.abs(this.value)), this.sign !== a.sign);
      };
      BigInteger.prototype._multiplyBySmall = function(a) {
        if (a.value === 0)
          return Integer[0];
        if (a.value === 1)
          return this;
        if (a.value === -1)
          return this.negate();
        return multiplySmallAndArray(Math.abs(a.value), this.value, this.sign !== a.sign);
      };
      SmallInteger.prototype.multiply = function(v) {
        return parseValue(v)._multiplyBySmall(this);
      };
      SmallInteger.prototype.times = SmallInteger.prototype.multiply;
      NativeBigInt.prototype.multiply = function(v) {
        return new NativeBigInt(this.value * parseValue(v).value);
      };
      NativeBigInt.prototype.times = NativeBigInt.prototype.multiply;
      function square(a) {
        var l2 = a.length, r = createArray(l2 + l2), base = BASE, product, carry, i2, a_i, a_j;
        for (i2 = 0; i2 < l2; i2++) {
          a_i = a[i2];
          carry = 0 - a_i * a_i;
          for (var j = i2; j < l2; j++) {
            a_j = a[j];
            product = 2 * (a_i * a_j) + r[i2 + j] + carry;
            carry = Math.floor(product / base);
            r[i2 + j] = product - carry * base;
          }
          r[i2 + l2] = carry;
        }
        trim(r);
        return r;
      }
      BigInteger.prototype.square = function() {
        return new BigInteger(square(this.value), false);
      };
      SmallInteger.prototype.square = function() {
        var value = this.value * this.value;
        if (isPrecise(value))
          return new SmallInteger(value);
        return new BigInteger(square(smallToArray(Math.abs(this.value))), false);
      };
      NativeBigInt.prototype.square = function(v) {
        return new NativeBigInt(this.value * this.value);
      };
      function divMod1(a, b) {
        var a_l = a.length, b_l = b.length, base = BASE, result = createArray(b.length), divisorMostSignificantDigit = b[b_l - 1], lambda = Math.ceil(base / (2 * divisorMostSignificantDigit)), remainder = multiplySmall(a, lambda), divisor = multiplySmall(b, lambda), quotientDigit, shift, carry, borrow, i2, l2, q;
        if (remainder.length <= a_l)
          remainder.push(0);
        divisor.push(0);
        divisorMostSignificantDigit = divisor[b_l - 1];
        for (shift = a_l - b_l; shift >= 0; shift--) {
          quotientDigit = base - 1;
          if (remainder[shift + b_l] !== divisorMostSignificantDigit) {
            quotientDigit = Math.floor((remainder[shift + b_l] * base + remainder[shift + b_l - 1]) / divisorMostSignificantDigit);
          }
          carry = 0;
          borrow = 0;
          l2 = divisor.length;
          for (i2 = 0; i2 < l2; i2++) {
            carry += quotientDigit * divisor[i2];
            q = Math.floor(carry / base);
            borrow += remainder[shift + i2] - (carry - q * base);
            carry = q;
            if (borrow < 0) {
              remainder[shift + i2] = borrow + base;
              borrow = -1;
            } else {
              remainder[shift + i2] = borrow;
              borrow = 0;
            }
          }
          while (borrow !== 0) {
            quotientDigit -= 1;
            carry = 0;
            for (i2 = 0; i2 < l2; i2++) {
              carry += remainder[shift + i2] - base + divisor[i2];
              if (carry < 0) {
                remainder[shift + i2] = carry + base;
                carry = 0;
              } else {
                remainder[shift + i2] = carry;
                carry = 1;
              }
            }
            borrow += carry;
          }
          result[shift] = quotientDigit;
        }
        remainder = divModSmall(remainder, lambda)[0];
        return [arrayToSmall(result), arrayToSmall(remainder)];
      }
      function divMod2(a, b) {
        var a_l = a.length, b_l = b.length, result = [], part = [], base = BASE, guess, xlen, highx, highy, check;
        while (a_l) {
          part.unshift(a[--a_l]);
          trim(part);
          if (compareAbs(part, b) < 0) {
            result.push(0);
            continue;
          }
          xlen = part.length;
          highx = part[xlen - 1] * base + part[xlen - 2];
          highy = b[b_l - 1] * base + b[b_l - 2];
          if (xlen > b_l) {
            highx = (highx + 1) * base;
          }
          guess = Math.ceil(highx / highy);
          do {
            check = multiplySmall(b, guess);
            if (compareAbs(check, part) <= 0)
              break;
            guess--;
          } while (guess);
          result.push(guess);
          part = subtract(part, check);
        }
        result.reverse();
        return [arrayToSmall(result), arrayToSmall(part)];
      }
      function divModSmall(value, lambda) {
        var length = value.length, quotient = createArray(length), base = BASE, i2, q, remainder, divisor;
        remainder = 0;
        for (i2 = length - 1; i2 >= 0; --i2) {
          divisor = remainder * base + value[i2];
          q = truncate(divisor / lambda);
          remainder = divisor - q * lambda;
          quotient[i2] = q | 0;
        }
        return [quotient, remainder | 0];
      }
      function divModAny(self2, v) {
        var value, n = parseValue(v);
        if (supportsNativeBigInt) {
          return [new NativeBigInt(self2.value / n.value), new NativeBigInt(self2.value % n.value)];
        }
        var a = self2.value, b = n.value;
        var quotient;
        if (b === 0)
          throw new Error("Cannot divide by zero");
        if (self2.isSmall) {
          if (n.isSmall) {
            return [new SmallInteger(truncate(a / b)), new SmallInteger(a % b)];
          }
          return [Integer[0], self2];
        }
        if (n.isSmall) {
          if (b === 1)
            return [self2, Integer[0]];
          if (b == -1)
            return [self2.negate(), Integer[0]];
          var abs = Math.abs(b);
          if (abs < BASE) {
            value = divModSmall(a, abs);
            quotient = arrayToSmall(value[0]);
            var remainder = value[1];
            if (self2.sign)
              remainder = -remainder;
            if (typeof quotient === "number") {
              if (self2.sign !== n.sign)
                quotient = -quotient;
              return [new SmallInteger(quotient), new SmallInteger(remainder)];
            }
            return [new BigInteger(quotient, self2.sign !== n.sign), new SmallInteger(remainder)];
          }
          b = smallToArray(abs);
        }
        var comparison = compareAbs(a, b);
        if (comparison === -1)
          return [Integer[0], self2];
        if (comparison === 0)
          return [Integer[self2.sign === n.sign ? 1 : -1], Integer[0]];
        if (a.length + b.length <= 200)
          value = divMod1(a, b);
        else
          value = divMod2(a, b);
        quotient = value[0];
        var qSign = self2.sign !== n.sign, mod = value[1], mSign = self2.sign;
        if (typeof quotient === "number") {
          if (qSign)
            quotient = -quotient;
          quotient = new SmallInteger(quotient);
        } else
          quotient = new BigInteger(quotient, qSign);
        if (typeof mod === "number") {
          if (mSign)
            mod = -mod;
          mod = new SmallInteger(mod);
        } else
          mod = new BigInteger(mod, mSign);
        return [quotient, mod];
      }
      BigInteger.prototype.divmod = function(v) {
        var result = divModAny(this, v);
        return {
          quotient: result[0],
          remainder: result[1]
        };
      };
      NativeBigInt.prototype.divmod = SmallInteger.prototype.divmod = BigInteger.prototype.divmod;
      BigInteger.prototype.divide = function(v) {
        return divModAny(this, v)[0];
      };
      NativeBigInt.prototype.over = NativeBigInt.prototype.divide = function(v) {
        return new NativeBigInt(this.value / parseValue(v).value);
      };
      SmallInteger.prototype.over = SmallInteger.prototype.divide = BigInteger.prototype.over = BigInteger.prototype.divide;
      BigInteger.prototype.mod = function(v) {
        return divModAny(this, v)[1];
      };
      NativeBigInt.prototype.mod = NativeBigInt.prototype.remainder = function(v) {
        return new NativeBigInt(this.value % parseValue(v).value);
      };
      SmallInteger.prototype.remainder = SmallInteger.prototype.mod = BigInteger.prototype.remainder = BigInteger.prototype.mod;
      BigInteger.prototype.pow = function(v) {
        var n = parseValue(v), a = this.value, b = n.value, value, x, y;
        if (b === 0)
          return Integer[1];
        if (a === 0)
          return Integer[0];
        if (a === 1)
          return Integer[1];
        if (a === -1)
          return n.isEven() ? Integer[1] : Integer[-1];
        if (n.sign) {
          return Integer[0];
        }
        if (!n.isSmall)
          throw new Error("The exponent " + n.toString() + " is too large.");
        if (this.isSmall) {
          if (isPrecise(value = Math.pow(a, b)))
            return new SmallInteger(truncate(value));
        }
        x = this;
        y = Integer[1];
        while (true) {
          if (b & true) {
            y = y.times(x);
            --b;
          }
          if (b === 0)
            break;
          b /= 2;
          x = x.square();
        }
        return y;
      };
      SmallInteger.prototype.pow = BigInteger.prototype.pow;
      NativeBigInt.prototype.pow = function(v) {
        var n = parseValue(v);
        var a = this.value, b = n.value;
        var _0 = BigInt(0), _1 = BigInt(1), _2 = BigInt(2);
        if (b === _0)
          return Integer[1];
        if (a === _0)
          return Integer[0];
        if (a === _1)
          return Integer[1];
        if (a === BigInt(-1))
          return n.isEven() ? Integer[1] : Integer[-1];
        if (n.isNegative())
          return new NativeBigInt(_0);
        var x = this;
        var y = Integer[1];
        while (true) {
          if ((b & _1) === _1) {
            y = y.times(x);
            --b;
          }
          if (b === _0)
            break;
          b /= _2;
          x = x.square();
        }
        return y;
      };
      BigInteger.prototype.modPow = function(exp, mod) {
        exp = parseValue(exp);
        mod = parseValue(mod);
        if (mod.isZero())
          throw new Error("Cannot take modPow with modulus 0");
        var r = Integer[1], base = this.mod(mod);
        if (exp.isNegative()) {
          exp = exp.multiply(Integer[-1]);
          base = base.modInv(mod);
        }
        while (exp.isPositive()) {
          if (base.isZero())
            return Integer[0];
          if (exp.isOdd())
            r = r.multiply(base).mod(mod);
          exp = exp.divide(2);
          base = base.square().mod(mod);
        }
        return r;
      };
      NativeBigInt.prototype.modPow = SmallInteger.prototype.modPow = BigInteger.prototype.modPow;
      function compareAbs(a, b) {
        if (a.length !== b.length) {
          return a.length > b.length ? 1 : -1;
        }
        for (var i2 = a.length - 1; i2 >= 0; i2--) {
          if (a[i2] !== b[i2])
            return a[i2] > b[i2] ? 1 : -1;
        }
        return 0;
      }
      BigInteger.prototype.compareAbs = function(v) {
        var n = parseValue(v), a = this.value, b = n.value;
        if (n.isSmall)
          return 1;
        return compareAbs(a, b);
      };
      SmallInteger.prototype.compareAbs = function(v) {
        var n = parseValue(v), a = Math.abs(this.value), b = n.value;
        if (n.isSmall) {
          b = Math.abs(b);
          return a === b ? 0 : a > b ? 1 : -1;
        }
        return -1;
      };
      NativeBigInt.prototype.compareAbs = function(v) {
        var a = this.value;
        var b = parseValue(v).value;
        a = a >= 0 ? a : -a;
        b = b >= 0 ? b : -b;
        return a === b ? 0 : a > b ? 1 : -1;
      };
      BigInteger.prototype.compare = function(v) {
        if (v === Infinity) {
          return -1;
        }
        if (v === -Infinity) {
          return 1;
        }
        var n = parseValue(v), a = this.value, b = n.value;
        if (this.sign !== n.sign) {
          return n.sign ? 1 : -1;
        }
        if (n.isSmall) {
          return this.sign ? -1 : 1;
        }
        return compareAbs(a, b) * (this.sign ? -1 : 1);
      };
      BigInteger.prototype.compareTo = BigInteger.prototype.compare;
      SmallInteger.prototype.compare = function(v) {
        if (v === Infinity) {
          return -1;
        }
        if (v === -Infinity) {
          return 1;
        }
        var n = parseValue(v), a = this.value, b = n.value;
        if (n.isSmall) {
          return a == b ? 0 : a > b ? 1 : -1;
        }
        if (a < 0 !== n.sign) {
          return a < 0 ? -1 : 1;
        }
        return a < 0 ? 1 : -1;
      };
      SmallInteger.prototype.compareTo = SmallInteger.prototype.compare;
      NativeBigInt.prototype.compare = function(v) {
        if (v === Infinity) {
          return -1;
        }
        if (v === -Infinity) {
          return 1;
        }
        var a = this.value;
        var b = parseValue(v).value;
        return a === b ? 0 : a > b ? 1 : -1;
      };
      NativeBigInt.prototype.compareTo = NativeBigInt.prototype.compare;
      BigInteger.prototype.equals = function(v) {
        return this.compare(v) === 0;
      };
      NativeBigInt.prototype.eq = NativeBigInt.prototype.equals = SmallInteger.prototype.eq = SmallInteger.prototype.equals = BigInteger.prototype.eq = BigInteger.prototype.equals;
      BigInteger.prototype.notEquals = function(v) {
        return this.compare(v) !== 0;
      };
      NativeBigInt.prototype.neq = NativeBigInt.prototype.notEquals = SmallInteger.prototype.neq = SmallInteger.prototype.notEquals = BigInteger.prototype.neq = BigInteger.prototype.notEquals;
      BigInteger.prototype.greater = function(v) {
        return this.compare(v) > 0;
      };
      NativeBigInt.prototype.gt = NativeBigInt.prototype.greater = SmallInteger.prototype.gt = SmallInteger.prototype.greater = BigInteger.prototype.gt = BigInteger.prototype.greater;
      BigInteger.prototype.lesser = function(v) {
        return this.compare(v) < 0;
      };
      NativeBigInt.prototype.lt = NativeBigInt.prototype.lesser = SmallInteger.prototype.lt = SmallInteger.prototype.lesser = BigInteger.prototype.lt = BigInteger.prototype.lesser;
      BigInteger.prototype.greaterOrEquals = function(v) {
        return this.compare(v) >= 0;
      };
      NativeBigInt.prototype.geq = NativeBigInt.prototype.greaterOrEquals = SmallInteger.prototype.geq = SmallInteger.prototype.greaterOrEquals = BigInteger.prototype.geq = BigInteger.prototype.greaterOrEquals;
      BigInteger.prototype.lesserOrEquals = function(v) {
        return this.compare(v) <= 0;
      };
      NativeBigInt.prototype.leq = NativeBigInt.prototype.lesserOrEquals = SmallInteger.prototype.leq = SmallInteger.prototype.lesserOrEquals = BigInteger.prototype.leq = BigInteger.prototype.lesserOrEquals;
      BigInteger.prototype.isEven = function() {
        return (this.value[0] & 1) === 0;
      };
      SmallInteger.prototype.isEven = function() {
        return (this.value & 1) === 0;
      };
      NativeBigInt.prototype.isEven = function() {
        return (this.value & BigInt(1)) === BigInt(0);
      };
      BigInteger.prototype.isOdd = function() {
        return (this.value[0] & 1) === 1;
      };
      SmallInteger.prototype.isOdd = function() {
        return (this.value & 1) === 1;
      };
      NativeBigInt.prototype.isOdd = function() {
        return (this.value & BigInt(1)) === BigInt(1);
      };
      BigInteger.prototype.isPositive = function() {
        return !this.sign;
      };
      SmallInteger.prototype.isPositive = function() {
        return this.value > 0;
      };
      NativeBigInt.prototype.isPositive = SmallInteger.prototype.isPositive;
      BigInteger.prototype.isNegative = function() {
        return this.sign;
      };
      SmallInteger.prototype.isNegative = function() {
        return this.value < 0;
      };
      NativeBigInt.prototype.isNegative = SmallInteger.prototype.isNegative;
      BigInteger.prototype.isUnit = function() {
        return false;
      };
      SmallInteger.prototype.isUnit = function() {
        return Math.abs(this.value) === 1;
      };
      NativeBigInt.prototype.isUnit = function() {
        return this.abs().value === BigInt(1);
      };
      BigInteger.prototype.isZero = function() {
        return false;
      };
      SmallInteger.prototype.isZero = function() {
        return this.value === 0;
      };
      NativeBigInt.prototype.isZero = function() {
        return this.value === BigInt(0);
      };
      BigInteger.prototype.isDivisibleBy = function(v) {
        var n = parseValue(v);
        if (n.isZero())
          return false;
        if (n.isUnit())
          return true;
        if (n.compareAbs(2) === 0)
          return this.isEven();
        return this.mod(n).isZero();
      };
      NativeBigInt.prototype.isDivisibleBy = SmallInteger.prototype.isDivisibleBy = BigInteger.prototype.isDivisibleBy;
      function isBasicPrime(v) {
        var n = v.abs();
        if (n.isUnit())
          return false;
        if (n.equals(2) || n.equals(3) || n.equals(5))
          return true;
        if (n.isEven() || n.isDivisibleBy(3) || n.isDivisibleBy(5))
          return false;
        if (n.lesser(49))
          return true;
      }
      function millerRabinTest(n, a) {
        var nPrev = n.prev(), b = nPrev, r = 0, d, t, i2, x;
        while (b.isEven())
          b = b.divide(2), r++;
        next:
          for (i2 = 0; i2 < a.length; i2++) {
            if (n.lesser(a[i2]))
              continue;
            x = bigInt(a[i2]).modPow(b, n);
            if (x.isUnit() || x.equals(nPrev))
              continue;
            for (d = r - 1; d != 0; d--) {
              x = x.square().mod(n);
              if (x.isUnit())
                return false;
              if (x.equals(nPrev))
                continue next;
            }
            return false;
          }
        return true;
      }
      BigInteger.prototype.isPrime = function(strict) {
        var isPrime = isBasicPrime(this);
        if (isPrime !== undefined2)
          return isPrime;
        var n = this.abs();
        var bits = n.bitLength();
        if (bits <= 64)
          return millerRabinTest(n, [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37]);
        var logN = Math.log(2) * bits.toJSNumber();
        var t = Math.ceil(strict === true ? 2 * Math.pow(logN, 2) : logN);
        for (var a = [], i2 = 0; i2 < t; i2++) {
          a.push(bigInt(i2 + 2));
        }
        return millerRabinTest(n, a);
      };
      NativeBigInt.prototype.isPrime = SmallInteger.prototype.isPrime = BigInteger.prototype.isPrime;
      BigInteger.prototype.isProbablePrime = function(iterations, rng2) {
        var isPrime = isBasicPrime(this);
        if (isPrime !== undefined2)
          return isPrime;
        var n = this.abs();
        var t = iterations === undefined2 ? 5 : iterations;
        for (var a = [], i2 = 0; i2 < t; i2++) {
          a.push(bigInt.randBetween(2, n.minus(2), rng2));
        }
        return millerRabinTest(n, a);
      };
      NativeBigInt.prototype.isProbablePrime = SmallInteger.prototype.isProbablePrime = BigInteger.prototype.isProbablePrime;
      BigInteger.prototype.modInv = function(n) {
        var t = bigInt.zero, newT = bigInt.one, r = parseValue(n), newR = this.abs(), q, lastT, lastR;
        while (!newR.isZero()) {
          q = r.divide(newR);
          lastT = t;
          lastR = r;
          t = newT;
          r = newR;
          newT = lastT.subtract(q.multiply(newT));
          newR = lastR.subtract(q.multiply(newR));
        }
        if (!r.isUnit())
          throw new Error(this.toString() + " and " + n.toString() + " are not co-prime");
        if (t.compare(0) === -1) {
          t = t.add(n);
        }
        if (this.isNegative()) {
          return t.negate();
        }
        return t;
      };
      NativeBigInt.prototype.modInv = SmallInteger.prototype.modInv = BigInteger.prototype.modInv;
      BigInteger.prototype.next = function() {
        var value = this.value;
        if (this.sign) {
          return subtractSmall(value, 1, this.sign);
        }
        return new BigInteger(addSmall(value, 1), this.sign);
      };
      SmallInteger.prototype.next = function() {
        var value = this.value;
        if (value + 1 < MAX_INT)
          return new SmallInteger(value + 1);
        return new BigInteger(MAX_INT_ARR, false);
      };
      NativeBigInt.prototype.next = function() {
        return new NativeBigInt(this.value + BigInt(1));
      };
      BigInteger.prototype.prev = function() {
        var value = this.value;
        if (this.sign) {
          return new BigInteger(addSmall(value, 1), true);
        }
        return subtractSmall(value, 1, this.sign);
      };
      SmallInteger.prototype.prev = function() {
        var value = this.value;
        if (value - 1 > -MAX_INT)
          return new SmallInteger(value - 1);
        return new BigInteger(MAX_INT_ARR, true);
      };
      NativeBigInt.prototype.prev = function() {
        return new NativeBigInt(this.value - BigInt(1));
      };
      var powersOfTwo = [1];
      while (2 * powersOfTwo[powersOfTwo.length - 1] <= BASE)
        powersOfTwo.push(2 * powersOfTwo[powersOfTwo.length - 1]);
      var powers2Length = powersOfTwo.length, highestPower2 = powersOfTwo[powers2Length - 1];
      function shift_isSmall(n) {
        return Math.abs(n) <= BASE;
      }
      BigInteger.prototype.shiftLeft = function(v) {
        var n = parseValue(v).toJSNumber();
        if (!shift_isSmall(n)) {
          throw new Error(String(n) + " is too large for shifting.");
        }
        if (n < 0)
          return this.shiftRight(-n);
        var result = this;
        if (result.isZero())
          return result;
        while (n >= powers2Length) {
          result = result.multiply(highestPower2);
          n -= powers2Length - 1;
        }
        return result.multiply(powersOfTwo[n]);
      };
      NativeBigInt.prototype.shiftLeft = SmallInteger.prototype.shiftLeft = BigInteger.prototype.shiftLeft;
      BigInteger.prototype.shiftRight = function(v) {
        var remQuo;
        var n = parseValue(v).toJSNumber();
        if (!shift_isSmall(n)) {
          throw new Error(String(n) + " is too large for shifting.");
        }
        if (n < 0)
          return this.shiftLeft(-n);
        var result = this;
        while (n >= powers2Length) {
          if (result.isZero() || result.isNegative() && result.isUnit())
            return result;
          remQuo = divModAny(result, highestPower2);
          result = remQuo[1].isNegative() ? remQuo[0].prev() : remQuo[0];
          n -= powers2Length - 1;
        }
        remQuo = divModAny(result, powersOfTwo[n]);
        return remQuo[1].isNegative() ? remQuo[0].prev() : remQuo[0];
      };
      NativeBigInt.prototype.shiftRight = SmallInteger.prototype.shiftRight = BigInteger.prototype.shiftRight;
      function bitwise(x, y, fn) {
        y = parseValue(y);
        var xSign = x.isNegative(), ySign = y.isNegative();
        var xRem = xSign ? x.not() : x, yRem = ySign ? y.not() : y;
        var xDigit = 0, yDigit = 0;
        var xDivMod = null, yDivMod = null;
        var result = [];
        while (!xRem.isZero() || !yRem.isZero()) {
          xDivMod = divModAny(xRem, highestPower2);
          xDigit = xDivMod[1].toJSNumber();
          if (xSign) {
            xDigit = highestPower2 - 1 - xDigit;
          }
          yDivMod = divModAny(yRem, highestPower2);
          yDigit = yDivMod[1].toJSNumber();
          if (ySign) {
            yDigit = highestPower2 - 1 - yDigit;
          }
          xRem = xDivMod[0];
          yRem = yDivMod[0];
          result.push(fn(xDigit, yDigit));
        }
        var sum = fn(xSign ? 1 : 0, ySign ? 1 : 0) !== 0 ? bigInt(-1) : bigInt(0);
        for (var i2 = result.length - 1; i2 >= 0; i2 -= 1) {
          sum = sum.multiply(highestPower2).add(bigInt(result[i2]));
        }
        return sum;
      }
      BigInteger.prototype.not = function() {
        return this.negate().prev();
      };
      NativeBigInt.prototype.not = SmallInteger.prototype.not = BigInteger.prototype.not;
      BigInteger.prototype.and = function(n) {
        return bitwise(this, n, function(a, b) {
          return a & b;
        });
      };
      NativeBigInt.prototype.and = SmallInteger.prototype.and = BigInteger.prototype.and;
      BigInteger.prototype.or = function(n) {
        return bitwise(this, n, function(a, b) {
          return a | b;
        });
      };
      NativeBigInt.prototype.or = SmallInteger.prototype.or = BigInteger.prototype.or;
      BigInteger.prototype.xor = function(n) {
        return bitwise(this, n, function(a, b) {
          return a ^ b;
        });
      };
      NativeBigInt.prototype.xor = SmallInteger.prototype.xor = BigInteger.prototype.xor;
      var LOBMASK_I = 1 << 30, LOBMASK_BI = (BASE & -BASE) * (BASE & -BASE) | LOBMASK_I;
      function roughLOB(n) {
        var v = n.value, x = typeof v === "number" ? v | LOBMASK_I : typeof v === "bigint" ? v | BigInt(LOBMASK_I) : v[0] + v[1] * BASE | LOBMASK_BI;
        return x & -x;
      }
      function integerLogarithm(value, base) {
        if (base.compareTo(value) <= 0) {
          var tmp = integerLogarithm(value, base.square(base));
          var p = tmp.p;
          var e = tmp.e;
          var t = p.multiply(base);
          return t.compareTo(value) <= 0 ? { p: t, e: e * 2 + 1 } : { p, e: e * 2 };
        }
        return { p: bigInt(1), e: 0 };
      }
      BigInteger.prototype.bitLength = function() {
        var n = this;
        if (n.compareTo(bigInt(0)) < 0) {
          n = n.negate().subtract(bigInt(1));
        }
        if (n.compareTo(bigInt(0)) === 0) {
          return bigInt(0);
        }
        return bigInt(integerLogarithm(n, bigInt(2)).e).add(bigInt(1));
      };
      NativeBigInt.prototype.bitLength = SmallInteger.prototype.bitLength = BigInteger.prototype.bitLength;
      function max(a, b) {
        a = parseValue(a);
        b = parseValue(b);
        return a.greater(b) ? a : b;
      }
      function min(a, b) {
        a = parseValue(a);
        b = parseValue(b);
        return a.lesser(b) ? a : b;
      }
      function gcd(a, b) {
        a = parseValue(a).abs();
        b = parseValue(b).abs();
        if (a.equals(b))
          return a;
        if (a.isZero())
          return b;
        if (b.isZero())
          return a;
        var c = Integer[1], d, t;
        while (a.isEven() && b.isEven()) {
          d = min(roughLOB(a), roughLOB(b));
          a = a.divide(d);
          b = b.divide(d);
          c = c.multiply(d);
        }
        while (a.isEven()) {
          a = a.divide(roughLOB(a));
        }
        do {
          while (b.isEven()) {
            b = b.divide(roughLOB(b));
          }
          if (a.greater(b)) {
            t = b;
            b = a;
            a = t;
          }
          b = b.subtract(a);
        } while (!b.isZero());
        return c.isUnit() ? a : a.multiply(c);
      }
      function lcm(a, b) {
        a = parseValue(a).abs();
        b = parseValue(b).abs();
        return a.divide(gcd(a, b)).multiply(b);
      }
      function randBetween(a, b, rng2) {
        a = parseValue(a);
        b = parseValue(b);
        var usedRNG = rng2 || Math.random;
        var low = min(a, b), high = max(a, b);
        var range = high.subtract(low).add(1);
        if (range.isSmall)
          return low.add(Math.floor(usedRNG() * range));
        var digits = toBase(range, BASE).value;
        var result = [], restricted = true;
        for (var i2 = 0; i2 < digits.length; i2++) {
          var top = restricted ? digits[i2] + (i2 + 1 < digits.length ? digits[i2 + 1] / BASE : 0) : BASE;
          var digit = truncate(usedRNG() * top);
          result.push(digit);
          if (digit < digits[i2])
            restricted = false;
        }
        return low.add(Integer.fromArray(result, BASE, false));
      }
      var parseBase = function(text, base, alphabet, caseSensitive) {
        alphabet = alphabet || DEFAULT_ALPHABET;
        text = String(text);
        if (!caseSensitive) {
          text = text.toLowerCase();
          alphabet = alphabet.toLowerCase();
        }
        var length = text.length;
        var i2;
        var absBase = Math.abs(base);
        var alphabetValues = {};
        for (i2 = 0; i2 < alphabet.length; i2++) {
          alphabetValues[alphabet[i2]] = i2;
        }
        for (i2 = 0; i2 < length; i2++) {
          var c = text[i2];
          if (c === "-")
            continue;
          if (c in alphabetValues) {
            if (alphabetValues[c] >= absBase) {
              if (c === "1" && absBase === 1)
                continue;
              throw new Error(c + " is not a valid digit in base " + base + ".");
            }
          }
        }
        base = parseValue(base);
        var digits = [];
        var isNegative = text[0] === "-";
        for (i2 = isNegative ? 1 : 0; i2 < text.length; i2++) {
          var c = text[i2];
          if (c in alphabetValues)
            digits.push(parseValue(alphabetValues[c]));
          else if (c === "<") {
            var start = i2;
            do {
              i2++;
            } while (text[i2] !== ">" && i2 < text.length);
            digits.push(parseValue(text.slice(start + 1, i2)));
          } else
            throw new Error(c + " is not a valid character");
        }
        return parseBaseFromArray(digits, base, isNegative);
      };
      function parseBaseFromArray(digits, base, isNegative) {
        var val = Integer[0], pow = Integer[1], i2;
        for (i2 = digits.length - 1; i2 >= 0; i2--) {
          val = val.add(digits[i2].times(pow));
          pow = pow.times(base);
        }
        return isNegative ? val.negate() : val;
      }
      function stringify2(digit, alphabet) {
        alphabet = alphabet || DEFAULT_ALPHABET;
        if (digit < alphabet.length) {
          return alphabet[digit];
        }
        return "<" + digit + ">";
      }
      function toBase(n, base) {
        base = bigInt(base);
        if (base.isZero()) {
          if (n.isZero())
            return { value: [0], isNegative: false };
          throw new Error("Cannot convert nonzero numbers to base 0.");
        }
        if (base.equals(-1)) {
          if (n.isZero())
            return { value: [0], isNegative: false };
          if (n.isNegative())
            return {
              value: [].concat.apply(
                [],
                Array.apply(null, Array(-n.toJSNumber())).map(Array.prototype.valueOf, [1, 0])
              ),
              isNegative: false
            };
          var arr = Array.apply(null, Array(n.toJSNumber() - 1)).map(Array.prototype.valueOf, [0, 1]);
          arr.unshift([1]);
          return {
            value: [].concat.apply([], arr),
            isNegative: false
          };
        }
        var neg = false;
        if (n.isNegative() && base.isPositive()) {
          neg = true;
          n = n.abs();
        }
        if (base.isUnit()) {
          if (n.isZero())
            return { value: [0], isNegative: false };
          return {
            value: Array.apply(null, Array(n.toJSNumber())).map(Number.prototype.valueOf, 1),
            isNegative: neg
          };
        }
        var out = [];
        var left = n, divmod;
        while (left.isNegative() || left.compareAbs(base) >= 0) {
          divmod = left.divmod(base);
          left = divmod.quotient;
          var digit = divmod.remainder;
          if (digit.isNegative()) {
            digit = base.minus(digit).abs();
            left = left.next();
          }
          out.push(digit.toJSNumber());
        }
        out.push(left.toJSNumber());
        return { value: out.reverse(), isNegative: neg };
      }
      function toBaseString(n, base, alphabet) {
        var arr = toBase(n, base);
        return (arr.isNegative ? "-" : "") + arr.value.map(function(x) {
          return stringify2(x, alphabet);
        }).join("");
      }
      BigInteger.prototype.toArray = function(radix) {
        return toBase(this, radix);
      };
      SmallInteger.prototype.toArray = function(radix) {
        return toBase(this, radix);
      };
      NativeBigInt.prototype.toArray = function(radix) {
        return toBase(this, radix);
      };
      BigInteger.prototype.toString = function(radix, alphabet) {
        if (radix === undefined2)
          radix = 10;
        if (radix !== 10 || alphabet)
          return toBaseString(this, radix, alphabet);
        var v = this.value, l2 = v.length, str = String(v[--l2]), zeros = "0000000", digit;
        while (--l2 >= 0) {
          digit = String(v[l2]);
          str += zeros.slice(digit.length) + digit;
        }
        var sign = this.sign ? "-" : "";
        return sign + str;
      };
      SmallInteger.prototype.toString = function(radix, alphabet) {
        if (radix === undefined2)
          radix = 10;
        if (radix != 10 || alphabet)
          return toBaseString(this, radix, alphabet);
        return String(this.value);
      };
      NativeBigInt.prototype.toString = SmallInteger.prototype.toString;
      NativeBigInt.prototype.toJSON = BigInteger.prototype.toJSON = SmallInteger.prototype.toJSON = function() {
        return this.toString();
      };
      BigInteger.prototype.valueOf = function() {
        return parseInt(this.toString(), 10);
      };
      BigInteger.prototype.toJSNumber = BigInteger.prototype.valueOf;
      SmallInteger.prototype.valueOf = function() {
        return this.value;
      };
      SmallInteger.prototype.toJSNumber = SmallInteger.prototype.valueOf;
      NativeBigInt.prototype.valueOf = NativeBigInt.prototype.toJSNumber = function() {
        return parseInt(this.toString(), 10);
      };
      function parseStringValue(v) {
        if (isPrecise(+v)) {
          var x = +v;
          if (x === truncate(x))
            return supportsNativeBigInt ? new NativeBigInt(BigInt(x)) : new SmallInteger(x);
          throw new Error("Invalid integer: " + v);
        }
        var sign = v[0] === "-";
        if (sign)
          v = v.slice(1);
        var split = v.split(/e/i);
        if (split.length > 2)
          throw new Error("Invalid integer: " + split.join("e"));
        if (split.length === 2) {
          var exp = split[1];
          if (exp[0] === "+")
            exp = exp.slice(1);
          exp = +exp;
          if (exp !== truncate(exp) || !isPrecise(exp))
            throw new Error("Invalid integer: " + exp + " is not a valid exponent.");
          var text = split[0];
          var decimalPlace = text.indexOf(".");
          if (decimalPlace >= 0) {
            exp -= text.length - decimalPlace - 1;
            text = text.slice(0, decimalPlace) + text.slice(decimalPlace + 1);
          }
          if (exp < 0)
            throw new Error("Cannot include negative exponent part for integers");
          text += new Array(exp + 1).join("0");
          v = text;
        }
        var isValid = /^([0-9][0-9]*)$/.test(v);
        if (!isValid)
          throw new Error("Invalid integer: " + v);
        if (supportsNativeBigInt) {
          return new NativeBigInt(BigInt(sign ? "-" + v : v));
        }
        var r = [], max2 = v.length, l2 = LOG_BASE, min2 = max2 - l2;
        while (max2 > 0) {
          r.push(+v.slice(min2, max2));
          min2 -= l2;
          if (min2 < 0)
            min2 = 0;
          max2 -= l2;
        }
        trim(r);
        return new BigInteger(r, sign);
      }
      function parseNumberValue(v) {
        if (supportsNativeBigInt) {
          return new NativeBigInt(BigInt(v));
        }
        if (isPrecise(v)) {
          if (v !== truncate(v))
            throw new Error(v + " is not an integer.");
          return new SmallInteger(v);
        }
        return parseStringValue(v.toString());
      }
      function parseValue(v) {
        if (typeof v === "number") {
          return parseNumberValue(v);
        }
        if (typeof v === "string") {
          return parseStringValue(v);
        }
        if (typeof v === "bigint") {
          return new NativeBigInt(v);
        }
        return v;
      }
      for (var i = 0; i < 1e3; i++) {
        Integer[i] = parseValue(i);
        if (i > 0)
          Integer[-i] = parseValue(-i);
      }
      Integer.one = Integer[1];
      Integer.zero = Integer[0];
      Integer.minusOne = Integer[-1];
      Integer.max = max;
      Integer.min = min;
      Integer.gcd = gcd;
      Integer.lcm = lcm;
      Integer.isInstance = function(x) {
        return x instanceof BigInteger || x instanceof SmallInteger || x instanceof NativeBigInt;
      };
      Integer.randBetween = randBetween;
      Integer.fromArray = function(digits, base, isNegative) {
        return parseBaseFromArray(digits.map(parseValue), parseValue(base || 10), isNegative);
      };
      return Integer;
    }();
    if (typeof module2 !== "undefined" && module2.hasOwnProperty("exports")) {
      module2.exports = bigInt;
    }
    if (typeof define === "function" && define.amd) {
      define(function() {
        return bigInt;
      });
    }
  }
});

// ../../../node_modules/unzipper/lib/Decrypt.js
var require_Decrypt = __commonJS({
  "../../../node_modules/unzipper/lib/Decrypt.js"(exports2, module2) {
    var bigInt = require_BigInteger();
    var Stream = require("stream");
    if (!Stream.Writable || !Stream.Writable.prototype.destroy)
      Stream = require_readable11();
    var table;
    function generateTable() {
      var poly = 3988292384, c, n, k;
      table = [];
      for (n = 0; n < 256; n++) {
        c = n;
        for (k = 0; k < 8; k++)
          c = c & 1 ? poly ^ c >>> 1 : c = c >>> 1;
        table[n] = c >>> 0;
      }
    }
    function crc(ch, crc2) {
      if (!table)
        generateTable();
      if (ch.charCodeAt)
        ch = ch.charCodeAt(0);
      return bigInt(crc2).shiftRight(8).and(16777215).xor(table[bigInt(crc2).xor(ch).and(255)]).value;
    }
    function Decrypt() {
      if (!(this instanceof Decrypt))
        return new Decrypt();
      this.key0 = 305419896;
      this.key1 = 591751049;
      this.key2 = 878082192;
    }
    Decrypt.prototype.update = function(h) {
      this.key0 = crc(h, this.key0);
      this.key1 = bigInt(this.key0).and(255).and(4294967295).add(this.key1);
      this.key1 = bigInt(this.key1).multiply(134775813).add(1).and(4294967295).value;
      this.key2 = crc(bigInt(this.key1).shiftRight(24).and(255), this.key2);
    };
    Decrypt.prototype.decryptByte = function(c) {
      var k = bigInt(this.key2).or(2);
      c = c ^ bigInt(k).multiply(bigInt(k ^ 1)).shiftRight(8).and(255);
      this.update(c);
      return c;
    };
    Decrypt.prototype.stream = function() {
      var stream = Stream.Transform(), self2 = this;
      stream._transform = function(d, e, cb) {
        for (var i = 0; i < d.length; i++) {
          d[i] = self2.decryptByte(d[i]);
        }
        this.push(d);
        cb();
      };
      return stream;
    };
    module2.exports = Decrypt;
  }
});

// ../../../node_modules/unzipper/lib/Open/unzip.js
var require_unzip = __commonJS({
  "../../../node_modules/unzipper/lib/Open/unzip.js"(exports2, module2) {
    var Promise2 = require_bluebird();
    var Decrypt = require_Decrypt();
    var PullStream = require_PullStream();
    var Stream = require("stream");
    var binary = require_binary();
    var zlib = require("zlib");
    var parseExtraField = require_parseExtraField();
    var Buffer2 = require_Buffer();
    var parseDateTime = require_parseDateTime();
    if (!Stream.Writable || !Stream.Writable.prototype.destroy)
      Stream = require_readable11();
    module2.exports = function unzip(source, offset, _password, directoryVars) {
      var file = PullStream(), entry = Stream.PassThrough();
      var req = source.stream(offset);
      req.pipe(file).on("error", function(e) {
        entry.emit("error", e);
      });
      entry.vars = file.pull(30).then(function(data) {
        var vars = binary.parse(data).word32lu("signature").word16lu("versionsNeededToExtract").word16lu("flags").word16lu("compressionMethod").word16lu("lastModifiedTime").word16lu("lastModifiedDate").word32lu("crc32").word32lu("compressedSize").word32lu("uncompressedSize").word16lu("fileNameLength").word16lu("extraFieldLength").vars;
        vars.lastModifiedDateTime = parseDateTime(vars.lastModifiedDate, vars.lastModifiedTime);
        return file.pull(vars.fileNameLength).then(function(fileName) {
          vars.fileName = fileName.toString("utf8");
          return file.pull(vars.extraFieldLength);
        }).then(function(extraField) {
          var checkEncryption;
          vars.extra = parseExtraField(extraField, vars);
          if (directoryVars && directoryVars.compressedSize)
            vars = directoryVars;
          if (vars.flags & 1)
            checkEncryption = file.pull(12).then(function(header) {
              if (!_password)
                throw new Error("MISSING_PASSWORD");
              var decrypt = Decrypt();
              String(_password).split("").forEach(function(d) {
                decrypt.update(d);
              });
              for (var i = 0; i < header.length; i++)
                header[i] = decrypt.decryptByte(header[i]);
              vars.decrypt = decrypt;
              vars.compressedSize -= 12;
              var check = vars.flags & 8 ? vars.lastModifiedTime >> 8 & 255 : vars.crc32 >> 24 & 255;
              if (header[11] !== check)
                throw new Error("BAD_PASSWORD");
              return vars;
            });
          return Promise2.resolve(checkEncryption).then(function() {
            entry.emit("vars", vars);
            return vars;
          });
        });
      });
      entry.vars.then(function(vars) {
        var fileSizeKnown = !(vars.flags & 8) || vars.compressedSize > 0, eof;
        var inflater = vars.compressionMethod ? zlib.createInflateRaw() : Stream.PassThrough();
        if (fileSizeKnown) {
          entry.size = vars.uncompressedSize;
          eof = vars.compressedSize;
        } else {
          eof = Buffer2.alloc(4);
          eof.writeUInt32LE(134695760, 0);
        }
        var stream = file.stream(eof);
        if (vars.decrypt)
          stream = stream.pipe(vars.decrypt.stream());
        stream.pipe(inflater).on("error", function(err) {
          entry.emit("error", err);
        }).pipe(entry).on("finish", function() {
          if (req.destroy)
            req.destroy();
          else if (req.abort)
            req.abort();
          else if (req.close)
            req.close();
          else if (req.push)
            req.push();
          else
            console.log("warning - unable to close stream");
        });
      }).catch(function(e) {
        entry.emit("error", e);
      });
      return entry;
    };
  }
});

// ../../../node_modules/unzipper/lib/Open/directory.js
var require_directory = __commonJS({
  "../../../node_modules/unzipper/lib/Open/directory.js"(exports2, module2) {
    var binary = require_binary();
    var PullStream = require_PullStream();
    var unzip = require_unzip();
    var Promise2 = require_bluebird();
    var BufferStream = require_BufferStream();
    var parseExtraField = require_parseExtraField();
    var Buffer2 = require_Buffer();
    var path = require("path");
    var Writer = require_fstream().Writer;
    var parseDateTime = require_parseDateTime();
    var signature = Buffer2.alloc(4);
    signature.writeUInt32LE(101010256, 0);
    function getCrxHeader(source) {
      var sourceStream = source.stream(0).pipe(PullStream());
      return sourceStream.pull(4).then(function(data) {
        var signature2 = data.readUInt32LE(0);
        if (signature2 === 875721283) {
          var crxHeader;
          return sourceStream.pull(12).then(function(data2) {
            crxHeader = binary.parse(data2).word32lu("version").word32lu("pubKeyLength").word32lu("signatureLength").vars;
          }).then(function() {
            return sourceStream.pull(crxHeader.pubKeyLength + crxHeader.signatureLength);
          }).then(function(data2) {
            crxHeader.publicKey = data2.slice(0, crxHeader.pubKeyLength);
            crxHeader.signature = data2.slice(crxHeader.pubKeyLength);
            crxHeader.size = 16 + crxHeader.pubKeyLength + crxHeader.signatureLength;
            return crxHeader;
          });
        }
      });
    }
    function getZip64CentralDirectory(source, zip64CDL) {
      var d64loc = binary.parse(zip64CDL).word32lu("signature").word32lu("diskNumber").word64lu("offsetToStartOfCentralDirectory").word32lu("numberOfDisks").vars;
      if (d64loc.signature != 117853008) {
        throw new Error("invalid zip64 end of central dir locator signature (0x07064b50): 0x" + d64loc.signature.toString(16));
      }
      var dir64 = PullStream();
      source.stream(d64loc.offsetToStartOfCentralDirectory).pipe(dir64);
      return dir64.pull(56);
    }
    function parseZip64DirRecord(dir64record) {
      var vars = binary.parse(dir64record).word32lu("signature").word64lu("sizeOfCentralDirectory").word16lu("version").word16lu("versionsNeededToExtract").word32lu("diskNumber").word32lu("diskStart").word64lu("numberOfRecordsOnDisk").word64lu("numberOfRecords").word64lu("sizeOfCentralDirectory").word64lu("offsetToStartOfCentralDirectory").vars;
      if (vars.signature != 101075792) {
        throw new Error("invalid zip64 end of central dir locator signature (0x06064b50): 0x0" + vars.signature.toString(16));
      }
      return vars;
    }
    module2.exports = function centralDirectory(source, options) {
      var endDir = PullStream(), records = PullStream(), tailSize = options && options.tailSize || 80, sourceSize, crxHeader, startOffset, vars;
      if (options && options.crx)
        crxHeader = getCrxHeader(source);
      return source.size().then(function(size) {
        sourceSize = size;
        source.stream(Math.max(0, size - tailSize)).on("error", function(error) {
          endDir.emit("error", error);
        }).pipe(endDir);
        return endDir.pull(signature);
      }).then(function() {
        return Promise2.props({ directory: endDir.pull(22), crxHeader });
      }).then(function(d) {
        var data = d.directory;
        startOffset = d.crxHeader && d.crxHeader.size || 0;
        vars = binary.parse(data).word32lu("signature").word16lu("diskNumber").word16lu("diskStart").word16lu("numberOfRecordsOnDisk").word16lu("numberOfRecords").word32lu("sizeOfCentralDirectory").word32lu("offsetToStartOfCentralDirectory").word16lu("commentLength").vars;
        if (vars.numberOfRecords == 65535 || vars.numberOfRecords == 65535 || vars.offsetToStartOfCentralDirectory == 4294967295) {
          const zip64CDLSize = 20;
          const zip64CDLOffset = sourceSize - (tailSize - endDir.match + zip64CDLSize);
          const zip64CDLStream = PullStream();
          source.stream(zip64CDLOffset).pipe(zip64CDLStream);
          return zip64CDLStream.pull(zip64CDLSize).then(function(d2) {
            return getZip64CentralDirectory(source, d2);
          }).then(function(dir64record) {
            vars = parseZip64DirRecord(dir64record);
          });
        } else {
          vars.offsetToStartOfCentralDirectory += startOffset;
        }
      }).then(function() {
        if (vars.commentLength)
          return endDir.pull(vars.commentLength).then(function(comment) {
            vars.comment = comment.toString("utf8");
          });
      }).then(function() {
        source.stream(vars.offsetToStartOfCentralDirectory).pipe(records);
        vars.extract = function(opts) {
          if (!opts || !opts.path)
            throw new Error("PATH_MISSING");
          opts.path = path.resolve(path.normalize(opts.path));
          return vars.files.then(function(files) {
            return Promise2.map(files, function(entry) {
              if (entry.type == "Directory")
                return;
              var extractPath = path.join(opts.path, entry.path);
              if (extractPath.indexOf(opts.path) != 0) {
                return;
              }
              var writer = opts.getWriter ? opts.getWriter({ path: extractPath }) : Writer({ path: extractPath });
              return new Promise2(function(resolve, reject) {
                entry.stream(opts.password).on("error", reject).pipe(writer).on("close", resolve).on("error", reject);
              });
            }, { concurrency: opts.concurrency > 1 ? opts.concurrency : 1 });
          });
        };
        vars.files = Promise2.mapSeries(Array(vars.numberOfRecords), function() {
          return records.pull(46).then(function(data) {
            var vars2 = binary.parse(data).word32lu("signature").word16lu("versionMadeBy").word16lu("versionsNeededToExtract").word16lu("flags").word16lu("compressionMethod").word16lu("lastModifiedTime").word16lu("lastModifiedDate").word32lu("crc32").word32lu("compressedSize").word32lu("uncompressedSize").word16lu("fileNameLength").word16lu("extraFieldLength").word16lu("fileCommentLength").word16lu("diskNumber").word16lu("internalFileAttributes").word32lu("externalFileAttributes").word32lu("offsetToLocalFileHeader").vars;
            vars2.offsetToLocalFileHeader += startOffset;
            vars2.lastModifiedDateTime = parseDateTime(vars2.lastModifiedDate, vars2.lastModifiedTime);
            return records.pull(vars2.fileNameLength).then(function(fileNameBuffer) {
              vars2.pathBuffer = fileNameBuffer;
              vars2.path = fileNameBuffer.toString("utf8");
              vars2.isUnicode = (vars2.flags & 2048) != 0;
              return records.pull(vars2.extraFieldLength);
            }).then(function(extraField) {
              vars2.extra = parseExtraField(extraField, vars2);
              return records.pull(vars2.fileCommentLength);
            }).then(function(comment) {
              vars2.comment = comment;
              vars2.type = vars2.uncompressedSize === 0 && /[\/\\]$/.test(vars2.path) ? "Directory" : "File";
              vars2.stream = function(_password) {
                return unzip(source, vars2.offsetToLocalFileHeader, _password, vars2);
              };
              vars2.buffer = function(_password) {
                return BufferStream(vars2.stream(_password));
              };
              return vars2;
            });
          });
        });
        return Promise2.props(vars);
      });
    };
  }
});

// ../../../node_modules/unzipper/lib/Open/index.js
var require_Open = __commonJS({
  "../../../node_modules/unzipper/lib/Open/index.js"(exports2, module2) {
    var fs = require_graceful_fs();
    var Promise2 = require_bluebird();
    var directory = require_directory();
    var Stream = require("stream");
    if (!Stream.Writable || !Stream.Writable.prototype.destroy)
      Stream = require_readable11();
    module2.exports = {
      buffer: function(buffer, options) {
        var source = {
          stream: function(offset, length) {
            var stream = Stream.PassThrough();
            stream.end(buffer.slice(offset, length));
            return stream;
          },
          size: function() {
            return Promise2.resolve(buffer.length);
          }
        };
        return directory(source, options);
      },
      file: function(filename, options) {
        var source = {
          stream: function(offset, length) {
            return fs.createReadStream(filename, { start: offset, end: length && offset + length });
          },
          size: function() {
            return new Promise2(function(resolve, reject) {
              fs.stat(filename, function(err, d) {
                if (err)
                  reject(err);
                else
                  resolve(d.size);
              });
            });
          }
        };
        return directory(source, options);
      },
      url: function(request, params, options) {
        if (typeof params === "string")
          params = { url: params };
        if (!params.url)
          throw "URL missing";
        params.headers = params.headers || {};
        var source = {
          stream: function(offset, length) {
            var options2 = Object.create(params);
            options2.headers = Object.create(params.headers);
            options2.headers.range = "bytes=" + offset + "-" + (length ? length : "");
            return request(options2);
          },
          size: function() {
            return new Promise2(function(resolve, reject) {
              var req = request(params);
              req.on("response", function(d) {
                req.abort();
                if (!d.headers["content-length"])
                  reject(new Error("Missing content length header"));
                else
                  resolve(d.headers["content-length"]);
              }).on("error", reject);
            });
          }
        };
        return directory(source, options);
      },
      s3: function(client, params, options) {
        var source = {
          size: function() {
            return new Promise2(function(resolve, reject) {
              client.headObject(params, function(err, d) {
                if (err)
                  reject(err);
                else
                  resolve(d.ContentLength);
              });
            });
          },
          stream: function(offset, length) {
            var d = {};
            for (var key in params)
              d[key] = params[key];
            d.Range = "bytes=" + offset + "-" + (length ? length : "");
            return client.getObject(d).createReadStream();
          }
        };
        return directory(source, options);
      },
      custom: function(source, options) {
        return directory(source, options);
      }
    };
  }
});

// ../../../node_modules/unzipper/unzip.js
var require_unzip2 = __commonJS({
  "../../../node_modules/unzipper/unzip.js"(exports2) {
    "use strict";
    require_listenercount();
    require_buffer_indexof_polyfill();
    require_setImmediate();
    exports2.Parse = require_parse();
    exports2.ParseOne = require_parseOne();
    exports2.Extract = require_extract2();
    exports2.Open = require_Open();
  }
});

// ../../../node_modules/exceljs/node_modules/tmp/lib/tmp.js
var require_tmp = __commonJS({
  "../../../node_modules/exceljs/node_modules/tmp/lib/tmp.js"(exports2, module2) {
    var fs = require("fs");
    var os = require("os");
    var path = require("path");
    var crypto4 = require("crypto");
    var _c = { fs: fs.constants, os: os.constants };
    var RANDOM_CHARS = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz";
    var TEMPLATE_PATTERN = /XXXXXX/;
    var DEFAULT_TRIES = 3;
    var CREATE_FLAGS = (_c.O_CREAT || _c.fs.O_CREAT) | (_c.O_EXCL || _c.fs.O_EXCL) | (_c.O_RDWR || _c.fs.O_RDWR);
    var IS_WIN32 = os.platform() === "win32";
    var EBADF = _c.EBADF || _c.os.errno.EBADF;
    var ENOENT = _c.ENOENT || _c.os.errno.ENOENT;
    var DIR_MODE = 448;
    var FILE_MODE = 384;
    var EXIT = "exit";
    var _removeObjects = [];
    var FN_RMDIR_SYNC = fs.rmdirSync.bind(fs);
    var _gracefulCleanup = false;
    function rimraf(dirPath, callback) {
      return fs.rm(dirPath, { recursive: true }, callback);
    }
    function FN_RIMRAF_SYNC(dirPath) {
      return fs.rmSync(dirPath, { recursive: true });
    }
    function tmpName(options, callback) {
      const args = _parseArguments(options, callback), opts = args[0], cb = args[1];
      try {
        _assertAndSanitizeOptions(opts);
      } catch (err) {
        return cb(err);
      }
      let tries = opts.tries;
      (function _getUniqueName() {
        try {
          const name = _generateTmpName(opts);
          fs.stat(name, function(err) {
            if (!err) {
              if (tries-- > 0)
                return _getUniqueName();
              return cb(new Error("Could not get a unique tmp filename, max tries reached " + name));
            }
            cb(null, name);
          });
        } catch (err) {
          cb(err);
        }
      })();
    }
    function tmpNameSync(options) {
      const args = _parseArguments(options), opts = args[0];
      _assertAndSanitizeOptions(opts);
      let tries = opts.tries;
      do {
        const name = _generateTmpName(opts);
        try {
          fs.statSync(name);
        } catch (e) {
          return name;
        }
      } while (tries-- > 0);
      throw new Error("Could not get a unique tmp filename, max tries reached");
    }
    function file(options, callback) {
      const args = _parseArguments(options, callback), opts = args[0], cb = args[1];
      tmpName(opts, function _tmpNameCreated(err, name) {
        if (err)
          return cb(err);
        fs.open(name, CREATE_FLAGS, opts.mode || FILE_MODE, function _fileCreated(err2, fd) {
          if (err2)
            return cb(err2);
          if (opts.discardDescriptor) {
            return fs.close(fd, function _discardCallback(possibleErr) {
              return cb(possibleErr, name, void 0, _prepareTmpFileRemoveCallback(name, -1, opts, false));
            });
          } else {
            const discardOrDetachDescriptor = opts.discardDescriptor || opts.detachDescriptor;
            cb(null, name, fd, _prepareTmpFileRemoveCallback(name, discardOrDetachDescriptor ? -1 : fd, opts, false));
          }
        });
      });
    }
    function fileSync(options) {
      const args = _parseArguments(options), opts = args[0];
      const discardOrDetachDescriptor = opts.discardDescriptor || opts.detachDescriptor;
      const name = tmpNameSync(opts);
      var fd = fs.openSync(name, CREATE_FLAGS, opts.mode || FILE_MODE);
      if (opts.discardDescriptor) {
        fs.closeSync(fd);
        fd = void 0;
      }
      return {
        name,
        fd,
        removeCallback: _prepareTmpFileRemoveCallback(name, discardOrDetachDescriptor ? -1 : fd, opts, true)
      };
    }
    function dir(options, callback) {
      const args = _parseArguments(options, callback), opts = args[0], cb = args[1];
      tmpName(opts, function _tmpNameCreated(err, name) {
        if (err)
          return cb(err);
        fs.mkdir(name, opts.mode || DIR_MODE, function _dirCreated(err2) {
          if (err2)
            return cb(err2);
          cb(null, name, _prepareTmpDirRemoveCallback(name, opts, false));
        });
      });
    }
    function dirSync(options) {
      const args = _parseArguments(options), opts = args[0];
      const name = tmpNameSync(opts);
      fs.mkdirSync(name, opts.mode || DIR_MODE);
      return {
        name,
        removeCallback: _prepareTmpDirRemoveCallback(name, opts, true)
      };
    }
    function _removeFileAsync(fdPath, next) {
      const _handler = function(err) {
        if (err && !_isENOENT(err)) {
          return next(err);
        }
        next();
      };
      if (0 <= fdPath[0])
        fs.close(fdPath[0], function() {
          fs.unlink(fdPath[1], _handler);
        });
      else
        fs.unlink(fdPath[1], _handler);
    }
    function _removeFileSync(fdPath) {
      let rethrownException = null;
      try {
        if (0 <= fdPath[0])
          fs.closeSync(fdPath[0]);
      } catch (e) {
        if (!_isEBADF(e) && !_isENOENT(e))
          throw e;
      } finally {
        try {
          fs.unlinkSync(fdPath[1]);
        } catch (e) {
          if (!_isENOENT(e))
            rethrownException = e;
        }
      }
      if (rethrownException !== null) {
        throw rethrownException;
      }
    }
    function _prepareTmpFileRemoveCallback(name, fd, opts, sync) {
      const removeCallbackSync = _prepareRemoveCallback(_removeFileSync, [fd, name], sync);
      const removeCallback = _prepareRemoveCallback(_removeFileAsync, [fd, name], sync, removeCallbackSync);
      if (!opts.keep)
        _removeObjects.unshift(removeCallbackSync);
      return sync ? removeCallbackSync : removeCallback;
    }
    function _prepareTmpDirRemoveCallback(name, opts, sync) {
      const removeFunction = opts.unsafeCleanup ? rimraf : fs.rmdir.bind(fs);
      const removeFunctionSync = opts.unsafeCleanup ? FN_RIMRAF_SYNC : FN_RMDIR_SYNC;
      const removeCallbackSync = _prepareRemoveCallback(removeFunctionSync, name, sync);
      const removeCallback = _prepareRemoveCallback(removeFunction, name, sync, removeCallbackSync);
      if (!opts.keep)
        _removeObjects.unshift(removeCallbackSync);
      return sync ? removeCallbackSync : removeCallback;
    }
    function _prepareRemoveCallback(removeFunction, fileOrDirName, sync, cleanupCallbackSync) {
      let called = false;
      return function _cleanupCallback(next) {
        if (!called) {
          const toRemove = cleanupCallbackSync || _cleanupCallback;
          const index = _removeObjects.indexOf(toRemove);
          if (index >= 0)
            _removeObjects.splice(index, 1);
          called = true;
          if (sync || removeFunction === FN_RMDIR_SYNC || removeFunction === FN_RIMRAF_SYNC) {
            return removeFunction(fileOrDirName);
          } else {
            return removeFunction(fileOrDirName, next || function() {
            });
          }
        }
      };
    }
    function _garbageCollector() {
      if (!_gracefulCleanup)
        return;
      while (_removeObjects.length) {
        try {
          _removeObjects[0]();
        } catch (e) {
        }
      }
    }
    function _randomChars(howMany) {
      let value = [], rnd = null;
      try {
        rnd = crypto4.randomBytes(howMany);
      } catch (e) {
        rnd = crypto4.pseudoRandomBytes(howMany);
      }
      for (var i = 0; i < howMany; i++) {
        value.push(RANDOM_CHARS[rnd[i] % RANDOM_CHARS.length]);
      }
      return value.join("");
    }
    function _isBlank(s) {
      return s === null || _isUndefined(s) || !s.trim();
    }
    function _isUndefined(obj2) {
      return typeof obj2 === "undefined";
    }
    function _parseArguments(options, callback) {
      if (typeof options === "function") {
        return [{}, options];
      }
      if (_isUndefined(options)) {
        return [{}, callback];
      }
      const actualOptions = {};
      for (const key of Object.getOwnPropertyNames(options)) {
        actualOptions[key] = options[key];
      }
      return [actualOptions, callback];
    }
    function _generateTmpName(opts) {
      const tmpDir = opts.tmpdir;
      if (!_isUndefined(opts.name))
        return path.join(tmpDir, opts.dir, opts.name);
      if (!_isUndefined(opts.template))
        return path.join(tmpDir, opts.dir, opts.template).replace(TEMPLATE_PATTERN, _randomChars(6));
      const name = [
        opts.prefix ? opts.prefix : "tmp",
        "-",
        process.pid,
        "-",
        _randomChars(12),
        opts.postfix ? "-" + opts.postfix : ""
      ].join("");
      return path.join(tmpDir, opts.dir, name);
    }
    function _assertAndSanitizeOptions(options) {
      options.tmpdir = _getTmpDir(options);
      const tmpDir = options.tmpdir;
      if (!_isUndefined(options.name))
        _assertIsRelative(options.name, "name", tmpDir);
      if (!_isUndefined(options.dir))
        _assertIsRelative(options.dir, "dir", tmpDir);
      if (!_isUndefined(options.template)) {
        _assertIsRelative(options.template, "template", tmpDir);
        if (!options.template.match(TEMPLATE_PATTERN))
          throw new Error(`Invalid template, found "${options.template}".`);
      }
      if (!_isUndefined(options.tries) && isNaN(options.tries) || options.tries < 0)
        throw new Error(`Invalid tries, found "${options.tries}".`);
      options.tries = _isUndefined(options.name) ? options.tries || DEFAULT_TRIES : 1;
      options.keep = !!options.keep;
      options.detachDescriptor = !!options.detachDescriptor;
      options.discardDescriptor = !!options.discardDescriptor;
      options.unsafeCleanup = !!options.unsafeCleanup;
      options.dir = _isUndefined(options.dir) ? "" : path.relative(tmpDir, _resolvePath(options.dir, tmpDir));
      options.template = _isUndefined(options.template) ? void 0 : path.relative(tmpDir, _resolvePath(options.template, tmpDir));
      options.template = _isBlank(options.template) ? void 0 : path.relative(options.dir, options.template);
      options.name = _isUndefined(options.name) ? void 0 : options.name;
      options.prefix = _isUndefined(options.prefix) ? "" : options.prefix;
      options.postfix = _isUndefined(options.postfix) ? "" : options.postfix;
    }
    function _resolvePath(name, tmpDir) {
      if (name.startsWith(tmpDir)) {
        return path.resolve(name);
      } else {
        return path.resolve(path.join(tmpDir, name));
      }
    }
    function _assertIsRelative(name, option, tmpDir) {
      if (option === "name") {
        if (path.isAbsolute(name))
          throw new Error(`${option} option must not contain an absolute path, found "${name}".`);
        let basename = path.basename(name);
        if (basename === ".." || basename === "." || basename !== name)
          throw new Error(`${option} option must not contain a path, found "${name}".`);
      } else {
        if (path.isAbsolute(name) && !name.startsWith(tmpDir)) {
          throw new Error(`${option} option must be relative to "${tmpDir}", found "${name}".`);
        }
        let resolvedPath = _resolvePath(name, tmpDir);
        if (!resolvedPath.startsWith(tmpDir))
          throw new Error(`${option} option must be relative to "${tmpDir}", found "${resolvedPath}".`);
      }
    }
    function _isEBADF(error) {
      return _isExpectedError(error, -EBADF, "EBADF");
    }
    function _isENOENT(error) {
      return _isExpectedError(error, -ENOENT, "ENOENT");
    }
    function _isExpectedError(error, errno, code) {
      return IS_WIN32 ? error.code === code : error.code === code && error.errno === errno;
    }
    function setGracefulCleanup() {
      _gracefulCleanup = true;
    }
    function _getTmpDir(options) {
      return path.resolve(options && options.tmpdir || os.tmpdir());
    }
    process.addListener(EXIT, _garbageCollector);
    Object.defineProperty(module2.exports, "tmpdir", {
      enumerable: true,
      configurable: false,
      get: function() {
        return _getTmpDir();
      }
    });
    module2.exports.dir = dir;
    module2.exports.dirSync = dirSync;
    module2.exports.file = file;
    module2.exports.fileSync = fileSync;
    module2.exports.tmpName = tmpName;
    module2.exports.tmpNameSync = tmpNameSync;
    module2.exports.setGracefulCleanup = setGracefulCleanup;
  }
});

// ../../../node_modules/exceljs/lib/utils/iterate-stream.js
var require_iterate_stream = __commonJS({
  "../../../node_modules/exceljs/lib/utils/iterate-stream.js"(exports2, module2) {
    module2.exports = async function* iterateStream(stream) {
      const contents = [];
      stream.on("data", (data) => contents.push(data));
      let resolveStreamEndedPromise;
      const streamEndedPromise = new Promise((resolve) => resolveStreamEndedPromise = resolve);
      let ended = false;
      stream.on("end", () => {
        ended = true;
        resolveStreamEndedPromise();
      });
      let error = false;
      stream.on("error", (err) => {
        error = err;
        resolveStreamEndedPromise();
      });
      while (!ended || contents.length > 0) {
        if (contents.length === 0) {
          stream.resume();
          await Promise.race([once(stream, "data"), streamEndedPromise]);
        } else {
          stream.pause();
          const data = contents.shift();
          yield data;
        }
        if (error)
          throw error;
      }
      resolveStreamEndedPromise();
    };
    function once(eventEmitter, type) {
      return new Promise((resolve) => {
        let fired = false;
        const handler = () => {
          if (!fired) {
            fired = true;
            eventEmitter.removeListener(type, handler);
            resolve();
          }
        };
        eventEmitter.addListener(type, handler);
      });
    }
  }
});

// ../../../node_modules/exceljs/lib/stream/xlsx/worksheet-reader.js
var require_worksheet_reader = __commonJS({
  "../../../node_modules/exceljs/lib/stream/xlsx/worksheet-reader.js"(exports2, module2) {
    var { EventEmitter } = require("events");
    var parseSax = require_parse_sax();
    var _2 = require_under_dash();
    var utils = require_utils2();
    var colCache = require_col_cache();
    var Dimensions = require_range();
    var Row = require_row();
    var Column = require_column();
    var WorksheetReader = class extends EventEmitter {
      constructor({ workbook, id, iterator, options }) {
        super();
        this.workbook = workbook;
        this.id = id;
        this.iterator = iterator;
        this.options = options || {};
        this.name = `Sheet${this.id}`;
        this._columns = null;
        this._keys = {};
        this._dimensions = new Dimensions();
      }
      // destroy - not a valid operation for a streaming writer
      // even though some streamers might be able to, it's a bad idea.
      destroy() {
        throw new Error("Invalid Operation: destroy");
      }
      // return the current dimensions of the writer
      get dimensions() {
        return this._dimensions;
      }
      // =========================================================================
      // Columns
      // get the current columns array.
      get columns() {
        return this._columns;
      }
      // get a single column by col number. If it doesn't exist, it and any gaps before it
      // are created.
      getColumn(c) {
        if (typeof c === "string") {
          const col = this._keys[c];
          if (col) {
            return col;
          }
          c = colCache.l2n(c);
        }
        if (!this._columns) {
          this._columns = [];
        }
        if (c > this._columns.length) {
          let n = this._columns.length + 1;
          while (n <= c) {
            this._columns.push(new Column(this, n++));
          }
        }
        return this._columns[c - 1];
      }
      getColumnKey(key) {
        return this._keys[key];
      }
      setColumnKey(key, value) {
        this._keys[key] = value;
      }
      deleteColumnKey(key) {
        delete this._keys[key];
      }
      eachColumnKey(f) {
        _2.each(this._keys, f);
      }
      async read() {
        try {
          for await (const events of this.parse()) {
            for (const { eventType, value } of events) {
              this.emit(eventType, value);
            }
          }
          this.emit("finished");
        } catch (error) {
          this.emit("error", error);
        }
      }
      async *[Symbol.asyncIterator]() {
        for await (const events of this.parse()) {
          for (const { eventType, value } of events) {
            if (eventType === "row") {
              yield value;
            }
          }
        }
      }
      async *parse() {
        const { iterator, options } = this;
        let emitSheet = false;
        let emitHyperlinks = false;
        let hyperlinks = null;
        switch (options.worksheets) {
          case "emit":
            emitSheet = true;
            break;
          case "prep":
            break;
          default:
            break;
        }
        switch (options.hyperlinks) {
          case "emit":
            emitHyperlinks = true;
            break;
          case "cache":
            this.hyperlinks = hyperlinks = {};
            break;
          default:
            break;
        }
        if (!emitSheet && !emitHyperlinks && !hyperlinks) {
          return;
        }
        const { sharedStrings, styles, properties } = this.workbook;
        let inCols = false;
        let inRows = false;
        let inHyperlinks = false;
        let cols = null;
        let row = null;
        let c = null;
        let current = null;
        for await (const events of parseSax(iterator)) {
          const worksheetEvents = [];
          for (const { eventType, value } of events) {
            if (eventType === "opentag") {
              const node = value;
              if (emitSheet) {
                switch (node.name) {
                  case "cols":
                    inCols = true;
                    cols = [];
                    break;
                  case "sheetData":
                    inRows = true;
                    break;
                  case "col":
                    if (inCols) {
                      cols.push({
                        min: parseInt(node.attributes.min, 10),
                        max: parseInt(node.attributes.max, 10),
                        width: parseFloat(node.attributes.width),
                        styleId: parseInt(node.attributes.style || "0", 10)
                      });
                    }
                    break;
                  case "row":
                    if (inRows) {
                      const r = parseInt(node.attributes.r, 10);
                      row = new Row(this, r);
                      if (node.attributes.ht) {
                        row.height = parseFloat(node.attributes.ht);
                      }
                      if (node.attributes.s) {
                        const styleId = parseInt(node.attributes.s, 10);
                        const style = styles.getStyleModel(styleId);
                        if (style) {
                          row.style = style;
                        }
                      }
                    }
                    break;
                  case "c":
                    if (row) {
                      c = {
                        ref: node.attributes.r,
                        s: parseInt(node.attributes.s, 10),
                        t: node.attributes.t
                      };
                    }
                    break;
                  case "f":
                    if (c) {
                      current = c.f = { text: "" };
                    }
                    break;
                  case "v":
                    if (c) {
                      current = c.v = { text: "" };
                    }
                    break;
                  case "is":
                  case "t":
                    if (c) {
                      current = c.v = { text: "" };
                    }
                    break;
                  case "mergeCell":
                    break;
                  default:
                    break;
                }
              }
              if (emitHyperlinks || hyperlinks) {
                switch (node.name) {
                  case "hyperlinks":
                    inHyperlinks = true;
                    break;
                  case "hyperlink":
                    if (inHyperlinks) {
                      const hyperlink = {
                        ref: node.attributes.ref,
                        rId: node.attributes["r:id"]
                      };
                      if (emitHyperlinks) {
                        worksheetEvents.push({ eventType: "hyperlink", value: hyperlink });
                      } else {
                        hyperlinks[hyperlink.ref] = hyperlink;
                      }
                    }
                    break;
                  default:
                    break;
                }
              }
            } else if (eventType === "text") {
              if (emitSheet) {
                if (current) {
                  current.text += value;
                }
              }
            } else if (eventType === "closetag") {
              const node = value;
              if (emitSheet) {
                switch (node.name) {
                  case "cols":
                    inCols = false;
                    this._columns = Column.fromModel(cols);
                    break;
                  case "sheetData":
                    inRows = false;
                    break;
                  case "row":
                    this._dimensions.expandRow(row);
                    worksheetEvents.push({ eventType: "row", value: row });
                    row = null;
                    break;
                  case "c":
                    if (row && c) {
                      const address = colCache.decodeAddress(c.ref);
                      const cell = row.getCell(address.col);
                      if (c.s) {
                        const style = styles.getStyleModel(c.s);
                        if (style) {
                          cell.style = style;
                        }
                      }
                      if (c.f) {
                        const cellValue = {
                          formula: c.f.text
                        };
                        if (c.v) {
                          if (c.t === "str") {
                            cellValue.result = utils.xmlDecode(c.v.text);
                          } else {
                            cellValue.result = parseFloat(c.v.text);
                          }
                        }
                        cell.value = cellValue;
                      } else if (c.v) {
                        switch (c.t) {
                          case "s": {
                            const index = parseInt(c.v.text, 10);
                            if (sharedStrings) {
                              cell.value = sharedStrings[index];
                            } else {
                              cell.value = {
                                sharedString: index
                              };
                            }
                            break;
                          }
                          case "inlineStr":
                          case "str":
                            cell.value = utils.xmlDecode(c.v.text);
                            break;
                          case "e":
                            cell.value = { error: c.v.text };
                            break;
                          case "b":
                            cell.value = parseInt(c.v.text, 10) !== 0;
                            break;
                          default:
                            if (utils.isDateFmt(cell.numFmt)) {
                              cell.value = utils.excelToDate(
                                parseFloat(c.v.text),
                                properties.model && properties.model.date1904
                              );
                            } else {
                              cell.value = parseFloat(c.v.text);
                            }
                            break;
                        }
                      }
                      if (hyperlinks) {
                        const hyperlink = hyperlinks[c.ref];
                        if (hyperlink) {
                          cell.text = cell.value;
                          cell.value = void 0;
                          cell.hyperlink = hyperlink;
                        }
                      }
                      c = null;
                    }
                    break;
                  default:
                    break;
                }
              }
              if (emitHyperlinks || hyperlinks) {
                switch (node.name) {
                  case "hyperlinks":
                    inHyperlinks = false;
                    break;
                  default:
                    break;
                }
              }
            }
          }
          if (worksheetEvents.length > 0) {
            yield worksheetEvents;
          }
        }
      }
    };
    module2.exports = WorksheetReader;
  }
});

// ../../../node_modules/exceljs/lib/stream/xlsx/hyperlink-reader.js
var require_hyperlink_reader = __commonJS({
  "../../../node_modules/exceljs/lib/stream/xlsx/hyperlink-reader.js"(exports2, module2) {
    var { EventEmitter } = require("events");
    var parseSax = require_parse_sax();
    var Enums = require_enums();
    var RelType = require_rel_type();
    var HyperlinkReader = class extends EventEmitter {
      constructor({ workbook, id, iterator, options }) {
        super();
        this.workbook = workbook;
        this.id = id;
        this.iterator = iterator;
        this.options = options;
      }
      get count() {
        return this.hyperlinks && this.hyperlinks.length || 0;
      }
      each(fn) {
        return this.hyperlinks.forEach(fn);
      }
      async read() {
        const { iterator, options } = this;
        let emitHyperlinks = false;
        let hyperlinks = null;
        switch (options.hyperlinks) {
          case "emit":
            emitHyperlinks = true;
            break;
          case "cache":
            this.hyperlinks = hyperlinks = {};
            break;
          default:
            break;
        }
        if (!emitHyperlinks && !hyperlinks) {
          this.emit("finished");
          return;
        }
        try {
          for await (const events of parseSax(iterator)) {
            for (const { eventType, value } of events) {
              if (eventType === "opentag") {
                const node = value;
                if (node.name === "Relationship") {
                  const rId = node.attributes.Id;
                  switch (node.attributes.Type) {
                    case RelType.Hyperlink:
                      {
                        const relationship = {
                          type: Enums.RelationshipType.Styles,
                          rId,
                          target: node.attributes.Target,
                          targetMode: node.attributes.TargetMode
                        };
                        if (emitHyperlinks) {
                          this.emit("hyperlink", relationship);
                        } else {
                          hyperlinks[relationship.rId] = relationship;
                        }
                      }
                      break;
                    default:
                      break;
                  }
                }
              }
            }
          }
          this.emit("finished");
        } catch (error) {
          this.emit("error", error);
        }
      }
    };
    module2.exports = HyperlinkReader;
  }
});

// ../../../node_modules/exceljs/lib/stream/xlsx/workbook-reader.js
var require_workbook_reader = __commonJS({
  "../../../node_modules/exceljs/lib/stream/xlsx/workbook-reader.js"(exports2, module2) {
    var fs = require("fs");
    var { EventEmitter } = require("events");
    var { PassThrough, Readable } = require_readable2();
    var nodeStream = require("stream");
    var unzip = require_unzip2();
    var tmp = require_tmp();
    var iterateStream = require_iterate_stream();
    var parseSax = require_parse_sax();
    var StyleManager = require_styles_xform();
    var WorkbookXform = require_workbook_xform();
    var RelationshipsXform = require_relationships_xform();
    var WorksheetReader = require_worksheet_reader();
    var HyperlinkReader = require_hyperlink_reader();
    tmp.setGracefulCleanup();
    var WorkbookReader = class extends EventEmitter {
      constructor(input, options = {}) {
        super();
        this.input = input;
        this.options = {
          worksheets: "emit",
          sharedStrings: "cache",
          hyperlinks: "ignore",
          styles: "ignore",
          entries: "ignore",
          ...options
        };
        this.styles = new StyleManager();
        this.styles.init();
      }
      _getStream(input) {
        if (input instanceof nodeStream.Readable || input instanceof Readable) {
          return input;
        }
        if (typeof input === "string") {
          return fs.createReadStream(input);
        }
        throw new Error(`Could not recognise input: ${input}`);
      }
      async read(input, options) {
        try {
          for await (const { eventType, value } of this.parse(input, options)) {
            switch (eventType) {
              case "shared-strings":
                this.emit(eventType, value);
                break;
              case "worksheet":
                this.emit(eventType, value);
                await value.read();
                break;
              case "hyperlinks":
                this.emit(eventType, value);
                break;
            }
          }
          this.emit("end");
          this.emit("finished");
        } catch (error) {
          this.emit("error", error);
        }
      }
      async *[Symbol.asyncIterator]() {
        for await (const { eventType, value } of this.parse()) {
          if (eventType === "worksheet") {
            yield value;
          }
        }
      }
      async *parse(input, options) {
        if (options)
          this.options = options;
        const stream = this.stream = this._getStream(input || this.input);
        const zip = unzip.Parse({ forceStream: true });
        stream.pipe(zip);
        const waitingWorkSheets = [];
        for await (const entry of iterateStream(zip)) {
          let match;
          let sheetNo;
          switch (entry.path) {
            case "_rels/.rels":
              break;
            case "xl/_rels/workbook.xml.rels":
              await this._parseRels(entry);
              break;
            case "xl/workbook.xml":
              await this._parseWorkbook(entry);
              break;
            case "xl/sharedStrings.xml":
              yield* this._parseSharedStrings(entry);
              break;
            case "xl/styles.xml":
              await this._parseStyles(entry);
              break;
            default:
              if (entry.path.match(/xl\/worksheets\/sheet\d+[.]xml/)) {
                match = entry.path.match(/xl\/worksheets\/sheet(\d+)[.]xml/);
                sheetNo = match[1];
                if (this.sharedStrings && this.workbookRels) {
                  yield* this._parseWorksheet(iterateStream(entry), sheetNo);
                } else {
                  await new Promise((resolve, reject) => {
                    tmp.file((err, path, fd, tempFileCleanupCallback) => {
                      if (err) {
                        return reject(err);
                      }
                      waitingWorkSheets.push({ sheetNo, path, tempFileCleanupCallback });
                      const tempStream = fs.createWriteStream(path);
                      tempStream.on("error", reject);
                      entry.pipe(tempStream);
                      return tempStream.on("finish", () => {
                        return resolve();
                      });
                    });
                  });
                }
              } else if (entry.path.match(/xl\/worksheets\/_rels\/sheet\d+[.]xml.rels/)) {
                match = entry.path.match(/xl\/worksheets\/_rels\/sheet(\d+)[.]xml.rels/);
                sheetNo = match[1];
                yield* this._parseHyperlinks(iterateStream(entry), sheetNo);
              }
              break;
          }
          entry.autodrain();
        }
        for (const { sheetNo, path, tempFileCleanupCallback } of waitingWorkSheets) {
          let fileStream = fs.createReadStream(path);
          if (!fileStream[Symbol.asyncIterator]) {
            fileStream = fileStream.pipe(new PassThrough());
          }
          yield* this._parseWorksheet(fileStream, sheetNo);
          tempFileCleanupCallback();
        }
      }
      _emitEntry(payload) {
        if (this.options.entries === "emit") {
          this.emit("entry", payload);
        }
      }
      async _parseRels(entry) {
        const xform = new RelationshipsXform();
        this.workbookRels = await xform.parseStream(iterateStream(entry));
      }
      async _parseWorkbook(entry) {
        this._emitEntry({ type: "workbook" });
        const workbook = new WorkbookXform();
        await workbook.parseStream(iterateStream(entry));
        this.properties = workbook.map.workbookPr;
        this.model = workbook.model;
      }
      async *_parseSharedStrings(entry) {
        this._emitEntry({ type: "shared-strings" });
        switch (this.options.sharedStrings) {
          case "cache":
            this.sharedStrings = [];
            break;
          case "emit":
            break;
          default:
            return;
        }
        let text = null;
        let richText = [];
        let index = 0;
        let font = null;
        for await (const events of parseSax(iterateStream(entry))) {
          for (const { eventType, value } of events) {
            if (eventType === "opentag") {
              const node = value;
              switch (node.name) {
                case "b":
                  font = font || {};
                  font.bold = true;
                  break;
                case "charset":
                  font = font || {};
                  font.charset = parseInt(node.attributes.charset, 10);
                  break;
                case "color":
                  font = font || {};
                  font.color = {};
                  if (node.attributes.rgb) {
                    font.color.argb = node.attributes.argb;
                  }
                  if (node.attributes.val) {
                    font.color.argb = node.attributes.val;
                  }
                  if (node.attributes.theme) {
                    font.color.theme = node.attributes.theme;
                  }
                  break;
                case "family":
                  font = font || {};
                  font.family = parseInt(node.attributes.val, 10);
                  break;
                case "i":
                  font = font || {};
                  font.italic = true;
                  break;
                case "outline":
                  font = font || {};
                  font.outline = true;
                  break;
                case "rFont":
                  font = font || {};
                  font.name = node.value;
                  break;
                case "si":
                  font = null;
                  richText = [];
                  text = null;
                  break;
                case "sz":
                  font = font || {};
                  font.size = parseInt(node.attributes.val, 10);
                  break;
                case "strike":
                  break;
                case "t":
                  text = null;
                  break;
                case "u":
                  font = font || {};
                  font.underline = true;
                  break;
                case "vertAlign":
                  font = font || {};
                  font.vertAlign = node.attributes.val;
                  break;
              }
            } else if (eventType === "text") {
              text = text ? text + value : value;
            } else if (eventType === "closetag") {
              const node = value;
              switch (node.name) {
                case "r":
                  richText.push({
                    font,
                    text
                  });
                  font = null;
                  text = null;
                  break;
                case "si":
                  if (this.options.sharedStrings === "cache") {
                    this.sharedStrings.push(richText.length ? { richText } : text);
                  } else if (this.options.sharedStrings === "emit") {
                    yield { index: index++, text: richText.length ? { richText } : text };
                  }
                  richText = [];
                  font = null;
                  text = null;
                  break;
              }
            }
          }
        }
      }
      async _parseStyles(entry) {
        this._emitEntry({ type: "styles" });
        if (this.options.styles === "cache") {
          this.styles = new StyleManager();
          await this.styles.parseStream(iterateStream(entry));
        }
      }
      *_parseWorksheet(iterator, sheetNo) {
        this._emitEntry({ type: "worksheet", id: sheetNo });
        const worksheetReader = new WorksheetReader({
          workbook: this,
          id: sheetNo,
          iterator,
          options: this.options
        });
        const matchingRel = (this.workbookRels || []).find((rel) => rel.Target === `worksheets/sheet${sheetNo}.xml`);
        const matchingSheet = matchingRel && (this.model.sheets || []).find((sheet) => sheet.rId === matchingRel.Id);
        if (matchingSheet) {
          worksheetReader.id = matchingSheet.id;
          worksheetReader.name = matchingSheet.name;
          worksheetReader.state = matchingSheet.state;
        }
        if (this.options.worksheets === "emit") {
          yield { eventType: "worksheet", value: worksheetReader };
        }
      }
      *_parseHyperlinks(iterator, sheetNo) {
        this._emitEntry({ type: "hyperlinks", id: sheetNo });
        const hyperlinksReader = new HyperlinkReader({
          workbook: this,
          id: sheetNo,
          iterator,
          options: this.options
        });
        if (this.options.hyperlinks === "emit") {
          yield { eventType: "hyperlinks", value: hyperlinksReader };
        }
      }
    };
    WorkbookReader.Options = {
      worksheets: ["emit", "ignore"],
      sharedStrings: ["cache", "emit", "ignore"],
      hyperlinks: ["cache", "emit", "ignore"],
      styles: ["cache", "ignore"],
      entries: ["emit", "ignore"]
    };
    module2.exports = WorkbookReader;
  }
});

// ../../../node_modules/exceljs/lib/exceljs.nodejs.js
var require_exceljs_nodejs = __commonJS({
  "../../../node_modules/exceljs/lib/exceljs.nodejs.js"(exports2, module2) {
    var ExcelJS2 = {
      Workbook: require_workbook(),
      ModelContainer: require_modelcontainer(),
      stream: {
        xlsx: {
          WorkbookWriter: require_workbook_writer(),
          WorkbookReader: require_workbook_reader()
        }
      }
    };
    Object.assign(ExcelJS2, require_enums());
    module2.exports = ExcelJS2;
  }
});

// ../../../node_modules/exceljs/excel.js
var require_excel = __commonJS({
  "../../../node_modules/exceljs/excel.js"(exports2, module2) {
    if (parseInt(process.versions.node.split(".")[0], 10) < 10) {
      throw new Error(
        "For node versions older than 10, please use the ES5 Import: https://github.com/exceljs/exceljs#es5-imports"
      );
    }
    module2.exports = require_exceljs_nodejs();
  }
});

// dist/server/index.js
var require_server = __commonJS({
  "dist/server/index.js"(exports2, module2) {
    "use strict";
    var bootstrap = ({ strapi }) => {
      strapi.log.info("Excel Export Plugin Loaded");
    };
    var destroy = ({ strapi }) => {
    };
    var register = ({ strapi }) => {
    };
    var config = {
      default: {},
      validator() {
      }
    };
    var contentTypes = {};
    var controller = ({ strapi }) => ({
      index(ctx) {
        ctx.body = strapi.plugin("excel-export").service("service");
      },
      async exportLeads(ctx) {
        const { from, to } = ctx.query;
        const filters = {};
        if (from && to) {
          filters.createdAt = { $gte: from, $lte: to };
        }
        const leads = await strapi.entityService.findMany("api::lead.lead", { filters });
        const workbook = new ExcelJS.Workbook();
        const sheet = workbook.addWorksheet("Leads");
        sheet.addRow(["ID", "Name", "Email", "Created At"]);
        leads.forEach((lead) => {
          sheet.addRow([lead.id, lead.name, lead.email, lead.createdAt]);
        });
        ctx.set("Content-Disposition", "attachment; filename=leads.xlsx");
        ctx.set("Content-Type", "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet");
        ctx.body = await workbook.xlsx.writeBuffer();
      }
    });
    var exportcontroller = ({ strapi }) => ({
      async exportLeads(ctx) {
        const { from, to } = ctx.query;
        const filters = {};
        if (from && to) {
          filters.createdAt = { $gte: from, $lte: to };
        }
        const leads = await strapi.entityService.findMany("api::lead.lead", { filters });
        const workbook = new ExcelJS.Workbook();
        const sheet = workbook.addWorksheet("Leads");
        sheet.addRow(["ID", "Name", "Email", "Created At"]);
        leads.forEach((lead) => {
          sheet.addRow([lead.id, lead.name, lead.email, lead.createdAt]);
        });
        ctx.set("Content-Disposition", "attachment; filename=leads.xlsx");
        ctx.set("Content-Type", "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet");
        ctx.body = await workbook.xlsx.writeBuffer();
      }
    });
    var controllers = {
      controller,
      exportcontroller
    };
    var middlewares = {};
    var policies = {};
    require_excel();
    var routes = [
      {
        method: "GET",
        path: "/",
        // name of the controller file & the method.
        handler: "controller.index",
        config: {
          policies: []
        }
      },
      {
        method: "GET",
        path: "/excel-export",
        handler: "controller.exportLeads",
        config: {
          auth: false
        }
      }
    ];
    var service = ({ strapi }) => ({
      getWelcomeMessage() {
        return "Welcome to Strapi \u{1F680}";
      }
    });
    var services = {
      service
    };
    var index = {
      bootstrap,
      destroy,
      register,
      config,
      controllers,
      contentTypes,
      middlewares,
      policies,
      routes,
      services
    };
    module2.exports = index;
  }
});

// <stdin>
require_admin();
require_server();
/*! xlsx.js (C) 2013-present SheetJS -- http://sheetjs.com */
/*! sheetjs (C) 2013-present SheetJS -- http://sheetjs.com */
/*! Bundled license information:

safe-buffer/index.js:
  (*! safe-buffer. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> *)

xmlchars/xml/1.0/ed5.js:
  (**
   * Character classes and associated utilities for the 5th edition of XML 1.0.
   *
   * @author Louis-Dominique Dubeau
   * @license MIT
   * @copyright Louis-Dominique Dubeau
   *)

xmlchars/xml/1.1/ed2.js:
  (**
   * Character classes and associated utilities for the 2nd edition of XML 1.1.
   *
   * @author Louis-Dominique Dubeau
   * @license MIT
   * @copyright Louis-Dominique Dubeau
   *)

xmlchars/xmlns/1.0/ed3.js:
  (**
   * Character class utilities for XML NS 1.0 edition 3.
   *
   * @author Louis-Dominique Dubeau
   * @license MIT
   * @copyright Louis-Dominique Dubeau
   *)

normalize-path/index.js:
  (*!
   * normalize-path <https://github.com/jonschlinkert/normalize-path>
   *
   * Copyright (c) 2014-2018, Jon Schlinkert.
   * Released under the MIT License.
   *)

archiver/lib/error.js:
  (**
   * Archiver Core
   *
   * @ignore
   * @license [MIT]{@link https://github.com/archiverjs/node-archiver/blob/master/LICENSE}
   * @copyright (c) 2012-2014 Chris Talkington, contributors.
   *)

archiver/lib/core.js:
  (**
   * Archiver Core
   *
   * @ignore
   * @license [MIT]{@link https://github.com/archiverjs/node-archiver/blob/master/LICENSE}
   * @copyright (c) 2012-2014 Chris Talkington, contributors.
   *)

crc-32/crc32.js:
  (*! crc32.js (C) 2014-present SheetJS -- http://sheetjs.com *)

zip-stream/index.js:
  (**
   * ZipStream
   *
   * @ignore
   * @license [MIT]{@link https://github.com/archiverjs/node-zip-stream/blob/master/LICENSE}
   * @copyright (c) 2014 Chris Talkington, contributors.
   *)

archiver/lib/plugins/zip.js:
  (**
   * ZIP Format Plugin
   *
   * @module plugins/zip
   * @license [MIT]{@link https://github.com/archiverjs/node-archiver/blob/master/LICENSE}
   * @copyright (c) 2012-2014 Chris Talkington, contributors.
   *)

archiver/lib/plugins/tar.js:
  (**
   * TAR Format Plugin
   *
   * @module plugins/tar
   * @license [MIT]{@link https://github.com/archiverjs/node-archiver/blob/master/LICENSE}
   * @copyright (c) 2012-2014 Chris Talkington, contributors.
   *)

archiver/lib/plugins/json.js:
  (**
   * JSON Format Plugin
   *
   * @module plugins/json
   * @license [MIT]{@link https://github.com/archiverjs/node-archiver/blob/master/LICENSE}
   * @copyright (c) 2012-2014 Chris Talkington, contributors.
   *)

archiver/index.js:
  (**
   * Archiver Vending
   *
   * @ignore
   * @license [MIT]{@link https://github.com/archiverjs/node-archiver/blob/master/LICENSE}
   * @copyright (c) 2012-2014 Chris Talkington, contributors.
   *)

tmp/lib/tmp.js:
  (*!
   * Tmp
   *
   * Copyright (c) 2011-2017 KARASZI Istvan <github@spam.raszi.hu>
   *
   * MIT Licensed
   *)
*/
